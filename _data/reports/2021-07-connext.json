{
  "circa": {
    "title": "Connext",
    "sponsor": "Connext",
    "slug": "2021-07-connext-findings",
    "date": "2021-08-30",
    "findings": "https://github.com/code-423n4/2021-07-connext-findings/issues",
    "contest": 19
  },
  "html": "<h1 id=\"overview\" style=\"position:relative;\"><a href=\"#overview\" aria-label=\"overview permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Overview</h1>\n<h2 id=\"about-c4\" style=\"position:relative;\"><a href=\"#about-c4\" aria-label=\"about c4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>About C4</h2>\n<p>Code 432n4 (C4) is an open organization consisting of security researchers, auditors, developers, and individuals with domain expertise in smart contracts.</p>\n<p>A C4 code contest is an event in which community participants, referred to as Wardens, review, audit, or analyze smart contract logic in exchange for a bounty provided by sponsoring projects.</p>\n<p>During the code contest outlined in this document, C4 conducted an analysis of Connext smart contract system written in Solidity. The code contest took place between July 8 — July 11, 2021.</p>\n<h2 id=\"wardens\" style=\"position:relative;\"><a href=\"#wardens\" aria-label=\"wardens permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Wardens</h2>\n<p>9 Wardens contributed reports to the Connext code contest:</p>\n<ul>\n<li><a href=\"https://twitter.com/0xRajeev\">0xRajeev</a></li>\n<li><a href=\"https://twitter.com/SolidityDev\">paulius.eth</a></li>\n<li><a href=\"https://twitter.com/cmichelio\">cmichel</a></li>\n<li><a href=\"https://github.com/x9453\">shw</a></li>\n<li><a href=\"https://twitter.com/gpersoon\">gpersoon</a></li>\n<li><a href=\"https://github.com/0xsanson\">0xsanson</a></li>\n<li><a href=\"https://twitter.com/_smonica_\">s1m0</a></li>\n<li><a href=\"https://twitter.com/_hrkrshnn\">hrkrshnn</a></li>\n<li><a href=\"https://twitter.com/gallodasballo\">GalloDaSballo</a></li>\n<li><a href=\"https://twitter.com/greiart\">greiart</a></li>\n</ul>\n<p>This contest was judged by <a href=\"https://twitter.com/ghoulsol\">ghoul.sol</a>.</p>\n<p>Final report assembled by <a href=\"https://twitter.com/money_lego\">moneylegobatman</a> and <a href=\"https://twitter.com/_ninek_\">ninek</a>.</p>\n<h1 id=\"summary\" style=\"position:relative;\"><a href=\"#summary\" aria-label=\"summary permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Summary</h1>\n<p>The C4 analysis yielded an aggregated total of 18 unique vulnerabilities. All of the issues presented here are linked back to their original finding</p>\n<p>Of these vulnerabilities, 5 received a risk rating in the category of HIGH severity, 2 received a risk rating in the category of MEDIUM severity, and 11 received a risk rating in the category of LOW severity.</p>\n<p>C4 analysis also identified 18 non-critical recommendations.</p>\n<h1 id=\"scope\" style=\"position:relative;\"><a href=\"#scope\" aria-label=\"scope permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Scope</h1>\n<p>The code under review can be found within the <a href=\"https://github.com/code-423n4/2021-07-connext\">C4 Connext code contest repository</a> is comprised of 6 smart contracts written in the Solidity programming language.</p>\n<h1 id=\"severity-criteria\" style=\"position:relative;\"><a href=\"#severity-criteria\" aria-label=\"severity criteria permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Severity Criteria</h1>\n<p>C4 assesses the severity of disclosed vulnerabilities according to a methodology based on <a href=\"https://owasp.org/www-community/OWASP_Risk_Rating_Methodology\">OWASP standards</a>.</p>\n<p>Vulnerabilities are divided into three primary risk categories: high, medium, and low.</p>\n<p>High-level considerations for vulnerabilities span the following key areas when conducting assessments:</p>\n<ul>\n<li>Malicious Input Handling</li>\n<li>Escalation of privileges</li>\n<li>Arithmetic</li>\n<li>Gas use</li>\n</ul>\n<p>Further information regarding the severity criteria referenced throughout the submission review process, please refer to the documentation provided on <a href=\"https://code423n4.com\">the C4 website</a>.</p>\n<h1 id=\"high-risk-findings-5\" style=\"position:relative;\"><a href=\"#high-risk-findings-5\" aria-label=\"high risk findings 5 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>High Risk Findings (5)</h1>\n<h2 id=\"h-01-anyone-can-arbitrarily-add-router-liquidity\" style=\"position:relative;\"><a href=\"#h-01-anyone-can-arbitrarily-add-router-liquidity\" aria-label=\"h 01 anyone can arbitrarily add router liquidity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/48\">[H-01] Anyone can arbitrarily add router liquidity</a></h2>\n<p><em>Submitted by 0xRajeev, also found by cmichel and pauliax</em></p>\n<p>The <code>addLiquidity()</code> function takes a router address parameter, whose liquidity is increased (instead of assuming that <code>router</code> == <code>msg.sender</code> like is done on <code>removeLiquidity()</code>) on this contract/chain, by transferring the fund amount from router address to this contract if <code>assetID</code> != 0 (i.e. ERC20 tokens). However, anyone can call this function on the router’s behalf. For <code>assetID</code> == 0, the Ether transfer via <code>msg.value</code> comes from <code>msg.sender</code> and hence is assumed to be the router itself.</p>\n<p>The impact is that this will allow anyone to call this function and arbitrarily move ERC20 tokens from router address to this contract, assuming router has given max approval to this contract and has <code>assetID</code> amount available for transfer. While the router can always remove the liquidity if it doesn’t want to maintain that level of liquidity, this lack of access control or flexibility for a relayer to add liquidity on router’s behalf, may unnecessarily (and without authorization) increase the router’s exposure to protocol risk to more than it desires. See <code>TransactionManager.sol</code> <a href=\"https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L88-L98\">#L88-L98</a>. See also, use of <code>msg.sender</code> in <code>removeLiquidity</code> (<a href=\"https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L88-L98\">#L88-L98</a>).</p>\n<p>Recommend considering the use of <code>msg.sender</code> in <code>addLiquidity()</code> or evaluate this risk otherwise.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/48#issuecomment-879189733\">LayneHaber (Connext) acknowledged</a>:</strong></p>\n<blockquote>\n<p>The bigger issue here is the typo <a href=\"https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L97\">here</a>, if we use the funds from <code>msg.sender</code> that means that people are donating funds to the router.</p>\n<p>We will fix the <code>msg.sender</code>, but allow <code>addLiquidity</code> to be callable by anyone</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/48#issuecomment-890607571\">ghoul-sol (Judge) commented</a>:</strong></p>\n<blockquote>\n<p>This is high risk because funds can be send to the wrong address.</p>\n</blockquote>\n<h2 id=\"h-02-activetransactionblocks-are-vulnerable-to-ddos-attacks\" style=\"position:relative;\"><a href=\"#h-02-activetransactionblocks-are-vulnerable-to-ddos-attacks\" aria-label=\"h 02 activetransactionblocks are vulnerable to ddos attacks permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/27\">[H-02] <code>activeTransactionBlocks</code> are vulnerable to DDoS attacks</a></h2>\n<p><em>Submitted by gpersoon, also found by pauliax and shw</em></p>\n<p>There is a potential issue in function <code>removeUserActiveBlocks</code> and the for loop inside it. I assume you are aware of block gas limits (they may be less relevant on other chains but still needs to be accounted for), so as there is no limit for <code>activeTransactionBlocks</code>, it may grow so large that the for loop may never finish. You should consider introducing an upper limit for <code>activeTransactionBlocks</code>. Also, a malicious actor may block any account (DDOS) by just calling <code>prepare</code> again and again with 0 amount acting as a router. This will push <code>activeTransactionBlocks</code> to the specified user until it is no longer possible to remove them from the array.</p>\n<p>This is also a gas issue, as function <code>removeUserActiveBlocks</code> iterating and assigning large dynamic arrays is very gas-consuming. Consider optimizing the algorithm, e.g. finding the first occurrence, then swap it with the last item, pop the array, and break. Or maybe even using an <a href=\"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableMap.sol\"><code>EnumerableMap</code></a>, so you can find and remove elements in <code>O(1)</code>.</p>\n<p>The best solution depends on what the usual number of <code>activeTransactionBlocks</code> is. If it is expected to be low (e.g. less than 5), then the current approach will work. But with larger arrays, I expect <code>EnumerableMap</code> would be more efficient.</p>\n<p>Because an upper limit will not fully mitigate this issue, as a malicious actor can still DDOS the user by pushing useless txs until this limit is reached and a valid router may not be able to submit new txs. And, because you need to improve both the security <em>and</em> performance of <code>removeUserActiveBlocks</code>; <code>EnumerableMap</code> may be a go-to solution.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/27#issuecomment-879509531\">LayneHaber (Connext) confirmed</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/connext/nxtp/pull/24\">https://github.com/connext/nxtp/pull/24</a></p>\n</blockquote>\n<h2 id=\"h-03-router-liquidity-on-receiving-chain-can-be-double-dipped-by-the-user\" style=\"position:relative;\"><a href=\"#h-03-router-liquidity-on-receiving-chain-can-be-double-dipped-by-the-user\" aria-label=\"h 03 router liquidity on receiving chain can be double dipped by the user permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/46\">[H-03] Router liquidity on receiving chain can be double-dipped by the user</a></h2>\n<p><em>Submitted by 0xRajeev, also found by cmichel, gpersoon, pauliax, s1m0 and shw</em></p>\n<p>During <code>fulfill()</code> on the receiving chain, if the user has set up an external contract at <code>txData.callTo</code>, the catch blocks for both <code>IFulfillHelper.addFunds()</code> and <code>IFulfillHelper.excute()</code> perform <code>transferAsset</code> to the predetermined fallback address <code>txData.receivingAddress</code>.</p>\n<p>If <code>addFunds()</code> has reverted earlier, <code>toSend</code> amount would already have been transferred to the <code>receivingAddress</code>. If <code>execute()</code> also fails, it is again transferred.</p>\n<p><strong>Scenario:</strong> User sets up receiver chain <code>txData.callTo</code> contract such that both <code>addFunds()</code> and <code>execute()</code> calls revert. That will let him get twice the <code>toSend</code> amount credited to the <code>receivingAddress</code>. So effectively, Alice locks 100 <code>tokenAs</code> on chain A, and can get 200 <code>tokenAs</code> (or twice the amount of any token she is supposed to get on chain B from the router), minus relayer fee, on chain B. Router liquidity is double-dipped by Alice and router loses funds. See <code>TransactionManager.sol</code> <a href=\"https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L395-L409\">L395-L409</a> and <a href=\"https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L413-L428\">L413-L428</a>.</p>\n<p>Recommend that the second catch block for <code>execute()</code> should likely not have the <code>transferAsset()</code> call. It seems like a copy-and-paste bug unless there is some reason that is outside the specified scope and documentation for this contest.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/46#issuecomment-880098271\">LayneHaber (Connext) confirmed and patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/connext/nxtp/pull/39\">https://github.com/connext/nxtp/pull/39</a></p>\n</blockquote>\n<h2 id=\"h-04-expired-transfers-will-lock-user-funds-on-the-sending-chain\" style=\"position:relative;\"><a href=\"#h-04-expired-transfers-will-lock-user-funds-on-the-sending-chain\" aria-label=\"h 04 expired transfers will lock user funds on the sending chain permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/47\">[H-04] Expired transfers will lock user funds on the sending chain</a></h2>\n<p><em>Submitted by 0xRajeev</em></p>\n<p>The cancelling relayer is being paid in <code>receivingAssetId</code> on the <code>sendingChain</code> instead of in <code>sendingAssetID</code>. If the user relies on a relayer to cancel transactions, and that <code>receivingAssetId</code> asset does not exist on the sending chain (assuming only <code>sendingAssetID</code> on the sending chain and <code>receivingAssetId</code> on the receiving chain are assured to be valid and present), then the cancel transaction from the relayer will always revert and user’s funds will remain locked on the sending chain.</p>\n<p>The impact is that expired transfers can never be cancelled and user funds will be locked forever if user relies on a relayer.</p>\n<p>Recommend changing <code>receivingAssetId</code> to <code>sendingAssetId</code> in <code>transferAsset()</code> on <code>TransactionManager.sol</code> <a href=\"https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L510-L517\">L514</a>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/47#issuecomment-879510286\">LayneHaber (Connext) confirmed and patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/connext/nxtp/pull/25\">https://github.com/connext/nxtp/pull/25</a></p>\n</blockquote>\n<h2 id=\"h-05-approval-is-not-reset-if-the-call-to-ifulfillhelper-fails\" style=\"position:relative;\"><a href=\"#h-05-approval-is-not-reset-if-the-call-to-ifulfillhelper-fails\" aria-label=\"h 05 approval is not reset if the call to ifulfillhelper fails permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/31\">[H-05] <code>Approval</code> is not reset if the call to <code>IFulfillHelper</code> fails</a></h2>\n<p><em>Submitted by pauliax, also found by 0xsanson, cmichel and shw</em></p>\n<p>The function <code>fulfill</code> first approves the <code>callTo</code> to transfer an amount of <code>toSend</code> tokens and tries to call <code>IFulfillHelper</code>, but if the call fails, it transfers these assets directly. However, in such case the approval is not reset, so a malicous <code>callTo</code> can pull these tokens later:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"0\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// First, approve the funds to the helper if needed</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (!</span><span class=\"mtk12\">LibAsset</span><span class=\"mtk1\">.</span><span class=\"mtk11\">isEther</span><span class=\"mtk1\">(</span><span class=\"mtk12\">txData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">receivingAssetId</span><span class=\"mtk1\">) &amp;&amp; </span><span class=\"mtk12\">toSend</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk7\">0</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">      </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">LibERC20</span><span class=\"mtk1\">.</span><span class=\"mtk11\">approve</span><span class=\"mtk1\">(</span><span class=\"mtk12\">txData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">receivingAssetId</span><span class=\"mtk1\">, </span><span class=\"mtk12\">txData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">callTo</span><span class=\"mtk1\">, </span><span class=\"mtk12\">toSend</span><span class=\"mtk1\">), </span><span class=\"mtk8\">&quot;fulfill: APPROVAL_FAILED&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// Next, call `addFunds` on the helper. Helpers should internally</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// track funds to make sure no one user is able to take all funds</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// for tx</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">toSend</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk7\">0</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">      </span><span class=\"mtk15\">try</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">IFulfillHelper</span><span class=\"mtk1\">(</span><span class=\"mtk12\">txData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">callTo</span><span class=\"mtk1\">).</span><span class=\"mtk12\">addFunds</span><span class=\"mtk1\">{ value: </span><span class=\"mtk12\">LibAsset</span><span class=\"mtk1\">.</span><span class=\"mtk11\">isEther</span><span class=\"mtk1\">(</span><span class=\"mtk12\">txData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">receivingAssetId</span><span class=\"mtk1\">) ? </span><span class=\"mtk12\">toSend</span><span class=\"mtk1\"> : </span><span class=\"mtk7\">0</span><span class=\"mtk1\">}(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">          </span><span class=\"mtk12\">txData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">user</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">          </span><span class=\"mtk12\">txData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">transactionId</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">          </span><span class=\"mtk12\">txData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">receivingAssetId</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">          </span><span class=\"mtk12\">toSend</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        )</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">      {} </span><span class=\"mtk15\">catch</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// Regardless of error within the callData execution, send funds</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// to the predetermined fallback address</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">          </span><span class=\"mtk12\">LibAsset</span><span class=\"mtk1\">.</span><span class=\"mtk11\">transferAsset</span><span class=\"mtk1\">(</span><span class=\"mtk12\">txData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">receivingAssetId</span><span class=\"mtk1\">, </span><span class=\"mtk11\">payable</span><span class=\"mtk1\">(</span><span class=\"mtk12\">txData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">receivingAddress</span><span class=\"mtk1\">), </span><span class=\"mtk12\">toSend</span><span class=\"mtk1\">),</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">          </span><span class=\"mtk8\">&quot;fulfill: TRANSFER_FAILED&quot;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        );</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">      }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span></code></pre>\n<p><a href=\"x-fantastical3://show/calendar/2021-08-18\">Tuesday, August 10, 2021</a>\nRecommend that <code>approval</code> should be placed inside the try/catch block or <code>approval</code> needs to be reset if the call fails.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/31#issuecomment-880098587\">LayneHaber (Connext) confirmed and patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/connext/nxtp/pull/39\">https://github.com/connext/nxtp/pull/39</a></p>\n</blockquote>\n<h1 id=\"medium-risk-findings-2\" style=\"position:relative;\"><a href=\"#medium-risk-findings-2\" aria-label=\"medium risk findings 2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Medium Risk Findings (2)</h1>\n<h2 id=\"m-01-signatures-use-only-tx-id-instead-of-entire-digest\" style=\"position:relative;\"><a href=\"#m-01-signatures-use-only-tx-id-instead-of-entire-digest\" aria-label=\"m 01 signatures use only tx id instead of entire digest permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/54\">[M-01] Signatures use only tx ID instead of entire digest</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The signature check in <code>recoverFulfillSignature()</code> only uses transaction ID (along with the relayer fee) which can be accidentally reused by the user, in which case the older signatures with the older relayer fees can be replayed.  The signature should be on the entire digest <code>hashInvariantTransactionData(txData)</code> as indicated in the comment on L306.</p>\n<p>The impact is that,  If the user signatures are indeed on the digest as indicated by the comment, the signature/address check in <code>fulfill()</code> will fail. If not, they may be accidentally/intentionally replayed with same transaction ID, which also appears to be an outstanding question as indicated by the comment on L12.</p>\n<p><code>recoverCancelSignature()</code> similarly uses only tx ID.</p>\n<p>Unless there is a good reason not to, it is safer to include <code>hashInvariantTransactionData(txData)</code> in signatures so that they cannot be replayed with different txData (but same tx ID) whose <code>preparedBlockNumber</code> is > 0.</p>\n<p>Recommend evaluating if the signature should contain only tx ID, or the entire digest, and then changing the logic appropriately.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/54#issuecomment-878569946\">LayneHaber (Connext) acknowledged</a>:</strong></p>\n<blockquote>\n<p>User should be able to break up large transfers across multiple routers using the same <code>transactionId</code> to keep the transaction  unlocking atomic. For example, say I want to transfer $100K, but there are only 8 routers who each have $60K available. I should be able to break up the single transaction into $20K transactions split across 5 of the routers. When unlocking this, I should only need to broadcast a single signature, so all of the transactions can be unlocked simultaneously.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/54#issuecomment-890612308\">ghoul-sol (Judge) commented</a>:</strong></p>\n<blockquote>\n<p>Bumping to medium risk as replay attack can have significant consequences</p>\n</blockquote>\n<h2 id=\"m-02-malicious-router-can-block-cross-chain-transfers\" style=\"position:relative;\"><a href=\"#m-02-malicious-router-can-block-cross-chain-transfers\" aria-label=\"m 02 malicious router can block cross chain transfers permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/12\">[M-02] Malicious router can block cross-chain-transfers</a></h2>\n<p><em>Submitted by 0xRajeev, also found by cmichel and shw</em></p>\n<p>The agreement between the <code>user</code> and the <code>router</code> seems to already happen off-chain because all the fields are required for the initial <code>In variantTransactionData</code> call already. A router could pretend to take on a user’s cross-chain transfer, the user sends their <code>prepare</code> transaction, locking up funds on the sending chain.\nBut then the <code>router</code> simply doesn’t respond or responds with a <code>prepare</code> transaction of <code>amount=0</code>.</p>\n<p>The user’s funds are then locked for the entire expiry time, whereas the router does not have to lock up anything as the amount is 0, even no gas if they simply don’t respond. In this way, a router can bid on everything off-chain without a penalty, and take down everyone that accepts the bid.</p>\n<p>Recommend that maybe there could be a penalty mechanism for non-responsive routers that agreed off-chain, slashing part of their added liquidity. Could also be that the bid signature already helps with this, but I’m not sure how it works as the off-chain part is not part of the repo.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/12#issuecomment-878590098\">LayneHaber (Connext) acknowledged</a>:</strong></p>\n<blockquote>\n<p>This is true, and we are building penalty mechanisms outside of these contracts. For now we are considering adding in a permissioned launch, see #49</p>\n</blockquote>\n<h1 id=\"low-risk-findings-11\" style=\"position:relative;\"><a href=\"#low-risk-findings-11\" aria-label=\"low risk findings 11 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Low Risk Findings (11)</h1>\n<h2 id=\"l-01-lack-of-guarded-launch-approach-may-be-risky\" style=\"position:relative;\"><a href=\"#l-01-lack-of-guarded-launch-approach-may-be-risky\" aria-label=\"l 01 lack of guarded launch approach may be risky permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/49\">[L-01] Lack of guarded launch approach may be risky</a></h2>\n<p><em>Submitted by 0xRajeev, also found by pauliax</em></p>\n<p>The protocol appears to allow arbitrary assets, amounts and routers/users without an initial time-bounded whitelist of assets/routers/users or upper bounds on amounts. Also, there is no pause/unpause functionality. While this lack of ownership and control makes it completely permission-less, it is a risky design because if there are latent protocol vulnerabilities there is no fallback option. See <a href=\"https://medium.com/electric-capital/derisking-defi-guarded-launches-2600ce730e0a\">Derisking DeFi Guarded Assets</a>.</p>\n<p>Recommend considering an initial guarded launch approach to owner-based whitelisting asset types, router/recipient addresses, amount thresholds, and adding a pause/unpause functionality for emergency handling. The design should be able to make this owner configurable, where the owner can renounce ownership at a later point when the protocol operation is sufficiently time-tested and deemed stable/safe.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/49#issuecomment-880309020\">LayneHaber (Connext) confirmed and patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/connext/nxtp/pull/40\">https://github.com/connext/nxtp/pull/40</a></p>\n</blockquote>\n<h2 id=\"l-02-deflationary-and-fee-on-transfer-tokens-are-not-correctly-accounted\" style=\"position:relative;\"><a href=\"#l-02-deflationary-and-fee-on-transfer-tokens-are-not-correctly-accounted\" aria-label=\"l 02 deflationary and fee on transfer tokens are not correctly accounted permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/68\">[L-02] Deflationary and fee-on-transfer tokens are not correctly accounted</a></h2>\n<p><em>Submitted by shw, also found by 0xRajeev, pauliax and cmichel</em></p>\n<p>When a router adds liquidity to the <code>TransactionManager</code>, the manager does not correctly handle the received amount if the transferred token is a deflationary or fee-on-transfer token. The actual received amount is less than what is recorded in the <code>routerBalances</code> variable. See <code>TransactionManager.sol</code> <a href=\"https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L97\">#L97</a> and <a href=\"https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L101\">#L101</a>.</p>\n<p>Recommend getting the received token amount by calculating the difference of token balance before and after the transfer, for example:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"1\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">balanceBefore</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">getOwnBalance</span><span class=\"mtk1\">(</span><span class=\"mtk12\">assetId</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">LibERC20</span><span class=\"mtk1\">.</span><span class=\"mtk11\">transferFrom</span><span class=\"mtk1\">(</span><span class=\"mtk12\">assetId</span><span class=\"mtk1\">, </span><span class=\"mtk12\">router</span><span class=\"mtk1\">, </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">), </span><span class=\"mtk12\">amount</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;addLiquidity: ERC20_TRANSFER_FAILED&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">receivedAmount</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">getOwnBalance</span><span class=\"mtk1\">(</span><span class=\"mtk12\">assetId</span><span class=\"mtk1\">) - </span><span class=\"mtk12\">balanceBefore</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// Update the router balances</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">routerBalances</span><span class=\"mtk1\">[</span><span class=\"mtk12\">router</span><span class=\"mtk1\">][</span><span class=\"mtk12\">assetId</span><span class=\"mtk1\">] += </span><span class=\"mtk12\">receivedAmount</span><span class=\"mtk1\">;</span></span></span></code></pre>\n<p><strong>- <a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/68\">LayneHaber (Connext) confirmed</a></strong></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/68#issuecomment-890608358\">ghoul-sol (Judge) commented</a>:</strong></p>\n<blockquote>\n<p>While correct, this is a low risk. Number of DeFi protocols are incompatible with “exotic” tokens and it’s a user responsibility to know this. Perfect example is rebase tokens and UniswapV2.</p>\n</blockquote>\n<h2 id=\"l-03-missing-zero-address-checks\" style=\"position:relative;\"><a href=\"#l-03-missing-zero-address-checks\" aria-label=\"l 03 missing zero address checks permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/50\">[L-03] Missing zero-address checks</a></h2>\n<p><em>Submitted by 0xRajeev, also found by pauliax</em></p>\n<p>Zero-address checks are in general a best-practice. However, <code>addLiquidity()</code> and <code>removeLiquidity()</code> are missing zero-address checks on router and recipient addresses respectively.</p>\n<p><code>addLiquidity()</code> on Eth transfers will update the zero index balance and get logged as such in the event without the amount getting accounted for the correct router.</p>\n<p>For ERC20 assets, <code>token.transfer()</code> generally implements this check but the Eth transfer using <code>transferEth()</code> does not have this check and calls <code>addr.call(value)</code>, which will lead to burning in the case of <code>removeLiquidity()</code>.</p>\n<p>The checks may be more important because <code>assetID</code> is 0 for Eth. So a router may accidentally use 0 values for both <code>assetID</code> and router/recipient.</p>\n<p>There is also a missing zero-address check on <code>sendingChainFallback</code> which is relevant for Eth transfers in <code>cancel()</code>. The comment on L178 indicates the need for this but the following check on L179 ends up checking <code>receivingAddress</code> instead (which is also necessary). See issue page for referenced code.</p>\n<p>Recommend adding zero-address checks.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/50#issuecomment-879728788\">sanchaymittal (Connext) confirmed and patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/connext/nxtp/pull/32\">https://github.com/connext/nxtp/pull/32</a></p>\n</blockquote>\n<h2 id=\"l-04-an-attacker-can-front-run-a-users-prepare-tx-on-sending-chain-to-cause-dos-by-griefing\" style=\"position:relative;\"><a href=\"#l-04-an-attacker-can-front-run-a-users-prepare-tx-on-sending-chain-to-cause-dos-by-griefing\" aria-label=\"l 04 an attacker can front run a users prepare tx on sending chain to cause dos by griefing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/52\">[L-04] An attacker can front-run a user’s <code>prepare()</code> tx on sending chain to cause DoS by griefing</a></h2>\n<p><em>Submitted by 0xRajeev, also found by cmichel</em></p>\n<p>The <code>prepare()</code> function  hashes the invariantData parameter data to check the mapping entry is 0 for that digest as a measure to prevent duplicate <code>prepare()</code>s. However, an attacker can abuse this check to front-run a targeted victim’s prepare Tx with the same parameters and with some dust amount to prevent the user’s actual prepare Tx from succeeding.</p>\n<p>The impact of this the potential griefing attack vector if user address is not <code>msg.sender</code>. This is with the assumption that relayers are only relevant on the receiving side where the user may not have the <code>receivingAssetId</code> i.e. no reason for <code>msg.sender</code> of <code>prepare()</code> to be the relayer and not the user.</p>\n<p>Recommend adding <code>msg.sender</code> == <code>invariantData.user</code> check on sending chain side similar to the check for router address on the receiving side.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/52#issuecomment-880333582\">LayneHaber (Connext) confirmed and patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/connext/nxtp/pull/42\">https://github.com/connext/nxtp/pull/42</a></p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/52#issuecomment-881780054\">LayneHaber (Connext) acknowledged</a>:</strong></p>\n<blockquote>\n<p>Reverted the changes, without tracking the active blocks this DOS vector still exists but presents no risk to locked funds. It is also unclear what the attacker would gain from this, and would cost them gas funds.</p>\n<p>Could add a signature, but comes with some UX drawbacks that seem more important than removing the DOS vector</p>\n</blockquote>\n<h2 id=\"l-05-txdataexpiry--blocktimestamp\" style=\"position:relative;\"><a href=\"#l-05-txdataexpiry--blocktimestamp\" aria-label=\"l 05 txdataexpiry  blocktimestamp permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/28\">[L-05] <code>txData.expiry</code> = <code>block.timestamp</code></a></h2>\n<p><em>Submitted by pauliax, also found by 0xRajeev and shw</em></p>\n<p>The function <code>fulfill</code> treats <code>txData.expiry</code> = <code>block.timestamp</code> as expired tx:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"2\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// Make sure the expiry has not elapsed</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">txData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">expiry</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk12\">block</span><span class=\"mtk1\">.</span><span class=\"mtk12\">timestamp</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;fulfill: EXPIRED&quot;</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p>However, function <code>cancel</code> has an inclusive check for the same condition:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"3\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">txData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">expiry</span><span class=\"mtk1\"> &gt;= </span><span class=\"mtk12\">block</span><span class=\"mtk1\">.</span><span class=\"mtk12\">timestamp</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// Timeout has not expired and tx may only be cancelled by router</span></span></span></code></pre>\n<p>Recommend unifying that to make the code coherent. Probably <code>txData.expiry</code> = <code>block.timestamp</code> should be treated as expired everywhere.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/28#issuecomment-879682018\">sanchaymittal (Connext) confirmed and patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/connext/nxtp/pull/28\">https://github.com/connext/nxtp/pull/28</a></p>\n</blockquote>\n<h2 id=\"l-06-unsafe-approve\" style=\"position:relative;\"><a href=\"#l-06-unsafe-approve\" aria-label=\"l 06 unsafe approve permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/13\">[L-06] Unsafe <code>approve</code></a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>Some ERC20 tokens like USDT require resetting the approval to 0 first before being able to reset it to another value. (See <a href=\"https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code\">Line 201</a>)\nThe <code>LIibERC20.approve</code> function does not do this - unlike OpenZeppelin’s <code>safeApprove</code> implementation.</p>\n<p>The impact of this, is that repeated USDT cross-chain transfers to the same user on receiving chain = ETH mainnet can fail due to this line not resetting the approval to zero first:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"4\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">LibERC20</span><span class=\"mtk1\">.</span><span class=\"mtk11\">approve</span><span class=\"mtk1\">(</span><span class=\"mtk12\">txData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">receivingAssetId</span><span class=\"mtk1\">, </span><span class=\"mtk12\">txData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">callTo</span><span class=\"mtk1\">, </span><span class=\"mtk12\">toSend</span><span class=\"mtk1\">), </span><span class=\"mtk8\">&quot;fulfill: APPROVAL_FAILED&quot;</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p>Recommend that <code>LiibERC20.approve</code> should do two <code>approve</code> calls, one setting it to <code>0</code> first, then the real one.\nCheck OpenZeppelin’s <code>safeApprove</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/13#issuecomment-879427181\">LayneHaber (Connext) confirmed and patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/connext/nxtp/pull/22\">https://github.com/connext/nxtp/pull/22</a></p>\n</blockquote>\n<h2 id=\"l-07-router-needs-to-decrease-expiry-by-a-significant-buffer\" style=\"position:relative;\"><a href=\"#l-07-router-needs-to-decrease-expiry-by-a-significant-buffer\" aria-label=\"l 07 router needs to decrease expiry by a significant buffer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/15\">[L-07] Router needs to decrease expiry by a significant buffer</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The user’s <code>fulfill</code> signature on the receiving chain is at the same time used by the router as a way to claim their amount on the sending chain.\nIf the sending chain’s <code>expiry</code> date has passed, the user can cancel this side of the transfer and claim back their deposit before the router can claim it.\nTherefore, the comment that the receiving chain’s expiry needs to be decreased is correct:</p>\n<blockquote>\n<p>// expiry should be decremented to ensure the router has time to complete the sender-side transaction after the user completes the receiver-side transactoin.</p>\n</blockquote>\n<p>However, this is not enforced and if a wrong expiry date is chosen by the router, or the sender congests the network long enough such that the router’s <code>fulfill</code> transaction does not get through, the router loses their claim and the user gets a free cross-chain transfer.</p>\n<p>It would be possible to enforce that <code>receivingSide.expiry + buffer &#x3C; sendingSide.expiry</code> if the original expiry was part of the invariant data.\nThis would programmatically avoid errors like the ones mentioned. (Assuming all supported chains use the same way to measure time / use UNIX timestamps.)</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/15#issuecomment-878588868\">LayneHaber (Connext) acknowledged</a>:</strong></p>\n<blockquote>\n<p>This is true, but the router is definitely incentivized to do this correctly. Adding this would also require adding an additional <code>{MINIMUM/MAXIMUM}_BUFFER</code>, and increases the complexity of the contracts for relatively minimal benefit</p>\n</blockquote>\n<h2 id=\"l-08-wrapcall-with-weird-erc20-contracts\" style=\"position:relative;\"><a href=\"#l-08-wrapcall-with-weird-erc20-contracts\" aria-label=\"l 08 wrapcall with weird erc20 contracts permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/4\">[L-08] <code>wrapCall</code> with weird ERC20 contracts</a></h2>\n<p><em>Submitted by gpersoon</em></p>\n<p>The function <code>wrapCall</code> is not completely safe for all possible ERC20 contracts.</p>\n<p>If the <code>returnData.length</code> is larger than 1, the ”<code>abi.decode(returnData, (bool));</code>” will fail. Which means the interactions with that ERC20 contract will fail. Although this is unlikely, it is easy to protect against it.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"5\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"21\"></span><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"22\"></span><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">wrapCall</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">assetId</span><span class=\"mtk1\">, </span><span class=\"mtk12\">bytes</span><span class=\"mtk1\"> </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">callData</span><span class=\"mtk1\">) </span><span class=\"mtk11\">internal</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">bool</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"23\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    ...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"24\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    (</span><span class=\"mtk12\">bool</span><span class=\"mtk1\"> </span><span class=\"mtk12\">success</span><span class=\"mtk1\">, </span><span class=\"mtk12\">bytes</span><span class=\"mtk1\"> </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">returnData</span><span class=\"mtk1\">) = </span><span class=\"mtk12\">assetId</span><span class=\"mtk1\">.</span><span class=\"mtk11\">call</span><span class=\"mtk1\">(</span><span class=\"mtk12\">callData</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"25\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">LibUtils</span><span class=\"mtk1\">.</span><span class=\"mtk11\">revertIfCallFailed</span><span class=\"mtk1\">(</span><span class=\"mtk12\">success</span><span class=\"mtk1\">, </span><span class=\"mtk12\">returnData</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"26\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk12\">returnData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span><span class=\"mtk1\"> == </span><span class=\"mtk7\">0</span><span class=\"mtk1\"> || </span><span class=\"mtk12\">abi</span><span class=\"mtk1\">.</span><span class=\"mtk11\">decode</span><span class=\"mtk1\">(</span><span class=\"mtk12\">returnData</span><span class=\"mtk1\">, (</span><span class=\"mtk12\">bool</span><span class=\"mtk1\">));</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"27\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p>Recommend changing</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"6\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk12\">returnData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span><span class=\"mtk1\"> == </span><span class=\"mtk7\">0</span><span class=\"mtk1\"> || </span><span class=\"mtk12\">abi</span><span class=\"mtk1\">.</span><span class=\"mtk11\">decode</span><span class=\"mtk1\">(</span><span class=\"mtk12\">returnData</span><span class=\"mtk1\">, (</span><span class=\"mtk12\">bool</span><span class=\"mtk1\">));</span></span></span></code></pre>\n<p>to:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"7\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">return</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">returnData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span><span class=\"mtk1\"> == </span><span class=\"mtk7\">0</span><span class=\"mtk1\">) || (</span><span class=\"mtk12\">returnData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span><span class=\"mtk1\"> == </span><span class=\"mtk7\">1</span><span class=\"mtk1\"> &amp;&amp; </span><span class=\"mtk12\">abi</span><span class=\"mtk1\">.</span><span class=\"mtk11\">decode</span><span class=\"mtk1\">(</span><span class=\"mtk12\">returnData</span><span class=\"mtk1\">, (</span><span class=\"mtk12\">bool</span><span class=\"mtk1\">)));</span></span></span></code></pre>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/4#issuecomment-879427044\">LayneHaber (Connext) confirmed and patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/connext/nxtp/pull/22\">https://github.com/connext/nxtp/pull/22</a></p>\n</blockquote>\n<h2 id=\"l-09-max_timeout\" style=\"position:relative;\"><a href=\"#l-09-max_timeout\" aria-label=\"l 09 max_timeout permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/33\">[L-09] <code>MAX_TIMEOUT</code></a></h2>\n<p><em>Submitted by pauliax</em></p>\n<p>There is a <code>MIN_TIMEOUT</code> for the expiry, but I think you should also introduce a <code>MAX_TIMEOUT</code> to avoid a scenario when, for example, expiry is set far in the future (e.g. 100 years) and one malicious side does not agree to fulfill or cancel the tx, so the other side then has to wait and leave the funds locked for 100 years or so.</p>\n<p>Recommend introducing a reasonable <code>MAX_TIMEOUT</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/33#issuecomment-879711651\">sanchaymittal (Connext) confirmed and patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/connext/nxtp/pull/30\">https://github.com/connext/nxtp/pull/30</a></p>\n</blockquote>\n<h2 id=\"l-10-unchangeable-chainid-information\" style=\"position:relative;\"><a href=\"#l-10-unchangeable-chainid-information\" aria-label=\"l 10 unchangeable chainid information permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/66\">[L-10] Unchangeable <code>chainID</code> information</a></h2>\n<p><em>Submitted by shw</em></p>\n<p>The <code>chainId</code> information included in the <code>TransactionManager</code> is immutable, i.e., it could not change after the contract is deployed. However, if a hard fork happens in the future, the contract would become invalid on one of the forked chains because the chain ID has changed. See <code>TransactionManager.sol</code> <a href=\"https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L73\">L73</a> and <a href=\"https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L79\">L79</a>.</p>\n<p>Recommend adding a function that allows the admin to set the <code>chainId</code> variable if a hard fork happens.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/66#issuecomment-878552742\">LayneHaber (Connext) acknowledged</a>:</strong></p>\n<blockquote>\n<p>This is a potential issue in the case of a hard fork, but we will not address it for the following reasons:</p>\n<ol>\n<li>It is reasonable to assume the participants will want their funds to remain consistent on the canonical chain, which should keep the same <code>chainId</code> in the event of a fork</li>\n<li>Creating an admin function to reset the <code>chainId</code> gives admins a huge amount of power over the system itself</li>\n<li>There would still be a race between hard fork activation and updating the <code>chainId</code> that could result in unpredictable transaction behavior</li>\n</ol>\n<p>Instead, the course of action is to redeploy the contracts with the correct <code>chainId</code>.</p>\n</blockquote>\n<h2 id=\"l-11-relayer-txs-can-be-front-runned\" style=\"position:relative;\"><a href=\"#l-11-relayer-txs-can-be-front-runned\" aria-label=\"l 11 relayer txs can be front runned permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/58\">[L-11] Relayer txs can be front-runned</a></h2>\n<p><em>Submitted by pauliax</em></p>\n<p>There is no relayer address param, only <code>relayerFee</code>, so technically anyone can front-run a profitable tx. The scenario might be as follows: A relayer submits a tx. A frontrunner sees it in the mempool and calculates that <code>relayerFee</code> is profitable enough (maybe even insta sell the <code>relayerFee</code> on AMM for the native asset) so he copies and submits the same tx but with a higher gas price. A frontrunner’s tx gets through and a relayer’s tx is reverted afterward. So basically a relayer will experience only losses in such a case.</p>\n<p>Recommend consider introducing relayer address param or reducing the probability of this scenario in any other meaningful way (e.g. blacklist front-runners).</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/58#issuecomment-878584797\">LayneHaber (Connext) acknowledged</a>:</strong></p>\n<blockquote>\n<p>This does technically introduce some frontrun-ability for the relayer fee on the onchain transactions, but relegating the responsibility to a single relayer within the network could compromise the overall network security.</p>\n<p>Consider the following case where a relayer is selected:</p>\n<ol>\n<li>User has a <code>fulfill</code> transaction they would like to be submitted on the receiving chain</li>\n<li>User selects a <code>relayer</code> who will submit a tx for a fee</li>\n<li>User sends the <code>relayer</code> the transaction data to submit the tx, including the <code>signature</code> on the receiving chain</li>\n<li>The <code>relayer</code> can see the <code>router</code> on the transaction, and they collude to submit the signature on the sending chain, wait to cancel the transaction on the receiving chain, and split the profits.</li>\n</ol>\n<p>While the relayer fees are frontrunnable, and this will drive up the costs of the relayer fees for all users, switching away from this pattern will force an “all honest relayers” assumption instead of a “one honest relayer” assumption.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/58#issuecomment-890637276\">ghoul-sol (Judge) commented</a>:</strong></p>\n<blockquote>\n<p>Making this a low risk as the front running doesn’t affect users and it actually forces the whole system to use the most optimal fees.</p>\n</blockquote>\n<h1 id=\"non-critical-findings\" style=\"position:relative;\"><a href=\"#non-critical-findings\" aria-label=\"non critical findings permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Non-Critical Findings</h1>\n<h2 id=\"n-01-missing-param-in-fulfill-natspec\" style=\"position:relative;\"><a href=\"#n-01-missing-param-in-fulfill-natspec\" aria-label=\"n 01 missing param in fulfill natspec permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/64\">[N-01] Missing @param in <code>fulfill</code> NatSpec</a></h2>\n<p><em>Submitted by 0xsanson</em></p>\n<p>The current implementation of NatSpec of <code>fulfill</code> function lacks @param <code>callData</code> in <code>TransactionManager.sol</code> <a href=\"https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L302\">L302</a>.</p>\n<p>Recommend adding @param <code>callData</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/64#issuecomment-880046867\">LayneHaber (Connext) confirmed and patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/connext/nxtp/pull/38\">https://github.com/connext/nxtp/pull/38</a></p>\n</blockquote>\n<h2 id=\"n-02-refactor-reuse-same-code-for-hashvarianttransactiondata-with-txdata-and-when-preparedblocknumber-is-0\" style=\"position:relative;\"><a href=\"#n-02-refactor-reuse-same-code-for-hashvarianttransactiondata-with-txdata-and-when-preparedblocknumber-is-0\" aria-label=\"n 02 refactor reuse same code for hashvarianttransactiondata with txdata and when preparedblocknumber is 0 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/56\">[N-02] Refactor: Reuse same code for <code>hashVariantTransactionData</code> with <code>txData</code> and when <code>preparedBlockNumber</code> is 0</a></h2>\n<p><em>Submitted by GalloDaSballo</em></p>\n<p>The code uses <code>hashVariantTransactionData</code> to verify the hash of the <code>VariantTransactionData</code>\nIt also uses</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"8\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">variantTransactionData</span><span class=\"mtk1\">[</span><span class=\"mtk12\">digest</span><span class=\"mtk1\">] = </span><span class=\"mtk11\">keccak256</span><span class=\"mtk1\">(</span><span class=\"mtk12\">abi</span><span class=\"mtk1\">.</span><span class=\"mtk11\">encode</span><span class=\"mtk1\">(</span><span class=\"mtk11\">VariantTransactionData</span><span class=\"mtk1\">({</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">amount:</span><span class=\"mtk1\"> </span><span class=\"mtk12\">txData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">amount</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">expiry:</span><span class=\"mtk1\"> </span><span class=\"mtk12\">txData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">expiry</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">preparedBlockNumber:</span><span class=\"mtk1\"> </span><span class=\"mtk7\">0</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">})));</span></span></span></code></pre>\n<p>To generate <code>VariantTransactionData</code> with <code>preparedBlockNumber</code> set to 0</p>\n<p>A simple refactoring of:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"9\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">hashVariantTransactionData</span><span class=\"mtk1\">(</span><span class=\"mtk12\">TransactionData</span><span class=\"mtk1\"> </span><span class=\"mtk12\">calldata</span><span class=\"mtk1\"> </span><span class=\"mtk12\">txData</span><span class=\"mtk1\">) </span><span class=\"mtk11\">internal</span><span class=\"mtk1\"> </span><span class=\"mtk11\">pure</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">bytes32</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk11\">hashVariantTransaction</span><span class=\"mtk1\">(</span><span class=\"mtk12\">txData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">amount</span><span class=\"mtk1\">, </span><span class=\"mtk12\">txData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">expiry</span><span class=\"mtk1\">, </span><span class=\"mtk12\">txData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">preparedBlockNumber</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">hashVariantTransaction</span><span class=\"mtk1\">(</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">amount</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">expiry</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">prepareBlocNumber</span><span class=\"mtk1\">) </span><span class=\"mtk11\">internal</span><span class=\"mtk1\"> </span><span class=\"mtk11\">pure</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">bytes32</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk11\">keccak256</span><span class=\"mtk1\">(</span><span class=\"mtk12\">abi</span><span class=\"mtk1\">.</span><span class=\"mtk11\">encode</span><span class=\"mtk1\">(</span><span class=\"mtk11\">VariantTransactionData</span><span class=\"mtk1\">({</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">amount:</span><span class=\"mtk1\"> </span><span class=\"mtk12\">amount</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">expiry:</span><span class=\"mtk1\"> </span><span class=\"mtk12\">expiry</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">preparedBlockNumber:</span><span class=\"mtk1\"> </span><span class=\"mtk12\">preparedBlockNumber</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  })));</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p>This would allow to further steamline the code from</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"10\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">variantTransactionData</span><span class=\"mtk1\">[</span><span class=\"mtk12\">digest</span><span class=\"mtk1\">] = </span><span class=\"mtk11\">keccak256</span><span class=\"mtk1\">(</span><span class=\"mtk12\">abi</span><span class=\"mtk1\">.</span><span class=\"mtk11\">encode</span><span class=\"mtk1\">(</span><span class=\"mtk11\">VariantTransactionData</span><span class=\"mtk1\">({</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">amount:</span><span class=\"mtk1\"> </span><span class=\"mtk12\">txData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">amount</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">expiry:</span><span class=\"mtk1\"> </span><span class=\"mtk12\">txData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">expiry</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">preparedBlockNumber:</span><span class=\"mtk1\"> </span><span class=\"mtk7\">0</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">})));</span></span></span></code></pre>\n<p>to</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"11\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">variantTransactionData</span><span class=\"mtk1\">[</span><span class=\"mtk12\">digest</span><span class=\"mtk1\">] = </span><span class=\"mtk11\">hashVariantTransaction</span><span class=\"mtk1\">(</span><span class=\"mtk12\">txData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">amount</span><span class=\"mtk1\">, </span><span class=\"mtk12\">txData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">expiry</span><span class=\"mtk1\">, </span><span class=\"mtk7\">0</span><span class=\"mtk1\">)</span></span></span></code></pre>\n<p>This has no particular benefit beside making all code related to Variant Data consistent.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/56#issuecomment-880025294\">LayneHaber (Connext) confirmed and patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/connext/nxtp/pull/37\">https://github.com/connext/nxtp/pull/37</a></p>\n</blockquote>\n<h2 id=\"n-03-dont-use-assembly-\" style=\"position:relative;\"><a href=\"#n-03-dont-use-assembly-\" aria-label=\"n 03 dont use assembly  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/3\">[N-03] don’t use assembly </a></h2>\n<p><em>Submitted by gpersoon</em></p>\n<p>The function <code>revertIfCallFailed</code> of <code>LibUtils.sol</code> uses “assembly” to log error information in a revert situation. In the latest solidity version, this can be done in solidity using the “error” keyword.\nSee: <a href=\"https://docs.soliditylang.org/en/latest/control-structures.html?#revert\">https://docs.soliditylang.org/en/latest/control-structures.html?#revert</a></p>\n<p>Using pure solidity improves readability.</p>\n<p><code>LibUtils.sol</code> <a href=\"https://github.com/code-423n4/2021-07-connext/blob/main/contracts/lib/LibUtils.sol#L10\">L10</a></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"12\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">revertIfCallFailed</span><span class=\"mtk1\">(</span><span class=\"mtk12\">bool</span><span class=\"mtk1\"> </span><span class=\"mtk12\">success</span><span class=\"mtk1\">, </span><span class=\"mtk12\">bytes</span><span class=\"mtk1\"> </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">returnData</span><span class=\"mtk1\">) </span><span class=\"mtk11\">internal</span><span class=\"mtk1\"> </span><span class=\"mtk11\">pure</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (!</span><span class=\"mtk12\">success</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">assembly</span><span class=\"mtk1\"> {  </span><span class=\"mtk11\">revert</span><span class=\"mtk1\">(</span><span class=\"mtk11\">add</span><span class=\"mtk1\">(</span><span class=\"mtk12\">returnData</span><span class=\"mtk1\">, </span><span class=\"mtk7\">0x20</span><span class=\"mtk1\">), </span><span class=\"mtk11\">mload</span><span class=\"mtk1\">(</span><span class=\"mtk12\">returnData</span><span class=\"mtk1\">))  }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p>Recommend using the error constructs of solidity 0.8.4+</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/3#issuecomment-879427528\">LayneHaber (Connext) confirmed and patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/connext/nxtp/pull/22\">https://github.com/connext/nxtp/pull/22</a></p>\n</blockquote>\n<h2 id=\"n-04-code-consistency-for-hashvarianttransactiondata\" style=\"position:relative;\"><a href=\"#n-04-code-consistency-for-hashvarianttransactiondata\" aria-label=\"n 04 code consistency for hashvarianttransactiondata permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/22\">[N-04] Code Consistency for <code>hashVariantTransactionData()</code></a></h2>\n<p><em>Submitted by greiart</em></p>\n<p><code>hashVariantTransactionData()</code> should follow the same style of <code>hashInvariantTransactionData()</code> and the recover signature functions, where the payload is generated is stored in memory before hashing. Preliminary tests in remix show that it is minimally more gas efficient as well.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"jsx\" data-index=\"13\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">hashVariantTransactionData</span><span class=\"mtk1\">(</span><span class=\"mtk12\">TransactionData</span><span class=\"mtk1\"> </span><span class=\"mtk12\">calldata</span><span class=\"mtk1\"> </span><span class=\"mtk12\">txData</span><span class=\"mtk1\">) </span><span class=\"mtk11\">internal</span><span class=\"mtk1\"> </span><span class=\"mtk11\">pure</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">bytes32</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">VariantTransactionData</span><span class=\"mtk1\"> </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">variant</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">VariantTransactionData</span><span class=\"mtk1\">({</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">      </span><span class=\"mtk12\">amount:</span><span class=\"mtk1\"> </span><span class=\"mtk12\">txData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">amount</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">      </span><span class=\"mtk12\">expiry:</span><span class=\"mtk1\"> </span><span class=\"mtk12\">txData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">expiry</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">      </span><span class=\"mtk12\">preparedBlockNumber:</span><span class=\"mtk1\"> </span><span class=\"mtk12\">txData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">preparedBlockNumber</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">\t\t});</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">\t\t</span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk11\">keccak256</span><span class=\"mtk1\">(</span><span class=\"mtk12\">abi</span><span class=\"mtk1\">.</span><span class=\"mtk11\">encode</span><span class=\"mtk1\">(</span><span class=\"mtk12\">variant</span><span class=\"mtk1\">));</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  }</span></span></span></code></pre>\n<p><a href=\"https://www.notion.so/Code-Consistency-for-hashVariantTransactionData-33bf6578a16c4b18896f4d7ca7582e21\">Alternative View on Notion</a></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/22#issuecomment-879669310\">sanchaymittal (Connext) confirmed and patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/connext/nxtp/pull/27\">https://github.com/connext/nxtp/pull/27</a></p>\n</blockquote>\n<h2 id=\"n-05-style-issues\" style=\"position:relative;\"><a href=\"#n-05-style-issues\" aria-label=\"n 05 style issues permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/29\">[N-05] Style issues</a></h2>\n<p><em>Submitted by pauliax</em></p>\n<p><code>ETHER_ASSETID</code> is a bit missleading name, I think a better name would be <code>NATIVE_ASSETID</code>:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"14\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">constant</span><span class=\"mtk1\"> </span><span class=\"mtk8\">`ETHER_ASSETID`</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p>Misleading comment (should be ‘for fulfillment’):</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"15\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// The structure of the signed data for cancellations</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">struct</span><span class=\"mtk1\"> </span><span class=\"mtk12\">SignedFulfillData</span><span class=\"mtk1\"> {</span></span></span></code></pre>\n<p><code>MIN_TIMEOUT</code> could be expressed in days:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"16\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">public</span><span class=\"mtk1\"> </span><span class=\"mtk12\">constant</span><span class=\"mtk1\"> </span><span class=\"mtk12\">MIN_TIMEOUT</span><span class=\"mtk1\"> = </span><span class=\"mtk7\">1</span><span class=\"mtk1\"> </span><span class=\"mtk12\">days</span><span class=\"mtk1\">; </span><span class=\"mtk3\">// 24 hours</span></span></span></code></pre>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/29#issuecomment-879688577\">sanchaymittal (Connext) confirmed and patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/connext/nxtp/pull/29\">https://github.com/connext/nxtp/pull/29</a></p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/29#issuecomment-879694397\">sanchaymittal (Connext) commented</a>:</strong></p>\n<blockquote>\n<p>@LayneHaber (Connext) I can’t find the above-mentioned typos in our latest contracts on main, not sure if changing min_timeout from hours to days makes a difference.</p>\n<p>Still created the Pr for the above.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/29#issuecomment-880061606\">LayneHaber (Connext) commented</a>:</strong></p>\n<blockquote>\n<p>It should be in <code>LibAsset</code>, will update</p>\n</blockquote>\n<h2 id=\"n-06-dont-ask-for-the-users-signature-when-msgsender--txdatauser\" style=\"position:relative;\"><a href=\"#n-06-dont-ask-for-the-users-signature-when-msgsender--txdatauser\" aria-label=\"n 06 dont ask for the users signature when msgsender  txdatauser permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/57\">[N-06] Don’t ask for the user’s signature when <code>msg.sender</code> == <code>txData.user</code></a></h2>\n<p><em>Submitted by pauliax</em></p>\n<p>I think it would make sense not to check the user’s signature in <code>recoverCancelSignature</code> or <code>recoverFulfillSignature</code> if the caller is the user himself.</p>\n<p>Recommend replacing</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"17\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk11\">recoverCancelSignature</span><span class=\"mtk1\">(</span><span class=\"mtk12\">txData</span><span class=\"mtk1\">, </span><span class=\"mtk12\">relayerFee</span><span class=\"mtk1\">, </span><span class=\"mtk12\">signature</span><span class=\"mtk1\">) == </span><span class=\"mtk12\">txData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">user</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;cancel: INVALID_SIGNATURE&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk11\">recoverFulfillSignature</span><span class=\"mtk1\">(</span><span class=\"mtk12\">txData</span><span class=\"mtk1\">, </span><span class=\"mtk12\">relayerFee</span><span class=\"mtk1\">, </span><span class=\"mtk12\">signature</span><span class=\"mtk1\">) == </span><span class=\"mtk12\">txData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">user</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;fulfill: INVALID_SIGNATURE&quot;</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p>with:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"18\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\"> == </span><span class=\"mtk12\">txData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">user</span><span class=\"mtk1\"> | </span><span class=\"mtk11\">recoverCancelSignature</span><span class=\"mtk1\">(</span><span class=\"mtk12\">txData</span><span class=\"mtk1\">, </span><span class=\"mtk12\">relayerFee</span><span class=\"mtk1\">, </span><span class=\"mtk12\">signature</span><span class=\"mtk1\">) == </span><span class=\"mtk12\">txData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">user</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;cancel: INVALID_SIGNATURE&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\"> == </span><span class=\"mtk12\">txData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">user</span><span class=\"mtk1\"> || </span><span class=\"mtk11\">recoverFulfillSignature</span><span class=\"mtk1\">(</span><span class=\"mtk12\">txData</span><span class=\"mtk1\">, </span><span class=\"mtk12\">relayerFee</span><span class=\"mtk1\">, </span><span class=\"mtk12\">signature</span><span class=\"mtk1\">) == </span><span class=\"mtk12\">txData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">user</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;fulfill: INVALID_SIGNATURE&quot;</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/57#issuecomment-880313581\">LayneHaber (Connext) confirmed</a>:</strong></p>\n<blockquote>\n<p>Cannot do this on <code>fulfill</code> because then users can prevent routers from fulfilling by never revealing the proper signature. But can do this on <code>cancel</code>.</p>\n<p>PR: <a href=\"https://github.com/connext/nxtp/pull/41\">https://github.com/connext/nxtp/pull/41</a></p>\n</blockquote>\n<h1 id=\"gas-optimizations-12\" style=\"position:relative;\"><a href=\"#gas-optimizations-12\" aria-label=\"gas optimizations 12 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Gas Optimizations (12)</h1>\n<h2 id=\"g-01-using-access-lists-can-save-gas-due-to-eip-2930-post-berlin-hard-fork\" style=\"position:relative;\"><a href=\"#g-01-using-access-lists-can-save-gas-due-to-eip-2930-post-berlin-hard-fork\" aria-label=\"g 01 using access lists can save gas due to eip 2930 post berlin hard fork permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/39\">[G-01] Using access lists can save gas due to EIP-2930 post-Berlin hard fork</a></h2>\n<p><em>Submitted by 0xRajeev</em></p>\n<p>EIP-2929 in Berlin fork increased the gas costs of SLOADs and CALL* family opcodes, increasing them for not-accessed slots/addresses and decreasing them for accessed slots. EIP-2930 optionally supports specifying an access list (in the transaction) of all slots and addresses accessed by the transaction, which reduces their gas cost upon access and prevents EIP-2929 gas cost increases from breaking contracts.</p>\n<p>The impact of this is that, these changes may significantly impact gas usage for transactions that call functions touching many state variables or making many external calls. Specifically, <code>removeUserActiveBlocks()</code> removes an active block from the array of blocks for an user, all of which are stored in storage. Transactions for <code>fulfill()</code> and <code>cancel()</code> functions that call <code>removeUserActiveBlocks()</code>  can consider using access lists for all the storage state (of user’s active blocks) they touch (read + write) to reduce gas.</p>\n<p>Recommend evaluating the feasibility of using access lists to save gas due to EIPs 2929 &#x26; 2930 post-Berlin hard fork. The tooling support is WIP.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/39#issuecomment-880951433\">LayneHaber (Connext) confirmed and patched</a>:</strong></p>\n<blockquote>\n<p>Removed tracking of active blocks: <a href=\"https://github.com/connext/nxtp/pull/24\">https://github.com/connext/nxtp/pull/24</a></p>\n</blockquote>\n<h2 id=\"g-02-cache-storage-variables-to-local-variables-to-save-gas\" style=\"position:relative;\"><a href=\"#g-02-cache-storage-variables-to-local-variables-to-save-gas\" aria-label=\"g 02 cache storage variables to local variables to save gas permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/75\">[G-02] Cache storage variables to local variables to save gas</a></h2>\n<p><em>Submitted by shw, also found by 0xRajeev</em></p>\n<p>In general, if a state variable is read more than once, caching its value to a local variable and reusing it will save gas since a storage read spends more gas than a memory write plus a memory read.</p>\n<p>Recommend rewriting <code>TransactionManager.sol</code> <a href=\"https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L122-L125\">#L122-L125</a> as follows:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"19\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">balance</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">routerBalances</span><span class=\"mtk1\">[</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">][</span><span class=\"mtk12\">assetId</span><span class=\"mtk1\">];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">balance</span><span class=\"mtk1\"> &gt;= </span><span class=\"mtk12\">amount</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;removeLiquidity: INSUFFICIENT_FUNDS&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// Update router balances</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">routerBalances</span><span class=\"mtk1\">[</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">][</span><span class=\"mtk12\">assetId</span><span class=\"mtk1\">] = </span><span class=\"mtk12\">balance</span><span class=\"mtk1\"> - </span><span class=\"mtk12\">amount</span><span class=\"mtk1\">;</span></span></span></code></pre>\n<p>And rewriting <code>TransactionManager.sol</code> <a href=\"https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L254-L260\">L254-L260</a> as follows:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"20\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">balance</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">routerBalances</span><span class=\"mtk1\">[</span><span class=\"mtk12\">invariantData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">router</span><span class=\"mtk1\">][</span><span class=\"mtk12\">invariantData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">receivingAssetId</span><span class=\"mtk1\">];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">balance</span><span class=\"mtk1\"> &gt;= </span><span class=\"mtk12\">amount</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk8\">&quot;prepare: INSUFFICIENT_LIQUIDITY&quot;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// Decrement the router liquidity</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">routerBalances</span><span class=\"mtk1\">[</span><span class=\"mtk12\">invariantData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">router</span><span class=\"mtk1\">][</span><span class=\"mtk12\">invariantData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">receivingAssetId</span><span class=\"mtk1\">] = </span><span class=\"mtk12\">balance</span><span class=\"mtk1\"> - </span><span class=\"mtk12\">amount</span><span class=\"mtk1\">;</span></span></span></code></pre>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/75#issuecomment-879859196\">sanchaymittal (Connext) confirmed and patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/connext/nxtp/pull/34\">https://github.com/connext/nxtp/pull/34</a></p>\n</blockquote>\n<h2 id=\"g-03-checking-before-external-library-call-can-save-2600-gas\" style=\"position:relative;\"><a href=\"#g-03-checking-before-external-library-call-can-save-2600-gas\" aria-label=\"g 03 checking before external library call can save 2600 gas permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/41\">[G-03] Checking before external library call can save 2600 gas</a></h2>\n<p><em>Submitted by 0xRajeev, also found by pauliax</em></p>\n<p>EIP-2929 in Berlin fork increased the gas costs of CALL* family opcodes to 2600. Making a <code>delegatecall</code> to a library function therefore costs 2600. <code>LibUtils.revertIfCallFailed()</code> reverts and passes on the revert string if the boolean argument is false. Instead, moving the checking of the boolean to the caller avoids the library call when the boolean is true, which is likely the case most of the time.</p>\n<p>Recommend removing the boolean parameter from <code>revertIfCallFailed()</code>, and move the conditional check logic to the call sites.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/41#issuecomment-880009356\">LayneHaber (Connext) confirmed and patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/connext/nxtp/pull/22\">https://github.com/connext/nxtp/pull/22</a></p>\n</blockquote>\n<h2 id=\"g-04-consolidating-library-functions-can-save-gas-by-preventing-external-calls\" style=\"position:relative;\"><a href=\"#g-04-consolidating-library-functions-can-save-gas-by-preventing-external-calls\" aria-label=\"g 04 consolidating library functions can save gas by preventing external calls permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/42\">[G-04] Consolidating library functions can save gas by preventing external calls</a></h2>\n<p><em>Submitted by 0xRajeev</em></p>\n<p>While code modularity is generally a good practice and creating libraries of functions commonly used across different contracts can increase maintainability and reduce contract deployment size/cost, it comes at the increased cost of gas usage at runtime because of the external calls. EIP-2929 in Berlin fork increased the gas costs of CALL* family opcodes to 2600. Making a <code>delegatecall</code> to a library function therefore costs 2600.</p>\n<p>The impact is that, <code>LibAsset.transferAsset()</code> call from <code>TransactionManager.sol</code> makes <code>LibERC20.transfer()</code> call for ERC20 which in turn makes another external call to <code>LibUtils.revertIfCallFailed()</code> in <code>wrapCall</code>. So an ERC20 transfer effectively makes 3 additional (besides the ERC20 token contract function call <code>assetId.call(..)</code> external calls -> <code>LibAsset</code> -> <code>LibERC20</code> -> <code>LibUtils</code>, which costs 2600*3 = 7800 gas.</p>\n<p>Combining these functions into a single library or making them all internal to <code>TransactionManager.sol</code> can convert these <code>delegatecall</code>s into JMPs to save gas. See issue page for referenced code.</p>\n<p>Recommend considering moving all the library functions internal to this contract, or to a single library, to save gas from external calls, each of which costs 2600 gas.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/42#issuecomment-879427119\">LayneHaber (Connext) confirmed and patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/connext/nxtp/pull/22\">https://github.com/connext/nxtp/pull/22</a></p>\n</blockquote>\n<h2 id=\"g-05-evaluate-security-benefit-vs-gas-usage-trade-off-for-using-nonreentrant-modifier-on-different-functions\" style=\"position:relative;\"><a href=\"#g-05-evaluate-security-benefit-vs-gas-usage-trade-off-for-using-nonreentrant-modifier-on-different-functions\" aria-label=\"g 05 evaluate security benefit vs gas usage trade off for using nonreentrant modifier on different functions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/43\">[G-05] Evaluate security benefit vs gas usage trade-off for using nonreentrant modifier on different functions</a></h2>\n<p><em>Submitted by 0xRajeev</em></p>\n<p>While it may be considered extra-safe to have a nonreentrant modifier on all functions making any external calls even though they are to trusted contracts, when functions implement Checks-Effects-Interactions (CEI) pattern, it is helpful to evaluate the perceived security benefit vs gas usage trade-off for using nonreentrant modifier.</p>\n<p>Functions adhering to the CEI pattern may consider not having the nonreentrant modifier which does two <code>SSTORES</code> (getting more expensive with the London fork EIP-3529) to its <code>_status</code> state variable.</p>\n<p><strong>Example 1:</strong> In <code>addLiquidity()</code>, by moving the updating of router balance on L101 to before the transfers from L92, the function would adhere to CEI pattern and could be evaluated to remove the nonreentrant modifier.</p>\n<p><strong>Example 2:</strong> <code>removeLiquidity()</code> already adheres to CEI pattern and could be evaluated to remove the nonreentrant modifier.</p>\n<p><code>prepare()</code> can be slightly restructured to follow CEI pattern as well. However, <code>fulfill()</code> and <code>cancel()</code> are risky with multiple external calls and its safer to leave the nonreentrant call at the expense of additional gas costs.</p>\n<p>The impact is that, you can save gas by removing  the nonreentrant modifier if function is deemed to be reentrant safe. This can save gas costs of 2 SSTORES per function call that uses this modifier: _status SSTORE from 1 to 2 costs 5000 and _status SSTORE from 2 to 1 which costs 100 (because it was already accessed) which is significant at 5100 per call post-Berlin EIP-2929. See <code>TransactionManager.sol</code> <a href=\"https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L92-L101\">L92-L101</a>.</p>\n<p>Recommend evaluating security benefit vs gas usage trade-off for using nonreentrant modifier on functions that may already be reentrant safe or do not need this protection. It may indeed be safe to leave this modifier (while accepting the gas impact) if such an evaluation is tricky or depends on assumptions.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/43#issuecomment-880949708\">LayneHaber (Connext) confirmed and patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/connext/nxtp/pull/44\">https://github.com/connext/nxtp/pull/44</a></p>\n</blockquote>\n<h2 id=\"g-06-use-the-unchecked-keyword-to-save-gas\" style=\"position:relative;\"><a href=\"#g-06-use-the-unchecked-keyword-to-save-gas\" aria-label=\"g 06 use the unchecked keyword to save gas permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/74\">[G-06] Use the <code>unchecked</code> keyword to save gas</a></h2>\n<p><em>Submitted by shw, also found by 0xRajeev, cmichel, greiart, and s1m0</em></p>\n<p>Using the <code>unchecked</code> keyword to avoid redundant arithmetic underflow/overflow checks to save gas when an underflow/overflow cannot happen.</p>\n<p>We can apply the <code>unchecked</code> keyword in the following lines of code since there are <code>require</code> statements before to ensure the arithmetic operations would not cause an integer underflow or overflow.</p>\n<p>For example, change the code at line 364 to:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"21\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">unchecked</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">toSend</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">txData</span><span class=\"mtk1\">.</span><span class=\"mtk12\">amount</span><span class=\"mtk1\"> - </span><span class=\"mtk12\">relayerFee</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/74#issuecomment-879837226\">sanchaymittal (Connext) confirmed and patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/connext/nxtp/pull/33\">https://github.com/connext/nxtp/pull/33</a></p>\n</blockquote>\n<h2 id=\"g-07-increment-in-the-loop-can-be-made-unchecked\" style=\"position:relative;\"><a href=\"#g-07-increment-in-the-loop-can-be-made-unchecked\" aria-label=\"g 07 increment in the loop can be made unchecked permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/65\">[G-07] Increment in the loop can be made unchecked</a></h2>\n<p><em>Submitted by hrkrshnn</em></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"diff\" data-index=\"22\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\"> import &quot;./interfaces/IFulfillHelper.sol&quot;;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\"> import &quot;./interfaces/ITransactionManager.sol&quot;;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">@@ -556,6 +556,12 @@ contract TransactionManager is ReentrancyGuard, ITransactionManager {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">     return activeTransactionBlocks[user];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">   }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">+  function unchecked_inc(uint256 i) internal pure returns (uint256) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">+      unchecked {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">+          return i + 1;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">+      }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">+  }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">+</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">   //////////////////////////</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">   /// Private functions ///</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">   //////////////////////////</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">@@ -570,7 +576,7 @@ contract TransactionManager is ReentrancyGuard, ITransactionManager {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">     uint256[] memory updated = new uint256[](newLength);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">     bool removed = false;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">     uint256 updatedIdx = 0;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk8\">-    for (uint256 i; i &lt; newLength + 1; i++) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">+    for (uint256 i; i &lt; newLength + 1; i = unchecked_inc(i)) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">       // Handle case where there could be more than one tx added in a block</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">       // And only one should be removed</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">       if (!removed &amp;&amp; activeTransactionBlocks[user][i] == preparedBlock) {</span></span></span></code></pre>\n<p>Recommend making sure that you enable the optimizer and need at least solidity 0.8.4 (i.e., the low level inliner).\nThe old code would have an unnecessary checked addition, and potentially also, not inlined. Would save at least 20-30 gas for each loop iteration.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/65#issuecomment-879268775\">LayneHaber (Connext) acknowledged</a>:</strong></p>\n<blockquote>\n<p><code>unchecked</code> references mentioned in #74 but missed the index. We will also be using <code>EnumerableSet</code> for the active block checking</p>\n</blockquote>\n<h2 id=\"g-08-checking-non-zero-value-can-avoid-an-external-call-to-save-gas\" style=\"position:relative;\"><a href=\"#g-08-checking-non-zero-value-can-avoid-an-external-call-to-save-gas\" aria-label=\"g 08 checking non zero value can avoid an external call to save gas permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/45\">[G-08] Checking non-zero value can avoid an external call to save gas</a></h2>\n<p><em>Submitted by 0xRajeev</em></p>\n<p>Checking if <code>toSend</code> > 0 before making the external library call to <code>LibAsset.transferAsset()</code> can save 2600 gas by avoiding the external call in such situations. See <a href=\"https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L375-L380\">L375-L380</a> and <a href=\"https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L364\">L364</a>.</p>\n<p>Recommend adding <code>toSend</code> > 0 to predicate on L375 similar to check on L387.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/45#issuecomment-879713986\">sanchaymittal (Connext) confirmed and patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/connext/nxtp/pull/31\">https://github.com/connext/nxtp/pull/31</a></p>\n</blockquote>\n<h2 id=\"g-09-optimizing-the-for-loop\" style=\"position:relative;\"><a href=\"#g-09-optimizing-the-for-loop\" aria-label=\"g 09 optimizing the for loop permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/60\">[G-09] Optimizing the for loop</a></h2>\n<p><em>Submitted by hrkrshnn, also found by GalloDaSballo, cmichel, gpersoon and shw</em></p>\n<p>The for loop can improved, here is a diff:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"diff\" data-index=\"23\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">@@ -565,22 +565,26 @@ contract TransactionManager is ReentrancyGuard, ITransactionManager {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">   /// @param user User who has completed a transaction</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">   /// @param preparedBlock The TransactionData.preparedBlockNumber to remove</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">   function removeUserActiveBlocks(address user, uint256 preparedBlock) internal {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk8\">-    // Remove active blocks</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk8\">-    uint256 newLength = activeTransactionBlocks[user].length - 1;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk8\">-    uint256[] memory updated = new uint256[](newLength);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk8\">-    bool removed = false;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk8\">-    uint256 updatedIdx = 0;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk8\">-    for (uint256 i; i &lt; newLength + 1; i++) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk8\">-      // Handle case where there could be more than one tx added in a block</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk8\">-      // And only one should be removed</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk8\">-      if (!removed &amp;&amp; activeTransactionBlocks[user][i] == preparedBlock) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk8\">-        removed = true;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk8\">-        continue;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk8\">-      }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk8\">-      updated[updatedIdx] = activeTransactionBlocks[user][i];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk8\">-      updatedIdx++;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">+</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">+    uint256[] storage array = activeTransactionBlocks[user];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">+    uint256 length = array.length;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">+    uint256 matchIdx = type(uint).max;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">+</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">+    for (uint256 i = 0; i &lt; length; i++) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">+        if (array[i] == preparedBlock)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">+        {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">+            matchIdx = i;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">+            break;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">+        }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">     }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk8\">-    activeTransactionBlocks[user] = updated;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">+</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">+    if (matchIdx != type(uint256).max) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">+        for (uint256 i = matchIdx; i &lt; length; i++) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">+            array[i] = array[i+1];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">+        }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">+        array.pop();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">+    }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">+</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">   }</span></span></span></code></pre>\n<p>The other implementation creates unnecessary copies in memory. And overwrites slots unnecessary (something like <code>sstore(slot,sload(slot))</code>). The above implementation should save significant amount of gas, by avoiding both unnecessary memory and unnecessary storage writes. Please check; was written in a hurry, but the general idea\nshould work 🙂</p>\n<h3 id=\"optimizing-the-loop-try-to-pass-the-array-index-instead\" style=\"position:relative;\"><a href=\"#optimizing-the-loop-try-to-pass-the-array-index-instead\" aria-label=\"optimizing the loop try to pass the array index instead permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Optimizing the loop: Try to pass the array index instead</h3>\n<p>Instead of trying to compute the index <code>i</code> where</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"24\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">activeTransactionBlocks</span><span class=\"mtk1\">[</span><span class=\"mtk12\">user</span><span class=\"mtk1\">][</span><span class=\"mtk12\">i</span><span class=\"mtk1\">] == </span><span class=\"mtk12\">blockIndex</span></span></span></code></pre>\n<p>One can try to already compute this off chain and pass it as the parameter. This avoids the expensive step of reading values from storage on chain, and saves a significant amount of gas. Assume that this index <code>i</code> is passed as a parameter. On chain, all you need to do is have</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"25\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">activeTransactionBlocks</span><span class=\"mtk1\">[</span><span class=\"mtk12\">user</span><span class=\"mtk1\">][</span><span class=\"mtk12\">i</span><span class=\"mtk1\">] == </span><span class=\"mtk12\">blockIndex</span><span class=\"mtk1\">)</span></span></span></code></pre>\n<p>After that, use the second for loop at the end in the previous example.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/60#issuecomment-879266202\">LayneHaber (Connext) acknowledged</a>:</strong></p>\n<blockquote>\n<p>Going to replace the <code>activeBlocks</code> with open zeppelin’s <code>EnumerableSet</code></p>\n</blockquote>\n<h2 id=\"g-10-gas-only-pass-transactionid-as-parameter-instead-of-transactiondata\" style=\"position:relative;\"><a href=\"#g-10-gas-only-pass-transactionid-as-parameter-instead-of-transactiondata\" aria-label=\"g 10 gas only pass transactionid as parameter instead of transactiondata permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/19\">[G-10] Gas: Only pass <code>transactionId</code> as parameter instead of <code>TransactionData</code></a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>Both the <code>recoverFulfillSignature</code> and <code>recoverCancelSignature</code> functions take a large <code>TransactionData</code> object as their first argument but only use the <code>transactionId</code> field of the struct. It should be more efficient to only pass <code>txData.transactionId</code> as the parameter.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/19#issuecomment-879434284\">LayneHaber (Connext) confirmed and patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/connext/nxtp/pull/23\">https://github.com/connext/nxtp/pull/23</a></p>\n</blockquote>\n<h2 id=\"g-11-revert-strings\" style=\"position:relative;\"><a href=\"#g-11-revert-strings\" aria-label=\"g 11 revert strings permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/59\">[G-11] Revert strings</a></h2>\n<p><em>Submitted by hrkrshnn</em></p>\n<p>Consider using custom errors instead of revert strings. Can save gas when the revert condition has been met and also during runtime.</p>\n<p>Consider shortening revert strings to less than 32 bytes. Revert strings more than 32 bytes require at least one additional <code>mstore</code>, along with additional operations for computing memory offset, etc.</p>\n<p>Even if you need a string to represent an error, it can usually be done in less than 32 bytes / characters.</p>\n<p>Here are some examples of strings that can be shortened from codebase:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"\" data-index=\"26\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">./contracts/TransactionManager.sol:96: &quot;addLiquidity: ETH_WITH_ERC_TRANSFER&quot;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">./contracts/TransactionManager.sol:97: &quot;addLiquidity: ERC20_TRANSFER_FAILED&quot;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">./contracts/TransactionManager.sol:122: &quot;removeLiquidity: INSUFFICIENT_FUNDS&quot;</span></span></code></pre>\n<p>Note that this will only decrease runtime gas when the revert condition has been met. Regardless, it will decrease deploy time gas.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/59#issuecomment-881722985\">sanchaymittal (Connext) confirmed and patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/connext/nxtp/pull/47\">https://github.com/connext/nxtp/pull/47</a></p>\n</blockquote>\n<h2 id=\"g-12-assignment-of-variables-not-needed\" style=\"position:relative;\"><a href=\"#g-12-assignment-of-variables-not-needed\" aria-label=\"g 12 assignment of variables not needed permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/36\">[G-12] Assignment of variables not needed</a></h2>\n<p><em>Submitted by s1m0</em></p>\n<p>Variables on <code>TransactionManager.sol</code> <a href=\"https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L571\">L571</a> and <a href=\"https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L572\">L572</a> are being assigned their default value so it’s not needed.</p>\n<p>Recommend removing the assignments for saving a bit of gas when deploying.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-connext-findings/issues/36#issuecomment-879276169\">LayneHaber (Connext) acknowledged</a>:</strong></p>\n<blockquote>\n<p>We are taking out the loop in favor of the <code>EnumerableSet</code> from OpenZeppelin</p>\n</blockquote>\n<h1 id=\"disclosures\" style=\"position:relative;\"><a href=\"#disclosures\" aria-label=\"disclosures permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Disclosures</h1>\n<p>C4 is an open organization governed by participants in the community.</p>\n<p>C4 Contests incentivize the discovery of exploits, vulnerabilities, and bugs in smart contracts. Security researchers are rewarded at an increasing rate for finding higher-risk issues. Contest submissions are judged by a knowledgeable security researcher and solidity developer and disclosed to sponsoring developers. C4 does not conduct formal verification regarding the provided code but instead provides final verification.</p>\n<p>C4 does not provide any guarantee or warranty regarding the security of this project. All smart contract software should be used at the sole risk and responsibility of users.</p>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n  .dark-default-dark {\n    background-color: #1E1E1E;\n    color: #D4D4D4;\n  }\n  .dark-default-dark .mtk3 { color: #6A9955; }\n  .dark-default-dark .mtk1 { color: #D4D4D4; }\n  .dark-default-dark .mtk15 { color: #C586C0; }\n  .dark-default-dark .mtk12 { color: #9CDCFE; }\n  .dark-default-dark .mtk11 { color: #DCDCAA; }\n  .dark-default-dark .mtk7 { color: #B5CEA8; }\n  .dark-default-dark .mtk8 { color: #CE9178; }\n  .dark-default-dark .mtk4 { color: #569CD6; }\n  .dark-default-dark .grvsc-line-highlighted::before {\n    background-color: var(--grvsc-line-highlighted-background-color, rgba(255, 255, 255, 0.1));\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(255, 255, 255, 0.5));\n  }\n</style>",
  "toc": "<ul>\n<li>\n<p><a href=\"#overview\">Overview</a></p>\n<ul>\n<li><a href=\"#about-c4\">About C4</a></li>\n<li><a href=\"#wardens\">Wardens</a></li>\n</ul>\n</li>\n<li><a href=\"#summary\">Summary</a></li>\n<li><a href=\"#scope\">Scope</a></li>\n<li><a href=\"#severity-criteria\">Severity Criteria</a></li>\n<li>\n<p><a href=\"#high-risk-findings-5\">High Risk Findings (5)</a></p>\n<ul>\n<li><a href=\"#h-01-anyone-can-arbitrarily-add-router-liquidity\">[H-01] Anyone can arbitrarily add router liquidity</a></li>\n<li><a href=\"#h-02-activetransactionblocks-are-vulnerable-to-ddos-attacks\">[H-02] <code>activeTransactionBlocks</code> are vulnerable to DDoS attacks</a></li>\n<li><a href=\"#h-03-router-liquidity-on-receiving-chain-can-be-double-dipped-by-the-user\">[H-03] Router liquidity on receiving chain can be double-dipped by the user</a></li>\n<li><a href=\"#h-04-expired-transfers-will-lock-user-funds-on-the-sending-chain\">[H-04] Expired transfers will lock user funds on the sending chain</a></li>\n<li><a href=\"#h-05-approval-is-not-reset-if-the-call-to-ifulfillhelper-fails\">[H-05] <code>Approval</code> is not reset if the call to <code>IFulfillHelper</code> fails</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#medium-risk-findings-2\">Medium Risk Findings (2)</a></p>\n<ul>\n<li><a href=\"#m-01-signatures-use-only-tx-id-instead-of-entire-digest\">[M-01] Signatures use only tx ID instead of entire digest</a></li>\n<li><a href=\"#m-02-malicious-router-can-block-cross-chain-transfers\">[M-02] Malicious router can block cross-chain-transfers</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#low-risk-findings-11\">Low Risk Findings (11)</a></p>\n<ul>\n<li><a href=\"#l-01-lack-of-guarded-launch-approach-may-be-risky\">[L-01] Lack of guarded launch approach may be risky</a></li>\n<li><a href=\"#l-02-deflationary-and-fee-on-transfer-tokens-are-not-correctly-accounted\">[L-02] Deflationary and fee-on-transfer tokens are not correctly accounted</a></li>\n<li><a href=\"#l-03-missing-zero-address-checks\">[L-03] Missing zero-address checks</a></li>\n<li><a href=\"#l-04-an-attacker-can-front-run-a-users-prepare-tx-on-sending-chain-to-cause-dos-by-griefing\">[L-04] An attacker can front-run a user’s <code>prepare()</code> tx on sending chain to cause DoS by griefing</a></li>\n<li><a href=\"#l-05-txdataexpiry--blocktimestamp\">[L-05] <code>txData.expiry</code> = <code>block.timestamp</code></a></li>\n<li><a href=\"#l-06-unsafe-approve\">[L-06] Unsafe <code>approve</code></a></li>\n<li><a href=\"#l-07-router-needs-to-decrease-expiry-by-a-significant-buffer\">[L-07] Router needs to decrease expiry by a significant buffer</a></li>\n<li><a href=\"#l-08-wrapcall-with-weird-erc20-contracts\">[L-08] <code>wrapCall</code> with weird ERC20 contracts</a></li>\n<li><a href=\"#l-09-max_timeout\">[L-09] <code>MAX_TIMEOUT</code></a></li>\n<li><a href=\"#l-10-unchangeable-chainid-information\">[L-10] Unchangeable <code>chainID</code> information</a></li>\n<li><a href=\"#l-11-relayer-txs-can-be-front-runned\">[L-11] Relayer txs can be front-runned</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#non-critical-findings\">Non-Critical Findings</a></p>\n<ul>\n<li><a href=\"#n-01-missing-param-in-fulfill-natspec\">[N-01] Missing @param in <code>fulfill</code> NatSpec</a></li>\n<li><a href=\"#n-02-refactor-reuse-same-code-for-hashvarianttransactiondata-with-txdata-and-when-preparedblocknumber-is-0\">[N-02] Refactor: Reuse same code for <code>hashVariantTransactionData</code> with <code>txData</code> and when <code>preparedBlockNumber</code> is 0</a></li>\n<li><a href=\"#n-03-dont-use-assembly-\">[N-03] don’t use assembly </a></li>\n<li><a href=\"#n-04-code-consistency-for-hashvarianttransactiondata\">[N-04] Code Consistency for <code>hashVariantTransactionData()</code></a></li>\n<li><a href=\"#n-05-style-issues\">[N-05] Style issues</a></li>\n<li><a href=\"#n-06-dont-ask-for-the-users-signature-when-msgsender--txdatauser\">[N-06] Don’t ask for the user’s signature when <code>msg.sender</code> == <code>txData.user</code></a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#gas-optimizations-12\">Gas Optimizations (12)</a></p>\n<ul>\n<li><a href=\"#g-01-using-access-lists-can-save-gas-due-to-eip-2930-post-berlin-hard-fork\">[G-01] Using access lists can save gas due to EIP-2930 post-Berlin hard fork</a></li>\n<li><a href=\"#g-02-cache-storage-variables-to-local-variables-to-save-gas\">[G-02] Cache storage variables to local variables to save gas</a></li>\n<li><a href=\"#g-03-checking-before-external-library-call-can-save-2600-gas\">[G-03] Checking before external library call can save 2600 gas</a></li>\n<li><a href=\"#g-04-consolidating-library-functions-can-save-gas-by-preventing-external-calls\">[G-04] Consolidating library functions can save gas by preventing external calls</a></li>\n<li><a href=\"#g-05-evaluate-security-benefit-vs-gas-usage-trade-off-for-using-nonreentrant-modifier-on-different-functions\">[G-05] Evaluate security benefit vs gas usage trade-off for using nonreentrant modifier on different functions</a></li>\n<li><a href=\"#g-06-use-the-unchecked-keyword-to-save-gas\">[G-06] Use the <code>unchecked</code> keyword to save gas</a></li>\n<li><a href=\"#g-07-increment-in-the-loop-can-be-made-unchecked\">[G-07] Increment in the loop can be made unchecked</a></li>\n<li><a href=\"#g-08-checking-non-zero-value-can-avoid-an-external-call-to-save-gas\">[G-08] Checking non-zero value can avoid an external call to save gas</a></li>\n<li><a href=\"#g-09-optimizing-the-for-loop\">[G-09] Optimizing the for loop</a></li>\n<li><a href=\"#g-10-gas-only-pass-transactionid-as-parameter-instead-of-transactiondata\">[G-10] Gas: Only pass <code>transactionId</code> as parameter instead of <code>TransactionData</code></a></li>\n<li><a href=\"#g-11-revert-strings\">[G-11] Revert strings</a></li>\n<li><a href=\"#g-12-assignment-of-variables-not-needed\">[G-12] Assignment of variables not needed</a></li>\n</ul>\n</li>\n<li><a href=\"#disclosures\">Disclosures</a></li>\n</ul>",
  "md": "\n# Overview\n\n## About C4\n\nCode 432n4 (C4) is an open organization consisting of security researchers, auditors, developers, and individuals with domain expertise in smart contracts.\n\nA C4 code contest is an event in which community participants, referred to as Wardens, review, audit, or analyze smart contract logic in exchange for a bounty provided by sponsoring projects.\n\nDuring the code contest outlined in this document, C4 conducted an analysis of Connext smart contract system written in Solidity. The code contest took place between July 8 — July 11, 2021.\n\n## Wardens\n\n9 Wardens contributed reports to the Connext code contest:\n\n* [0xRajeev](https://twitter.com/0xRajeev)\n* [paulius.eth](https://twitter.com/SolidityDev)\n* [cmichel](https://twitter.com/cmichelio)\n* [shw](https://github.com/x9453)\n* [gpersoon](https://twitter.com/gpersoon)\n* [0xsanson](https://github.com/0xsanson)\n* [s1m0](https://twitter.com/_smonica_)\n* [hrkrshnn](https://twitter.com/_hrkrshnn)\n* [GalloDaSballo](https://twitter.com/gallodasballo)\n* [greiart](https://twitter.com/greiart)\n\nThis contest was judged by [ghoul.sol](https://twitter.com/ghoulsol).\n\nFinal report assembled by [moneylegobatman](https://twitter.com/money_lego) and [ninek](https://twitter.com/_ninek_).\n\n# Summary\n\nThe C4 analysis yielded an aggregated total of 18 unique vulnerabilities. All of the issues presented here are linked back to their original finding\n\nOf these vulnerabilities, 5 received a risk rating in the category of HIGH severity, 2 received a risk rating in the category of MEDIUM severity, and 11 received a risk rating in the category of LOW severity.\n\nC4 analysis also identified 18 non-critical recommendations.\n\n# Scope\n\nThe code under review can be found within the [C4 Connext code contest repository](https://github.com/code-423n4/2021-07-connext) is comprised of 6 smart contracts written in the Solidity programming language.\n\n# Severity Criteria\n\nC4 assesses the severity of disclosed vulnerabilities according to a methodology based on [OWASP standards](https://owasp.org/www-community/OWASP_Risk_Rating_Methodology).\n\nVulnerabilities are divided into three primary risk categories: high, medium, and low.\n\nHigh-level considerations for vulnerabilities span the following key areas when conducting assessments:\n\n- Malicious Input Handling\n- Escalation of privileges\n- Arithmetic\n- Gas use\n\nFurther information regarding the severity criteria referenced throughout the submission review process, please refer to the documentation provided on [the C4 website](https://code423n4.com).\n\n# High Risk Findings (5)\n\n## [[H-01] Anyone can arbitrarily add router liquidity](https://github.com/code-423n4/2021-07-connext-findings/issues/48)\n_Submitted by 0xRajeev, also found by cmichel and pauliax_\n\nThe `addLiquidity()` function takes a router address parameter, whose liquidity is increased (instead of assuming that `router` == `msg.sender` like is done on `removeLiquidity()`) on this contract/chain, by transferring the fund amount from router address to this contract if `assetID` != 0 (i.e. ERC20 tokens). However, anyone can call this function on the router’s behalf. For `assetID` == 0, the Ether transfer via `msg.value` comes from `msg.sender` and hence is assumed to be the router itself.\n\nThe impact is that this will allow anyone to call this function and arbitrarily move ERC20 tokens from router address to this contract, assuming router has given max approval to this contract and has `assetID` amount available for transfer. While the router can always remove the liquidity if it doesn’t want to maintain that level of liquidity, this lack of access control or flexibility for a relayer to add liquidity on router’s behalf, may unnecessarily (and without authorization) increase the router’s exposure to protocol risk to more than it desires. See `TransactionManager.sol` [#L88-L98](https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L88-L98). See also, use of `msg.sender` in `removeLiquidity` ([#L88-L98](https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L88-L98)).\n\nRecommend considering the use of `msg.sender` in `addLiquidity()` or evaluate this risk otherwise.\n\n**[LayneHaber (Connext) acknowledged](https://github.com/code-423n4/2021-07-connext-findings/issues/48#issuecomment-879189733):**\n > The bigger issue here is the typo [here](https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L97), if we use the funds from `msg.sender` that means that people are donating funds to the router.\n>\n> We will fix the `msg.sender`, but allow `addLiquidity` to be callable by anyone\n\n**[ghoul-sol (Judge) commented](https://github.com/code-423n4/2021-07-connext-findings/issues/48#issuecomment-890607571):**\n > This is high risk because funds can be send to the wrong address.\n\n\n## [[H-02] `activeTransactionBlocks` are vulnerable to DDoS attacks](https://github.com/code-423n4/2021-07-connext-findings/issues/27)\n_Submitted by gpersoon, also found by pauliax and shw_\n\nThere is a potential issue in function `removeUserActiveBlocks` and the for loop inside it. I assume you are aware of block gas limits (they may be less relevant on other chains but still needs to be accounted for), so as there is no limit for `activeTransactionBlocks`, it may grow so large that the for loop may never finish. You should consider introducing an upper limit for `activeTransactionBlocks`. Also, a malicious actor may block any account (DDOS) by just calling `prepare` again and again with 0 amount acting as a router. This will push `activeTransactionBlocks` to the specified user until it is no longer possible to remove them from the array.\n\nThis is also a gas issue, as function `removeUserActiveBlocks` iterating and assigning large dynamic arrays is very gas-consuming. Consider optimizing the algorithm, e.g. finding the first occurrence, then swap it with the last item, pop the array, and break. Or maybe even using an [`EnumerableMap`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableMap.sol), so you can find and remove elements in `O(1)`.\n\nThe best solution depends on what the usual number of `activeTransactionBlocks` is. If it is expected to be low (e.g. less than 5), then the current approach will work. But with larger arrays, I expect `EnumerableMap` would be more efficient.\n\nBecause an upper limit will not fully mitigate this issue, as a malicious actor can still DDOS the user by pushing useless txs until this limit is reached and a valid router may not be able to submit new txs. And, because you need to improve both the security _and_ performance of `removeUserActiveBlocks`; `EnumerableMap` may be a go-to solution.\n\n**[LayneHaber (Connext) confirmed](https://github.com/code-423n4/2021-07-connext-findings/issues/27#issuecomment-879509531):**\n > https://github.com/connext/nxtp/pull/24\n\n\n## [[H-03] Router liquidity on receiving chain can be double-dipped by the user](https://github.com/code-423n4/2021-07-connext-findings/issues/46)\n_Submitted by 0xRajeev, also found by cmichel, gpersoon, pauliax, s1m0 and shw_\n\nDuring `fulfill()` on the receiving chain, if the user has set up an external contract at `txData.callTo`, the catch blocks for both `IFulfillHelper.addFunds()` and `IFulfillHelper.excute()` perform `transferAsset` to the predetermined fallback address `txData.receivingAddress`.\n\nIf `addFunds()` has reverted earlier, `toSend` amount would already have been transferred to the `receivingAddress`. If `execute()` also fails, it is again transferred.\n\n**Scenario:** User sets up receiver chain `txData.callTo` contract such that both `addFunds()` and `execute()` calls revert. That will let him get twice the `toSend` amount credited to the `receivingAddress`. So effectively, Alice locks 100 `tokenAs` on chain A, and can get 200 `tokenAs` (or twice the amount of any token she is supposed to get on chain B from the router), minus relayer fee, on chain B. Router liquidity is double-dipped by Alice and router loses funds. See `TransactionManager.sol` [L395-L409](https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L395-L409) and [L413-L428](https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L413-L428).\n\nRecommend that the second catch block for `execute()` should likely not have the `transferAsset()` call. It seems like a copy-and-paste bug unless there is some reason that is outside the specified scope and documentation for this contest.\n\n**[LayneHaber (Connext) confirmed and patched](https://github.com/code-423n4/2021-07-connext-findings/issues/46#issuecomment-880098271):**\n > https://github.com/connext/nxtp/pull/39\n\n## [[H-04] Expired transfers will lock user funds on the sending chain](https://github.com/code-423n4/2021-07-connext-findings/issues/47)\n_Submitted by 0xRajeev_\n\nThe cancelling relayer is being paid in `receivingAssetId` on the `sendingChain` instead of in `sendingAssetID`. If the user relies on a relayer to cancel transactions, and that `receivingAssetId` asset does not exist on the sending chain (assuming only `sendingAssetID` on the sending chain and `receivingAssetId` on the receiving chain are assured to be valid and present), then the cancel transaction from the relayer will always revert and user’s funds will remain locked on the sending chain.\n\nThe impact is that expired transfers can never be cancelled and user funds will be locked forever if user relies on a relayer.\n\nRecommend changing `receivingAssetId` to `sendingAssetId` in `transferAsset()` on `TransactionManager.sol` [L514](https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L510-L517).\n\n**[LayneHaber (Connext) confirmed and patched](https://github.com/code-423n4/2021-07-connext-findings/issues/47#issuecomment-879510286):**\n > https://github.com/connext/nxtp/pull/25\n\n## [[H-05] `Approval` is not reset if the call to `IFulfillHelper` fails](https://github.com/code-423n4/2021-07-connext-findings/issues/31)\n_Submitted by pauliax, also found by 0xsanson, cmichel and shw_\n\nThe function `fulfill` first approves the `callTo` to transfer an amount of `toSend` tokens and tries to call `IFulfillHelper`, but if the call fails, it transfers these assets directly. However, in such case the approval is not reset, so a malicous `callTo` can pull these tokens later:\n```solidity\n// First, approve the funds to the helper if needed\n    if (!LibAsset.isEther(txData.receivingAssetId) && toSend > 0) {\n      require(LibERC20.approve(txData.receivingAssetId, txData.callTo, toSend), \"fulfill: APPROVAL_FAILED\");\n    }\n\n    // Next, call `addFunds` on the helper. Helpers should internally\n    // track funds to make sure no one user is able to take all funds\n    // for tx\n    if (toSend > 0) {\n      try\n        IFulfillHelper(txData.callTo).addFunds{ value: LibAsset.isEther(txData.receivingAssetId) ? toSend : 0}(\n          txData.user,\n          txData.transactionId,\n          txData.receivingAssetId,\n          toSend\n        )\n      {} catch {\n        // Regardless of error within the callData execution, send funds\n        // to the predetermined fallback address\n        require(\n          LibAsset.transferAsset(txData.receivingAssetId, payable(txData.receivingAddress), toSend),\n          \"fulfill: TRANSFER_FAILED\"\n        );\n      }\n    }\n```\n[Tuesday, August 10, 2021](x-fantastical3://show/calendar/2021-08-18)\nRecommend that `approval` should be placed inside the try/catch block or `approval` needs to be reset if the call fails.\n\n**[LayneHaber (Connext) confirmed and patched](https://github.com/code-423n4/2021-07-connext-findings/issues/31#issuecomment-880098587):**\n > https://github.com/connext/nxtp/pull/39\n\n# Medium Risk Findings (2)\n\n## [[M-01] Signatures use only tx ID instead of entire digest](https://github.com/code-423n4/2021-07-connext-findings/issues/54)\n_Submitted by cmichel_\n\nThe signature check in `recoverFulfillSignature()` only uses transaction ID (along with the relayer fee) which can be accidentally reused by the user, in which case the older signatures with the older relayer fees can be replayed.  The signature should be on the entire digest `hashInvariantTransactionData(txData)` as indicated in the comment on L306.\n\nThe impact is that,  If the user signatures are indeed on the digest as indicated by the comment, the signature/address check in `fulfill()` will fail. If not, they may be accidentally/intentionally replayed with same transaction ID, which also appears to be an outstanding question as indicated by the comment on L12.\n\n`recoverCancelSignature()` similarly uses only tx ID.\n\nUnless there is a good reason not to, it is safer to include `hashInvariantTransactionData(txData)` in signatures so that they cannot be replayed with different txData (but same tx ID) whose `preparedBlockNumber` is > 0.\n\nRecommend evaluating if the signature should contain only tx ID, or the entire digest, and then changing the logic appropriately.\n\n**[LayneHaber (Connext) acknowledged](https://github.com/code-423n4/2021-07-connext-findings/issues/54#issuecomment-878569946):**\n > User should be able to break up large transfers across multiple routers using the same `transactionId` to keep the transaction  unlocking atomic. For example, say I want to transfer \\$100K, but there are only 8 routers who each have \\$60K available. I should be able to break up the single transaction into \\$20K transactions split across 5 of the routers. When unlocking this, I should only need to broadcast a single signature, so all of the transactions can be unlocked simultaneously.\n\n**[ghoul-sol (Judge) commented](https://github.com/code-423n4/2021-07-connext-findings/issues/54#issuecomment-890612308):**\n > Bumping to medium risk as replay attack can have significant consequences\n\n## [[M-02] Malicious router can block cross-chain-transfers](https://github.com/code-423n4/2021-07-connext-findings/issues/12)\n_Submitted by 0xRajeev, also found by cmichel and shw_\n\nThe agreement between the `user` and the `router` seems to already happen off-chain because all the fields are required for the initial `In variantTransactionData` call already. A router could pretend to take on a user's cross-chain transfer, the user sends their `prepare` transaction, locking up funds on the sending chain.\nBut then the `router` simply doesn't respond or responds with a `prepare` transaction of `amount=0`.\n\nThe user's funds are then locked for the entire expiry time, whereas the router does not have to lock up anything as the amount is 0, even no gas if they simply don't respond. In this way, a router can bid on everything off-chain without a penalty, and take down everyone that accepts the bid.\n\nRecommend that maybe there could be a penalty mechanism for non-responsive routers that agreed off-chain, slashing part of their added liquidity. Could also be that the bid signature already helps with this, but I'm not sure how it works as the off-chain part is not part of the repo.\n\n**[LayneHaber (Connext) acknowledged](https://github.com/code-423n4/2021-07-connext-findings/issues/12#issuecomment-878590098):**\n > This is true, and we are building penalty mechanisms outside of these contracts. For now we are considering adding in a permissioned launch, see #49\n\n# Low Risk Findings (11)\n\n## [[L-01] Lack of guarded launch approach may be risky](https://github.com/code-423n4/2021-07-connext-findings/issues/49)\n_Submitted by 0xRajeev, also found by pauliax_\n\nThe protocol appears to allow arbitrary assets, amounts and routers/users without an initial time-bounded whitelist of assets/routers/users or upper bounds on amounts. Also, there is no pause/unpause functionality. While this lack of ownership and control makes it completely permission-less, it is a risky design because if there are latent protocol vulnerabilities there is no fallback option. See [Derisking DeFi Guarded Assets](https://medium.com/electric-capital/derisking-defi-guarded-launches-2600ce730e0a).\n\nRecommend considering an initial guarded launch approach to owner-based whitelisting asset types, router/recipient addresses, amount thresholds, and adding a pause/unpause functionality for emergency handling. The design should be able to make this owner configurable, where the owner can renounce ownership at a later point when the protocol operation is sufficiently time-tested and deemed stable/safe.\n\n**[LayneHaber (Connext) confirmed and patched](https://github.com/code-423n4/2021-07-connext-findings/issues/49#issuecomment-880309020):**\n > https://github.com/connext/nxtp/pull/40\n\n## [[L-02] Deflationary and fee-on-transfer tokens are not correctly accounted](https://github.com/code-423n4/2021-07-connext-findings/issues/68)\n_Submitted by shw, also found by 0xRajeev, pauliax and cmichel_\n\nWhen a router adds liquidity to the `TransactionManager`, the manager does not correctly handle the received amount if the transferred token is a deflationary or fee-on-transfer token. The actual received amount is less than what is recorded in the `routerBalances` variable. See `TransactionManager.sol` [#L97](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L97) and [#L101](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L101).\n\n\nRecommend getting the received token amount by calculating the difference of token balance before and after the transfer, for example:\n\n```solidity\nuint256 balanceBefore = getOwnBalance(assetId);\nrequire(LibERC20.transferFrom(assetId, router, address(this), amount, \"addLiquidity: ERC20_TRANSFER_FAILED\");\nuint256 receivedAmount = getOwnBalance(assetId) - balanceBefore;\n\n// Update the router balances\nrouterBalances[router][assetId] += receivedAmount;\n```\n\n**- [LayneHaber (Connext) confirmed](https://github.com/code-423n4/2021-07-connext-findings/issues/68)**\n\n**[ghoul-sol (Judge) commented](https://github.com/code-423n4/2021-07-connext-findings/issues/68#issuecomment-890608358):**\n > While correct, this is a low risk. Number of DeFi protocols are incompatible with \"exotic\" tokens and it's a user responsibility to know this. Perfect example is rebase tokens and UniswapV2.\n\n## [[L-03] Missing zero-address checks](https://github.com/code-423n4/2021-07-connext-findings/issues/50)\n_Submitted by 0xRajeev, also found by pauliax_\n\nZero-address checks are in general a best-practice. However, `addLiquidity()` and `removeLiquidity()` are missing zero-address checks on router and recipient addresses respectively.\n\n`addLiquidity()` on Eth transfers will update the zero index balance and get logged as such in the event without the amount getting accounted for the correct router.\n\nFor ERC20 assets, `token.transfer()` generally implements this check but the Eth transfer using `transferEth()` does not have this check and calls `addr.call(value)`, which will lead to burning in the case of `removeLiquidity()`.\n\nThe checks may be more important because `assetID` is 0 for Eth. So a router may accidentally use 0 values for both `assetID` and router/recipient.\n\nThere is also a missing zero-address check on `sendingChainFallback` which is relevant for Eth transfers in `cancel()`. The comment on L178 indicates the need for this but the following check on L179 ends up checking `receivingAddress` instead (which is also necessary). See issue page for referenced code.\n\nRecommend adding zero-address checks.\n\n**[sanchaymittal (Connext) confirmed and patched](https://github.com/code-423n4/2021-07-connext-findings/issues/50#issuecomment-879728788):**\n > https://github.com/connext/nxtp/pull/32\n\n## [[L-04] An attacker can front-run a user’s `prepare()` tx on sending chain to cause DoS by griefing](https://github.com/code-423n4/2021-07-connext-findings/issues/52)\n_Submitted by 0xRajeev, also found by cmichel_\n\nThe `prepare()` function  hashes the invariantData parameter data to check the mapping entry is 0 for that digest as a measure to prevent duplicate `prepare()`s. However, an attacker can abuse this check to front-run a targeted victim's prepare Tx with the same parameters and with some dust amount to prevent the user’s actual prepare Tx from succeeding.\n\nThe impact of this the potential griefing attack vector if user address is not `msg.sender`. This is with the assumption that relayers are only relevant on the receiving side where the user may not have the `receivingAssetId` i.e. no reason for `msg.sender` of `prepare()` to be the relayer and not the user.\n\nRecommend adding `msg.sender` == `invariantData.user` check on sending chain side similar to the check for router address on the receiving side.\n\n**[LayneHaber (Connext) confirmed and patched](https://github.com/code-423n4/2021-07-connext-findings/issues/52#issuecomment-880333582):**\n > https://github.com/connext/nxtp/pull/42\n\n**[LayneHaber (Connext) acknowledged](https://github.com/code-423n4/2021-07-connext-findings/issues/52#issuecomment-881780054):**\n > Reverted the changes, without tracking the active blocks this DOS vector still exists but presents no risk to locked funds. It is also unclear what the attacker would gain from this, and would cost them gas funds.\n>\n> Could add a signature, but comes with some UX drawbacks that seem more important than removing the DOS vector\n\n## [[L-05] `txData.expiry` = `block.timestamp`](https://github.com/code-423n4/2021-07-connext-findings/issues/28)\n_Submitted by pauliax, also found by 0xRajeev and shw_\n\nThe function `fulfill` treats `txData.expiry` = `block.timestamp` as expired tx:\n```solidity\n// Make sure the expiry has not elapsed\nrequire(txData.expiry > block.timestamp, \"fulfill: EXPIRED\");\n```\n\nHowever, function `cancel` has an inclusive check for the same condition:\n\n```solidity\nif (txData.expiry >= block.timestamp) {\n// Timeout has not expired and tx may only be cancelled by router\n```\n\nRecommend unifying that to make the code coherent. Probably `txData.expiry` = `block.timestamp` should be treated as expired everywhere.\n\n**[sanchaymittal (Connext) confirmed and patched](https://github.com/code-423n4/2021-07-connext-findings/issues/28#issuecomment-879682018):**\n > https://github.com/connext/nxtp/pull/28\n\n## [[L-06] Unsafe `approve`](https://github.com/code-423n4/2021-07-connext-findings/issues/13)\n_Submitted by cmichel_\n\nSome ERC20 tokens like USDT require resetting the approval to 0 first before being able to reset it to another value. (See [Line 201](https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code))\nThe `LIibERC20.approve` function does not do this - unlike OpenZeppelin's `safeApprove` implementation.\n\nThe impact of this, is that repeated USDT cross-chain transfers to the same user on receiving chain = ETH mainnet can fail due to this line not resetting the approval to zero first:\n\n```solidity\nrequire(LibERC20.approve(txData.receivingAssetId, txData.callTo, toSend), \"fulfill: APPROVAL_FAILED\");\n```\n\nRecommend that `LiibERC20.approve` should do two `approve` calls, one setting it to `0` first, then the real one.\nCheck OpenZeppelin's `safeApprove`.\n\n**[LayneHaber (Connext) confirmed and patched](https://github.com/code-423n4/2021-07-connext-findings/issues/13#issuecomment-879427181):**\n > https://github.com/connext/nxtp/pull/22\n\n## [[L-07] Router needs to decrease expiry by a significant buffer](https://github.com/code-423n4/2021-07-connext-findings/issues/15)\n_Submitted by cmichel_\n\nThe user's `fulfill` signature on the receiving chain is at the same time used by the router as a way to claim their amount on the sending chain.\nIf the sending chain's `expiry` date has passed, the user can cancel this side of the transfer and claim back their deposit before the router can claim it.\nTherefore, the comment that the receiving chain's expiry needs to be decreased is correct:\n\n> // expiry should be decremented to ensure the router has time to complete the sender-side transaction after the user completes the receiver-side transactoin.\n\nHowever, this is not enforced and if a wrong expiry date is chosen by the router, or the sender congests the network long enough such that the router's `fulfill` transaction does not get through, the router loses their claim and the user gets a free cross-chain transfer.\n\nIt would be possible to enforce that `receivingSide.expiry + buffer < sendingSide.expiry` if the original expiry was part of the invariant data.\nThis would programmatically avoid errors like the ones mentioned. (Assuming all supported chains use the same way to measure time / use UNIX timestamps.)\n\n**[LayneHaber (Connext) acknowledged](https://github.com/code-423n4/2021-07-connext-findings/issues/15#issuecomment-878588868):**\n > This is true, but the router is definitely incentivized to do this correctly. Adding this would also require adding an additional `{MINIMUM/MAXIMUM}_BUFFER`, and increases the complexity of the contracts for relatively minimal benefit\n\n## [[L-08] `wrapCall` with weird ERC20 contracts](https://github.com/code-423n4/2021-07-connext-findings/issues/4)\n_Submitted by gpersoon_\n\nThe function `wrapCall` is not completely safe for all possible ERC20 contracts.\n\nIf the `returnData.length` is larger than 1, the \"`abi.decode(returnData, (bool));`\" will fail. Which means the interactions with that ERC20 contract will fail. Although this is unlikely, it is easy to protect against it.\n\n```solidity\n// https://github.com/code-423n4/2021-07-connext/blob/main/contracts/lib/LibERC20.sol#L21\nfunction wrapCall(address assetId, bytes memory callData) internal returns (bool) {\n    ...\n    (bool success, bytes memory returnData) = assetId.call(callData);\n    LibUtils.revertIfCallFailed(success, returnData);\n    return returnData.length == 0 || abi.decode(returnData, (bool));\n}\n```\n\nRecommend changing\n```solidity\nreturn returnData.length == 0 || abi.decode(returnData, (bool));\n```\nto:\n```solidity\nreturn (returnData.length == 0) || (returnData.length == 1 && abi.decode(returnData, (bool)));\n```\n\n**[LayneHaber (Connext) confirmed and patched](https://github.com/code-423n4/2021-07-connext-findings/issues/4#issuecomment-879427044):**\n > https://github.com/connext/nxtp/pull/22\n\n## [[L-09] `MAX_TIMEOUT`](https://github.com/code-423n4/2021-07-connext-findings/issues/33)\n_Submitted by pauliax_\n\nThere is a `MIN_TIMEOUT` for the expiry, but I think you should also introduce a `MAX_TIMEOUT` to avoid a scenario when, for example, expiry is set far in the future (e.g. 100 years) and one malicious side does not agree to fulfill or cancel the tx, so the other side then has to wait and leave the funds locked for 100 years or so.\n\nRecommend introducing a reasonable `MAX_TIMEOUT`.\n\n**[sanchaymittal (Connext) confirmed and patched](https://github.com/code-423n4/2021-07-connext-findings/issues/33#issuecomment-879711651):**\n > https://github.com/connext/nxtp/pull/30\n\n## [[L-10] Unchangeable `chainID` information](https://github.com/code-423n4/2021-07-connext-findings/issues/66)\n_Submitted by shw_\n\nThe `chainId` information included in the `TransactionManager` is immutable, i.e., it could not change after the contract is deployed. However, if a hard fork happens in the future, the contract would become invalid on one of the forked chains because the chain ID has changed. See `TransactionManager.sol` [L73](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L73) and [L79](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L79).\n\nRecommend adding a function that allows the admin to set the `chainId` variable if a hard fork happens.\n\n**[LayneHaber (Connext) acknowledged](https://github.com/code-423n4/2021-07-connext-findings/issues/66#issuecomment-878552742):**\n > This is a potential issue in the case of a hard fork, but we will not address it for the following reasons:\n> 1. It is reasonable to assume the participants will want their funds to remain consistent on the canonical chain, which should keep the same `chainId` in the event of a fork\n> 2. Creating an admin function to reset the `chainId` gives admins a huge amount of power over the system itself\n> 3. There would still be a race between hard fork activation and updating the `chainId` that could result in unpredictable transaction behavior\n>\n> Instead, the course of action is to redeploy the contracts with the correct `chainId`.\n\n## [[L-11] Relayer txs can be front-runned](https://github.com/code-423n4/2021-07-connext-findings/issues/58)\n_Submitted by pauliax_\n\nThere is no relayer address param, only `relayerFee`, so technically anyone can front-run a profitable tx. The scenario might be as follows: A relayer submits a tx. A frontrunner sees it in the mempool and calculates that `relayerFee` is profitable enough (maybe even insta sell the `relayerFee` on AMM for the native asset) so he copies and submits the same tx but with a higher gas price. A frontrunner's tx gets through and a relayer's tx is reverted afterward. So basically a relayer will experience only losses in such a case.\n\nRecommend consider introducing relayer address param or reducing the probability of this scenario in any other meaningful way (e.g. blacklist front-runners).\n\n**[LayneHaber (Connext) acknowledged](https://github.com/code-423n4/2021-07-connext-findings/issues/58#issuecomment-878584797):**\n > This does technically introduce some frontrun-ability for the relayer fee on the onchain transactions, but relegating the responsibility to a single relayer within the network could compromise the overall network security.\n>\n> Consider the following case where a relayer is selected:\n> 1. User has a `fulfill` transaction they would like to be submitted on the receiving chain\n> 2. User selects a `relayer` who will submit a tx for a fee\n> 3. User sends the `relayer` the transaction data to submit the tx, including the `signature` on the receiving chain\n> 4. The `relayer` can see the `router` on the transaction, and they collude to submit the signature on the sending chain, wait to cancel the transaction on the receiving chain, and split the profits.\n>\n> While the relayer fees are frontrunnable, and this will drive up the costs of the relayer fees for all users, switching away from this pattern will force an \"all honest relayers\" assumption instead of a \"one honest relayer\" assumption.\n>\n\n**[ghoul-sol (Judge) commented](https://github.com/code-423n4/2021-07-connext-findings/issues/58#issuecomment-890637276):**\n > Making this a low risk as the front running doesn't affect users and it actually forces the whole system to use the most optimal fees.\n\n# Non-Critical Findings\n\n## [[N-01] Missing @param in `fulfill` NatSpec](https://github.com/code-423n4/2021-07-connext-findings/issues/64)\n_Submitted by 0xsanson_\n\nThe current implementation of NatSpec of `fulfill` function lacks @param `callData` in `TransactionManager.sol` [L302](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L302).\n\nRecommend adding @param `callData`.\n\n**[LayneHaber (Connext) confirmed and patched](https://github.com/code-423n4/2021-07-connext-findings/issues/64#issuecomment-880046867):**\n > https://github.com/connext/nxtp/pull/38\n\n\n## [[N-02] Refactor: Reuse same code for `hashVariantTransactionData` with `txData` and when `preparedBlockNumber` is 0](https://github.com/code-423n4/2021-07-connext-findings/issues/56)\n_Submitted by GalloDaSballo_\n\nThe code uses `hashVariantTransactionData` to verify the hash of the `VariantTransactionData`\nIt also uses\n```solidity\nvariantTransactionData[digest] = keccak256(abi.encode(VariantTransactionData({\n  amount: txData.amount,\n  expiry: txData.expiry,\n  preparedBlockNumber: 0\n})));\n```\n\nTo generate `VariantTransactionData` with `preparedBlockNumber` set to 0\n\nA simple refactoring of:\n```solidity\nfunction hashVariantTransactionData(TransactionData calldata txData) internal pure returns (bytes32) {\n  return hashVariantTransaction(txData.amount, txData.expiry, txData.preparedBlockNumber)\n}\n\nfunction hashVariantTransaction(uint256 amount, uint256 expiry, uint256 prepareBlocNumber) internal pure returns (bytes32) {\n  return keccak256(abi.encode(VariantTransactionData({\n    amount: amount,\n    expiry: expiry,\n    preparedBlockNumber: preparedBlockNumber\n  })));\n}\n```\n\nThis would allow to further steamline the code from\n```solidity\nvariantTransactionData[digest] = keccak256(abi.encode(VariantTransactionData({\n  amount: txData.amount,\n  expiry: txData.expiry,\n  preparedBlockNumber: 0\n})));\n```\n\nto\n```solidity\n  variantTransactionData[digest] = hashVariantTransaction(txData.amount, txData.expiry, 0)\n```\n\nThis has no particular benefit beside making all code related to Variant Data consistent.\n\n**[LayneHaber (Connext) confirmed and patched](https://github.com/code-423n4/2021-07-connext-findings/issues/56#issuecomment-880025294):**\n > https://github.com/connext/nxtp/pull/37\n\n## [[N-03] don't use assembly ](https://github.com/code-423n4/2021-07-connext-findings/issues/3)\n_Submitted by gpersoon_\n\nThe function `revertIfCallFailed` of `LibUtils.sol` uses \"assembly\" to log error information in a revert situation. In the latest solidity version, this can be done in solidity using the \"error\" keyword.\nSee: https://docs.soliditylang.org/en/latest/control-structures.html?#revert\n\nUsing pure solidity improves readability.\n\n`LibUtils.sol` [L10](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/lib/LibUtils.sol#L10)\n```solidity\nfunction revertIfCallFailed(bool success, bytes memory returnData) internal pure {\n  if (!success) {\n    assembly {  revert(add(returnData, 0x20), mload(returnData))  }\n  }\n}\n```\n\nRecommend using the error constructs of solidity 0.8.4+\n\n**[LayneHaber (Connext) confirmed and patched](https://github.com/code-423n4/2021-07-connext-findings/issues/3#issuecomment-879427528):**\n > https://github.com/connext/nxtp/pull/22\n\n## [[N-04] Code Consistency for `hashVariantTransactionData()`](https://github.com/code-423n4/2021-07-connext-findings/issues/22)\n_Submitted by greiart_\n\n`hashVariantTransactionData()` should follow the same style of `hashInvariantTransactionData()` and the recover signature functions, where the payload is generated is stored in memory before hashing. Preliminary tests in remix show that it is minimally more gas efficient as well.\n\n```jsx\nfunction hashVariantTransactionData(TransactionData calldata txData) internal pure returns (bytes32) {\n    VariantTransactionData memory variant = VariantTransactionData({\n      amount: txData.amount,\n      expiry: txData.expiry,\n      preparedBlockNumber: txData.preparedBlockNumber\n\t\t});\n\t\treturn keccak256(abi.encode(variant));\n  }\n```\n\n[Alternative View on Notion](https://www.notion.so/Code-Consistency-for-hashVariantTransactionData-33bf6578a16c4b18896f4d7ca7582e21)\n\n\n**[sanchaymittal (Connext) confirmed and patched](https://github.com/code-423n4/2021-07-connext-findings/issues/22#issuecomment-879669310):**\n > https://github.com/connext/nxtp/pull/27\n\n## [[N-05] Style issues](https://github.com/code-423n4/2021-07-connext-findings/issues/29)\n_Submitted by pauliax_\n\n`ETHER_ASSETID` is a bit missleading name, I think a better name would be `NATIVE_ASSETID`:\n```solidity\naddress constant `ETHER_ASSETID` = address(0);\n```\n\nMisleading comment (should be 'for fulfillment'):\n```solidity\n// The structure of the signed data for cancellations\nstruct SignedFulfillData {\n```\n`MIN_TIMEOUT` could be expressed in days:\n```solidity\nuint256 public constant MIN_TIMEOUT = 1 days; // 24 hours\n```\n\n**[sanchaymittal (Connext) confirmed and patched](https://github.com/code-423n4/2021-07-connext-findings/issues/29#issuecomment-879688577):**\n > https://github.com/connext/nxtp/pull/29\n>\n\n**[sanchaymittal (Connext) commented](https://github.com/code-423n4/2021-07-connext-findings/issues/29#issuecomment-879694397):**\n > @LayneHaber (Connext) I can't find the above-mentioned typos in our latest contracts on main, not sure if changing min_timeout from hours to days makes a difference.\n>\n> Still created the Pr for the above.\n\n**[LayneHaber (Connext) commented](https://github.com/code-423n4/2021-07-connext-findings/issues/29#issuecomment-880061606):**\n > It should be in `LibAsset`, will update\n\n## [[N-06] Don't ask for the user's signature when `msg.sender` == `txData.user`](https://github.com/code-423n4/2021-07-connext-findings/issues/57)\n_Submitted by pauliax_\n\nI think it would make sense not to check the user's signature in `recoverCancelSignature` or `recoverFulfillSignature` if the caller is the user himself.\n\nRecommend replacing\n```solidity\nrequire(recoverCancelSignature(txData, relayerFee, signature) == txData.user, \"cancel: INVALID_SIGNATURE\");\nrequire(recoverFulfillSignature(txData, relayerFee, signature) == txData.user, \"fulfill: INVALID_SIGNATURE\");\n```\nwith:\n```solidity\nrequire(msg.sender == txData.user | recoverCancelSignature(txData, relayerFee, signature) == txData.user, \"cancel: INVALID_SIGNATURE\");\nrequire(msg.sender == txData.user || recoverFulfillSignature(txData, relayerFee, signature) == txData.user, \"fulfill: INVALID_SIGNATURE\");\n```\n\n**[LayneHaber (Connext) confirmed](https://github.com/code-423n4/2021-07-connext-findings/issues/57#issuecomment-880313581):**\n > Cannot do this on `fulfill` because then users can prevent routers from fulfilling by never revealing the proper signature. But can do this on `cancel`.\n>\n> PR: https://github.com/connext/nxtp/pull/41\n\n# Gas Optimizations (12)\n\n## [[G-01] Using access lists can save gas due to EIP-2930 post-Berlin hard fork](https://github.com/code-423n4/2021-07-connext-findings/issues/39)\n_Submitted by 0xRajeev_\n\nEIP-2929 in Berlin fork increased the gas costs of SLOADs and CALL* family opcodes, increasing them for not-accessed slots/addresses and decreasing them for accessed slots. EIP-2930 optionally supports specifying an access list (in the transaction) of all slots and addresses accessed by the transaction, which reduces their gas cost upon access and prevents EIP-2929 gas cost increases from breaking contracts.\n\nThe impact of this is that, these changes may significantly impact gas usage for transactions that call functions touching many state variables or making many external calls. Specifically, `removeUserActiveBlocks()` removes an active block from the array of blocks for an user, all of which are stored in storage. Transactions for `fulfill()` and `cancel()` functions that call `removeUserActiveBlocks()`  can consider using access lists for all the storage state (of user’s active blocks) they touch (read + write) to reduce gas.\n\nRecommend evaluating the feasibility of using access lists to save gas due to EIPs 2929 & 2930 post-Berlin hard fork. The tooling support is WIP.\n\n**[LayneHaber (Connext) confirmed and patched](https://github.com/code-423n4/2021-07-connext-findings/issues/39#issuecomment-880951433):**\n > Removed tracking of active blocks: https://github.com/connext/nxtp/pull/24\n\n## [[G-02] Cache storage variables to local variables to save gas](https://github.com/code-423n4/2021-07-connext-findings/issues/75)\n_Submitted by shw, also found by 0xRajeev_\n\nIn general, if a state variable is read more than once, caching its value to a local variable and reusing it will save gas since a storage read spends more gas than a memory write plus a memory read.\n\nRecommend rewriting `TransactionManager.sol` [#L122-L125](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L122-L125) as follows:\n\n```solidity\nuint256 balance = routerBalances[msg.sender][assetId];\nrequire(balance >= amount, \"removeLiquidity: INSUFFICIENT_FUNDS\");\n\n// Update router balances\nrouterBalances[msg.sender][assetId] = balance - amount;\n```\n\nAnd rewriting `TransactionManager.sol` [L254-L260](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L254-L260) as follows:\n\n```solidity\nuint256 balance = routerBalances[invariantData.router][invariantData.receivingAssetId];\nrequire(\n  balance >= amount,\n  \"prepare: INSUFFICIENT_LIQUIDITY\"\n);\n\n// Decrement the router liquidity\nrouterBalances[invariantData.router][invariantData.receivingAssetId] = balance - amount;\n```\n\n**[sanchaymittal (Connext) confirmed and patched](https://github.com/code-423n4/2021-07-connext-findings/issues/75#issuecomment-879859196):**\n > https://github.com/connext/nxtp/pull/34\n\n## [[G-03] Checking before external library call can save 2600 gas](https://github.com/code-423n4/2021-07-connext-findings/issues/41)\n_Submitted by 0xRajeev, also found by pauliax_\n\nEIP-2929 in Berlin fork increased the gas costs of CALL* family opcodes to 2600. Making a `delegatecall` to a library function therefore costs 2600. `LibUtils.revertIfCallFailed()` reverts and passes on the revert string if the boolean argument is false. Instead, moving the checking of the boolean to the caller avoids the library call when the boolean is true, which is likely the case most of the time.\n\nRecommend removing the boolean parameter from `revertIfCallFailed()`, and move the conditional check logic to the call sites.\n\n**[LayneHaber (Connext) confirmed and patched](https://github.com/code-423n4/2021-07-connext-findings/issues/41#issuecomment-880009356):**\n > https://github.com/connext/nxtp/pull/22\n\n## [[G-04] Consolidating library functions can save gas by preventing external calls](https://github.com/code-423n4/2021-07-connext-findings/issues/42)\n_Submitted by 0xRajeev_\n\nWhile code modularity is generally a good practice and creating libraries of functions commonly used across different contracts can increase maintainability and reduce contract deployment size/cost, it comes at the increased cost of gas usage at runtime because of the external calls. EIP-2929 in Berlin fork increased the gas costs of CALL* family opcodes to 2600. Making a `delegatecall` to a library function therefore costs 2600.\n\nThe impact is that, `LibAsset.transferAsset()` call from `TransactionManager.sol` makes `LibERC20.transfer()` call for ERC20 which in turn makes another external call to `LibUtils.revertIfCallFailed()` in `wrapCall`. So an ERC20 transfer effectively makes 3 additional (besides the ERC20 token contract function call `assetId.call(..)` external calls -> `LibAsset` -> `LibERC20` -> `LibUtils`, which costs 2600*3 = 7800 gas.\n\nCombining these functions into a single library or making them all internal to `TransactionManager.sol` can convert these `delegatecall`s into JMPs to save gas. See issue page for referenced code.\n\nRecommend considering moving all the library functions internal to this contract, or to a single library, to save gas from external calls, each of which costs 2600 gas.\n\n**[LayneHaber (Connext) confirmed and patched](https://github.com/code-423n4/2021-07-connext-findings/issues/42#issuecomment-879427119):**\n > https://github.com/connext/nxtp/pull/22\n\n## [[G-05] Evaluate security benefit vs gas usage trade-off for using nonreentrant modifier on different functions](https://github.com/code-423n4/2021-07-connext-findings/issues/43)\n_Submitted by 0xRajeev_\n\nWhile it may be considered extra-safe to have a nonreentrant modifier on all functions making any external calls even though they are to trusted contracts, when functions implement Checks-Effects-Interactions (CEI) pattern, it is helpful to evaluate the perceived security benefit vs gas usage trade-off for using nonreentrant modifier.\n\nFunctions adhering to the CEI pattern may consider not having the nonreentrant modifier which does two `SSTORES` (getting more expensive with the London fork EIP-3529) to its `_status` state variable.\n\n**Example 1:** In `addLiquidity()`, by moving the updating of router balance on L101 to before the transfers from L92, the function would adhere to CEI pattern and could be evaluated to remove the nonreentrant modifier.\n\n**Example 2:** `removeLiquidity()` already adheres to CEI pattern and could be evaluated to remove the nonreentrant modifier.\n\n`prepare()` can be slightly restructured to follow CEI pattern as well. However, `fulfill()` and `cancel()` are risky with multiple external calls and its safer to leave the nonreentrant call at the expense of additional gas costs.\n\nThe impact is that, you can save gas by removing  the nonreentrant modifier if function is deemed to be reentrant safe. This can save gas costs of 2 SSTORES per function call that uses this modifier: _status SSTORE from 1 to 2 costs 5000 and _status SSTORE from 2 to 1 which costs 100 (because it was already accessed) which is significant at 5100 per call post-Berlin EIP-2929. See `TransactionManager.sol` [L92-L101](https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L92-L101).\n\nRecommend evaluating security benefit vs gas usage trade-off for using nonreentrant modifier on functions that may already be reentrant safe or do not need this protection. It may indeed be safe to leave this modifier (while accepting the gas impact) if such an evaluation is tricky or depends on assumptions.\n\n**[LayneHaber (Connext) confirmed and patched](https://github.com/code-423n4/2021-07-connext-findings/issues/43#issuecomment-880949708):**\n > https://github.com/connext/nxtp/pull/44\n\n## [[G-06] Use the `unchecked` keyword to save gas](https://github.com/code-423n4/2021-07-connext-findings/issues/74)\n_Submitted by shw, also found by 0xRajeev, cmichel, greiart, and s1m0_\n\nUsing the `unchecked` keyword to avoid redundant arithmetic underflow/overflow checks to save gas when an underflow/overflow cannot happen.\n\nWe can apply the `unchecked` keyword in the following lines of code since there are `require` statements before to ensure the arithmetic operations would not cause an integer underflow or overflow.\n\nFor example, change the code at line 364 to:\n\n```solidity\nunchecked {\n  uint256 toSend = txData.amount - relayerFee;\n}\n```\n\n**[sanchaymittal (Connext) confirmed and patched](https://github.com/code-423n4/2021-07-connext-findings/issues/74#issuecomment-879837226):**\n > https://github.com/connext/nxtp/pull/33\n>\n\n## [[G-07] Increment in the loop can be made unchecked](https://github.com/code-423n4/2021-07-connext-findings/issues/65)\n_Submitted by hrkrshnn_\n\n```diff\n import \"./interfaces/IFulfillHelper.sol\";\n import \"./interfaces/ITransactionManager.sol\";\n@@ -556,6 +556,12 @@ contract TransactionManager is ReentrancyGuard, ITransactionManager {\n     return activeTransactionBlocks[user];\n   }\n\n+  function unchecked_inc(uint256 i) internal pure returns (uint256) {\n+      unchecked {\n+          return i + 1;\n+      }\n+  }\n+\n   //////////////////////////\n   /// Private functions ///\n   //////////////////////////\n@@ -570,7 +576,7 @@ contract TransactionManager is ReentrancyGuard, ITransactionManager {\n     uint256[] memory updated = new uint256[](newLength);\n     bool removed = false;\n     uint256 updatedIdx = 0;\n-    for (uint256 i; i < newLength + 1; i++) {\n+    for (uint256 i; i < newLength + 1; i = unchecked_inc(i)) {\n       // Handle case where there could be more than one tx added in a block\n       // And only one should be removed\n       if (!removed && activeTransactionBlocks[user][i] == preparedBlock) {\n```\n\nRecommend making sure that you enable the optimizer and need at least solidity 0.8.4 (i.e., the low level inliner).\nThe old code would have an unnecessary checked addition, and potentially also, not inlined. Would save at least 20-30 gas for each loop iteration.\n\n**[LayneHaber (Connext) acknowledged](https://github.com/code-423n4/2021-07-connext-findings/issues/65#issuecomment-879268775):**\n > `unchecked` references mentioned in #74 but missed the index. We will also be using `EnumerableSet` for the active block checking\n\n## [[G-08] Checking non-zero value can avoid an external call to save gas](https://github.com/code-423n4/2021-07-connext-findings/issues/45)\n_Submitted by 0xRajeev_\n\nChecking if `toSend` > 0 before making the external library call to `LibAsset.transferAsset()` can save 2600 gas by avoiding the external call in such situations. See [L375-L380](https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L375-L380) and [L364](https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L364).\n\nRecommend adding `toSend` > 0 to predicate on L375 similar to check on L387.\n\n**[sanchaymittal (Connext) confirmed and patched](https://github.com/code-423n4/2021-07-connext-findings/issues/45#issuecomment-879713986):**\n > https://github.com/connext/nxtp/pull/31\n\n## [[G-09] Optimizing the for loop](https://github.com/code-423n4/2021-07-connext-findings/issues/60)\n_Submitted by hrkrshnn, also found by GalloDaSballo, cmichel, gpersoon and shw_\n\nThe for loop can improved, here is a diff:\n\n```diff\n@@ -565,22 +565,26 @@ contract TransactionManager is ReentrancyGuard, ITransactionManager {\n   /// @param user User who has completed a transaction\n   /// @param preparedBlock The TransactionData.preparedBlockNumber to remove\n   function removeUserActiveBlocks(address user, uint256 preparedBlock) internal {\n-    // Remove active blocks\n-    uint256 newLength = activeTransactionBlocks[user].length - 1;\n-    uint256[] memory updated = new uint256[](newLength);\n-    bool removed = false;\n-    uint256 updatedIdx = 0;\n-    for (uint256 i; i < newLength + 1; i++) {\n-      // Handle case where there could be more than one tx added in a block\n-      // And only one should be removed\n-      if (!removed && activeTransactionBlocks[user][i] == preparedBlock) {\n-        removed = true;\n-        continue;\n-      }\n-      updated[updatedIdx] = activeTransactionBlocks[user][i];\n-      updatedIdx++;\n+\n+    uint256[] storage array = activeTransactionBlocks[user];\n+    uint256 length = array.length;\n+    uint256 matchIdx = type(uint).max;\n+\n+    for (uint256 i = 0; i < length; i++) {\n+        if (array[i] == preparedBlock)\n+        {\n+            matchIdx = i;\n+            break;\n+        }\n     }\n-    activeTransactionBlocks[user] = updated;\n+\n+    if (matchIdx != type(uint256).max) {\n+        for (uint256 i = matchIdx; i < length; i++) {\n+            array[i] = array[i+1];\n+        }\n+        array.pop();\n+    }\n+\n   }\n```\n\nThe other implementation creates unnecessary copies in memory. And overwrites slots unnecessary (something like `sstore(slot,sload(slot))`). The above implementation should save significant amount of gas, by avoiding both unnecessary memory and unnecessary storage writes. Please check; was written in a hurry, but the general idea\nshould work 🙂\n\n### Optimizing the loop: Try to pass the array index instead\n\nInstead of trying to compute the index `i` where\n\n```solidity\nactiveTransactionBlocks[user][i] == blockIndex\n```\n\nOne can try to already compute this off chain and pass it as the parameter. This avoids the expensive step of reading values from storage on chain, and saves a significant amount of gas. Assume that this index `i` is passed as a parameter. On chain, all you need to do is have\n\n```solidity\nrequire(activeTransactionBlocks[user][i] == blockIndex)\n```\n\nAfter that, use the second for loop at the end in the previous example.\n\n**[LayneHaber (Connext) acknowledged](https://github.com/code-423n4/2021-07-connext-findings/issues/60#issuecomment-879266202):**\n > Going to replace the `activeBlocks` with open zeppelin's `EnumerableSet`\n\n## [[G-10] Gas: Only pass `transactionId` as parameter instead of `TransactionData`](https://github.com/code-423n4/2021-07-connext-findings/issues/19)\n_Submitted by cmichel_\n\nBoth the `recoverFulfillSignature` and `recoverCancelSignature` functions take a large `TransactionData` object as their first argument but only use the `transactionId` field of the struct. It should be more efficient to only pass `txData.transactionId` as the parameter.\n\n**[LayneHaber (Connext) confirmed and patched](https://github.com/code-423n4/2021-07-connext-findings/issues/19#issuecomment-879434284):**\n > https://github.com/connext/nxtp/pull/23\n\n## [[G-11] Revert strings](https://github.com/code-423n4/2021-07-connext-findings/issues/59)\n_Submitted by hrkrshnn_\n\nConsider using custom errors instead of revert strings. Can save gas when the revert condition has been met and also during runtime.\n\nConsider shortening revert strings to less than 32 bytes. Revert strings more than 32 bytes require at least one additional `mstore`, along with additional operations for computing memory offset, etc.\n\nEven if you need a string to represent an error, it can usually be done in less than 32 bytes / characters.\n\nHere are some examples of strings that can be shortened from codebase:\n\n```\n./contracts/TransactionManager.sol:96: \"addLiquidity: ETH_WITH_ERC_TRANSFER\"\n./contracts/TransactionManager.sol:97: \"addLiquidity: ERC20_TRANSFER_FAILED\"\n./contracts/TransactionManager.sol:122: \"removeLiquidity: INSUFFICIENT_FUNDS\"\n```\n\nNote that this will only decrease runtime gas when the revert condition has been met. Regardless, it will decrease deploy time gas.\n\n**[sanchaymittal (Connext) confirmed and patched](https://github.com/code-423n4/2021-07-connext-findings/issues/59#issuecomment-881722985):**\n > https://github.com/connext/nxtp/pull/47\n\n## [[G-12] Assignment of variables not needed](https://github.com/code-423n4/2021-07-connext-findings/issues/36)\n_Submitted by s1m0_\n\nVariables on `TransactionManager.sol` [L571](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L571) and [L572](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L572) are being assigned their default value so it's not needed.\n\nRecommend removing the assignments for saving a bit of gas when deploying.\n\n**[LayneHaber (Connext) acknowledged](https://github.com/code-423n4/2021-07-connext-findings/issues/36#issuecomment-879276169):**\n > We are taking out the loop in favor of the `EnumerableSet` from OpenZeppelin\n\n# Disclosures\n\nC4 is an open organization governed by participants in the community.\n\nC4 Contests incentivize the discovery of exploits, vulnerabilities, and bugs in smart contracts. Security researchers are rewarded at an increasing rate for finding higher-risk issues. Contest submissions are judged by a knowledgeable security researcher and solidity developer and disclosed to sponsoring developers. C4 does not conduct formal verification regarding the provided code but instead provides final verification.\n\nC4 does not provide any guarantee or warranty regarding the security of this project. All smart contract software should be used at the sole risk and responsibility of users.\n"
}