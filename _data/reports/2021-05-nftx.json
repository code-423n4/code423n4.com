{
  "circa": {
    "title": "NFTX",
    "sponsor": "NFTX",
    "slug": "2021-05-nftx",
    "date": "2021-06-21",
    "findings": "https://github.com/code-423n4/2021-05-nftx-findings/issues",
    "contest": 8
  },
  "html": "<h1 id=\"overview\" style=\"position:relative;\"><a href=\"#overview\" aria-label=\"overview permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Overview</h1>\n<h2 id=\"about-c4\" style=\"position:relative;\"><a href=\"#about-c4\" aria-label=\"about c4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>About C4</h2>\n<p>Code 432n4 (C4) is an open organization consisting of security researchers, auditors, developers, and individuals with domain expertise in smart contracts.</p>\n<p>A C4 code contest is an event in which community participants, referred to as Wardens, review, audit, or analyze smart contract logic in exchange for a bounty provided by sponsoring projects.</p>\n<p>During the code contest outlined in this document, C4 conducted an analysis of the NFTX smart contract system written in Solidity. The code contest took place between May 5th and May 11th, 2021.</p>\n<h2 id=\"wardens\" style=\"position:relative;\"><a href=\"#wardens\" aria-label=\"wardens permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Wardens</h2>\n<p>11 Wardens contributed reports to the NFTX code contest:</p>\n<ul>\n<li><a href=\"https://twitter.com/cmichelio\">cmichel</a></li>\n<li><a href=\"https://twitter.com/SolidityDev\">pauliax</a> (Thunder)</li>\n<li><a href=\"https://twitter.com/unsafe_call\">janbro</a></li>\n<li><a href=\"https://github.com/x9453\">shw</a></li>\n<li><a href=\"https://twitter.com/gpersoon\">gpersoon</a></li>\n<li><a href=\"https://twitter.com/0xRajeev\">rajeev</a></li>\n<li><a href=\"https://twitter.com/a_delamo\">a_delamo</a></li>\n<li><a href=\"https://github.com/alex-ppg%22\">0xsomeone</a></li>\n<li><a href=\"https://github.com/heiho1\">heiho1</a> (Thisguy)</li>\n<li><a href=\"https://twitter.com/MukeshJ_eth\">mukesh jaiswal</a></li>\n<li><a href=\"https://twitter.com/jvaqa\">jvaqa</a></li>\n</ul>\n<p>This contest was judged by <a href=\"https://twitter.com/cemozer_\">cemozer</a>.</p>\n<p>Final report assembled by <a href=\"https://twitter.com/money_lego\">moneylegobatman</a>.</p>\n<h1 id=\"summary\" style=\"position:relative;\"><a href=\"#summary\" aria-label=\"summary permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Summary</h1>\n<p>The C4 analysis yielded an aggregated total of 24 unique vulnerabilities. All of the issues presented here are linked back to their original finding</p>\n<p>Of these vulnerabilities, 4 received a risk rating in the category of HIGH severity, 10 received a risk rating in the category of MEDIUM severity, and 10 received a risk rating in the category of LOW severity.</p>\n<p>C4 analysis also identified 15 non-critical recommendations.</p>\n<h1 id=\"scope\" style=\"position:relative;\"><a href=\"#scope\" aria-label=\"scope permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Scope</h1>\n<p>The code under review can be found within the <a href=\"https://github.com/code-423n4/2021-05-nftx\">C4 NFTX code contest repository</a> and comprises 68 smart contracts written in the Solidity programming language.</p>\n<h1 id=\"severity-criteria\" style=\"position:relative;\"><a href=\"#severity-criteria\" aria-label=\"severity criteria permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Severity Criteria</h1>\n<p>C4 assesses the severity of disclosed vulnerabilities according to a methodology based on <a href=\"https://owasp.org/www-community/OWASP_Risk_Rating_Methodology\">OWASP standards</a>.</p>\n<p>Vulnerabilities are divided into three primary risk categories: high, medium, and low.</p>\n<p>High-level considerations for vulnerabilities span the following key areas when conducting assessments:</p>\n<ul>\n<li>Malicious Input Handling</li>\n<li>Escalation of privileges</li>\n<li>Arithmetic</li>\n<li>Gas use</li>\n</ul>\n<p>Further information regarding the severity criteria referenced throughout the submission review process, please refer to the documentation provided on <a href=\"https://code423n4.com\">the C4 website</a>.</p>\n<h1 id=\"high-risk-findings-4\" style=\"position:relative;\"><a href=\"#high-risk-findings-4\" aria-label=\"high risk findings 4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>High Risk Findings (4)</h1>\n<h2 id=\"h-01-missing-overflow-check-in-flashloan\" style=\"position:relative;\"><a href=\"#h-01-missing-overflow-check-in-flashloan\" aria-label=\"h 01 missing overflow check in flashloan permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/43\">[H-01] Missing overflow check in <code>flashLoan</code></a></h2>\n<p><code>ERC20FlashMintUpgradeable.flashLoan</code> does not check for an overflow when adding the fees to the <code>flashloan</code> amount.\nThe functionality might have been copied from <a href=\"https://eips.ethereum.org/EIPS/eip-3156\">https://eips.ethereum.org/EIPS/eip-3156</a> but this one already has overflow checks as it uses solidity 0.8.0. This leads to an issue where the attacker does not need to pay back the <code>flashloan</code> as they will burn 0 tokens:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"0\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">_burn</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk12\">receiver</span><span class=\"mtk1\">), </span><span class=\"mtk12\">amount</span><span class=\"mtk1\"> + </span><span class=\"mtk12\">fee</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p>They end up with a huge profit. (Luckily, this is currently not exploitable as the fee is set to 0 so there’s no possibility to overflow. However, if governance decides to change the flashloan fee, flashloans can be taken without having to repay them). Recommend using <code>SafeMath</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/43#issuecomment-845566980\">0xKiwi (NFTX) confirmed</a>:</strong></p>\n<blockquote>\n<p>Upgraded to 0.8.x.</p>\n</blockquote>\n<h2 id=\"h-02-distribute-dos-on-missing-receiverewards-implementation\" style=\"position:relative;\"><a href=\"#h-02-distribute-dos-on-missing-receiverewards-implementation\" aria-label=\"h 02 distribute dos on missing receiverewards implementation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/46\">[H-02] <code>distribute</code> DoS on missing <code>receiveRewards</code> implementation</a></h2>\n<p><code>NFTXEligiblityManager._sendForReceiver</code> should check <code>returnData.length == 1</code> before decoding. Otherwise, if it returns no return data, the <code>abi.decode</code> call will revert and with it the whole <code>distribute</code> function .</p>\n<p>A single poorly implemented <code>feeReceiver</code> can break the whole <code>distribute</code> function and allow a denial of service by reverting the transaction.</p>\n<p>Recommend changing to: <code>bool tokensReceived = returnData.length == 1 &#x26;&#x26; abi.decode(returnData, (bool));</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/46\">0xKiwi (NFTX) confirmed</a>:</strong></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/46#issuecomment-848259748\">cemozer (Judge) commented</a>:</strong></p>\n<blockquote>\n<p>Marking this as high risk because one nefarious feeReceiver can in fact deny other users to receive their fees</p>\n</blockquote>\n<h2 id=\"h-03-getrandomtokenidfromfund-yields-wrong-probabilities-for-erc1155\" style=\"position:relative;\"><a href=\"#h-03-getrandomtokenidfromfund-yields-wrong-probabilities-for-erc1155\" aria-label=\"h 03 getrandomtokenidfromfund yields wrong probabilities for erc1155 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/56\">[H-03] <code>getRandomTokenIdFromFund</code> yields wrong probabilities for ERC1155</a></h2>\n<p><code>NFTXVaultUpgradeable.getRandomTokenIdFromFund</code> does not work with ERC1155 as it does not take the deposited <code>quantity1155</code> into account.</p>\n<p>Assume <code>tokenId0</code> has a count of 100, and <code>tokenId1</code> has a count of 1.\nThen <code>getRandomId</code> would have a pseudo-random 1:1 chance for token 0 and 1 when in reality it should be 100:1.</p>\n<p>This might make it easier for an attacker to redeem more valuable NFTs as the probabilities are off.</p>\n<p>Recommend taking the quantities of each token into account (<code>quantity1155</code>) which probably requires a design change as it is currently hard to do without iterating over all tokens.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/56\">0xKiwi (NFTX) acknowledged</a></strong></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/56#issuecomment-848266608\">cemozer (Judge) commented</a>:</strong></p>\n<blockquote>\n<p>Marking this as high risk as an attacker can weed out high-value NFTs from a vault putting other users funds at risk</p>\n</blockquote>\n<h2 id=\"h-04-nftxlpstaking-is-subject-to-a-flash-loan-attack-that-can-steal-nearly-all-rewardsfees-that-have-accrued-for-a-particular-vault\" style=\"position:relative;\"><a href=\"#h-04-nftxlpstaking-is-subject-to-a-flash-loan-attack-that-can-steal-nearly-all-rewardsfees-that-have-accrued-for-a-particular-vault\" aria-label=\"h 04 nftxlpstaking is subject to a flash loan attack that can steal nearly all rewardsfees that have accrued for a particular vault permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/88\">[H-04] <code>NFTXLPStaking</code> Is Subject To A Flash Loan Attack That Can Steal Nearly All Rewards/Fees That Have Accrued For A Particular Vault</a></h2>\n<p>The LPStaking contract does not require that a stake be locked for any period of time. The LPStaking contract also does not track how long your stake has been locked. So an attacker Alice can stake, claim rewards, and unstake, all in one transaction. If Alice utilizes a flash loan, then she can claim nearly all of the rewards for herself, leaving very little left for the legitimate stakers.</p>\n<p>The fact that the <code>NFTXVaultUpgradeable</code> contract contains a native <code>flashLoan</code> function makes this attack that much easier, although it would still be possible even without that due to flashloans on Uniswap, or wherever else the nftX token is found.</p>\n<p>Since a flash loan will easily dwarf all of the legitimate stakers’ size of stake, the contract will erroneously award nearly all of the rewards to Alice.</p>\n<ol>\n<li>Wait until an NFTX vault has accrued any significant amount of fees/rewards</li>\n<li><code>FlashLoanBorrow</code> a lot of ETH using any generic flash loan provider</li>\n<li><code>FlashLoanBorrow</code> a lot of nftx-vault-token using <code>NFTXVaultUpgradeable.flashLoan()</code></li>\n<li>Deposit the ETH and nftx-vault-token’s into Uniswap for Uniswap LP tokens by calling <code>Uniswap.addLiquidity()</code></li>\n<li>Stake the Uniswap LP tokens in <code>NFTXLPStaking</code> by calling <code>NFTXLPStaking.deposit()</code></li>\n<li>Claim nearly all of the rewards that have accrued for this vault due to how large the flashLoaned deposit is relative to all of the legitimate stakes by calling <code>NFTXLPStaking.claimRewards()</code></li>\n<li>Remove LP tokens from <code>NFTXLPStaking</code> by calling <code>NFTXLPStaking.exit()</code>;</li>\n<li>Withdraw ETH and nftx-vault-token’s by calling <code>Uniswap.removeLiquidity()</code>;</li>\n<li>Pay back nftx-vault-token flash loan</li>\n<li>Pay back ETH flash loan</li>\n</ol>\n<p>See <a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/88\">GitHub issue page</a> for an in-depth  example.</p>\n<p>Recommend requiring that staked LP tokens be staked for a particular period of time before they can be removed. Although a very short time frame (a few blocks) would avoid flash loan attacks, this attack could still be performed over the course of a few blocks less efficiently. Ideally, you would want the rewards to reflect the product of the amount staked and the duration that they’ve been staked, as well as having a minimum time staked.</p>\n<p>Alternatively, if you really want to allow people to have the ability to remove their stake immediately, then only allow rewards to be claimed for stakes that have been staked for a certain period of time. Users would still be able to remove their LP tokens, but they could no longer siphon off rewards immediately.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/88#issuecomment-845695223\">0xKiwi (NFTX) disputed</a>:</strong></p>\n<blockquote>\n<p>After looking at the code, this is not possible. The dividend token code takes into consideration the current unclaimed rewards and when a deposit is made that value is deducted.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/88#issuecomment-848325710\">cemozer (Judge) commented</a>:</strong></p>\n<blockquote>\n<p>@0xKiwi do you mind showing where in code that occurs?</p>\n</blockquote>\n<h1 id=\"medium-risk-findings-8\" style=\"position:relative;\"><a href=\"#medium-risk-findings-8\" aria-label=\"medium risk findings 8 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Medium Risk Findings (8)</h1>\n<h2 id=\"m-01-randomization-of-nfts-returned-in-redeemswap-operations-can-be-brute-forced\" style=\"position:relative;\"><a href=\"#m-01-randomization-of-nfts-returned-in-redeemswap-operations-can-be-brute-forced\" aria-label=\"m 01 randomization of nfts returned in redeemswap operations can be brute forced permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/78\">[M-01] Randomization of NFTs returned in redeem/swap operations can be brute-forced</a></h2>\n<p>If we assume that certain NFTs in a vault over time will have different market demand/price, then the users will try to redeem those specific NFTs. Even if direct redeems are disabled to prevent such a scenario to default to returning randomized NFTs, a user can brute-forced this on-chain randomization (using nonce + blockhash) by repeatedly trying to redeem/swap from a contract, checking the NFT IDs returned from the function and reverting the transaction if those are not the NFT IDs of specific interest.</p>\n<p>The impact will be a subversion of the randomization goal to return random NFTs which cannot be specified by the user.</p>\n<p>A <a href=\"https://twitter.com/sillytuna/status/1391013965170454540\">similar exploit happened recently with Meebit NFTs</a>.</p>\n<p>Recommend considering only EOA (external only account) for redeem/swap operations to prevent brute-forcing via contracts. Alternatively, make the user commit to pseudo-random IDs before revealing them.</p>\n<p>**- <a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/78\">0xKiwi acknowledged</a> **</p>\n<h2 id=\"m-02-use-safetransfersafetransferfrom-consistently-instead-of-transfertransferfrom\" style=\"position:relative;\"><a href=\"#m-02-use-safetransfersafetransferfrom-consistently-instead-of-transfertransferfrom\" aria-label=\"m 02 use safetransfersafetransferfrom consistently instead of transfertransferfrom permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/79\">[M-02] Use <code>safeTransfer</code>/<code>safeTransferFrom</code> consistently instead of <code>transfer</code>/<code>transferFrom</code></a></h2>\n<p>It is good to add a <code>require()</code> statement that checks the return value of token transfers, or to use something like OpenZeppelin’s <code>safeTransfer</code>/<code>safeTransferFrom</code> unless one is sure the given token reverts in case of a failure. Failure to do so will cause silent failures of transfers and affect token accounting in contract.</p>\n<p>While most places use a <code>require</code> or <code>safeTransfer</code>/<code>safeTransferFrom</code>, there are three missing cases in the withdrawal of staking token and rescue of arbitrary tokens sent to the <code>FeeDistributor</code> contract.</p>\n<p>Reference this similar medium-severity finding from <a href=\"https://consensys.net/diligence/audits/2021/01/fei-protocol/#unchecked-return-value-for-iweth-transfer-call\">Consensys Diligence Audit of Fei Protocol</a>.</p>\n<p>Recommend using <code>safeTransfer</code>/<code>safeTransferFrom</code> or <code>require()</code> consistently.</p>\n<p><strong>- <a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/79\">0xKiwi (NFTX) confirmed</a></strong></p>\n<h2 id=\"m-03-fee-distribution-re-entrancy\" style=\"position:relative;\"><a href=\"#m-03-fee-distribution-re-entrancy\" aria-label=\"m 03 fee distribution re entrancy permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/11\">[M-03] Fee Distribution Re-Entrancy</a></h2>\n<p>The <code>distribute</code> function of <code>NFTXFeeDistributor</code> has no access control and will invoke a fallback on the fee receivers, meaning that a fee receiver can re-enter via this function to acquire their allocation repeatedly potentially draining the full balance and sending zero amounts to the rest of the recipients.</p>\n<p>A smart contract with a malicious <code>receiveRewards</code> function can re-enter the <code>distribute</code> function with the same vault ID, thereby causing the exploit.</p>\n<p>Recommend that re-entrancy protection should be incorporated into the <code>distribute</code> function. I should note that a seemingly innocuous contract can cause this re-entrancy by simply asking the owners of the project to include an upgrade-able contract that is then replaced for a malicious implementation.</p>\n<p><strong>- <a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/11\">0xKiwi (NFTX) confirmed</a></strong></p>\n<h2 id=\"m-05-unbounded-iteration-in-nftxeligiblitymanagerdistribute-over-_feereceivers\" style=\"position:relative;\"><a href=\"#m-05-unbounded-iteration-in-nftxeligiblitymanagerdistribute-over-_feereceivers\" aria-label=\"m 05 unbounded iteration in nftxeligiblitymanagerdistribute over _feereceivers permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/47\">[M-05] Unbounded iteration in <code>NFTXEligiblityManager.distribute</code> over <code>_feeReceivers</code></a></h2>\n<p><code>NFTXEligiblityManager.distribute</code> iterates over all <code>_feeReceivers</code>. If the number of <code>_feeReceivers</code> gets too big, the transaction’s gas cost could exceed the block gas limit and make it impossible to call <code>distribute</code> at all.</p>\n<p>Recommend keeping the number of <code>_feeReceivers</code> small.</p>\n<p><strong>- <a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/47\">0xKiwi (NFTX) confirmed</a></strong></p>\n<h2 id=\"m-06-manager-can-grief-with-fees\" style=\"position:relative;\"><a href=\"#m-06-manager-can-grief-with-fees\" aria-label=\"m 06 manager can grief with fees permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/51\">[M-06] Manager can grief with fees</a></h2>\n<p>The fees in <code>NFTXVaultUpgradeable</code> can be set arbitrarily high (no restriction in <code>setFees</code>).</p>\n<p>The manager can front-run mints and set a huge fee (for example <code>fee = base</code>) which transfers user’s NFTs to the vault but doesn’t mint any pool share tokens in return for the user.</p>\n<p>Similar griefing attacks are also possible with other functions besides <code>mint</code>.</p>\n<p>Recommend checking for a max fee as a percentage of <code>base</code> (like 10%) whenever setting fees.</p>\n<h2 id=\"m-07-tokens-can-get-stuck-in-nftxmintrequesteligibility\" style=\"position:relative;\"><a href=\"#m-07-tokens-can-get-stuck-in-nftxmintrequesteligibility\" aria-label=\"m 07 tokens can get stuck in nftxmintrequesteligibility permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/59\">[M-07] Tokens can get stuck in <code>NFTXMintRequestEligibility</code></a></h2>\n<p>When dealing with ERC721 (instead of 1155) the amounts array is ignored, which leads to an issue.</p>\n<p>User can call <code>NFTXMintRequestEligibility.requestMint</code> for an ERC721 with <code>amounts[i] = 0</code>.\nThe <code>ERC721.transferFrom</code> is still executed but user cannot <code>reclaimRequestedMint</code> later and the NFT is stuck as it checks (<code>amounts[i] > 0</code>).</p>\n<p>Tokens can get stuck.\nAlso, subscribers to <code>Request</code> event could be tricked by specifying <code>amounts[i] > 1</code> in the ERC721 case, as only one token was transferred, but the amount multiple quantities get logged.</p>\n<p>Recommend that <code>requestMint</code>: Check <code>amounts[i] == 1</code> in ERC721 case, <code>amounts[i] > 0</code> in 1155 case.</p>\n<p><strong>- <a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/59\">0xKiwi (NFTX) confirmed</a></strong></p>\n<h2 id=\"m-08-a-malicious-receiver-can-cause-another-receiver-to-lose-out-on-distributed-fees-by-returning-false-for-tokensreceived-when-receiverewards-is-called-on-their-receiver-contract\" style=\"position:relative;\"><a href=\"#m-08-a-malicious-receiver-can-cause-another-receiver-to-lose-out-on-distributed-fees-by-returning-false-for-tokensreceived-when-receiverewards-is-called-on-their-receiver-contract\" aria-label=\"m 08 a malicious receiver can cause another receiver to lose out on distributed fees by returning false for tokensreceived when receiverewards is called on their receiver contract permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/69\">[M-08] A malicious receiver can cause another receiver to lose out on distributed fees by returning <code>false</code> for <code>tokensReceived</code> when <code>receiveRewards</code> is called on their receiver contract.</a></h2>\n<p>A malicious receiver can cause another receiver to lose out on distributed fees by returning <code>false</code> for <code>tokensReceived</code> when <code>receiveRewards</code> is called on their receiver contract. This causes the fee distributor to double spend the <code>amountToSend</code> because the contract incorrectly assumes the returned data is truthful.</p>\n<p><code>NFTXFeeDistributor.sol</code>:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"1\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">Line</span><span class=\"mtk1\"> </span><span class=\"mtk7\">163</span><span class=\"mtk1\">: (</span><span class=\"mtk12\">bool</span><span class=\"mtk1\"> </span><span class=\"mtk12\">success</span><span class=\"mtk1\">, </span><span class=\"mtk12\">bytes</span><span class=\"mtk1\"> </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">returnData</span><span class=\"mtk1\">) = </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_receiver</span><span class=\"mtk1\">.</span><span class=\"mtk12\">receiver</span><span class=\"mtk1\">).</span><span class=\"mtk11\">call</span><span class=\"mtk1\">(</span><span class=\"mtk12\">payload</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p>Recommend that you don’t trust return data from externally called contracts. Only utilize whether the transaction succeeds to determine if the treasury fallback should be called.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"\" data-index=\"2\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">Line 165: if (!success) {</span></span></code></pre>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/69#issuecomment-845681145\">0xKiwi (NFTX) confirmed</a>:</strong></p>\n<blockquote>\n<p>Nice catch!</p>\n</blockquote>\n<h2 id=\"m-09-the-direct-redeem-fee-can-be-circumvented\" style=\"position:relative;\"><a href=\"#m-09-the-direct-redeem-fee-can-be-circumvented\" aria-label=\"m 09 the direct redeem fee can be circumvented permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/71\">[M-09] The direct redeem fee can be circumvented</a></h2>\n<p>Since the random NFT is determined in the same transaction a payment or swap is being executed, a malicious actor can revert a transaction if they did not get the NFT they wanted. Combined with utilizing Flashbots miners which do not publish transactions which revert with <code>FlashbotsCheckAndSend</code>, there would be no cost to constantly attempting this every block or after the nonce is updated from <code>getPseudoRand()</code>.</p>\n<p><code>NFTXVaultUpgradeable.sol</code></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"3\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">Line</span><span class=\"mtk1\"> </span><span class=\"mtk7\">374</span><span class=\"mtk1\">: </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">tokenId</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">i</span><span class=\"mtk1\"> &lt; </span><span class=\"mtk12\">specificIds</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    ? </span><span class=\"mtk12\">specificIds</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">]</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    : </span><span class=\"mtk11\">getRandomTokenIdFromFund</span><span class=\"mtk1\">();</span></span></span></code></pre>\n<p>In this way, the <code>directReedemFee</code> can be avoided and users may lose out on potential earnings. The code below shows a transfer ownership of ERC20 tokens to attack the contract.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"\" data-index=\"4\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">function revertIfNotSpecifiedID(uint256 targetTokenID) public {</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    NFTXVaultUpgradeable vault = NFTXVaultUpgradeable(_vault);</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    uint256[] resultID = vault.redeem(1,[]);</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    require(resultID[0] == targetTokenID);</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">}</span></span></code></pre>\n<p>Recommend using a commit-reveal pattern for NFT swaps and redemptions.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/71\">0xKiwi (NFTX) acknowledged</a></strong></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/71#issuecomment-848321831\">cemozer (Judge) commented</a>:</strong></p>\n<blockquote>\n<p>Leaving this as medium risk as it puts user earnings into risk</p>\n</blockquote>\n<h1 id=\"low-risk-findings-10\" style=\"position:relative;\"><a href=\"#low-risk-findings-10\" aria-label=\"low risk findings 10 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Low Risk Findings (10)</h1>\n<h2 id=\"l-01-front-running-setfees-could-avoid-fees\" style=\"position:relative;\"><a href=\"#l-01-front-running-setfees-could-avoid-fees\" aria-label=\"l 01 front running setfees could avoid fees permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/72\">[L-01] Front-running <code>setFees()</code> could avoid fees</a></h2>\n<p><code>setVaultFeatures()</code> and <code>setFees()</code> are two separate privileged functions. Users could front-run <code>setFees()</code> immediately after vault is enabled in <code>setVaultFeatures()</code> to mint (and possibly redeem/directRedeem/swap) many tokens. The fees for mint/redeem/directRedeem/swap are not initialized so are 0 by default. This leads to loss of fee revenue.</p>\n<p>Recommend Setting defaults at initialization or combine this with <code>setVaultFeatures()</code> for atomically enabling functions and setting their fees in the same transaction.</p>\n<p><strong>- <a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/72\">0xKiwi (NFTX) confirmed</a></strong></p>\n<h2 id=\"l-02-missing-pool-existence-check-in-balanceof\" style=\"position:relative;\"><a href=\"#l-02-missing-pool-existence-check-in-balanceof\" aria-label=\"l 02 missing pool existence check in balanceof permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/80\">[L-02] Missing pool existence check in <code>balanceOf</code></a></h2>\n<p>In <code>NFTXLPStaking.sol</code>, <code>deposit()</code>, <code>exit()</code>, <code>withdraw()</code>,<code>claimRewards()</code> and other related functions that take a <code>vaultID</code> as parameter perform a pool existence check on the staking pool associated with that <code>vaultID</code>. However, <code>balanceOf</code> is missing a similar pool check.</p>\n<p>This may result in returning an invalid balance of a non-existing or stale pool.</p>\n<p>Recommend adding check <code>require(pool.stakingToken != address(0), \"LPStaking: Nonexistent pool”);</code> before L170.</p>\n<p><strong>- <a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/80\">0xKiwi (NFTX) confirmed</a></strong></p>\n<h2 id=\"l-03-missing-parameter-validation\" style=\"position:relative;\"><a href=\"#l-03-missing-parameter-validation\" aria-label=\"l 03 missing parameter validation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/44\">[L-03] Missing parameter validation</a></h2>\n<p>Missing parameter validation for functions:</p>\n<ul>\n<li><code>NFTXEligiblityManager.addModule, updateModule</code></li>\n<li><code>NFTXFeeDistributor</code> all <code>setter</code> functions (<code>setTreasuryAddress</code>, …)</li>\n<li><code>NFTXVaultUpgradeable.setManager</code></li>\n</ul>\n<p>Some wallets still default to zero addresses for a missing input which can lead to breaking critical functionality like setting the manager to the zero address and being locked out.</p>\n<p>Recommend validating the parameters.</p>\n<p><strong>- <a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/44\">0xKiwi (NFTX) confirmed </a></strong></p>\n<h2 id=\"l-04-missing-usage-of-safemath\" style=\"position:relative;\"><a href=\"#l-04-missing-usage-of-safemath\" aria-label=\"l 04 missing usage of safemath permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/45\">[L-04] Missing usage of SafeMath</a></h2>\n<p>The following code does not use <code>SafeMath</code> and can potentially lead to overflows:</p>\n<ul>\n<li><code>NFTXFeeDistributor.distribute</code></li>\n<li><code>NFTXFeeDistributor._sendForReceiver</code></li>\n</ul>\n<p>While looping through all <code>_feeReceivers</code> it could be that a broken vault was whitelisted that allows an attacker to perform an external call and break the invariant that always 1000 tokens are left in the contract.</p>\n<p>Add <code>SafeMath</code> to <code>_sendForReceiver</code> even though one would expect the math to be safe.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/45#issuecomment-840872967\">0xKiwi (NFTX) confirmed</a>:</strong></p>\n<blockquote>\n<p>Confirmed and updated all code to 0.8.x.</p>\n</blockquote>\n<h2 id=\"l-05-inconsistent-solidity-pragma\" style=\"position:relative;\"><a href=\"#l-05-inconsistent-solidity-pragma\" aria-label=\"l 05 inconsistent solidity pragma permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/3\">[L-05] Inconsistent solidity pragma</a></h2>\n<p>The source files have different solidity compiler ranges referenced.  This leads to potential security flaws between deployed contracts depending on the compiler version chosen for any particular file.  It also greatly increases the cost of maintenance as different compiler versions have different semantics and behavior.</p>\n<p>This defect has numerous surfaces at <a href=\"https://github.com/code-423n4/2021-05-nftx/tree/main/nftx-protocol-v2/contracts/solidity\">https://github.com/code-423n4/2021-05-nftx/tree/main/nftx-protocol-v2/contracts/solidity</a></p>\n<p>Recommend fixing a definite compiler range that is consistent between contracts and upgrade any affected contracts to conform to the specified compiler.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/3#issuecomment-845494409\">0xKiwi (NFTX) commented</a>:</strong></p>\n<blockquote>\n<p>We have updated everything to 0.8.x.</p>\n</blockquote>\n<h2 id=\"l-06-unchecked-external-calls-in-nftxlpstaking\" style=\"position:relative;\"><a href=\"#l-06-unchecked-external-calls-in-nftxlpstaking\" aria-label=\"l 06 unchecked external calls in nftxlpstaking permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/48\">[L-06] Unchecked external calls in <code>NFTXLPStaking</code></a></h2>\n<p>The <code>emergencyExit</code>/<code>emergencyExitAndClaim</code> functions take the staking and reward tokens as parameters and trust them for the withdrawal.</p>\n<p>This does not lead to a critical issue (like being able to withdraw all funds) as one cannot deploy a fake reward smart contract to a <code>_rewardDistributionTokenAddr</code> and a random address without a smart contract will fail because of the <code>dist.balanceOf(msg.sender)</code> call not returning any data. However, checking if the distribution token exists is still recommended.</p>\n<p>Recommend requiring <code>isContract(dist)</code>.</p>\n<p><strong>- <a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/48\">0xKiwi (NFTX) confirmed</a></strong></p>\n<h2 id=\"l-07-vaults-flash-loan-not-implemented-according-to-eip-3156\" style=\"position:relative;\"><a href=\"#l-07-vaults-flash-loan-not-implemented-according-to-eip-3156\" aria-label=\"l 07 vaults flash loan not implemented according to eip 3156 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/54\">[L-07] Vault’s flash loan not implemented according to EIP-3156</a></h2>\n<p>The <code>NFTXVaultUpgradeable.flashLoan</code> is not correctly implemented according to  EIP-3156 (but it tries to implement it as it inherits from <code>IERC3156FlashLenderUpgradeable</code>).</p>\n<blockquote>\n<p>“If successful, flashLoan MUST return true.” - <a href=\"https://eips.ethereum.org/EIPS/eip-3156\">https://eips.ethereum.org/EIPS/eip-3156</a></p>\n</blockquote>\n<p>It misses the return and currently always returns <code>false</code>.</p>\n<p>Always returning <code>false</code> indicates that the flash loan was unsuccessful, when in reality it could have been successful.\nThis breaks any contract trying to integrate with it.</p>\n<p>Recommend adding the return statement: <code>return super.flashLoan(...)</code></p>\n<p><strong>- <a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/54\">0xKiwi (NFTX) confirmed</a></strong></p>\n<p><strong>- <a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/54#issuecomment-848263863\">cemozer (Judge) commented</a>:</strong></p>\n<blockquote>\n<p>Keeping this as low-risk as flash loan returning the project does not pose a security threat for the NFTX project itself</p>\n</blockquote>\n<h2 id=\"l-08-eligibilitymanager-is-always-0x0\" style=\"position:relative;\"><a href=\"#l-08-eligibilitymanager-is-always-0x0\" aria-label=\"l 08 eligibilitymanager is always 0x0 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/25\">[L-08] <code>eligibilityManager</code> is always 0x0</a></h2>\n<p>the contract <code>NFTXVaultFactoryUpgradeable</code>, variable <code>eligibilityManager</code> is never set thus it gets a default value of 0x0. So function <code>deployEligibilityStorage</code> should always fail as the eligibility manager does not exist on address 0x0.</p>\n<p>Recommend either adding a setter for <code>eligibilityManager</code> or refactor function <code>deployEligibilityStorage</code> to work in such case.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/25#issuecomment-845558815\">0xKiwi (NFTX) confirmed</a>:</strong></p>\n<blockquote>\n<p>Nice find!</p>\n</blockquote>\n<h2 id=\"l-09-lack-of-zero-address-validation\" style=\"position:relative;\"><a href=\"#l-09-lack-of-zero-address-validation\" aria-label=\"l 09 lack of zero address validation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/82\">[L-09] lack of zero address validation</a></h2>\n<p>Init function like <code>__FeeDistributor__init__()</code> is used to initialize the state variables. Since these state variables are used in many functions, it is possible that due to lack of input validation, an error in these state variables can lead to redeployment of contract.</p>\n<ul>\n<li><code>In NFTXFeeDistributor.sol --> __FeeDistributor__init__()</code></li>\n<li><code>in NFTXLPStaking.sol --> __NFTXLPStaking__init()</code></li>\n<li><code>in NFTXVaultUpgradeable.sol -- > __NFTXVault_init()</code></li>\n<li><code>in StakingTokenProvider.sol --> __StakingTokenProvider_init()</code></li>\n</ul>\n<p>Recommend adding zero address validation.</p>\n<p><strong>- <a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/82\">0xKiwi (NFTX) confirmed</a></strong></p>\n<h2 id=\"l-10-__ownable_init-will-be-called-twice-in-multiple-eligibility-contracts\" style=\"position:relative;\"><a href=\"#l-10-__ownable_init-will-be-called-twice-in-multiple-eligibility-contracts\" aria-label=\"l 10 __ownable_init will be called twice in multiple eligibility contracts permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/84\">[L-10] <code>__Ownable_init</code> will be called twice in multiple Eligibility contracts</a></h2>\n<p>Here you have more info: <a href=\"https://gist.github.com/alexon1234/43bf4a72a5b06651f04fc8052349ac5a\">https://gist.github.com/alexon1234/43bf4a72a5b06651f04fc8052349ac5a</a></p>\n<p><strong>- <a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/84\">0xKiwi (NFTX) confirmed</a></strong></p>\n<h1 id=\"non-critical-findings\" style=\"position:relative;\"><a href=\"#non-critical-findings\" aria-label=\"non critical findings permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Non-Critical Findings</h1>\n<h2 id=\"n-01-lockids-not-according-to-spec\" style=\"position:relative;\"><a href=\"#n-01-lockids-not-according-to-spec\" aria-label=\"n 01 lockids not according to spec permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/52\">[N-01] <code>LockIds</code> not according to spec</a></h2>\n<p>The <code>PausableUpgradeable.onlyOwnerIfPaused</code> doc comment specifies the pause states as:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"5\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// 0 : createFund</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// 1 : mint</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// 2 : redeem</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// 3 : mintAndRedeem</span></span></span></code></pre>\n<p>But <code>lockId = 3</code> does not prevent mints and redeems in <code>NFTXVaultUpgradeable</code>.\nInstead, it prevents swaps.\nThere is also an undocumented <code>lockId = 4</code> to prevent <code>flashLoans</code>.</p>\n<p>A manager might look at the spec and try to prevent mints and redeems in an emergency by setting the highest <code>lockId</code> <code>3</code>, which would prevent these according to spec. However, users can still mint and redeem as <code>lockId</code> prevents swaps only.</p>\n<p>Recommend updating the documentation to reflect the code.</p>\n<p><strong>- <a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/52\">0xKiwi (NFTX) confirmed</a></strong></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/52#issuecomment-848262690\">cemozer (Judge) commented</a>:</strong></p>\n<blockquote>\n<p>Marking this as non-critical as the issue is only in the documentation.</p>\n</blockquote>\n<h2 id=\"n-01-simpler-way-to-suppress-compiler-warning\" style=\"position:relative;\"><a href=\"#n-01-simpler-way-to-suppress-compiler-warning\" aria-label=\"n 01 simpler way to suppress compiler warning permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/12\">[N-01] simpler way to suppress compiler warning</a></h2>\n<p>In the function <code>flashFee</code> of <code>ERC20FlashMintUpgradeable.sol</code>, the variable amount is referenced to suppress a compiler warning. There is a simpler way to do this, by commenting out the variable name.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"6\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">   </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">flashFee</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">token</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">amount</span><span class=\"mtk1\">) </span><span class=\"mtk11\">public</span><span class=\"mtk1\"> </span><span class=\"mtk11\">view</span><span class=\"mtk1\"> </span><span class=\"mtk11\">virtual</span><span class=\"mtk1\"> </span><span class=\"mtk11\">override</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">token</span><span class=\"mtk1\"> == </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">), </span><span class=\"mtk8\">&quot;ERC20FlashMint: wrong token&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// silence warning about unused variable without the addition of bytecode.</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">amount</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span></span></code></pre>\n<p>Recommend using the following code:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"7\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">   </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">flashFee</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">token</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk3\">/*amount*/</span><span class=\"mtk1\">) </span><span class=\"mtk11\">public</span><span class=\"mtk1\"> </span><span class=\"mtk11\">view</span><span class=\"mtk1\"> </span><span class=\"mtk11\">virtual</span><span class=\"mtk1\"> </span><span class=\"mtk11\">override</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">token</span><span class=\"mtk1\"> == </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">), </span><span class=\"mtk8\">&quot;ERC20FlashMint: wrong token&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span></span></code></pre>\n<p><strong>- <a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/12\">0xKiwi (NFTX) acknowldged</a></strong></p>\n<h2 id=\"n-02-not-checked-if-within-array-bounds\" style=\"position:relative;\"><a href=\"#n-02-not-checked-if-within-array-bounds\" aria-label=\"n 02 not checked if within array bounds permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/13\">[N-02] Not checked if within array bounds</a></h2>\n<p>In the function <code>updateModule</code> and <code>deployEligibility</code> of <code>NFTXEligiblityManager.sol</code>, the array modules is used without checking if the index is within bounds. If index would be out of bounds, the function will revert, but it’s more difficult to troubleshoot.</p>\n<p>NFTXEligiblityManager.sol:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"8\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">updateModule</span><span class=\"mtk1\">(</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">index</span><span class=\"mtk1\">, </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">implementation</span><span class=\"mtk1\">) </span><span class=\"mtk11\">public</span><span class=\"mtk1\"> </span><span class=\"mtk11\">onlyOwner</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">modules</span><span class=\"mtk1\">[</span><span class=\"mtk12\">index</span><span class=\"mtk1\">].</span><span class=\"mtk12\">impl</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">implementation</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">deployEligibility</span><span class=\"mtk1\">(</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">moduleIndex</span><span class=\"mtk1\">, </span><span class=\"mtk12\">bytes</span><span class=\"mtk1\"> </span><span class=\"mtk12\">calldata</span><span class=\"mtk1\"> </span><span class=\"mtk12\">configData</span><span class=\"mtk1\">) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">virtual</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">address</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">eligImpl</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">modules</span><span class=\"mtk1\">[</span><span class=\"mtk12\">moduleIndex</span><span class=\"mtk1\">].</span><span class=\"mtk12\">impl</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    ...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p>Recommend adding something like:\n<code>require(index &#x3C; modules.length,\"out or range\");</code></p>\n<p><strong>- <a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/13\">0xKiwi (NFTX) confirmed</a></strong></p>\n<h2 id=\"n-03-missing-documentation-for-flashloan-paused-number\" style=\"position:relative;\"><a href=\"#n-03-missing-documentation-for-flashloan-paused-number\" aria-label=\"n 03 missing documentation for flashloan paused number permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/14\">[N-03] Missing documentation for <code>flashloan</code> paused number</a></h2>\n<p>The contract <code>PausableUpgradeable.sol</code> documents the paused variables 0..3.\nHowever, <code>onlyOwnerIfPaused</code> is also used with a parameter of 4. This is used for <code>flashloans</code>.</p>\n<p>PausableUpgradeable.sol:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"9\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// 0 : createFund</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// 1 : mint</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// 2 : redeem</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// 3 : mintAndRedeem</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">.\\</span><span class=\"mtk12\">NFTXVaultFactoryUpgradeable</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">:        </span><span class=\"mtk11\">onlyOwnerIfPaused</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">.\\</span><span class=\"mtk12\">NFTXVaultUpgradeable</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">:        </span><span class=\"mtk11\">onlyOwnerIfPaused</span><span class=\"mtk1\">(</span><span class=\"mtk7\">1</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">.\\</span><span class=\"mtk12\">NFTXVaultUpgradeable</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">:        </span><span class=\"mtk11\">onlyOwnerIfPaused</span><span class=\"mtk1\">(</span><span class=\"mtk7\">2</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">.\\</span><span class=\"mtk12\">NFTXVaultUpgradeable</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">:        </span><span class=\"mtk11\">onlyOwnerIfPaused</span><span class=\"mtk1\">(</span><span class=\"mtk7\">3</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">.\\</span><span class=\"mtk12\">NFTXVaultUpgradeable</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">:        </span><span class=\"mtk11\">onlyOwnerIfPaused</span><span class=\"mtk1\">(</span><span class=\"mtk7\">4</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p>Recommend adding documentation for #4. Or even better, create constants or enums.</p>\n<h2 id=\"n-04-no-check-_rangestart_rangeend\" style=\"position:relative;\"><a href=\"#n-04-no-check-_rangestart_rangeend\" aria-label=\"n 04 no check _rangestart_rangeend permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/17\">[N-04] no check <code>_rangeStart&#x3C;=_rangeEnd</code></a></h2>\n<p>In <code>NFTXRangeEligibility.sol</code> a range is defined via <code>__NFTXEligibility_init</code> and <code>setEligibilityPreferences</code>.\nNo check is done to make sure <code>_rangeStart&#x3C;=_rangeEnd</code>, so one could accidentally define it as a range that is effectively empty.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"10\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">setEligibilityPreferences</span><span class=\"mtk1\">(</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_rangeStart</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_rangeEnd</span><span class=\"mtk1\">) </span><span class=\"mtk11\">externalvirtual</span><span class=\"mtk1\"> </span><span class=\"mtk11\">onlyOwner</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">rangeStart</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_rangeStart</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">rangeEnd</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_rangeEnd</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">emit</span><span class=\"mtk1\"> </span><span class=\"mtk11\">RangeSet</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_rangeStart</span><span class=\"mtk1\">, </span><span class=\"mtk12\">_rangeEnd</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span></code></pre>\n<p>Recommend considering adding a check to make sure <code>_rangeStart&#x3C;=_rangeEnd</code></p>\n<p><strong>- <a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/17\">0xKiwi (NFTX) confirmed</a></strong></p>\n<h2 id=\"n-05-incorrect-type-specified-for-argument-_address-in-nftxfeedistributorrescuetokens\" style=\"position:relative;\"><a href=\"#n-05-incorrect-type-specified-for-argument-_address-in-nftxfeedistributorrescuetokens\" aria-label=\"n 05 incorrect type specified for argument _address in nftxfeedistributorrescuetokens permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/89\">[N-05] Incorrect Type Specified For Argument <code>_address</code> In <code>NFTXFeeDistributor.rescueTokens()</code></a></h2>\n<p><code>NFTXFeeDistributor.rescueTokens()</code> is not functional since it casts <code>_address</code> as a uint256 in the function declaration in <a href=\"https://github.com/code-423n4/2021-05-nftx/blob/f6d793c136d110774de259d9f3b25d003c4f8098/nftx-protocol-v2/contracts/solidity/NFTXFeeDistributor.sol#L141\">L141</a></p>\n<p>Recommend changing this:</p>\n<p><code>function rescueTokens(uint256 _address) external override onlyOwner {</code></p>\n<p>To this:</p>\n<p><code>function rescueTokens(address _address) external override onlyOwner {</code></p>\n<p><strong>- <a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/89\">0xKiwi (NFTX) confirmed</a></strong></p>\n<h2 id=\"n-06-two-duplicate-rescuetokens-functions-in-nftxfeedistributor-\" style=\"position:relative;\"><a href=\"#n-06-two-duplicate-rescuetokens-functions-in-nftxfeedistributor-\" aria-label=\"n 06 two duplicate rescuetokens functions in nftxfeedistributor  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/91\">[N-06] Two Duplicate “rescueTokens” Functions In <code>NFTXFeeDistributor</code> </a></h2>\n<p>There are two duplicate functions that both intended to rescue tokens that have incorrectly been sent to the <code>NFTXFeeDistributor</code>. The only difference is a typo in one of the functions which incorrectly casts <code>_address</code> as a uint256.</p>\n<p>Recommend deleting the <code>rescueTokens</code> function on L141 that incorrectly casts <code>_address</code> as a uint256.</p>\n<p><strong>- <a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/91\">0xKiwi (NFTX) confirmed</a></strong></p>\n<h2 id=\"n-07-info-function-publicmint-is-for-testing-only\" style=\"position:relative;\"><a href=\"#n-07-info-function-publicmint-is-for-testing-only\" aria-label=\"n 07 info function publicmint is for testing only permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/26\">[N-07] [INFO] function <code>publicMint</code> is for testing only</a></h2>\n<p>The function <code>publicMint</code> has a comment that says it is meant for testing only:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"11\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// For testing</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">publicMint</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">to</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">tokenId</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">amount</span><span class=\"mtk1\">) </span><span class=\"mtk11\">public</span><span class=\"mtk1\"> </span><span class=\"mtk11\">virtual</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">_mint</span><span class=\"mtk1\">(</span><span class=\"mtk12\">to</span><span class=\"mtk1\">, </span><span class=\"mtk12\">tokenId</span><span class=\"mtk1\">, </span><span class=\"mtk12\">amount</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span></code></pre>\n<p>Recommend not to forget to comment or delete this code before going to production.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/26#issuecomment-845559009\">0xKiwi (NFTX) acknowledged</a>:</strong></p>\n<blockquote>\n<p>Test code</p>\n</blockquote>\n<h2 id=\"n-08-using-calldata-when-not-appropriate\" style=\"position:relative;\"><a href=\"#n-08-using-calldata-when-not-appropriate\" aria-label=\"n 08 using calldata when not appropriate permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/100\">[N-08] Using <code>calldata</code> when not appropriate</a></h2>\n<p>Here’s more info: <a href=\"https://gist.github.com/alexon1234/7b6799434cccda5e3f3d461b8186ec89\">https://gist.github.com/alexon1234/7b6799434cccda5e3f3d461b8186ec89</a></p>\n<p><strong>- <a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/100\">0xKiwi (NFTX) disputed</a></strong></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/100#issuecomment-848300810\">cemozer (Judge) commented</a>:</strong></p>\n<blockquote>\n<p>@0xKiwi can you explain why you’ve disputed this issue?</p>\n</blockquote>\n<h1 id=\"gas-optimizations\" style=\"position:relative;\"><a href=\"#gas-optimizations\" aria-label=\"gas optimizations permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Gas Optimizations</h1>\n<h2 id=\"g-01-unused-storage-variables\" style=\"position:relative;\"><a href=\"#g-01-unused-storage-variables\" aria-label=\"g 01 unused storage variables permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/62\">[G-01] Unused storage variables</a></h2>\n<p>Unused storage variables in contracts use up storage slots and increase contract size and gas usage at deployment and initialization. Multiple variables across different contracts including <code>manager</code> , <code>allVaults</code>, <code>vaultsForAsset</code>, and <code>prevContract</code>. Recommend removing unused variables.</p>\n<p><strong>- <a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/62\">0xKiwi (NFTX) confirmed</a></strong></p>\n<h2 id=\"g-02-unused-events\" style=\"position:relative;\"><a href=\"#g-02-unused-events\" aria-label=\"g 02 unused events permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/63\">[G-02] Unused events</a></h2>\n<p>Unused events increase contract size at deployment. Multiple events in <code>NFTXMintRequestEligibility.sol</code> listed on the issue page. Recommend removing unused events or emit at appropriate places.</p>\n<p><strong>- <a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/63\">0xKiwi (NFTX) confirmed</a></strong></p>\n<h2 id=\"g-03-change-function-visibility-from-public-to-external\" style=\"position:relative;\"><a href=\"#g-03-change-function-visibility-from-public-to-external\" aria-label=\"g 03 change function visibility from public to external permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/64\">[G-03] Change function visibility from public to external</a></h2>\n<p>Various functions across contracts are never called from within contracts yet are declared public. Their visibility can be made external to save gas.</p>\n<p>As described in <a href=\"https://mudit.blog/solidity-gas-optimization-tips/\">https://mudit.blog/solidity-gas-optimization-tips/</a>:</p>\n<blockquote>\n<p>“For all the public functions, the input parameters are copied to memory automatically, and it costs gas. If your function is only called externally, then you should explicitly mark it as external. External function’s parameters are not copied into memory but are read from <code>calldata</code> directly. This small optimization in your solidity code can save you a lot of gas when the function input parameters are huge.”</p>\n</blockquote>\n<p>Recommend changing function visibility from public to external.</p>\n<p><strong>- <a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/64\">0xKiwi (NFTX) confirmed</a></strong></p>\n<h2 id=\"g-04-gas-optimization-for-stakingtokenprovidernameforstakingtoken\" style=\"position:relative;\"><a href=\"#g-04-gas-optimization-for-stakingtokenprovidernameforstakingtoken\" aria-label=\"g 04 gas optimization for stakingtokenprovidernameforstakingtoken permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/49\">[G-04] Gas optimization for <code>StakingTokenProvider.nameForStakingToken</code></a></h2>\n<p><code>StakingTokenProvider.nameForStakingToken</code>: <code>if (keccak256(abi.encode(_pairedPrefix)) == keccak256(abi.encode(address(0))))</code> can be simplified to <code>if(bytes(_pairedPrefix).length== 0)</code></p>\n<p><strong>- <a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/49\">0xKiwi (NFTX) confirmed</a></strong></p>\n<h2 id=\"g-05-revert-inside-a-loop\" style=\"position:relative;\"><a href=\"#g-05-revert-inside-a-loop\" aria-label=\"g 05 revert inside a loop permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/97\">[G-05] Revert inside a loop</a></h2>\n<p>Here you have more info: <a href=\"https://gist.github.com/alexon1234/a2275d1724ce2122d36bc555e46a25c1\">https://gist.github.com/alexon1234/a2275d1724ce2122d36bc555e46a25c1</a></p>\n<p><strong>- <a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/97\">0xKiwi (NFTX) acknowledged</a></strong></p>\n<h2 id=\"g-06-unused-variables\" style=\"position:relative;\"><a href=\"#g-06-unused-variables\" aria-label=\"g 06 unused variables permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-nftx-findings/issues/39\">[G-06] Unused variables</a></h2>\n<p>There are unused variables in contract <code>NFTXVaultUpgradeable</code> (string public description) and in contract <code>NFTXMintRequestEligibility</code> (address public manager). Recommend deleting unused variables to reduce the deployment costs.</p>\n<h1 id=\"disclosures\" style=\"position:relative;\"><a href=\"#disclosures\" aria-label=\"disclosures permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Disclosures</h1>\n<p>C4 is an open organization governed by participants in the community.</p>\n<p>C4 Contests incentivize the discovery of exploits, vulnerabilities, and bugs in smart contracts. Security researchers are rewarded at an increasing rate for finding higher-risk issues. Contest submissions are judged by a knowledgeable security researcher and solidity developer and disclosed to sponsoring developers. C4 does not conduct formal verification regarding the provided code but instead provides final verification.</p>\n<p>C4 does not provide any guarantee or warranty regarding the security of this project. All smart contract software should be used at the sole risk and responsibility of users.</p>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n  .dark-default-dark {\n    background-color: #1E1E1E;\n    color: #D4D4D4;\n  }\n  .dark-default-dark .mtk11 { color: #DCDCAA; }\n  .dark-default-dark .mtk1 { color: #D4D4D4; }\n  .dark-default-dark .mtk12 { color: #9CDCFE; }\n  .dark-default-dark .mtk7 { color: #B5CEA8; }\n  .dark-default-dark .mtk3 { color: #6A9955; }\n  .dark-default-dark .mtk4 { color: #569CD6; }\n  .dark-default-dark .mtk8 { color: #CE9178; }\n  .dark-default-dark .mtk15 { color: #C586C0; }\n  .dark-default-dark .grvsc-line-highlighted::before {\n    background-color: var(--grvsc-line-highlighted-background-color, rgba(255, 255, 255, 0.1));\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(255, 255, 255, 0.5));\n  }\n</style>",
  "toc": "<ul>\n<li>\n<p><a href=\"#overview\">Overview</a></p>\n<ul>\n<li><a href=\"#about-c4\">About C4</a></li>\n<li><a href=\"#wardens\">Wardens</a></li>\n</ul>\n</li>\n<li><a href=\"#summary\">Summary</a></li>\n<li><a href=\"#scope\">Scope</a></li>\n<li><a href=\"#severity-criteria\">Severity Criteria</a></li>\n<li>\n<p><a href=\"#high-risk-findings-4\">High Risk Findings (4)</a></p>\n<ul>\n<li><a href=\"#h-01-missing-overflow-check-in-flashloan\">[H-01] Missing overflow check in <code>flashLoan</code></a></li>\n<li><a href=\"#h-02-distribute-dos-on-missing-receiverewards-implementation\">[H-02] <code>distribute</code> DoS on missing <code>receiveRewards</code> implementation</a></li>\n<li><a href=\"#h-03-getrandomtokenidfromfund-yields-wrong-probabilities-for-erc1155\">[H-03] <code>getRandomTokenIdFromFund</code> yields wrong probabilities for ERC1155</a></li>\n<li><a href=\"#h-04-nftxlpstaking-is-subject-to-a-flash-loan-attack-that-can-steal-nearly-all-rewardsfees-that-have-accrued-for-a-particular-vault\">[H-04] <code>NFTXLPStaking</code> Is Subject To A Flash Loan Attack That Can Steal Nearly All Rewards/Fees That Have Accrued For A Particular Vault</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#medium-risk-findings-8\">Medium Risk Findings (8)</a></p>\n<ul>\n<li><a href=\"#m-01-randomization-of-nfts-returned-in-redeemswap-operations-can-be-brute-forced\">[M-01] Randomization of NFTs returned in redeem/swap operations can be brute-forced</a></li>\n<li><a href=\"#m-02-use-safetransfersafetransferfrom-consistently-instead-of-transfertransferfrom\">[M-02] Use <code>safeTransfer</code>/<code>safeTransferFrom</code> consistently instead of <code>transfer</code>/<code>transferFrom</code></a></li>\n<li><a href=\"#m-03-fee-distribution-re-entrancy\">[M-03] Fee Distribution Re-Entrancy</a></li>\n<li><a href=\"#m-05-unbounded-iteration-in-nftxeligiblitymanagerdistribute-over-_feereceivers\">[M-05] Unbounded iteration in <code>NFTXEligiblityManager.distribute</code> over <code>_feeReceivers</code></a></li>\n<li><a href=\"#m-06-manager-can-grief-with-fees\">[M-06] Manager can grief with fees</a></li>\n<li><a href=\"#m-07-tokens-can-get-stuck-in-nftxmintrequesteligibility\">[M-07] Tokens can get stuck in <code>NFTXMintRequestEligibility</code></a></li>\n<li><a href=\"#m-08-a-malicious-receiver-can-cause-another-receiver-to-lose-out-on-distributed-fees-by-returning-false-for-tokensreceived-when-receiverewards-is-called-on-their-receiver-contract\">[M-08] A malicious receiver can cause another receiver to lose out on distributed fees by returning <code>false</code> for <code>tokensReceived</code> when <code>receiveRewards</code> is called on their receiver contract.</a></li>\n<li><a href=\"#m-09-the-direct-redeem-fee-can-be-circumvented\">[M-09] The direct redeem fee can be circumvented</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#low-risk-findings-10\">Low Risk Findings (10)</a></p>\n<ul>\n<li><a href=\"#l-01-front-running-setfees-could-avoid-fees\">[L-01] Front-running <code>setFees()</code> could avoid fees</a></li>\n<li><a href=\"#l-02-missing-pool-existence-check-in-balanceof\">[L-02] Missing pool existence check in <code>balanceOf</code></a></li>\n<li><a href=\"#l-03-missing-parameter-validation\">[L-03] Missing parameter validation</a></li>\n<li><a href=\"#l-04-missing-usage-of-safemath\">[L-04] Missing usage of SafeMath</a></li>\n<li><a href=\"#l-05-inconsistent-solidity-pragma\">[L-05] Inconsistent solidity pragma</a></li>\n<li><a href=\"#l-06-unchecked-external-calls-in-nftxlpstaking\">[L-06] Unchecked external calls in <code>NFTXLPStaking</code></a></li>\n<li><a href=\"#l-07-vaults-flash-loan-not-implemented-according-to-eip-3156\">[L-07] Vault’s flash loan not implemented according to EIP-3156</a></li>\n<li><a href=\"#l-08-eligibilitymanager-is-always-0x0\">[L-08] <code>eligibilityManager</code> is always 0x0</a></li>\n<li><a href=\"#l-09-lack-of-zero-address-validation\">[L-09] lack of zero address validation</a></li>\n<li><a href=\"#l-10-__ownable_init-will-be-called-twice-in-multiple-eligibility-contracts\">[L-10] <code>__Ownable_init</code> will be called twice in multiple Eligibility contracts</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#non-critical-findings\">Non-Critical Findings</a></p>\n<ul>\n<li><a href=\"#n-01-lockids-not-according-to-spec\">[N-01] <code>LockIds</code> not according to spec</a></li>\n<li><a href=\"#n-01-simpler-way-to-suppress-compiler-warning\">[N-01] simpler way to suppress compiler warning</a></li>\n<li><a href=\"#n-02-not-checked-if-within-array-bounds\">[N-02] Not checked if within array bounds</a></li>\n<li><a href=\"#n-03-missing-documentation-for-flashloan-paused-number\">[N-03] Missing documentation for <code>flashloan</code> paused number</a></li>\n<li><a href=\"#n-04-no-check-_rangestart_rangeend\">[N-04] no check <code>_rangeStart&#x3C;=_rangeEnd</code></a></li>\n<li><a href=\"#n-05-incorrect-type-specified-for-argument-_address-in-nftxfeedistributorrescuetokens\">[N-05] Incorrect Type Specified For Argument <code>_address</code> In <code>NFTXFeeDistributor.rescueTokens()</code></a></li>\n<li><a href=\"#n-06-two-duplicate-rescuetokens-functions-in-nftxfeedistributor-\">[N-06] Two Duplicate “rescueTokens” Functions In <code>NFTXFeeDistributor</code> </a></li>\n<li><a href=\"#n-07-info-function-publicmint-is-for-testing-only\">[N-07] [INFO] function <code>publicMint</code> is for testing only</a></li>\n<li><a href=\"#n-08-using-calldata-when-not-appropriate\">[N-08] Using <code>calldata</code> when not appropriate</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#gas-optimizations\">Gas Optimizations</a></p>\n<ul>\n<li><a href=\"#g-01-unused-storage-variables\">[G-01] Unused storage variables</a></li>\n<li><a href=\"#g-02-unused-events\">[G-02] Unused events</a></li>\n<li><a href=\"#g-03-change-function-visibility-from-public-to-external\">[G-03] Change function visibility from public to external</a></li>\n<li><a href=\"#g-04-gas-optimization-for-stakingtokenprovidernameforstakingtoken\">[G-04] Gas optimization for <code>StakingTokenProvider.nameForStakingToken</code></a></li>\n<li><a href=\"#g-05-revert-inside-a-loop\">[G-05] Revert inside a loop</a></li>\n<li><a href=\"#g-06-unused-variables\">[G-06] Unused variables</a></li>\n</ul>\n</li>\n<li><a href=\"#disclosures\">Disclosures</a></li>\n</ul>",
  "md": "\n# Overview\n\n## About C4\n\nCode 432n4 (C4) is an open organization consisting of security researchers, auditors, developers, and individuals with domain expertise in smart contracts.\n\nA C4 code contest is an event in which community participants, referred to as Wardens, review, audit, or analyze smart contract logic in exchange for a bounty provided by sponsoring projects.\n\nDuring the code contest outlined in this document, C4 conducted an analysis of the NFTX smart contract system written in Solidity. The code contest took place between May 5th and May 11th, 2021.\n\n## Wardens\n\n11 Wardens contributed reports to the NFTX code contest:\n- [cmichel](https://twitter.com/cmichelio)\n- [pauliax](https://twitter.com/SolidityDev) (Thunder)\n- [janbro](https://twitter.com/unsafe_call)\n- [shw](https://github.com/x9453)\n- [gpersoon](https://twitter.com/gpersoon)\n- [rajeev](https://twitter.com/0xRajeev)\n- [a_delamo](https://twitter.com/a_delamo)\n- [0xsomeone](https://github.com/alex-ppg\")\n- [heiho1](https://github.com/heiho1) (Thisguy)\n- [mukesh jaiswal](https://twitter.com/MukeshJ_eth)\n- [jvaqa](https://twitter.com/jvaqa)\n\nThis contest was judged by [cemozer](https://twitter.com/cemozer_).\n\nFinal report assembled by [moneylegobatman](https://twitter.com/money_lego).\n\n# Summary\nThe C4 analysis yielded an aggregated total of 24 unique vulnerabilities. All of the issues presented here are linked back to their original finding\n\nOf these vulnerabilities, 4 received a risk rating in the category of HIGH severity, 10 received a risk rating in the category of MEDIUM severity, and 10 received a risk rating in the category of LOW severity.\n\nC4 analysis also identified 15 non-critical recommendations.\n\n# Scope\n\nThe code under review can be found within the [C4 NFTX code contest repository](https://github.com/code-423n4/2021-05-nftx) and comprises 68 smart contracts written in the Solidity programming language.\n\n# Severity Criteria\n\nC4 assesses the severity of disclosed vulnerabilities according to a methodology based on [OWASP standards](https://owasp.org/www-community/OWASP_Risk_Rating_Methodology).\n\nVulnerabilities are divided into three primary risk categories: high, medium, and low.\n\nHigh-level considerations for vulnerabilities span the following key areas when conducting assessments:\n\n- Malicious Input Handling\n- Escalation of privileges\n- Arithmetic\n- Gas use\n\nFurther information regarding the severity criteria referenced throughout the submission review process, please refer to the documentation provided on [the C4 website](https://code423n4.com).\n\n# High Risk Findings (4)\n\n## [[H-01] Missing overflow check in `flashLoan`](https://github.com/code-423n4/2021-05-nftx-findings/issues/43)\n\n`ERC20FlashMintUpgradeable.flashLoan` does not check for an overflow when adding the fees to the `flashloan` amount.\nThe functionality might have been copied from https://eips.ethereum.org/EIPS/eip-3156 but this one already has overflow checks as it uses solidity 0.8.0. This leads to an issue where the attacker does not need to pay back the `flashloan` as they will burn 0 tokens:\n\n```solidity\n_burn(address(receiver), amount + fee);\n```\nThey end up with a huge profit. (Luckily, this is currently not exploitable as the fee is set to 0 so there's no possibility to overflow. However, if governance decides to change the flashloan fee, flashloans can be taken without having to repay them). Recommend using `SafeMath`.\n\n**[0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/43#issuecomment-845566980):**\n > Upgraded to 0.8.x.\n\n## [[H-02] `distribute` DoS on missing `receiveRewards` implementation](https://github.com/code-423n4/2021-05-nftx-findings/issues/46)\n\n`NFTXEligiblityManager._sendForReceiver` should check `returnData.length == 1` before decoding. Otherwise, if it returns no return data, the `abi.decode` call will revert and with it the whole `distribute` function .\n\nA single poorly implemented `feeReceiver` can break the whole `distribute` function and allow a denial of service by reverting the transaction.\n\nRecommend changing to: `bool tokensReceived = returnData.length == 1 && abi.decode(returnData, (bool));`.\n\n**[0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/46):**\n\n**[cemozer (Judge) commented](https://github.com/code-423n4/2021-05-nftx-findings/issues/46#issuecomment-848259748):**\n > Marking this as high risk because one nefarious feeReceiver can in fact deny other users to receive their fees\n\n## [[H-03] `getRandomTokenIdFromFund` yields wrong probabilities for ERC1155](https://github.com/code-423n4/2021-05-nftx-findings/issues/56)\n\n`NFTXVaultUpgradeable.getRandomTokenIdFromFund` does not work with ERC1155 as it does not take the deposited `quantity1155` into account.\n\nAssume `tokenId0` has a count of 100, and `tokenId1` has a count of 1.\nThen `getRandomId` would have a pseudo-random 1:1 chance for token 0 and 1 when in reality it should be 100:1.\n\nThis might make it easier for an attacker to redeem more valuable NFTs as the probabilities are off.\n\nRecommend taking the quantities of each token into account (`quantity1155`) which probably requires a design change as it is currently hard to do without iterating over all tokens.\n\n**[0xKiwi (NFTX) acknowledged](https://github.com/code-423n4/2021-05-nftx-findings/issues/56)**\n\n**[cemozer (Judge) commented](https://github.com/code-423n4/2021-05-nftx-findings/issues/56#issuecomment-848266608):**\n > Marking this as high risk as an attacker can weed out high-value NFTs from a vault putting other users funds at risk\n\n## [[H-04] `NFTXLPStaking` Is Subject To A Flash Loan Attack That Can Steal Nearly All Rewards/Fees That Have Accrued For A Particular Vault](https://github.com/code-423n4/2021-05-nftx-findings/issues/88)\n\nThe LPStaking contract does not require that a stake be locked for any period of time. The LPStaking contract also does not track how long your stake has been locked. So an attacker Alice can stake, claim rewards, and unstake, all in one transaction. If Alice utilizes a flash loan, then she can claim nearly all of the rewards for herself, leaving very little left for the legitimate stakers.\n\nThe fact that the `NFTXVaultUpgradeable` contract contains a native `flashLoan` function makes this attack that much easier, although it would still be possible even without that due to flashloans on Uniswap, or wherever else the nftX token is found.\n\nSince a flash loan will easily dwarf all of the legitimate stakers' size of stake, the contract will erroneously award nearly all of the rewards to Alice.\n\n1.  Wait until an NFTX vault has accrued any significant amount of fees/rewards\n2.  `FlashLoanBorrow` a lot of ETH using any generic flash loan provider\n3.  `FlashLoanBorrow` a lot of nftx-vault-token using `NFTXVaultUpgradeable.flashLoan()`\n4.  Deposit the ETH and nftx-vault-token's into Uniswap for Uniswap LP tokens by calling `Uniswap.addLiquidity()`\n5.  Stake the Uniswap LP tokens in `NFTXLPStaking` by calling `NFTXLPStaking.deposit()`\n6.  Claim nearly all of the rewards that have accrued for this vault due to how large the flashLoaned deposit is relative to all of the legitimate stakes by calling `NFTXLPStaking.claimRewards()`\n7.  Remove LP tokens from `NFTXLPStaking` by calling `NFTXLPStaking.exit()`;\n8.  Withdraw ETH and nftx-vault-token's by calling `Uniswap.removeLiquidity()`;\n9.  Pay back nftx-vault-token flash loan\n10. Pay back ETH flash loan\n\nSee [GitHub issue page](https://github.com/code-423n4/2021-05-nftx-findings/issues/88) for an in-depth  example.\n\nRecommend requiring that staked LP tokens be staked for a particular period of time before they can be removed. Although a very short time frame (a few blocks) would avoid flash loan attacks, this attack could still be performed over the course of a few blocks less efficiently. Ideally, you would want the rewards to reflect the product of the amount staked and the duration that they've been staked, as well as having a minimum time staked.\n\nAlternatively, if you really want to allow people to have the ability to remove their stake immediately, then only allow rewards to be claimed for stakes that have been staked for a certain period of time. Users would still be able to remove their LP tokens, but they could no longer siphon off rewards immediately.\n\n**[0xKiwi (NFTX) disputed](https://github.com/code-423n4/2021-05-nftx-findings/issues/88#issuecomment-845695223):**\n > After looking at the code, this is not possible. The dividend token code takes into consideration the current unclaimed rewards and when a deposit is made that value is deducted.\n\n**[cemozer (Judge) commented](https://github.com/code-423n4/2021-05-nftx-findings/issues/88#issuecomment-848325710):**\n > @0xKiwi do you mind showing where in code that occurs?\n\n# Medium Risk Findings (8)\n\n## [[M-01] Randomization of NFTs returned in redeem/swap operations can be brute-forced](https://github.com/code-423n4/2021-05-nftx-findings/issues/78)\n\nIf we assume that certain NFTs in a vault over time will have different market demand/price, then the users will try to redeem those specific NFTs. Even if direct redeems are disabled to prevent such a scenario to default to returning randomized NFTs, a user can brute-forced this on-chain randomization (using nonce + blockhash) by repeatedly trying to redeem/swap from a contract, checking the NFT IDs returned from the function and reverting the transaction if those are not the NFT IDs of specific interest.\n\nThe impact will be a subversion of the randomization goal to return random NFTs which cannot be specified by the user.\n\nA [similar exploit happened recently with Meebit NFTs](https://twitter.com/sillytuna/status/1391013965170454540).\n\nRecommend considering only EOA (external only account) for redeem/swap operations to prevent brute-forcing via contracts. Alternatively, make the user commit to pseudo-random IDs before revealing them.\n\n**- [0xKiwi acknowledged](https://github.com/code-423n4/2021-05-nftx-findings/issues/78) **\n\n## [[M-02] Use `safeTransfer`/`safeTransferFrom` consistently instead of `transfer`/`transferFrom`](https://github.com/code-423n4/2021-05-nftx-findings/issues/79)\n\nIt is good to add a `require()` statement that checks the return value of token transfers, or to use something like OpenZeppelin’s `safeTransfer`/`safeTransferFrom` unless one is sure the given token reverts in case of a failure. Failure to do so will cause silent failures of transfers and affect token accounting in contract.\n\nWhile most places use a `require` or `safeTransfer`/`safeTransferFrom`, there are three missing cases in the withdrawal of staking token and rescue of arbitrary tokens sent to the `FeeDistributor` contract.\n\nReference this similar medium-severity finding from [Consensys Diligence Audit of Fei Protocol](https://consensys.net/diligence/audits/2021/01/fei-protocol/#unchecked-return-value-for-iweth-transfer-call).\n\nRecommend using `safeTransfer`/`safeTransferFrom` or `require()` consistently.\n\n**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/79)**\n\n## [[M-03] Fee Distribution Re-Entrancy](https://github.com/code-423n4/2021-05-nftx-findings/issues/11)\n\nThe `distribute` function of `NFTXFeeDistributor` has no access control and will invoke a fallback on the fee receivers, meaning that a fee receiver can re-enter via this function to acquire their allocation repeatedly potentially draining the full balance and sending zero amounts to the rest of the recipients.\n\nA smart contract with a malicious `receiveRewards` function can re-enter the `distribute` function with the same vault ID, thereby causing the exploit.\n\nRecommend that re-entrancy protection should be incorporated into the `distribute` function. I should note that a seemingly innocuous contract can cause this re-entrancy by simply asking the owners of the project to include an upgrade-able contract that is then replaced for a malicious implementation.\n\n**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/11)**\n\n## [[M-05] Unbounded iteration in `NFTXEligiblityManager.distribute` over `_feeReceivers`](https://github.com/code-423n4/2021-05-nftx-findings/issues/47)\n\n`NFTXEligiblityManager.distribute` iterates over all `_feeReceivers`. If the number of `_feeReceivers` gets too big, the transaction's gas cost could exceed the block gas limit and make it impossible to call `distribute` at all.\n\nRecommend keeping the number of `_feeReceivers` small.\n\n**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/47)**\n\n## [[M-06] Manager can grief with fees](https://github.com/code-423n4/2021-05-nftx-findings/issues/51)\n\nThe fees in `NFTXVaultUpgradeable` can be set arbitrarily high (no restriction in `setFees`).\n\nThe manager can front-run mints and set a huge fee (for example `fee = base`) which transfers user's NFTs to the vault but doesn't mint any pool share tokens in return for the user.\n\nSimilar griefing attacks are also possible with other functions besides `mint`.\n\nRecommend checking for a max fee as a percentage of `base` (like 10%) whenever setting fees.\n\n## [[M-07] Tokens can get stuck in `NFTXMintRequestEligibility`](https://github.com/code-423n4/2021-05-nftx-findings/issues/59)\n\nWhen dealing with ERC721 (instead of 1155) the amounts array is ignored, which leads to an issue.\n\nUser can call `NFTXMintRequestEligibility.requestMint` for an ERC721 with `amounts[i] = 0`.\nThe `ERC721.transferFrom` is still executed but user cannot `reclaimRequestedMint` later and the NFT is stuck as it checks (`amounts[i] > 0`).\n\n\nTokens can get stuck.\nAlso, subscribers to `Request` event could be tricked by specifying `amounts[i] > 1` in the ERC721 case, as only one token was transferred, but the amount multiple quantities get logged.\n\nRecommend that `requestMint`: Check `amounts[i] == 1` in ERC721 case, `amounts[i] > 0` in 1155 case.\n\n**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/59)**\n\n## [[M-08] A malicious receiver can cause another receiver to lose out on distributed fees by returning `false` for `tokensReceived` when `receiveRewards` is called on their receiver contract.](https://github.com/code-423n4/2021-05-nftx-findings/issues/69)\n\nA malicious receiver can cause another receiver to lose out on distributed fees by returning `false` for `tokensReceived` when `receiveRewards` is called on their receiver contract. This causes the fee distributor to double spend the `amountToSend` because the contract incorrectly assumes the returned data is truthful.\n\n`NFTXFeeDistributor.sol`:\n```solidity\nLine 163: (bool success, bytes memory returnData) = address(_receiver.receiver).call(payload);\n```\nRecommend that you don't trust return data from externally called contracts. Only utilize whether the transaction succeeds to determine if the treasury fallback should be called.\n```\nLine 165: if (!success) {\n```\n\n**[0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/69#issuecomment-845681145):**\n > Nice catch!\n\n## [[M-09] The direct redeem fee can be circumvented](https://github.com/code-423n4/2021-05-nftx-findings/issues/71)\n\nSince the random NFT is determined in the same transaction a payment or swap is being executed, a malicious actor can revert a transaction if they did not get the NFT they wanted. Combined with utilizing Flashbots miners which do not publish transactions which revert with `FlashbotsCheckAndSend`, there would be no cost to constantly attempting this every block or after the nonce is updated from `getPseudoRand()`.\n\n`NFTXVaultUpgradeable.sol`\n```solidity\nLine 374: uint256 tokenId = i < specificIds.length\n    ? specificIds[i]\n    : getRandomTokenIdFromFund();\n```\n\nIn this way, the `directReedemFee` can be avoided and users may lose out on potential earnings. The code below shows a transfer ownership of ERC20 tokens to attack the contract.\n```\nfunction revertIfNotSpecifiedID(uint256 targetTokenID) public {\n    NFTXVaultUpgradeable vault = NFTXVaultUpgradeable(_vault);\n    uint256[] resultID = vault.redeem(1,[]);\n    require(resultID[0] == targetTokenID);\n}\n```\n\nRecommend using a commit-reveal pattern for NFT swaps and redemptions.\n\n**[0xKiwi (NFTX) acknowledged](https://github.com/code-423n4/2021-05-nftx-findings/issues/71)**\n\n**[cemozer (Judge) commented](https://github.com/code-423n4/2021-05-nftx-findings/issues/71#issuecomment-848321831):**\n > Leaving this as medium risk as it puts user earnings into risk\n\n# Low Risk Findings (10)\n\n## [[L-01] Front-running `setFees()` could avoid fees](https://github.com/code-423n4/2021-05-nftx-findings/issues/72)\n\n`setVaultFeatures()` and `setFees()` are two separate privileged functions. Users could front-run `setFees()` immediately after vault is enabled in `setVaultFeatures()` to mint (and possibly redeem/directRedeem/swap) many tokens. The fees for mint/redeem/directRedeem/swap are not initialized so are 0 by default. This leads to loss of fee revenue.\n\nRecommend Setting defaults at initialization or combine this with `setVaultFeatures()` for atomically enabling functions and setting their fees in the same transaction.\n\n**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/72)**\n\n## [[L-02] Missing pool existence check in `balanceOf`](https://github.com/code-423n4/2021-05-nftx-findings/issues/80)\n\nIn `NFTXLPStaking.sol`, `deposit()`, `exit()`, `withdraw()`,` claimRewards()` and other related functions that take a `vaultID` as parameter perform a pool existence check on the staking pool associated with that `vaultID`. However, `balanceOf` is missing a similar pool check.\n\nThis may result in returning an invalid balance of a non-existing or stale pool.\n\nRecommend adding check ```require(pool.stakingToken != address(0), \"LPStaking: Nonexistent pool”);``` before L170.\n\n**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/80)**\n\n## [[L-03] Missing parameter validation](https://github.com/code-423n4/2021-05-nftx-findings/issues/44)\n\nMissing parameter validation for functions:\n- `NFTXEligiblityManager.addModule, updateModule`\n- `NFTXFeeDistributor` all `setter` functions (`setTreasuryAddress`, ...)\n- `NFTXVaultUpgradeable.setManager`\n\nSome wallets still default to zero addresses for a missing input which can lead to breaking critical functionality like setting the manager to the zero address and being locked out.\n\nRecommend validating the parameters.\n\n**- [0xKiwi (NFTX) confirmed ](https://github.com/code-423n4/2021-05-nftx-findings/issues/44)**\n\n## [[L-04] Missing usage of SafeMath](https://github.com/code-423n4/2021-05-nftx-findings/issues/45)\n\nThe following code does not use `SafeMath` and can potentially lead to overflows:\n- `NFTXFeeDistributor.distribute`\n- `NFTXFeeDistributor._sendForReceiver`\n\nWhile looping through all `_feeReceivers` it could be that a broken vault was whitelisted that allows an attacker to perform an external call and break the invariant that always 1000 tokens are left in the contract.\n\nAdd `SafeMath` to `_sendForReceiver` even though one would expect the math to be safe.\n\n**[0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/45#issuecomment-840872967):**\n > Confirmed and updated all code to 0.8.x.\n\n## [[L-05] Inconsistent solidity pragma](https://github.com/code-423n4/2021-05-nftx-findings/issues/3)\n\nThe source files have different solidity compiler ranges referenced.  This leads to potential security flaws between deployed contracts depending on the compiler version chosen for any particular file.  It also greatly increases the cost of maintenance as different compiler versions have different semantics and behavior.\n\nThis defect has numerous surfaces at https://github.com/code-423n4/2021-05-nftx/tree/main/nftx-protocol-v2/contracts/solidity\n\nRecommend fixing a definite compiler range that is consistent between contracts and upgrade any affected contracts to conform to the specified compiler.\n\n**[0xKiwi (NFTX) commented](https://github.com/code-423n4/2021-05-nftx-findings/issues/3#issuecomment-845494409):**\n > We have updated everything to 0.8.x.\n\n## [[L-06] Unchecked external calls in `NFTXLPStaking`](https://github.com/code-423n4/2021-05-nftx-findings/issues/48)\n\nThe `emergencyExit`/`emergencyExitAndClaim` functions take the staking and reward tokens as parameters and trust them for the withdrawal.\n\nThis does not lead to a critical issue (like being able to withdraw all funds) as one cannot deploy a fake reward smart contract to a `_rewardDistributionTokenAddr` and a random address without a smart contract will fail because of the `dist.balanceOf(msg.sender)` call not returning any data. However, checking if the distribution token exists is still recommended.\n\nRecommend requiring `isContract(dist)`.\n\n**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/48)**\n\n## [[L-07] Vault's flash loan not implemented according to EIP-3156](https://github.com/code-423n4/2021-05-nftx-findings/issues/54)\n\nThe `NFTXVaultUpgradeable.flashLoan` is not correctly implemented according to  EIP-3156 (but it tries to implement it as it inherits from `IERC3156FlashLenderUpgradeable`).\n\n> \"If successful, flashLoan MUST return true.\" - https://eips.ethereum.org/EIPS/eip-3156\n\nIt misses the return and currently always returns `false`.\n\nAlways returning `false` indicates that the flash loan was unsuccessful, when in reality it could have been successful.\nThis breaks any contract trying to integrate with it.\n\nRecommend adding the return statement: `return super.flashLoan(...)`\n\n**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/54)**\n\n**- [cemozer (Judge) commented](https://github.com/code-423n4/2021-05-nftx-findings/issues/54#issuecomment-848263863):**\n > Keeping this as low-risk as flash loan returning the project does not pose a security threat for the NFTX project itself\n\n## [[L-08] `eligibilityManager` is always 0x0](https://github.com/code-423n4/2021-05-nftx-findings/issues/25)\n\nthe contract `NFTXVaultFactoryUpgradeable`, variable `eligibilityManager` is never set thus it gets a default value of 0x0. So function `deployEligibilityStorage` should always fail as the eligibility manager does not exist on address 0x0.\n\nRecommend either adding a setter for `eligibilityManager` or refactor function `deployEligibilityStorage` to work in such case.\n\n**[0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/25#issuecomment-845558815):**\n > Nice find!\n\n## [[L-09] lack of zero address validation](https://github.com/code-423n4/2021-05-nftx-findings/issues/82)\n\nInit function like `__FeeDistributor__init__()` is used to initialize the state variables. Since these state variables are used in many functions, it is possible that due to lack of input validation, an error in these state variables can lead to redeployment of contract.\n\n* `In NFTXFeeDistributor.sol --> __FeeDistributor__init__()`\n* `in NFTXLPStaking.sol --> __NFTXLPStaking__init()`\n* `in NFTXVaultUpgradeable.sol -- > __NFTXVault_init()`\n* `in StakingTokenProvider.sol --> __StakingTokenProvider_init()`\n\nRecommend adding zero address validation.\n\n**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/82)**\n\n## [[L-10] `__Ownable_init` will be called twice in multiple Eligibility contracts](https://github.com/code-423n4/2021-05-nftx-findings/issues/84)\n\nHere you have more info: https://gist.github.com/alexon1234/43bf4a72a5b06651f04fc8052349ac5a\n\n**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/84)**\n\n# Non-Critical Findings\n\n## [[N-01] `LockIds` not according to spec](https://github.com/code-423n4/2021-05-nftx-findings/issues/52)\n\nThe `PausableUpgradeable.onlyOwnerIfPaused` doc comment specifies the pause states as:\n\n```solidity\n// 0 : createFund\n// 1 : mint\n// 2 : redeem\n// 3 : mintAndRedeem\n```\n\nBut ```lockId = 3``` does not prevent mints and redeems in `NFTXVaultUpgradeable`.\nInstead, it prevents swaps.\nThere is also an undocumented `lockId = 4` to prevent `flashLoans`.\n\nA manager might look at the spec and try to prevent mints and redeems in an emergency by setting the highest `lockId` `3`, which would prevent these according to spec. However, users can still mint and redeem as `lockId` prevents swaps only.\n\nRecommend updating the documentation to reflect the code.\n\n**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/52)**\n\n**[cemozer (Judge) commented](https://github.com/code-423n4/2021-05-nftx-findings/issues/52#issuecomment-848262690):**\n > Marking this as non-critical as the issue is only in the documentation.\n\n## [[N-01] simpler way to suppress compiler warning](https://github.com/code-423n4/2021-05-nftx-findings/issues/12)\n\nIn the function `flashFee` of `ERC20FlashMintUpgradeable.sol`, the variable amount is referenced to suppress a compiler warning. There is a simpler way to do this, by commenting out the variable name.\n```solidity\n   function flashFee(address token, uint256 amount) public view virtual override returns (uint256) {\n        require(token == address(this), \"ERC20FlashMint: wrong token\");\n        // silence warning about unused variable without the addition of bytecode.\n        amount;\n        return 0;\n```\n\nRecommend using the following code:\n```solidity\n   function flashFee(address token, uint256 /*amount*/) public view virtual override returns (uint256) {\n        require(token == address(this), \"ERC20FlashMint: wrong token\");\n        return 0;\n```\n\n**- [0xKiwi (NFTX) acknowldged](https://github.com/code-423n4/2021-05-nftx-findings/issues/12)**\n\n## [[N-02] Not checked if within array bounds](https://github.com/code-423n4/2021-05-nftx-findings/issues/13)\n\nIn the function `updateModule` and `deployEligibility` of `NFTXEligiblityManager.sol`, the array modules is used without checking if the index is within bounds. If index would be out of bounds, the function will revert, but it's more difficult to troubleshoot.\n\nNFTXEligiblityManager.sol:\n\n```solidity\nfunction updateModule(uint256 index, address implementation) public onlyOwner {\n    modules[index].impl = implementation;\n}\n\nfunction deployEligibility(uint256 moduleIndex, bytes calldata configData) external virtual returns (address) {\n    address eligImpl = modules[moduleIndex].impl;\n    ...\n}\n```\n\nRecommend adding something like:\n```require(index < modules.length,\"out or range\");```\n\n**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/13)**\n\n## [[N-03] Missing documentation for `flashloan` paused number](https://github.com/code-423n4/2021-05-nftx-findings/issues/14)\n\nThe contract `PausableUpgradeable.sol` documents the paused variables 0..3.\nHowever, `onlyOwnerIfPaused` is also used with a parameter of 4. This is used for `flashloans`.\n\nPausableUpgradeable.sol:\n```solidity\n    // 0 : createFund\n    // 1 : mint\n    // 2 : redeem\n    // 3 : mintAndRedeem\n.\\NFTXVaultFactoryUpgradeable.sol:        onlyOwnerIfPaused(0);\n.\\NFTXVaultUpgradeable.sol:        onlyOwnerIfPaused(1);\n.\\NFTXVaultUpgradeable.sol:        onlyOwnerIfPaused(2);\n.\\NFTXVaultUpgradeable.sol:        onlyOwnerIfPaused(3);\n.\\NFTXVaultUpgradeable.sol:        onlyOwnerIfPaused(4);\n```\n\nRecommend adding documentation for #4. Or even better, create constants or enums.\n\n## [[N-04] no check `_rangeStart<=_rangeEnd`](https://github.com/code-423n4/2021-05-nftx-findings/issues/17)\n\nIn `NFTXRangeEligibility.sol` a range is defined via `__NFTXEligibility_init` and `setEligibilityPreferences`.\nNo check is done to make sure ``` _rangeStart<=_rangeEnd```, so one could accidentally define it as a range that is effectively empty.\n```solidity\nfunction setEligibilityPreferences(uint256 _rangeStart, uint256 _rangeEnd) externalvirtual onlyOwner {\n        rangeStart = _rangeStart;\n        rangeEnd = _rangeEnd;\n        emit RangeSet(_rangeStart, _rangeEnd);\n    }\n```\nRecommend considering adding a check to make sure ```_rangeStart<=_rangeEnd```\n\n**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/17)**\n\n## [[N-05] Incorrect Type Specified For Argument `_address` In `NFTXFeeDistributor.rescueTokens()`](https://github.com/code-423n4/2021-05-nftx-findings/issues/89)\n\n`NFTXFeeDistributor.rescueTokens()` is not functional since it casts `_address` as a uint256 in the function declaration in [L141](https://github.com/code-423n4/2021-05-nftx/blob/f6d793c136d110774de259d9f3b25d003c4f8098/nftx-protocol-v2/contracts/solidity/NFTXFeeDistributor.sol#L141)\n\nRecommend changing this:\n\n`function rescueTokens(uint256 _address) external override onlyOwner {`\n\nTo this:\n\n`function rescueTokens(address _address) external override onlyOwner {`\n\n**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/89)**\n\n## [[N-06] Two Duplicate \"rescueTokens\" Functions In `NFTXFeeDistributor` ](https://github.com/code-423n4/2021-05-nftx-findings/issues/91)\n\nThere are two duplicate functions that both intended to rescue tokens that have incorrectly been sent to the `NFTXFeeDistributor`. The only difference is a typo in one of the functions which incorrectly casts `_address` as a uint256.\n\nRecommend deleting the `rescueTokens` function on L141 that incorrectly casts `_address` as a uint256.\n\n**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/91)**\n\n## [[N-07] [INFO] function `publicMint` is for testing only](https://github.com/code-423n4/2021-05-nftx-findings/issues/26)\n\nThe function `publicMint` has a comment that says it is meant for testing only:\n```solidity\n    // For testing\n    function publicMint(address to, uint256 tokenId, uint256 amount) public virtual {\n        _mint(to, tokenId, amount, \"\");\n    }\n```\nRecommend not to forget to comment or delete this code before going to production.\n\n**[0xKiwi (NFTX) acknowledged](https://github.com/code-423n4/2021-05-nftx-findings/issues/26#issuecomment-845559009):**\n > Test code\n\n## [[N-08] Using `calldata` when not appropriate](https://github.com/code-423n4/2021-05-nftx-findings/issues/100)\n\nHere's more info: https://gist.github.com/alexon1234/7b6799434cccda5e3f3d461b8186ec89\n\n\n**- [0xKiwi (NFTX) disputed](https://github.com/code-423n4/2021-05-nftx-findings/issues/100)**\n\n**[cemozer (Judge) commented](https://github.com/code-423n4/2021-05-nftx-findings/issues/100#issuecomment-848300810):**\n > @0xKiwi can you explain why you've disputed this issue?\n\n# Gas Optimizations\n\n## [[G-01] Unused storage variables](https://github.com/code-423n4/2021-05-nftx-findings/issues/62)\n\nUnused storage variables in contracts use up storage slots and increase contract size and gas usage at deployment and initialization. Multiple variables across different contracts including `manager` , `allVaults`, `vaultsForAsset`, and `prevContract`. Recommend removing unused variables.\n\n**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/62)**\n\n## [[G-02] Unused events](https://github.com/code-423n4/2021-05-nftx-findings/issues/63)\n\nUnused events increase contract size at deployment. Multiple events in `NFTXMintRequestEligibility.sol` listed on the issue page. Recommend removing unused events or emit at appropriate places.\n\n**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/63)**\n\n## [[G-03] Change function visibility from public to external](https://github.com/code-423n4/2021-05-nftx-findings/issues/64)\n\nVarious functions across contracts are never called from within contracts yet are declared public. Their visibility can be made external to save gas.\n\nAs described in https://mudit.blog/solidity-gas-optimization-tips/:\n> “For all the public functions, the input parameters are copied to memory automatically, and it costs gas. If your function is only called externally, then you should explicitly mark it as external. External function’s parameters are not copied into memory but are read from `calldata` directly. This small optimization in your solidity code can save you a lot of gas when the function input parameters are huge.”\n\nRecommend changing function visibility from public to external.\n\n**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/64)**\n\n## [[G-04] Gas optimization for `StakingTokenProvider.nameForStakingToken`](https://github.com/code-423n4/2021-05-nftx-findings/issues/49)\n\n`StakingTokenProvider.nameForStakingToken`: `if (keccak256(abi.encode(_pairedPrefix)) == keccak256(abi.encode(address(0)))) ` can be simplified to `if(bytes(_pairedPrefix).length== 0)`\n\n**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/49)**\n\n## [[G-05] Revert inside a loop](https://github.com/code-423n4/2021-05-nftx-findings/issues/97)\n\nHere you have more info: https://gist.github.com/alexon1234/a2275d1724ce2122d36bc555e46a25c1\n\n**- [0xKiwi (NFTX) acknowledged](https://github.com/code-423n4/2021-05-nftx-findings/issues/97)**\n\n## [[G-06] Unused variables](https://github.com/code-423n4/2021-05-nftx-findings/issues/39)\n\nThere are unused variables in contract `NFTXVaultUpgradeable` (string public description) and in contract `NFTXMintRequestEligibility` (address public manager). Recommend deleting unused variables to reduce the deployment costs.\n\n# Disclosures\n\nC4 is an open organization governed by participants in the community.\n\nC4 Contests incentivize the discovery of exploits, vulnerabilities, and bugs in smart contracts. Security researchers are rewarded at an increasing rate for finding higher-risk issues. Contest submissions are judged by a knowledgeable security researcher and solidity developer and disclosed to sponsoring developers. C4 does not conduct formal verification regarding the provided code but instead provides final verification.\n\nC4 does not provide any guarantee or warranty regarding the security of this project. All smart contract software should be used at the sole risk and responsibility of users.\n"
}