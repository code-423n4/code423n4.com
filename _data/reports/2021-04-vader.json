{
  "circa": {
    "title": "Vader Protocol",
    "sponsor": "Vader Protocol",
    "slug": "2021-04-vader",
    "date": "2021-06-14",
    "findings": "https://github.com/code-423n4/2021-04-vader-findings",
    "contest": 5
  },
  "html": "<h1 id=\"overview\" style=\"position:relative;\"><a href=\"#overview\" aria-label=\"overview permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Overview</h1>\n<h2 id=\"about-c4\" style=\"position:relative;\"><a href=\"#about-c4\" aria-label=\"about c4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>About C4</h2>\n<p>Code 432n4 (C4) is an open organization consisting of security researchers, auditors, developers, and individuals with domain expertise in smart contracts.</p>\n<p>A C4 code contest is an event in which community participants, referred to as Wardens, review, audit, or analyze smart contract logic in exchange for a bounty provided by sponsoring projects.</p>\n<p>During the code contest outlined in this document, C4 conducted an analysis of the Vader Protocol smart contract system written in Solidity. The code contest took place between April 21 and April 28, 2021.</p>\n<h2 id=\"wardens\" style=\"position:relative;\"><a href=\"#wardens\" aria-label=\"wardens permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Wardens</h2>\n<p>10 Wardens contributed reports to the Vader code contest:</p>\n<ul>\n<li><a href=\"https://twitter.com/cmichelio\">cmichel</a></li>\n<li><a href=\"https://twitter.com/0xRajeev\">rajeev</a></li>\n<li><a href=\"https://github.com/x9453\">shw</a></li>\n<li><a href=\"https://twitter.com/SolidityDev\">pauliax</a> (Thunder)</li>\n<li><a href=\"https://twitter.com/jvaqa\">jvaqa</a></li>\n<li><a href=\"https://twitter.com/_smonica_\">s1m0</a></li>\n<li><a href=\"https://twitter.com/a_delamo\">a_delamo</a></li>\n<li><a href=\"https://twitter.com/AshiqAmien\">toastedsteaksandwich</a></li>\n<li><a href=\"https://twitter.com/MukeshJ_eth\">mukesh jaiswal</a></li>\n<li><a href=\"https://twitter.com/gpersoon\">gpersoon</a></li>\n</ul>\n<p>This contest was judged by <a href=\"https://twitter.com/lsdan_defi\">LSDan</a>.</p>\n<p>Final report assembled by <a href=\"https://twitter.com/money_lego\">moneylegobatman</a>.</p>\n<h1 id=\"summary\" style=\"position:relative;\"><a href=\"#summary\" aria-label=\"summary permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Summary</h1>\n<p>The C4 analysis yielded an aggregated total of 121 unique vulnerabilities. All of the issues presented here are linked back to their original finding.</p>\n<p>Of these vulnerabilities, 24 received a risk rating in the category of HIGH severity, 16 received a risk rating in the category of MEDIUM severity, and 23 received a risk rating in the category of LOW severity.</p>\n<p>C4 analysis also identified 60 non-critical recommendations including gas optimizations.</p>\n<h1 id=\"scope\" style=\"position:relative;\"><a href=\"#scope\" aria-label=\"scope permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Scope</h1>\n<p>The code under review can be found within the <a href=\"https://github.com/code-423n4/2021-04-vader\">C4 vader code contest repository</a> and comprises 23  smart contracts written in the Solidity programming language.</p>\n<h1 id=\"severity-criteria\" style=\"position:relative;\"><a href=\"#severity-criteria\" aria-label=\"severity criteria permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Severity Criteria</h1>\n<p>C4 assesses the severity of disclosed vulnerabilities according to a methodology based on <a href=\"https://owasp.org/www-community/OWASP_Risk_Rating_Methodology\">OWASP standards</a>.</p>\n<p>Vulnerabilities are divided into three primary risk categories: high, medium, and low.</p>\n<p>High-level considerations for vulnerabilities span the following key areas when conducting assessments:</p>\n<ul>\n<li>Malicious Input Handling</li>\n<li>Escalation of privileges</li>\n<li>Arithmetic</li>\n<li>Gas use</li>\n</ul>\n<p>Further information regarding the severity criteria referenced throughout the submission review process, please refer to the documentation provided on <a href=\"https://code423n4.com\">the C4 website</a>.</p>\n<h1 id=\"high-risk-findings\" style=\"position:relative;\"><a href=\"#high-risk-findings\" aria-label=\"high risk findings permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>High Risk Findings</h1>\n<h2 id=\"h-01-unhandled-return-value-of-transfer-in-transferout-of-poolssol\" style=\"position:relative;\"><a href=\"#h-01-unhandled-return-value-of-transfer-in-transferout-of-poolssol\" aria-label=\"h 01 unhandled return value of transfer in transferout of poolssol permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/128\">[H-01] Unhandled return value of transfer in <code>transferOut()</code> of Pools.sol</a></h2>\n<p>ERC20 implementations are not always consistent. Some implementations of transfer and <code>transferFrom</code> could return ‘false’ on failure instead of reverting. It is safer to wrap such calls into <code>require()</code> statements to handle these failures.</p>\n<p>The transfer call <a href=\"https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Pools.sol#L211\">on L211</a> of <code>transferOut()</code> could be made on a user-supplied untrusted token address (from the different call sites) whose implementation can be malicious.</p>\n<p>For reference, see similar finding from Consensys Diligence Audit of AAVE Protocol V2</p>\n<p>Recommend requirements to check the return value and revert on 0/false or use OpenZeppelin’s SafeERC20 wrapper functions.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/128#issuecomment-830602601\">strictly-scarce (vader) disputed</a>:</strong></p>\n<blockquote>\n<p>Not valid. Since the funds came in, and did not revert, they can leave. If the call passes, then the transferout is valid.</p>\n</blockquote>\n<h2 id=\"h-02-flash-attack-mitigation-does-not-work-as-intended-in-usdvsol\" style=\"position:relative;\"><a href=\"#h-02-flash-attack-mitigation-does-not-work-as-intended-in-usdvsol\" aria-label=\"h 02 flash attack mitigation does not work as intended in usdvsol permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/138\">[H-02] Flash attack mitigation does not work as intended in USDV.sol</a></h2>\n<p>One of the stated protocol (review) goals is to detect susceptibility to “Any attack vectors using flash loans on Anchor price, synths or lending.” As such, USDV contract aims to protect against flash attacks using <code>flashProof()</code> modifier which uses the following check in <code>isMature()</code> to determine if currently executing contract context is at least <code>blockDelay</code> duration ahead of the previous context: <code>lastBlock[tx.origin] + blockDelay &#x3C;= block.number</code></p>\n<p>However, <code>blockDelay</code> state variable is not initialized which means it has a default uint value of 0. So unless it is set to >= 1 by <code>setParams()</code> which can be called only by the DAO (which currently does not have the capability to call <code>setParams()</code> function), <code>blockDelay</code> will be 0, which allows current executing context (<code>block.number</code>) to be the same as the previous one (<code>lastBlock[tx.origin]</code>). This effectively allows multiple calls on this contract to be executed in the same transaction of a block which enables flash attacks as opposed to what is expected as commented on <a href=\"https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L140-L142\">L41</a>: ”// Stops an EOA from doing a flash attack in the same block”</p>\n<p>Even if the DAO can call <code>setParams()</code> to change <code>blockDelay</code> to >= 1, there is a big window of opportunity for flash attacks until the DAO votes, finalizes and approves such a proposal. Moreover, such proposals can be cancelled by a DAO minority or replaced by a malicious DAO minority to launch flash attacks.</p>\n<p>Recommend initalizing <code>blockDelay</code> to >= 1 at declaration or in constructor.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/138#issuecomment-830606188\">strictly-scarce (vader) confirmed</a>:</strong></p>\n<blockquote>\n<p>The actual issue is simply:</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p><code>blockDelay</code> state variable is not initialized</p>\n</blockquote>\n<p>It is intended to be initialised to 1, so this is a bug. Severity: 2</p>\n</blockquote>\n<h2 id=\"h-03-missing-dao-functionality-to-call-changedao-function-in-vadersol\" style=\"position:relative;\"><a href=\"#h-03-missing-dao-functionality-to-call-changedao-function-in-vadersol\" aria-label=\"h 03 missing dao functionality to call changedao function in vadersol permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/161\">[H-03] Missing DAO functionality to call <code>changeDAO()</code> function in Vader.sol</a></h2>\n<p><code>changeDAO()</code> is authorized to be called only from the DAO (per modifier) but DAO contract has no corresponding functionality to call <code>changeDAO()</code> function. As a result, DAO address cannot be changed (<a href=\"https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L192-L196\">L192-L196</a>).</p>\n<p>Recommend adding functionality to DAO to be able to call <code>changeDAO()</code> of Vader.sol.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/161#issuecomment-830606766\">strictly-scarce (vader) commented</a></strong>:</p>\n<blockquote>\n<p><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/46\">#46</a></p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/161#issuecomment-847848752\">dmvt (judge) commented</a></strong>:</p>\n<blockquote>\n<p>Unlike in issues #140, #157, #158, &#x26; #159; without this functionality, missing functionality in the DAO becomes a very serious issue. As a result, this one is very high risk were it to be overlooked.</p>\n</blockquote>\n<h2 id=\"h-04-proposals-can-be-cancelled\" style=\"position:relative;\"><a href=\"#h-04-proposals-can-be-cancelled\" aria-label=\"h 04 proposals can be cancelled permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/227\">[H-04] Proposals can be cancelled</a></h2>\n<p>Anyone can cancel any proposals by calling <code>DAO.cancelProposal(id, id)</code> with <code>oldProposalID == newProposalID</code>.\nThis always passes the minority check as the proposal was approved.</p>\n<p>An attacker can launch a denial of service attack on the DAO governance and prevent any proposals from being executed.</p>\n<p>Recommend checking that <code>oldProposalID</code> == <code>newProposalID</code></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/227#issuecomment-828455719\">strictly-scarce (vader) confirmed</a>:</strong></p>\n<blockquote>\n<p>This is valid, can fix with a <code>require()</code></p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/227#issuecomment-830634810\">strictly-scarce (vader) commented</a>:</strong></p>\n<h2 id=\"h-05-flash-loans-can-affect-governance-voting-in-daosol\" style=\"position:relative;\"><a href=\"#h-05-flash-loans-can-affect-governance-voting-in-daosol\" aria-label=\"h 05 flash loans can affect governance voting in daosol permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/187\">[H-05] Flash loans can affect governance voting in DAO.sol</a></h2>\n<p>Flash loans can significantly increase a single voter’s weight and be used to impact the voting outcome. A voter can borrow a significant quantity of tokens to increase their voting weight in a transaction within which, they also deterministically  influence the voting outcome to their choice.</p>\n<p>This has already happened in the case of MakerDAO governance where <a href=\"https://forum.makerdao.com/t/urgent-flash-loans-and-securing-the-maker-protocol/4901\">a flash loan was used to affect voting outcome</a> and noted by the Maker team as: “a practical example for the community that flash loans can and may impact system governance”</p>\n<p>Given that flash loans are a noted concern, the impact of it to DAO governance which can control all critical protocol parameters should be mitigated as in other places.</p>\n<p>Recommend accounting for flash loans in <code>countMemberVotes()</code> by using weight from previous blocks or consider capping the weight of individual voters. (<a href=\"https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/DAO.sol#L158-L163\">L158-L163</a>)</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/187#issuecomment-830608957\">strictly-scarce (vader) disputed</a>:</strong></p>\n<blockquote>\n<p>Not valid.\nAll pools use slip-based fees so flash loan attack by buying up USDV or synths is not going to work.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/187#issuecomment-847890126\">dmvt (judge) commented</a>:</strong></p>\n<blockquote>\n<p>The funds to execute this attack do not need to come from a pool. It could be done as simply as malicious members pooling their funds in a flash loan contract, and each borrowing the funds in turn to vote.</p>\n</blockquote>\n<h2 id=\"h-06-incorrect-burn-address-in-vadersol\" style=\"position:relative;\"><a href=\"#h-06-incorrect-burn-address-in-vadersol\" aria-label=\"h 06 incorrect burn address in vadersol permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/202\">[H-06] Incorrect burn address in Vader.sol</a></h2>\n<p>The <code>internal _transfer()</code> function is called from external facing <code>transfer()</code>, <code>transferFrom()</code>, and <code>transferTo()</code> functions all of which have different sender addresses. It is <code>msg.sender</code> for <code>transfer()</code>, sender parameter for <code>transferFrom()</code> and <code>tx.origin</code> for <code>transferTo()</code>.</p>\n<p>These different senders are reflected in the sender parameter of <code>_transfer()</code> function. While this sender parameter is correctly used for transfer of tokens within <code>_transfer</code>, the call to <code>_burn()</code> on L129 incorrectly uses <code>msg.sender</code> as the burn address which is correct only in the case of the <code>transfer()</code> caller’s context. This is incorrect for <code>transferFrom()</code> and <code>transferTo()</code> caller contexts.</p>\n<p>This will incorrectly burn the fees from a different (intermediate contract) account for all users of the protocol interacting with the <code>transferTo()</code> and <code>transferFrom()</code> functions and lead to incorrect accounting of token balances or exceptional conditions. Protocol will break and lead to fund loss.</p>\n<p>Recommend changing L129 to: <code>_burn(sender, _fee);</code></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/202#issuecomment-830609535\">strictly-scarce (vader) confirmed</a>:</strong></p>\n<blockquote>\n<p>Valid, disagree with severity though. Funds-not-at-risk.\nRecommend: 2</p>\n</blockquote>\n<h2 id=\"h-07-wrong-calcasymmetricshare-calculation\" style=\"position:relative;\"><a href=\"#h-07-wrong-calcasymmetricshare-calculation\" aria-label=\"h 07 wrong calcasymmetricshare calculation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/214\">[H-07] Wrong <code>calcAsymmetricShare</code> calculation</a></h2>\n<p>The inline-comment defines the number of asymmetric shares as <code>(u * U * (2 * A^2 - 2 * U * u + U^2))/U^3</code> but the <code>Utils.calcAsymmetricShare</code> function computes <code>(uA * 2U^2 - 2uU + u^2) / U^3</code> which is not equivalent as can be seen from the <code>A^2</code> term in the first term which does not occur in the second one.</p>\n<p>The associativity on <code>P * part1</code> is wrong, and <code>part2</code> is not multiplied by <code>P</code>.</p>\n<p>The math from the spec is not correctly implemented and could lead to the protocol being economically exploited, as the asymmetric share (which is used to determine the collateral value in base tokens) could be wrong. For example, it might be possible to borrow more than the collateral put up.</p>\n<p>Recommend clarifying if the comment or the code is correct and fix them if not.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/214#issuecomment-828468071\">strictly-scarce (vader) confirmed</a>:</strong></p>\n<blockquote>\n<p>Valid</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/214#issuecomment-830635568\">strictly-scarce (vader) commented</a>:</strong></p>\n<blockquote>\n<p>Whilst the math is incorrect, in the current implementation it is not yet implemented, so disagree with Severity (funds not lost), recommend: 2</p>\n</blockquote>\n<h2 id=\"h-08-wrong-liquidity-units-calculation\" style=\"position:relative;\"><a href=\"#h-08-wrong-liquidity-units-calculation\" aria-label=\"h 08 wrong liquidity units calculation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/204\">[H-08] Wrong liquidity units calculation</a></h2>\n<p>The spec defines the number of LP units to be minted as <code>units = (P (a B + A b))/(2 A B) * slipAdjustment = P * (part1 + part2) / part3 * slipAdjustments</code> but the <code>Utils.calcLiquidityUnits</code> function computes <code>((P * part1) + part2) / part3 * slipAdjustments</code>.</p>\n<p>The associativity on <code>P * part1</code> is wrong, and <code>part2</code> is not multiplied by <code>P</code>.</p>\n<p>The math from the spec is not correctly implemented and could lead to the protocol being economically exploited, as redeeming the minted LP tokens does not result in the initial tokens anymore.</p>\n<p>Recommend fixing the equation.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/204#issuecomment-830609695\">strictly-scarce (vader) confirmed</a>:</strong></p>\n<blockquote>\n<p>Valid, but funds not at risk.</p>\n</blockquote>\n<h2 id=\"h-09-incorrect-initialization-gives-il-protection-of-only-1-second-instead-of-100-days-in-routersol\" style=\"position:relative;\"><a href=\"#h-09-incorrect-initialization-gives-il-protection-of-only-1-second-instead-of-100-days-in-routersol\" aria-label=\"h 09 incorrect initialization gives il protection of only 1 second instead of 100 days in routersol permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/84\">[H-09] Incorrect initialization gives IL protection of only 1 second instead of 100 days in Router.sol</a></h2>\n<p>Incorrect initialization of <code>timeForFullProtection</code> to 1 sec instead of 8640000 secs (100 days) as indicated in code comments, appears to be a test setting mistakenly carried over for deployment. Therefore, unless <code>timeForFullProtection</code> is reset to 100 days by <code>setParams()</code> (calling this function is a missing functionality in the DAO currently), the Impermanent Loss (IL) protection “rule” of 100 days will not apply in <code>Utils.getProtection()</code>.</p>\n<p>This breaks a key value proposition of the Vader protocol which is IL protection as indicated in the specification:</p>\n<blockquote>\n<p>“Impermanent Loss Protection: The deposit value for each member is recorded when they deposit. When they go to withdraw, the redemption value is computed. If it is less than the deposit value, the member is paid the deficit from the reserve. The protection issued increases from 0 to 100% linearly for 100 days.”</p>\n</blockquote>\n<p>Recommend changing to <code>“timeForFullProtection = 8640000; //100 days”</code> on L84</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/84#issuecomment-830597447\">strictly-scarce (vader) disputed</a>:</strong></p>\n<blockquote>\n<p>It’s deliberately set to 1 second to conduct adequate testing.</p>\n</blockquote>\n<h2 id=\"h-10-anyone-can-list-anchors--curate-tokens\" style=\"position:relative;\"><a href=\"#h-10-anyone-can-list-anchors--curate-tokens\" aria-label=\"h 10 anyone can list anchors  curate tokens permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/211\">[H-10] Anyone can list anchors / curate tokens</a></h2>\n<p>The <code>Router.listAnchor</code> function can be called by anyone and tokens can be added. The only check is that <code>require(iPOOLS(POOLS).isAnchor(token));</code> but this can easily be set by calling <code>Pools.addLiquidity(VADER, token, _)</code> once even without actually sending any tokens to the contract. This makes it an essentially useless check.</p>\n<p>This only works initially as long as the <code>anchorLimit</code> has not been reached yet.\nHowever, the <code>replaceAnchor</code> can be used in the same way and flash loans can be used to get around the liquidity restrictions and push another anchor token out of the price range as these checks use the current reserves.</p>\n<p>Anchored pools are automatically curated pools and determine if a pool receives rewards. An attacker can remove rewards of a curated pool this way and add rewards to their own pool with a custom token they control.</p>\n<p>After a pool has been anchored through flash loans, liquidity can be withdrawn which could make the anchor price easy to manipulate in the next block and launch other attacks.</p>\n<p>Recommend revisiting the <code>_isAnchor[token] = true;</code> statement in <code>addLiquidity</code>, it seems strange without any further checks.\nConsider making <code>listAnchor</code> / <code>replaceAnchor</code> DAO-only functions and make them flash-loan secure.\nOne should probably use time-weighted prices for these pools for the bounds check.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/211#issuecomment-828472672\">strictly-scarce (vader) disputed</a>:</strong></p>\n<blockquote>\n<p>The protocol is intended to be launched with 5 anchors so it can only be attacked by using <code>replaceAnchor()</code>, in which case slip-based fees apply for attacks and thwart the attack path.</p>\n</blockquote>\n<h2 id=\"h-11-swap-token-can-be-traded-as-fake-base-token\" style=\"position:relative;\"><a href=\"#h-11-swap-token-can-be-traded-as-fake-base-token\" aria-label=\"h 11 swap token can be traded as fake base token permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/205\">[H-11] Swap token can be traded as fake base token</a></h2>\n<p>The <code>Pools.swap</code> function does not check if <code>base</code> is one of the base tokens. One can transfer <code>token</code>s to the pool and set <code>base=token</code> and call <code>swap(token, token, member, toBase=false)</code></p>\n<p>The <code>_actualInput = getAddedAmount(base, token);</code> will return the <strong>token</strong> amount added but use the ratio compared to the <strong>base</strong> reserve <code>calcSwapOutput(_actualInput=tokenInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]); = tokenIn / baseAmount * tokenAmount</code> which yields a wrong swap result.</p>\n<p>It breaks the accounting for the pool as <code>token</code>s are transferred in, but the <code>base</code> balance is increased (and <code>token</code> balance decreased). LPs cannot correctly withdraw again, and others cannot correctly swap again.</p>\n<p>Another example scenario is that the token pool amount can be stolen.\nSend <code>tokenIn=baseAmount</code> of tokens to the pool and call <code>swap(base=token, token, member, toBase=false)</code>. Depending on the price of <code>token</code> relative to <code>base</code> this could be cheaper than trading with the base tokens.</p>\n<p>Recommend checking that <code>base</code> is either <code>USDV</code> or <code>VADER</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/205#issuecomment-830609893\">strictly-scarce (vader) confirmed</a>:</strong></p>\n<blockquote>\n<p>Valid, funds can be lost</p>\n</blockquote>\n<h2 id=\"h-12-getaddedamount-can-return-wrong-results\" style=\"position:relative;\"><a href=\"#h-12-getaddedamount-can-return-wrong-results\" aria-label=\"h 12 getaddedamount can return wrong results permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/206\">[H-12] <code>getAddedAmount</code> can return wrong results</a></h2>\n<p>The <code>getAddedAmount</code> function only works correctly when called with <code>(VADER/USDV, pool)</code> or <code>(pool, pool)</code>.\nHowever, when called with (<code>token, pool)</code> where <code>token</code> is neither <code>VADER/USDV/pool</code>, it returns the wrong results:</p>\n<ol>\n<li>It gets the <code>token</code> balance</li>\n<li>And subtracts it from the stored <code>mapToken_tokenAmount[_pool]</code> amount which can be that of a completely different token</li>\n</ol>\n<p>Anyone can break individual pairs by calling <code>sync(token1, token2)</code> where the <code>token1</code> balance is less than <code>mapToken_tokenAmount[token2]</code>. This will add the difference to <code>mapToken_tokenAmount[token2]</code> and break the accounting and result in a wrong swap logic.</p>\n<p>Furthermore, this can also be used to swap tokens without having to pay anthing with <code>swap(token1, token2, member, toBase=false)</code>.</p>\n<p>Recommend adding a require statement in the <code>else</code> branch that checks that <code>_token == _pool</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/206#issuecomment-830610039\">strictly-scarce (vader) confirmed</a>:</strong></p>\n<blockquote>\n<p>Valid, funds can be lost</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/206#issuecomment-830610281\">strictly-scarce (vader) commented</a>:</strong></p>\n<blockquote>\n<p>Would bundle this issue with:\n<a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/205\">https://github.com/code-423n4/2021-04-vader-findings/issues/205</a></p>\n</blockquote>\n<h2 id=\"h-13-4-synths-can-be-minted-with-fake-base-token\" style=\"position:relative;\"><a href=\"#h-13-4-synths-can-be-minted-with-fake-base-token\" aria-label=\"h 13 4 synths can be minted with fake base token permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/207\">[H-13] 4 Synths can be minted with fake base token</a></h2>\n<p>The <code>Pools.mintSynth</code> function does not check if <code>base</code> is one of the base tokens. One can transfer <code>token</code>s to the pool and set <code>base=token</code> and call <code>mintSynth(token, token, member)</code>.</p>\n<p>The <code>_actualInput = getAddedAmount(base, token);</code> will return the <strong>token</strong> amount added but use the ratio compared to the <strong>base</strong> reserve <code>calcSwapOutput(_actualInput=tokenInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]); = tokenIn / baseAmount * tokenAmount</code> which yields a wrong swap result.</p>\n<p>It breaks the accounting for the pool as <code>token</code>s are transferred in, but the <code>base</code> balance is increased.</p>\n<p>The amount that is minted could also be inflated (cheaper than sending the actual base tokens), especially if <code>token</code> is a high-precision token or worth less than base.</p>\n<p>Recommend checking that <code>base</code> is either <code>USDV</code> or <code>VADER</code> in <code>mintSynth</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/207#issuecomment-830610147\">strictly-scarce (vader) confirmed</a>:</strong></p>\n<blockquote>\n<p>Valid, funds can be lost.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/207#issuecomment-830610260\">strictly-scarce (vader) commented</a>:</strong></p>\n<blockquote>\n<p>would bundle this issue with:\n<a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/205\">https://github.com/code-423n4/2021-04-vader-findings/issues/205</a></p>\n</blockquote>\n<h2 id=\"h-14-missing-access-restriction-on-lockunitsunlockunits\" style=\"position:relative;\"><a href=\"#h-14-missing-access-restriction-on-lockunitsunlockunits\" aria-label=\"h 14 missing access restriction on lockunitsunlockunits permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/208\">[H-14] Missing access restriction on <code>lockUnits/unlockUnits</code></a></h2>\n<p>The <code>Pool.lockUnits</code> allows anyone to steal pool tokens from a <code>member</code> and assign them to <code>msg.sender</code>. Anyone can steal pool tokens from any other user.</p>\n<p>Recommend adding access control and require that <code>msg.sender</code> is the router or another authorized party.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/208#issuecomment-828478127\">strictly-scarce (vader) confirmed</a>:</strong></p>\n<blockquote>\n<p>Valid, although this is part of the partially-complete lending code.</p>\n</blockquote>\n<h2 id=\"h-15-wrong-slippage-protection-on-token---token-trades\" style=\"position:relative;\"><a href=\"#h-15-wrong-slippage-protection-on-token---token-trades\" aria-label=\"h 15 wrong slippage protection on token   token trades permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/209\">[H-15] Wrong slippage protection on Token -> Token trades</a></h2>\n<p>The <code>Router.swapWithSynthsWithLimit</code> allows trading token to token and specifying slippage protection. A token to token trade consists of two trades:</p>\n<ol>\n<li>token to base</li>\n<li>base to token</li>\n</ol>\n<p>The slippage protection of the second trade (base to token) is computed wrong:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"0\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk11\">iUTILS</span><span class=\"mtk1\">(</span><span class=\"mtk11\">UTILS</span><span class=\"mtk1\">()).</span><span class=\"mtk11\">calcSwapSlip</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">inputAmount</span><span class=\"mtk1\">, </span><span class=\"mtk3\">// should use outToken here from prev trade</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">iPOOLS</span><span class=\"mtk1\">(</span><span class=\"mtk12\">POOLS</span><span class=\"mtk1\">).</span><span class=\"mtk11\">getBaseAmount</span><span class=\"mtk1\">(</span><span class=\"mtk12\">outputToken</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  ) &lt;= </span><span class=\"mtk12\">slipLimit</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">);</span></span></span></code></pre>\n<p>It compares the <strong>token</strong> input amount (of the first trade) to the <strong>base</strong> reserve of the second pair.</p>\n<p>Slippage protection fails and either the trade is cancelled when it shouldn’t be or it is accepted even though the user suffered more losses than expected.</p>\n<p>Recommend it should use the base output from the first trade to check for slippage protection. Note that this still just computes the slippage protection of each trade individually. An even better way would be to come up with a formula to compute the slippage on the two trades at once.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/209#issuecomment-828476313\">strictly-scarce (vader) confirmed</a>:</strong></p>\n<blockquote>\n<p>Valid, although disagree with severity, the wrongly compute slip amount would just fail the trade or allow the second trade to go thru with no protection.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/209#issuecomment-830580592\">Mervyn853 commented</a>:</strong></p>\n<blockquote>\n<p>Our decision matrix for severity:</p>\n<p>0: No-risk: Code style, clarity, off-chain monitoring (events etc), exclude gas-optimisations\n1: Low Risk: UX, state handling, function incorrect as to spec\n2: Funds-Not-At-Risk, but can impact the functioning of the protocol, or leak value with a hypothetical attack path with stated assumptions, but external requirements\n3: Funds can be stolen/lost directly, or indirectly if a valid attack path shown that does not have handwavey hypotheticals.</p>\n<p>Recommended: 1</p>\n</blockquote>\n<h2 id=\"h-16-tokens-can-be-stolen-through-transferto\" style=\"position:relative;\"><a href=\"#h-16-tokens-can-be-stolen-through-transferto\" aria-label=\"h 16 tokens can be stolen through transferto permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/217\">[H-16] Tokens can be stolen through <code>transferTo</code></a></h2>\n<p>I know that it’s stated that:</p>\n<blockquote>\n<p>VADER, USDV, SYNTHS all employ the <code>transferTo()</code> function, which interrogates for <code>tx.origin</code> and skips approvals. The author does not subscribe to the belief that this is dangerous</p>\n</blockquote>\n<p>In my opinion, it can be very dangerous. Imagine the following scenario:</p>\n<ol>\n<li>I create a custom attacker ERC20 token that has a hook in the <code>_transfer</code> function that checks tx.origin for USDV/VADER/SYNTHS and calls <code>transferTo</code> to steal these funds.</li>\n<li>I set up a honeypot by providing liquidity to the <code>BASE &#x3C;> ATTACKER</code> pool.</li>\n<li>I target high-profile accounts holdinging VADER/USDV/SYNTHS and airdrop them free tokens.</li>\n<li>Block explorers / Vader swap websites could show that this token has value and can be traded for actual <code>BASE</code> tokens.</li>\n<li>User wants to sell the airdropped <code>ATTACKER</code> token to receive valuable tokens through the Vader swap and has all their tokens (that are even completely unrelated to the tokens being swapped) stolen.</li>\n</ol>\n<p>In general, a holder of any of the core assets of the protocol risks all their funds being stolen if they ever interact with an unvetted external contract/token.\nThis could even be completely unrelated to the VADER protocol.</p>\n<p>Recommend removing <code>transferTo</code> and use <code>permit</code> + <code>transferFrom</code> instead to move tokens from <code>tx.origin</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/217#issuecomment-828445128\">strictly-scarce (vader) acknowledged</a>:</strong></p>\n<blockquote>\n<p>This attack path has already been assessed as the most likely, no new information is being presented here.</p>\n</blockquote>\n<blockquote>\n<p>Do not interact with attack contracts, interacting with an ERC20 is an attack contract.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/217#issuecomment-829142947\">0xBrian commented</a>:</strong></p>\n<blockquote>\n<p>@strictly-scarce (vader) What would be the downside of adopting the suggested mitigation? Since we cannot communicate effectively with all users to tell them not to interact with certain kinds of contracts (and even if we could, they may not be able to discern which are OK and which aren’t), we don’t want to set up a thicket for fraudsters to operate. If the downside of the mitigation is not too bad, I think it could be worth it in order to deny fraudsters an opportunity to steal.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/217#issuecomment-830582387\">Mervyn853 commented</a>:</strong></p>\n<blockquote>\n<p>Our decision matrix for severity:</p>\n<p>0: No-risk: Code style, clarity, off-chain monitoring (events etc), exclude gas-optimisations\n1: Low Risk: UX, state handling, function incorrect as to spec\n2: Funds-Not-At-Risk, but can impact the functioning of the protocol, or leak value with a hypothetical attack path with stated assumptions, but external requirements\n3: Funds can be stolen/lost directly, or indirectly if a valid attack path shown that does not have handwavey hypotheticals.</p>\n<p>Recommended: 0</p>\n</blockquote>\n<h2 id=\"h-17-transfer-fee-is-burned-on-wrong-accounts\" style=\"position:relative;\"><a href=\"#h-17-transfer-fee-is-burned-on-wrong-accounts\" aria-label=\"h 17 transfer fee is burned on wrong accounts permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/220\">[H-17] Transfer fee is burned on wrong accounts</a></h2>\n<p>The <code>Vader._transfer</code> function burns the transfer fee on <code>msg.sender</code> but this address might not be involved in the transfer at all due to <code>transferFrom</code>.</p>\n<p>Smart contracts that simply relay transfers like aggregators have their Vader balance burned or the transaction fails because these accounts don’t have any balance to burn, breaking the functionality.</p>\n<p>Recommend that It should first increase the balance of <code>recipient</code> by the full amount and then burn the fee on the <code>recipient</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/220#issuecomment-828463080\">strictly-scarce (vader) confirmed</a>:</strong></p>\n<blockquote>\n<p>For composabilty with the rest of the ecosystem, this should be addressed, although disagree with the severity, no funds are lost, just the aggregrator cannot transfer unless they first transfer to themselves, which most often do.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/220#issuecomment-830582199\">Mervyn853 commented</a>:</strong></p>\n<blockquote>\n<p>Our decision matrix for severity:</p>\n<p>0: No-risk: Code style, clarity, off-chain monitoring (events etc), exclude gas-optimisations\n1: Low Risk: UX, state handling, function incorrect as to spec\n2: Funds-Not-At-Risk, but can impact the functioning of the protocol, or leak value with a hypothetical attack path with stated assumptions, but external requirements\n3: Funds can be stolen/lost directly, or indirectly if a valid attack path shown that does not have handwavey hypotheticals.</p>\n<p>Recommended: 2</p>\n</blockquote>\n<h2 id=\"h-18--vault-rewards-can-be-gamed\" style=\"position:relative;\"><a href=\"#h-18--vault-rewards-can-be-gamed\" aria-label=\"h 18  vault rewards can be gamed permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/222\">[H-18]  Vault rewards can be gamed</a></h2>\n<p>The <code>_deposit</code> function increases the member’s <em>weight</em> by <code>_weight = iUTILS(UTILS()).calcValueInBase(iSYNTH(_synth).TOKEN(), _amount);</code> which is the swap output amount when trading the deposited underlying synth amount.</p>\n<p>Notice that anyone can create synths of custom tokens by calling <code>Pools.deploySynth(customToken)</code>.</p>\n<p>Therefore an attacker can deposit valueless custom tokens and inflate their member weight as follows:</p>\n<ol>\n<li>Create a custom token and issue lots of tokens to the attacker</li>\n<li>Create synth of this token</li>\n<li>Add liquidity for the <code>TOKEN &#x3C;> BASE</code> pair by providing a single wei of <code>TOKEN</code> and <code>10^18</code> BASE tokens. This makes the <code>TOKEN</code> price very expensive.</li>\n<li>Mint some synths by paying BASE to the pool</li>\n<li>Deposit the fake synth, <code>_weight</code> will be very high because the token pool price is so high.</li>\n</ol>\n<p>Call <code>harvest(realSynth)</code> with a synth with actual value. This will increase the synth balance and it can be withdrawn later.</p>\n<p>Anyone can inflate their member weight through depositing a custom synth and earn almost all vault rewards by calling <code>harvest(realSynth)</code> with a valuable “real” synth.\nThe rewards are distributed pro rata to the member weight which is independent of the actual synth deposited.</p>\n<p>The <code>calcReward</code> function completely disregards the <code>synth</code> parameter which seems odd.\nRecommend thinking about making the rewards based on the actual synths deposited instead of a “global” weight tracker.\nAlternatively, whitelist certain synths that count toward the weight, or don’t let anyone create synths.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/222#issuecomment-828453323\">strictly-scarce (vader) confirmed</a>:</strong></p>\n<blockquote>\n<p>This is a valid attack path.</p>\n<p>The counter is two fold:</p>\n<ol>\n<li>In the vault, <code>require(isCurated(token))</code> this will only allow synths of curated tokens to be deposited for rewards. <a href=\"https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L234\">The curation logic </a> does a check for liquidity depth, so only deep pools can become synths. Thus an attacker would need to deposit a lot of BASE.</li>\n<li>In the vaults, use <code>_weight = iUTILS(UTILS()).calcSwapValueInBase(iSYNTH(_synth).TOKEN(), _amount);</code>, which computes the weight with respect to slip, so a small manipulated pool cannot be eligible. The pool would need to be deep.</li>\n</ol>\n<hr>\n<p>The Vault converts all synths back to common accounting asset - USDV, so member weight can be tracked.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/222#issuecomment-830635200\">strictly-scarce (vader) commented</a>:</strong>\nDisagree with severity, since the daily rewards can be claimed by anyone in a fee-bidding war but no actual extra inflation occurs.</p>\n<p>Severity: 2</p>\n</blockquote>\n<h2 id=\"h-19-vault-rewards-last-claim-time-not-always-initialized\" style=\"position:relative;\"><a href=\"#h-19-vault-rewards-last-claim-time-not-always-initialized\" aria-label=\"h 19 vault rewards last claim time not always initialized permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/223\">[H-19] Vault rewards last claim time not always initialized</a></h2>\n<p>The <code>harvest</code> calls <code>calcCurrentReward</code> which computes <code>_secondsSinceClaim = block.timestamp - mapMemberSynth_lastTime[member][synth];</code>.  As one can claim different synths than the synths that they deposited, <code>mapMemberSynth_lastTime[member][synth]</code> might still be uninitialized and the <code>_secondsSinceClaim</code> becomes the current block timestamp.</p>\n<p>The larger the <code>_secondsSinceClaim</code> the larger the rewards.\nThis bug allows claiming a huge chunk of the rewards.</p>\n<p>Recommend letting users only harvest synths that they deposited.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/223#issuecomment-828461277\">strictly-scarce (vader) confirmed</a>:</strong></p>\n<blockquote>\n<p>This is valid.</p>\n<p>The member should only claim against synths they have deposited, where the time would be initialised.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/223#issuecomment-830635006\">strictly-scarce (vader) commented</a>:</strong></p>\n<blockquote>\n<p>Would place this as severity: 2, since the anyone can participate in claiming rewards, but no extra inflation occurs.</p>\n</blockquote>\n<h2 id=\"h-20-vault-weight-accounting-is-wrong-for-withdrawals\" style=\"position:relative;\"><a href=\"#h-20-vault-weight-accounting-is-wrong-for-withdrawals\" aria-label=\"h 20 vault weight accounting is wrong for withdrawals permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/224\">[H-20] Vault Weight accounting is wrong for withdrawals</a></h2>\n<p>When depositing two different synths, their weight is added to the same <code>mapMember_weight[_member]</code> storage variable.\nWhen withdrawing the full amount of one synth with <code>_processWithdraw(synth, member, basisPoints=10000</code> the full weight is decreased.</p>\n<p>The second deposited synth is now essentially weightless.</p>\n<p>Users that deposited more than one synth can not claim their fair share of rewards after a withdrawal.</p>\n<p>Recommed that the weight should be indexed by the synth as well.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/224#issuecomment-828457510\">strictly-scarce (vader) confirmed</a>:</strong></p>\n<blockquote>\n<p>This is valid.</p>\n<p>The weight should be reduced only as applied to a specific synth</p>\n<p>There is no loss of funds, just less rewards for that member, disputing severity level.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/224#issuecomment-830578796\">Mervyn853 commented</a>:</strong></p>\n<blockquote>\n<p>Our decision matrix for severity:</p>\n<p>0: No-risk: Code style, clarity, off-chain monitoring (events etc), exclude gas-optimisations\n1: Low Risk: UX, state handling, function incorrect as to spec\n2: Funds-Not-At-Risk, but can impact the functioning of the protocol, or leak value with a hypothetical attack path with stated assumptions, but external requirements\n3: Funds can be stolen/lost directly, or indirectly if a valid attack path shown that does not have handwavey hypotheticals.</p>\n<p>Recommended: 2</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/224#issuecomment-849037439\">dmvt (judge) commented</a>:</strong></p>\n<blockquote>\n<p>My viewpoint on this and the last several reward based high risk issues is that loss of rewards is loss of funds. High risk is appropriate.</p>\n</blockquote>\n<h2 id=\"h-21-anyone-can-avoid-all-vether-transfer-fees-by-adding-their-address-to-the-vether-excludedaddresses-list\" style=\"position:relative;\"><a href=\"#h-21-anyone-can-avoid-all-vether-transfer-fees-by-adding-their-address-to-the-vether-excludedaddresses-list\" aria-label=\"h 21 anyone can avoid all vether transfer fees by adding their address to the vether excludedaddresses list permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/189\">[H-21] Anyone Can Avoid All Vether Transfer Fees By Adding Their Address to the Vether <code>ExcludedAddresses</code> List.</a></h2>\n<p><code>Vether.sol</code> implements a fee on every token transfer, unless either the sender or the recipient exists on a list of excluded addresses <code>(mapAddress_Excluded)</code>. However, the <code>addExcluded()</code> function in <code>Vether.sol</code> has no restrictions on who can call it.\nSo any user can call <code>addExcluded</code> with their own address as the argument, and bypass all transfer fees.</p>\n<p>Alice calls:</p>\n<p>(1) <code>Vether.addExcluded(aliceAddress)</code>, which adds Alice’s address to <code>mapAddress_Excluded</code>.\n(2) Alice can now freely transfer Vether with no fees.</p>\n<p>Recommend adding restrictions to who can call <code>addExcluded</code>, perhaps by restricting it to a caller set by <code>DAO.sol</code></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/189#issuecomment-830609051\">strictly-scarce (vader) commented</a>:</strong></p>\n<blockquote>\n<p>Vether contract is outside of contest</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/189#issuecomment-849162113\">dmvt (judge) commented</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/3#issuecomment-849043144\">https://github.com/code-423n4/2021-04-vader-findings/issues/3#issuecomment-849043144</a></p>\n<blockquote>\n<p>The warden should be paid out on this issue, in my opinion, because the code was included in the repo to be reviewed. The work to review the contract was done despite the fact that the team has addressed the issue and has already deployed <code>vether.sol</code>. I do not think that any issues related to <code>Vether.sol</code> should be included in the final report generated by @code423n4.</p>\n</blockquote>\n<p>It was unclear to me (and obviously most of the wardens) that <code>Vether.sol</code> was considered out of scope.</p>\n</blockquote>\n<p><strong>moneylegobatman (C4 Editor) commented:</strong></p>\n<blockquote>\n<p>Leaving report and discussion in for transparency, since finding was awarded.</p>\n</blockquote>\n<h2 id=\"h-22-users-may-unintentionally-remove-liquidity-under-a-phishing-attack\" style=\"position:relative;\"><a href=\"#h-22-users-may-unintentionally-remove-liquidity-under-a-phishing-attack\" aria-label=\"h 22 users may unintentionally remove liquidity under a phishing attack permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/316\">[H-22] Users may unintentionally remove liquidity under a phishing attack.</a></h2>\n<p>The <code>removeLiquidity</code> function in <code>Pools.sol</code> uses <code>tx.origin</code> to determine the person who wants to remove liquidity. However, such a design is dangerous since the pool assumes that this function is called from the router, which may not be true if the user is under a phishing attack, and he could unintentionally remove liquidity.</p>\n<p>Referenced code: <a href=\"https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Pools.sol#L77-L79\">Pool.sol#L77-L79</a></p>\n<p>Recommend consider making the function <code>_removeLiquidity</code> external, which can be utilized by the router, providing information of which person removes his liquidity.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/316#issuecomment-830571343\">strictly-scarce (vader) acknowledged</a>:</strong></p>\n<blockquote>\n<p>If a user has been phished, consider all their funds already stolen.</p>\n</blockquote>\n<blockquote>\n<p>Vader’s security assumption is a user is not phished.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/316#issuecomment-830578243\">Mervyn853 commented</a>:</strong></p>\n<blockquote>\n<p>Our decision matrix for severity:</p>\n<p>0: No-risk: Code style, clarity, off-chain monitoring (events etc), exclude gas-optimisations\n1: Low Risk: UX, state handling, function incorrect as to spec\n2: Funds-Not-At-Risk, but can impact the functioning of the protocol, or leak value with a hypothetical attack path with stated assumptions, but external requirements\n3: Funds can be stolen/lost directly, or indirectly if a valid attack path shown that does not have handwavey hypotheticals.</p>\n<p>Recommended: 0</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/316#issuecomment-849061196\">dmvt (judge) commented</a>:</strong></p>\n<blockquote>\n<p>This is reasonably easy to mitigate as an issue and failure to do so does leave an attack vector open. If exploited it will result in a loss of user funds.</p>\n</blockquote>\n<h2 id=\"h-23-anyone-can-curate-pools-and-steal-rewards\" style=\"position:relative;\"><a href=\"#h-23-anyone-can-curate-pools-and-steal-rewards\" aria-label=\"h 23 anyone can curate pools and steal rewards permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/210\">[H-23] Anyone can curate pools and steal rewards</a></h2>\n<p>The <code>Router.curatePool</code> and <code>replacePool</code> don’t have any access restriction.\nAn attacker can get a flash loan of base tokens and replace existing curated pools with their own curated pools.</p>\n<p>Curated pools determine if a pool receives rewards. An attacker can remove rewards of a curated pool this way and add rewards to their own pool with a custom token they control.\nThey can then go ahead and game the reward system by repeatedly swapping in their custom pool with useless tokens, withdraw liquidity, and in the end, pay back the base flashloan.</p>\n<p>Recommend preventing the replacing of curations through flash loans. Also, consider making pool curations DAO-exclusive actions.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/210#issuecomment-828473380\">strictly-scarce (vader) disputed</a>:</strong></p>\n<blockquote>\n<p>Slip-based pools cannot be attacked with flash loans.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/210#issuecomment-849131582\">dmvt (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Further comment from @cmichelio:</p>\n<p>I can curate my custom token using <code>curatePool</code> without using a flashloan or using replacePool by temporarily providing liquidity to the pool without trading in it and getting slip-fee’d. I’m not trading in the pool, and don’t think providing/removing liquidity comes with a fee. I think this is still an issue.</p>\n</blockquote>\n<h2 id=\"h-25-incorrect-initialization-causes-vader-emission-rate-of-1-second-instead-of-1-day-in-vadersol\" style=\"position:relative;\"><a href=\"#h-25-incorrect-initialization-causes-vader-emission-rate-of-1-second-instead-of-1-day-in-vadersol\" aria-label=\"h 25 incorrect initialization causes vader emission rate of 1 second instead of 1 day in vadersol permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/155\">[H-25] Incorrect initialization causes VADER emission rate of 1 second instead of 1 day in Vader.sol</a></h2>\n<p>Incorrect initialization (perhaps testing parameterization mistakenly carried over to deployment) of <code>secondsPerEra</code> to 1 sec instead of 86400 secs (1 day) causes what should be the daily emission rate to be a secondly emission rate.</p>\n<p>This causes inflation of VADER token and likely breaks VADER&#x3C;>USDV peg and other protocol invariants. Protocol will break and funds will be lost.</p>\n<p>Recommend Initializing <code>secondsPerEra</code> to 86400 on L67.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/155#issuecomment-830606416\">strictly-scarce (vader) acknowledged</a>:</strong></p>\n<blockquote>\n<p>This is purely for testing purposes.</p>\n</blockquote>\n<h1 id=\"medium-risk-findings\" style=\"position:relative;\"><a href=\"#medium-risk-findings\" aria-label=\"medium risk findings permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Medium Risk Findings</h1>\n<h2 id=\"m-01-user-may-not-get-il-protection-if-certain-functions-are-called-directly-in-poolssol\" style=\"position:relative;\"><a href=\"#m-01-user-may-not-get-il-protection-if-certain-functions-are-called-directly-in-poolssol\" aria-label=\"m 01 user may not get il protection if certain functions are called directly in poolssol permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/120\">[M-01] User may not get IL protection if certain functions are called directly in <code>Pools.sol</code></a></h2>\n<p>Functions <code>removeLiquidity()</code> and <code>removeLiquidityDirectly()</code> when called directly, do not provide the the user with IL protection unlike when calling the corresponding <code>removeLiquidity()</code> function in <code>Router.sol</code>. This should be prevented, at least for <code>removeLiquidity()</code> or highlighted in the specification and user documentation.</p>\n<p>Recommend adding access control (e.g. via a modifier <code>onlyRouter</code>) so <code>removeLiquidity()</code> function of Pools contract can be called only from corresponding Router contract’s <code>removeLiquidity()</code> function which provides IL protection. Alternatively, highlight in the specification and user documentation about which contract interfaces provide IL protection to users.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/120#issuecomment-830613596\">strictly-scarce (vader) acknowledged</a>:</strong></p>\n<blockquote>\n<p>User should use the Router, as designed.</p>\n</blockquote>\n<h2 id=\"m-02-undefined-behavior-for-dao-and-grant-vote-proposals-in-daosol\" style=\"position:relative;\"><a href=\"#m-02-undefined-behavior-for-dao-and-grant-vote-proposals-in-daosol\" aria-label=\"m 02 undefined behavior for dao and grant vote proposals in daosol permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/183\">[M-02] Undefined behavior for DAO and GRANT vote proposals in <code>DAO.sol</code></a></h2>\n<p>Given that there are only three proposal types (GRANT, UTILS, REWARD) that are actionable, it is unclear if ‘DAO’ type checked in <code>voteProposal()</code> is a typographical error and should really be ‘GRANT’. Otherwise, GRANT proposals will only require quorum (33%) and not majority (50%).</p>\n<p>Recommend changing ‘DAO’ on L83 to ‘GRANT’ or if not, specify what DAO proposals are and how GRANT proposals should be handled with quorum or majority.</p>\n<p>Also, check and enforce that <code>mapPID_types</code> are only these three actionable proposal types: GRANT, UTILS, REWARD.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/183#issuecomment-830615194\">strictly-scarce (vader) acknowledged</a>:</strong></p>\n<blockquote>\n<p>DAO not yet fully implemented</p>\n</blockquote>\n<h2 id=\"m-03-lack-of-input-validation-in-replacepool-allows-curated-pool-limit-bypass-in-routersol\" style=\"position:relative;\"><a href=\"#m-03-lack-of-input-validation-in-replacepool-allows-curated-pool-limit-bypass-in-routersol\" aria-label=\"m 03 lack of input validation in replacepool allows curated pool limit bypass in routersol permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/87\">[M-03] Lack of input validation in <code>replacePool()</code> allows curated pool limit bypass in <code>Router.sol</code></a></h2>\n<p>There is no input validation in <code>replacePool()</code> function to check if <code>oldToken</code> exists and is curated. Using a non-existing <code>oldToken</code> (even 0 address) passes the check on L236 (because <code>Pools.getBaseAmount()</code> will return 0 for the non-existing token) and <code>newToken</code> will be made curated. This can be used to bypass the <code>curatedPoolLimit</code> enforced only in <code>curatePool() function</code>.</p>\n<p>Recommend checking if <code>oldToken</code> exists and is curated as part of input validation in <code>replacePool()</code> function.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/87#issuecomment-830613505\">strictly-scarce (vader) confirmed</a>:</strong></p>\n<blockquote>\n<p>Valid</p>\n</blockquote>\n<h2 id=\"m-04-flashproof-is-not-flash-proof\" style=\"position:relative;\"><a href=\"#m-04-flashproof-is-not-flash-proof\" aria-label=\"m 04 flashproof is not flash proof permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/218\">[M-04] <code>flashProof</code> is not flash-proof</a></h2>\n<p>The <code>flashProof</code> modifier is supposed to prevent flash-loan attacks by disallowing performing several sensitive functions in the same block.</p>\n<p>However, it performs this check on <code>tx.origin</code> and not on an individual user address basis. This only prevents flash loan attacks from happening within a single transaction.</p>\n<p>But flash loan attacks are theoretically not limited to the same transaction but to the same block as miners have full control of the block and include several vulnerable transactions back to back. (Think transaction <em>bundles</em> similar to flashbot bundles that most mining pools currently offer.)</p>\n<p>A miner can deploy a proxy smart contract relaying all contract calls and call it from a different EOA each time bypassing the <code>tx.origin</code> restriction.</p>\n<p>The <code>flashProof</code> modifier does not serve its purpose.</p>\n<p>Recommend trying to apply the modifier to individual addresses that interact with the protocol instead of <code>tx.origin</code>.</p>\n<p>Furthermore, attacks possible with flash loans are usually also possible for whales, making it debatable if adding flash-loan prevention logic is a good practice.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/218#issuecomment-830616044\">strictly-scarce (vader) confirmed</a>:</strong></p>\n<blockquote>\n<p>Flash loans with the help of miners <em>was not intended to be countered</em>, although a check for <code>msg.sender</code> AND <code>tx.origin</code> will be applied.</p>\n</blockquote>\n<h2 id=\"m-05-interest-debt-is-capped-after-a-year\" style=\"position:relative;\"><a href=\"#m-05-interest-debt-is-capped-after-a-year\" aria-label=\"m 05 interest debt is capped after a year permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/219\">[M-05] Interest debt is capped after a year</a></h2>\n<p>The <code>Utils.getInterestOwed</code> function computes the <code>_interestPayment</code> as:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"1\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_interestPayment</span><span class=\"mtk1\"> =</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk11\">calcShare</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">      </span><span class=\"mtk12\">timeElapsed</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">      </span><span class=\"mtk12\">_year</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">      </span><span class=\"mtk11\">getInterestPayment</span><span class=\"mtk1\">(</span><span class=\"mtk12\">collateralAsset</span><span class=\"mtk1\">, </span><span class=\"mtk12\">debtAsset</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  ); </span><span class=\"mtk3\">// Share of the payment over 1 year</span></span></span></code></pre>\n<p>However, <code>calcShare</code> caps <code>timeElpased</code> to <code>_year</code> and therefore the owed interest does not grow after a year has elapsed.</p>\n<p>The impact is probably small because the only call so far computes the elapsed time as <code>block.timestamp - mapCollateralAsset_NextEra[collateralAsset][debtAsset];</code> which most likely will never go beyond a year.</p>\n<p>It’s still recommended to fix the logic bug in case more functions will be added that use the broken function.</p>\n<p>Recommend using a different function than <code>calcShare</code> that does not cap.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/219#issuecomment-830616264\">strictly-scarce (vader) confirmed</a>:</strong></p>\n<blockquote>\n<p>A member who doesn’t interact with the contract for more than a year misses out on some rewards, so severity:1</p>\n</blockquote>\n<h2 id=\"m-06-canceled-proposals-can-still-be-executed\" style=\"position:relative;\"><a href=\"#m-06-canceled-proposals-can-still-be-executed\" aria-label=\"m 06 canceled proposals can still be executed permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/228\">[M-06] Canceled proposals can still be executed</a></h2>\n<p>Proposals that passed the threshold (“finalized”) can be cancelled by a minority again using the <code>cancelProposal</code> functions.\nIt only sets <code>mapPID_votes</code> to zero but <code>mapPID_timeStart</code> and <code>mapPID_finalising</code> stay the same and pass the checks in <code>finaliseProposal</code> which queues them for execution.</p>\n<p>Proposals cannot be cancelled.</p>\n<p>Recommend setting a cancel flag and check for it in <code>finaliseProposal</code> and in execution.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/228#issuecomment-830616938\">strictly-scarce (vader) confirmed</a>:</strong></p>\n<blockquote>\n<p>Valid</p>\n</blockquote>\n<h2 id=\"m-07-completed-proposals-can-be-voted-on-and-executed-again\" style=\"position:relative;\"><a href=\"#m-07-completed-proposals-can-be-voted-on-and-executed-again\" aria-label=\"m 07 completed proposals can be voted on and executed again permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/229\">[M-07] Completed proposals can be voted on and executed again</a></h2>\n<p>A proposal that is completed has its state reset, including the votes.\nUsers can just vote on it again and it can be executed again.</p>\n<p>Completed proposals should most likely not be allowed to be voted on / executed again.\nThis could also lead to issues in backend scripts that don’t expect any voting/execution events to be fired again after the <code>FinalisedProposal</code> event has fired.</p>\n<p>Recommend adding an <code>executed</code> flag to the proposals and disallow voting/finalising on already executed proposals.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/229#issuecomment-830617230\">strictly-scarce (vader) disputed</a>:</strong></p>\n<blockquote>\n<p>It might be intended to have repeated proposals.</p>\n</blockquote>\n<h2 id=\"m-09-divide-before-multiply\" style=\"position:relative;\"><a href=\"#m-09-divide-before-multiply\" aria-label=\"m 09 divide before multiply permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/255\">[M-09] Divide before multiply</a></h2>\n<p>Here you have more information: <a href=\"https://gist.github.com/alexon1234/e5038a9f66136ae210be692f8803d874\">https://gist.github.com/alexon1234/e5038a9f66136ae210be692f8803d874</a></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/255#issuecomment-830631408\">strictly-scarce (vader) questioned</a>:</strong></p>\n<blockquote>\n<p>Can’t quite understand the assertion that a division is made before a multiply in the code outlined</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"\" data-index=\"2\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">uint _units = (((P * part1) + part2) / part3);</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    return (_units * slipAdjustment) / one;  // Divide by 10**18</span></span></code></pre>\n<p> <code>_units</code> will be <code>0 -> 2**256</code>.\n<code>slipAdjustment</code> will be <code>0 -> 10**18</code>\n<code>one</code> is <code>10**18</code></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"\" data-index=\"3\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">// returns 0</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"> return (0 * 10**18) / 10**18;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"> return (2**256 * 0) / 10**18;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">return (&lt;10**9 * &lt;10**9) / 10**18;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">  // returns  non-zero</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"> return (&gt;=10**9 * &gt;=10**9) / 10**18;</span></span></code></pre>\n</blockquote>\n<h2 id=\"m-10-incorrect-operator-used-in-deploysynth-of-poolssol\" style=\"position:relative;\"><a href=\"#m-10-incorrect-operator-used-in-deploysynth-of-poolssol\" aria-label=\"m 10 incorrect operator used in deploysynth of poolssol permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/124\">[M-10] Incorrect operator used in <code>deploySynth()</code> of <code>Pools.sol</code></a></h2>\n<p>The <code>deploySynth()</code> function in <code>Pools.sol</code> is expected to perform a check on the token parameter to determine that it is neither VADER or USDV before calling Factory’s <code>deploySynth()</code> function.</p>\n<p>However, the <code>require()</code> incorrectly uses the ‘||’ operator instead of ‘&#x26;&#x26;’ which allows both VADER and USDV to be supplied as the token parameters. This will allow an attacker to deploy either VADER or USDV as a Synth which will break assumptions throughout the entire protocol. Protocol will break and funds may be lost.</p>\n<p>Recommend changing ‘||’ operator to ‘&#x26;&#x26;’ in the require statement:\n<code>require(token != VADER &#x26;&#x26; token != USDV);</code></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/124#issuecomment-830601704\">strictly-scarce (vader) addressed</a>:</strong></p>\n<blockquote>\n<p>Duplicate\n<a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/21\">https://github.com/code-423n4/2021-04-vader-findings/issues/21</a></p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/124#issuecomment-837805692\">0xBrian commented</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/vetherasset/vaderprotocol-contracts/pull/159/commits/2f69f8317ce98846fbe227a3bf6ca1b644d01ff2#diff-5de3130299a0ddc914d7a906802a4cc093ed18d7a89c52a4aafefc8a11ac3f54R193\">https://github.com/vetherasset/vaderprotocol-contracts/pull/159/commits/2f69f8317ce98846fbe227a3bf6ca1b644d01ff2#diff-5de3130299a0ddc914d7a906802a4cc093ed18d7a89c52a4aafefc8a11ac3f54R193</a></p>\n</blockquote>\n<h2 id=\"m-11-allowing-duplicated-anchors-could-cause-bias-on-anchor-price\" style=\"position:relative;\"><a href=\"#m-11-allowing-duplicated-anchors-could-cause-bias-on-anchor-price\" aria-label=\"m 11 allowing duplicated anchors could cause bias on anchor price permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/314\">[M-11] Allowing duplicated anchors could cause bias on anchor price.</a></h2>\n<p>In <code>Router.sol</code>, the setup of the five anchors can be interrupted by anyone adding a new anchor due to the lack of access control of the <code>listAnchor</code> function. Also, duplicate anchors are allowed. If the same anchor is added three times, then this anchor biases the result of <code>getAnchorPrice</code>.</p>\n<p>Referenced code:\n<a href=\"https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L245-L252\">Router.sol#L245-L252</a></p>\n<p>PoC: <a href=\"https://drive.google.com/drive/folders/1W3jhlWIIh7FxTLZET3z49yA0DBvlbcPg?usp=sharing\">Link to PoC</a>\nSee the file <code>200_listAnchor.js</code> for a PoC of this attack. To run it, use <code>npx hardhat test 200_listAnchor.js</code>.</p>\n<p>Recommend only allowing <code>listAnchor</code> to be called from the deployer by adding a <code>require</code> statement. Also, check if an anchor is added before by <code>require(_isCurated == false)</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/314#issuecomment-830633778\">strictly-scarce (vader) acknowledged</a>:</strong></p>\n<blockquote>\n<p>Deployer will list the anchors, seems highly unlikely they will get griefed in practice. Severity: 1</p>\n</blockquote>\n<h2 id=\"m-12-transfer-fee-avoidance-\" style=\"position:relative;\"><a href=\"#m-12-transfer-fee-avoidance-\" aria-label=\"m 12 transfer fee avoidance  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/33\">[M-12] Transfer fee avoidance </a></h2>\n<p>The <code>Vether4.addExcluded()</code> function on mainnet (0x4Ba6dDd7b89ed838FEd25d208D4f644106E34279) allows a user to exclude an address from transfer fees for a cost of 128 VETH. By exploiting the conditions in which fees are taken, it is possible to set up a contract for a once-off cost in which all users can use to avoid transfer fees.</p>\n<h1 id=\"all-transfer-fees-can-be-avoided-by-routing-transfers-through-an-excluded-contract-an-estimated-140k-of-transfer-fees-was-accumulated-at-the-time-of-writing-these-fees-can-be-avoided-in-future-causing-an-indirect-loss-of-funds-for-the-contract\" style=\"position:relative;\"><a href=\"#all-transfer-fees-can-be-avoided-by-routing-transfers-through-an-excluded-contract-an-estimated-140k-of-transfer-fees-was-accumulated-at-the-time-of-writing-these-fees-can-be-avoided-in-future-causing-an-indirect-loss-of-funds-for-the-contract\" aria-label=\"all transfer fees can be avoided by routing transfers through an excluded contract an estimated 140k of transfer fees was accumulated at the time of writing these fees can be avoided in future causing an indirect loss of funds for the contract permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>All transfer fees can be avoided by routing transfers through an excluded contract. An estimated $140k of transfer fees was accumulated at the time of writing. These fees can be avoided in future, causing an indirect loss of funds for the contract.</h1>\n<p>Recommend that the <code>_transfer()</code> function should be updated to only exclude transfer fees if the sender has been excluded, not both the sender and the recipient. This would prevent any user from being able to set up a central transfer forwarder as demonstrated. Moreover, the <code>Transfer(_from, address(this), _fee);</code> event should only be emitted if the sender has been excluded from transfer fees.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/33\">strictly-scarce (vader) disputed</a></strong></p>\n<h2 id=\"m-13-init-function-can-be-called-by-everyone\" style=\"position:relative;\"><a href=\"#m-13-init-function-can-be-called-by-everyone\" aria-label=\"m 13 init function can be called by everyone permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/18\">[M-13] Init function can be called by everyone</a></h2>\n<p>Most of the solidity contracts have an init function that everyone can call.\nThis could lead to a race condition when the contract is deployed. At that moment a hacker could call the <code>init</code> function and make the deployed contracts useless. Then it would have to be redeployed, costing a lot of gas.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"\" data-index=\"4\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">DAO.sol:    function init(address _vader, address _usdv, address _vault) public {</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">Factory.sol:    function init(address _pool) public {</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">Pools.sol:    function init(address _vader, address _usdv, address _router, address _factory) public {</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">Router.sol:    function init(address _vader, address _usdv, address _pool) public {</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">USDV.sol:    function init(address _vader, address _vault, address _router) external {</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">Utils.sol:    function init(address _vader, address _usdv, address _router, address _pools, address _factory) public {</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">Vader.sol:    function init(address _vether, address _USDV, address _utils) external {</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">Vault.sol:    function init(address _vader, address _usdv, address _router, address _factory, address _pool) public {</span></span></code></pre>\n<p>Recommend adding a check to the <code>init</code> function, for example that only the deployer can call the function.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/18#issuecomment-826910451\">strictly-scarce (vader) confirmed</a>:</strong></p>\n<blockquote>\n<p>Yes, but only once. Could add a deployer check tho</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/18#issuecomment-847760153\">dmvt (judge) commented</a>:</strong></p>\n<blockquote>\n<p>After considerable evaluation and seeing the wide range of threat factors that were put forward by wardens related to this issue, I’ve decided that the potential threat here does extend beyond gas.</p>\n<p>A worst case scenario could cause significant damage.</p>\n<p>It is extremely unlikely that an attacker could successfully time this type of attack.</p>\n<p>An attacker would have to successfully intercept more than one init due to the highly coupled nature of the contract. If they did so incorrectly, the entire system would not function. Presuming they succeeded, the team would also have to overlook the failure of or forget to make multiple critical transaction calls in their deployment scripts. To realize significant financial gains, the attacker would have to leave their exploit code in place for an extended period of time.</p>\n<p>The likelihood is extremely low, but the impact would be critical. For this reason, I’m normalizing all of these reports to a Medium Risk.</p>\n</blockquote>\n<h2 id=\"m-14-pool-functions-can-be-called-before-initialization-in-init-of-poolssol\" style=\"position:relative;\"><a href=\"#m-14-pool-functions-can-be-called-before-initialization-in-init-of-poolssol\" aria-label=\"m 14 pool functions can be called before initialization in init of poolssol permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/114\">[M-14] Pool functions can be called before initialization in <em>`init</em>()` of Pools.sol</a></h2>\n<p>All the external/public functions of <code>Pools.sol</code> can be called by other contracts even before <code>Pools.sol</code>contract is initialized. This can lead to exceptions, state corruption or incorrect accounting in other contracts, which may require redeployment of said contract.</p>\n<p>Recommend using a factory pattern that will deploy and initialize atomically to prevent front-running of the initialization,</p>\n<p>OR</p>\n<p>Given that contracts are not using <code>delegatecall</code> proxy pattern, it is not required to use a separate <code>init()</code> function to initialize parameters when the same can be done in a constructor. If the reason for doing so is to get the deployment addresses of the various contracts, which may not all be available at the same time, then consider rearchitecting to create a “globals” contract which can hold all the globally required addresses of various contracts. see <a href=\"https://github.com/maple-labs/maple-core/blob/develop/contracts/MapleGlobals.sol\">Maple protocol’s</a> for example.</p>\n<p>OR</p>\n<p>Prevent external/public functions from being called until after initialization is done by checking initialization state tracked by the inited variable.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/114#issuecomment-830598388\">strictly-scarce (vader) dipsuted</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/39\">https://github.com/code-423n4/2021-04-vader-findings/issues/39</a></p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/114#issuecomment-847769580\">dmvt (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Same general comments apply to this issue as with issue #18, but it is a separate type of exploit that would be slightly less detectable. This increase in risk is balanced against the exploit being much harder to effect and the likely impact being lower.</p>\n</blockquote>\n<h2 id=\"m-15-changedao-should-be-a-two-step-process-in-vadersol\" style=\"position:relative;\"><a href=\"#m-15-changedao-should-be-a-two-step-process-in-vadersol\" aria-label=\"m 15 changedao should be a two step process in vadersol permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/162\">[M-15] <code>changeDAO</code> should be a two-step process in Vader.sol</a></h2>\n<p><code>changeDAO()</code> updates DAO address in one-step. If an incorrect address is mistakenly used (and voted upon) then future administrative access or recovering from this mistake is prevented because <code>onlyDAO</code> modifier is used for <code>changeDAO()</code>, which requires <code>msg.sender</code> to be the incorrectly used DAO address (for which private keys may not be available to sign transactions). See <a href=\"https://github.com/trailofbits/publications/blob/master/reviews/hermez.pdf\">finding #6 from Trail of Bits audit of Hermez Network</a>.</p>\n<p>Recommend using a two-step process where the old DAO address first proposes new ownership in one transaction; and then, accepts ownership from the newly proposed DAO address in a second transaction. A mistake in the first step can be recovered by granting with a new correct address again before the new DAO address accepts ownership. Ideally, there should also be a timelock enforced before the new DAO takes effect.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/162#issuecomment-830607270\">strictly-scarce (vader) confirmed</a>:</strong></p>\n<blockquote>\n<p>A lot has to go wrong to get to this point, so disagree with severity (funds not at risk).</p>\n<p>Two step-process seems wise though.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/162#issuecomment-847850118\">dmvt (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Risk lowered because of the extremely low probability</p>\n</blockquote>\n<h2 id=\"m-16-copy-paste-bug-leading-to-incorrect-harvest-rewards-in-vaultsol\" style=\"position:relative;\"><a href=\"#m-16-copy-paste-bug-leading-to-incorrect-harvest-rewards-in-vaultsol\" aria-label=\"m 16 copy paste bug leading to incorrect harvest rewards in vaultsol permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/51\">[M-16] Copy-paste bug leading to incorrect harvest rewards in Vault.sol</a></h2>\n<p>The conditional in <code>calcReward()</code> function uses the same code in both if/else parts with repeated use of <code>reserveUSDV</code>, <code>reserveVADER</code> and <code>getUSDVAmount</code> leading to incorrect computed value of <code>_adjustedReserve</code> in the else part.</p>\n<p>This will affect harvest rewards for all users of the protocol and lead to incorrect accounting. Protocol will break and lead to fund loss.</p>\n<p>Recommend changing variables and function calls from using USDV to VADER in the else part of the conditional which has to return the adjusted reserves when synth is not an asset i.e. an anchor and therefore base is VADER. L144 should be changed to:\n<code>uint _adjustedReserve = iROUTER(ROUTER).getVADERAmount(reserveUSDV()) + reserveVADER();</code></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/51#issuecomment-830576589\">strictly-scarce (vader) confirmed</a>:</strong></p>\n<blockquote>\n<p>Funds are not at-risk, just that some users will get less rewards, some will get more.</p>\n<p>Recommend: 2</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/51#issuecomment-830582964\">Mervyn853 commented</a>:</strong></p>\n<blockquote>\n<p>Our decision matrix for severity:</p>\n<p>0: No-risk: Code style, clarity, off-chain monitoring (events etc), exclude gas-optimisations\n1: Low Risk: UX, state handling, function incorrect as to spec\n2: Funds-Not-At-Risk, but can impact the functioning of the protocol, or leak value with a hypothetical attack path with stated assumptions, but external requirements\n3: Funds can be stolen/lost directly, or indirectly if a valid attack path shown that does not have handwavey hypotheticals.</p>\n<p>Recommended: 2</p>\n</blockquote>\n<h2 id=\"m-17-vaderredeemtomember-vulnerable-to-front-running\" style=\"position:relative;\"><a href=\"#m-17-vaderredeemtomember-vulnerable-to-front-running\" aria-label=\"m 17 vaderredeemtomember vulnerable to front running permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/36\">[M-17] <code>Vader.redeemToMember()</code> vulnerable to front running</a></h2>\n<p>The USDV balance of the Vader contract is vulnerable to theft through the <code>Vader.redeemToMember()</code> function. A particular case is through USDV redemption front-running. Users can redeem USDV for Vader through the <code>USDV.redeemForMember()</code> function or the <code>Vader.redeemToMember()</code> function. In the case of <code>Vader.redeemToMember()</code>, a user would need to send their USDV to the contract before redemption. However, as this process does not happen in a single call, the victim’s call is vulnerable to front running and could have their redeemed USDV stolen by an attacker.</p>\n<p>User’s redeem USDV could be stolen by an attacker front running their <code>Vader.redeemToMember()</code> call.</p>\n<p>The steps are as follows:</p>\n<ol>\n<li>User sends USDV to Vader contract to be redeemed</li>\n<li>User calls <code>Vader.redeemToMember()</code></li>\n<li>The <code>Vader.redeemToMember()</code> call is detected by an attacker, who front-runs the call by calling <code>Vader.redeemToMember()</code> specifying their own address as the member parameter.</li>\n<li>The full USDV balance of the Vader contract is redeemed and sent to the attacker.</li>\n</ol>\n<p>Note that while this particular case is front running a redemption call, any USDV balance could be stolen in this manner. Please find the POC showing the above steps here: <a href=\"https://gist.github.com/toastedsteaksandwich/39bfed78b21d7e6c02fe13ea5b2023c3\">https://gist.github.com/toastedsteaksandwich/39bfed78b21d7e6c02fe13ea5b2023c3</a></p>\n<p>Recommend that the <code>Vader.redeemToMember()</code> function should be restricted so that only the USDV contract can call it. Moreover, the amount parameter from <code>USDV.redeem()</code> or <code>USDV.redeemForMember()</code> should also be passed to <code>Vader.redeemToMember()</code> to avoid the need to sweep the entire USDV balance. In this way, the member’s redemption happens in a single tx, and would only be allocated as much Vader as redeemed in USDV.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/36#issuecomment-827577253\">strictly-scarce (vader) disputed</a>:</strong></p>\n<blockquote>\n<p>Vader complies with a monetary security policy of “money in, money out”. Contracts will only send out funds if they are first sent funds.</p>\n<p>This is the case for the entire system, not just <code>Vader.redeemToMember()</code>, such as swaps and adding liquidity. Vader is not designed to be interacted with directly, it should be wrapped. In this case, users should convert and redeem only thru the USDV contract, which first sends funds.</p>\n<p>Incidentally this is the same mechanism that uniswap employs for withdrawing liquidity, or syncing funds to balances. You can also get front-runned if you do it in two tx, it should be wrapped in 1 tx.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/36#issuecomment-830582247\">Mervyn853 commented</a>:</strong></p>\n<blockquote>\n<p>Our decision matrix for severity:</p>\n<p>0: No-risk: Code style, clarity, off-chain monitoring (events etc), exclude gas-optimisations\n1: Low Risk: UX, state handling, function incorrect as to spec\n2: Funds-Not-At-Risk, but can impact the functioning of the protocol, or leak value with a hypothetical attack path with stated assumptions, but external requirements\n3: Funds can be stolen/lost directly, or indirectly if a valid attack path shown that does not have handwavey hypotheticals.</p>\n<p>Recommended: 0</p>\n</blockquote>\n<h1 id=\"low-risk-findings\" style=\"position:relative;\"><a href=\"#low-risk-findings\" aria-label=\"low risk findings permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Low Risk Findings</h1>\n<h2 id=\"l-01-missing-event-for-critical-init-function-in-factorysol\" style=\"position:relative;\"><a href=\"#l-01-missing-event-for-critical-init-function-in-factorysol\" aria-label=\"l 01 missing event for critical init function in factorysol permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/108\">[L-01] Missing event for critical <code>init()</code> function in Factory.sol</a></h2>\n<p>The <code>init()</code> function initializes critical POOLS protocol address for this contract but is missing an event emission for off-chain monitoring tools to monitor this on-chain change.</p>\n<p>Recommend adding an init event and emit that at the end of <code>init()</code> function.</p>\n<h2 id=\"l-02-uninitialized-variable-leads-to-zero-fees-for-first-transfer-in-vadersol\" style=\"position:relative;\"><a href=\"#l-02-uninitialized-variable-leads-to-zero-fees-for-first-transfer-in-vadersol\" aria-label=\"l 02 uninitialized variable leads to zero fees for first transfer in vadersol permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/203\">[L-02] Uninitialized variable leads to zero-fees for first transfer in <code>Vader.sol</code></a></h2>\n<p>The state variables <code>feeOnTransfer</code> is never initialized which leads to a default uint value of 0. When it is used on L126 in the first call to <code>_transfer()</code>, it will lead to a zero fee. <code>feeOnTransfer</code> is updated only in function <code>_checkEmission()</code> whose call happens later on <a href=\"https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L133\">L133</a>, after which it has a value as calculated in that function. This causes only the first transfer to be a zero-fee transfer.</p>\n<p>Recommend initializing <code>feeOnTransfer</code> suitably on declaration, in constructor, or <code>init()</code> function.</p>\n<h2 id=\"l-03-misleading-comment-for-deposit-function-of-vaultsol\" style=\"position:relative;\"><a href=\"#l-03-misleading-comment-for-deposit-function-of-vaultsol\" aria-label=\"l 03 misleading comment for deposit function of vaultsol permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/48\">[L-03] Misleading comment for <code>deposit()</code> function of <code>Vault.sol</code></a></h2>\n<p>Use of accurate comments helps users read, audit and maintain code. Inaccurate comments can be misleading, obstruct the flagging of vulnerabilities, or even introduce them.</p>\n<p>Misleading comment on <a href=\"https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vault.sol#L76-L77\">L76</a> that says <code>deposit()</code> function allows USDV and Synths, but the code only allows Synths.</p>\n<p>Recommend using accurate and descriptive comments (even NatSpec) correctly describing the function behavior, parameters and return values.</p>\n<h2 id=\"l-04-fee-can-be-at-most-1-and-dead-code\" style=\"position:relative;\"><a href=\"#l-04-fee-can-be-at-most-1-and-dead-code\" aria-label=\"l 04 fee can be at most 1 and dead code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/221\">[L-04] Fee can be at most 1% and dead code</a></h2>\n<p>The <code>Vader._checkEmission</code> functions caps the fee at <code>1000</code> = 10% but the max fee that can be returned from the <code>iUTILS(UTILS).getFeeOnTransfer</code> call is <code>100</code>.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"5\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// returns value between 0 and 100</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">feeOnTransfer</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">iUTILS</span><span class=\"mtk1\">(</span><span class=\"mtk12\">UTILS</span><span class=\"mtk1\">).</span><span class=\"mtk11\">getFeeOnTransfer</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">totalSupply</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">maxSupply</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">); </span><span class=\"mtk3\">// UpdateFeeOnTransfer</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">feeOnTransfer</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk7\">1000</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">feeOnTransfer</span><span class=\"mtk1\"> = </span><span class=\"mtk7\">1000</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">} </span><span class=\"mtk3\">// Max 10% if UTILS corrupted</span></span></span></code></pre>\n<p>It seems like there is a misunderstanding in whether the fee should be at most 1% (<code>Utils.sol</code>) or 10% (<code>Vader.sol</code>).</p>\n<p>Recommend clarifying what the max fee should be, and then adjusting either <code>Utils.getFeeOnTransfer</code> or the <code>Vader._checkEmission</code> cap.</p>\n<h2 id=\"l-05-lack-of-zero-address-validation-in-init-function\" style=\"position:relative;\"><a href=\"#l-05-lack-of-zero-address-validation-in-init-function\" aria-label=\"l 05 lack of zero address validation in init function permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/12\">[L-05] Lack of zero address validation in <code>init()</code> function</a></h2>\n<p>The parameters that are used in <code>init()</code> function to initialize the state variable, these state variable are used in other function to perform operation. since it lacks zero address validation, it will be problematic if there is error in these state variable. some of the function will loss their functionality which can cause the redeployment of contract.</p>\n<p>Recommend adding require condition which check zero address validation</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/12#issuecomment-826295256\">strictly-scarce (vader) acknowledged</a>:</strong></p>\n<blockquote>\n<p>Same as: <a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/13#issuecomment-826294937\">https://github.com/code-423n4/2021-04-vader-findings/issues/13#issuecomment-826294937</a></p>\n<p>No issue found</p>\n</blockquote>\n<h2 id=\"l-06-events-not-emitted\" style=\"position:relative;\"><a href=\"#l-06-events-not-emitted\" aria-label=\"l 06 events not emitted permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/250\">[L-06] Events not emitted</a></h2>\n<p>Events not emitted for important state changes.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/250#issuecomment-830629461\">strictly-scarce (vader) acknowledged</a>:</strong></p>\n<blockquote>\n<p>The ethereum state machine isn’t a parking lot for event data</p>\n<ul>\n<li><code>setParams()</code> - no, plenty events in DAO</li>\n<li><code>setAnchorParams()</code> - no, plenty events in DAO</li>\n</ul>\n<p>But these are warranted, purely for off-chain metrics:</p>\n<ul>\n<li><code>addDepositData()</code> - valid for off-chain IL tracking</li>\n<li><code>removeDepositData()</code> - valid for off-chain IL tracking</li>\n</ul>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/250#issuecomment-830629536\">strictly-scarce (vader) commented</a>:</strong></p>\n<blockquote>\n<p>Severity: 0, no impact to protocol itself</p>\n</blockquote>\n<h2 id=\"l-07-swap-fee-not-applied\" style=\"position:relative;\"><a href=\"#l-07-swap-fee-not-applied\" aria-label=\"l 07 swap fee not applied permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/272\">[L-07] Swap fee not applied</a></h2>\n<p>Here you have more information: <a href=\"https://gist.github.com/alexon1234/a2d3619fb3faa4e5676329f70bd565d3\">https://gist.github.com/alexon1234/a2d3619fb3faa4e5676329f70bd565d3</a></p>\n<h2 id=\"l-08-the-calculation-for-nexteratime-drifts-causing-eras-to-occur-further-and-further-into-the-future\" style=\"position:relative;\"><a href=\"#l-08-the-calculation-for-nexteratime-drifts-causing-eras-to-occur-further-and-further-into-the-future\" aria-label=\"l 08 the calculation for nexteratime drifts causing eras to occur further and further into the future permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/193\">[L-08] The Calculation For <code>nextEraTime</code> Drifts, Causing Eras To Occur Further And Further Into The Future</a></h2>\n<p>In <code>Vader.sol</code>, eras are intended to occur every 24 hours. This means that a correct implementation would add 24 hours to the end-time of the previous era in order to find the end-time of the next era. However, the current method for calculating the next era’s end-time uses <code>block.timestamp</code>, rather than the previous era’s end-time.</p>\n<p>This line of code will cause a perpetual drift of era times, causing each era to actually be 24 hours plus the time between when the last era ended and when <code>Vader._transfer()</code> is next called.</p>\n<p>Recommend that In <code>Vader.sol</code>, change this:</p>\n<p><code>nextEraTime = block.timestamp + secondsPerEra;</code></p>\n<p>to this:</p>\n<p><code>nextEraTime = nextEraTime + secondsPerEra;</code></p>\n<h2 id=\"l-09-_recordburn-does-not-handle-0-_eth-appropriately\" style=\"position:relative;\"><a href=\"#l-09-_recordburn-does-not-handle-0-_eth-appropriately\" aria-label=\"l 09 _recordburn does not handle 0 _eth appropriately permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/269\">[L-09] <code>_recordBurn</code> does not handle 0 _eth appropriately</a></h2>\n<p>Contract Vether4 function <code>_recordBurn</code> does not check that <code>_eth > 0</code>, thus it is possible to pass this check multiple times:</p>\n<p><code>if (mapEraDay_MemberUnits[_era][_day][_member] == 0)</code></p>\n<p>If the user hasn’t contributed to this day yet, it updates <code>mapMemberEra_Days</code>, <code>mapEraDay_MemberCount</code>, and <code>mapEraDay_Members</code>. However, when <code>msg.value</code> is 0, it is possible to trigger this condition again and again as <code>mapEraDay_MemberUnits</code> still remains 0.</p>\n<p>Recommend either not allowing burns of 0 _eth, or add an extra check in the if statement.</p>\n<h2 id=\"l-10-getanchorprice-potentially-returns-the-wrong-median\" style=\"position:relative;\"><a href=\"#l-10-getanchorprice-potentially-returns-the-wrong-median\" aria-label=\"l 10 getanchorprice potentially returns the wrong median permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/213\">[L-10] <code>getAnchorPrice</code> potentially returns the wrong median</a></h2>\n<p>The <code>Router.getAnchorPrice</code> sorts the <code>arrayPrices</code> array and always returns the third element <code>_sortedAnchorFeed[2]</code>.\nThis only returns the median if <code>_sortedAnchorFeed</code> is of length 5, but it can be anything from <code>0</code> to <code>anchorLimit</code>.</p>\n<p>If not enough anchors are listed initially, it might become out-of-bounds and break all contract functionality due to revert, or return a wrong median. If <code>anchorLimit</code> is set to a different value than 5, it’s also wrong.</p>\n<p>recommend checking the length of <code>_sortedAnchorFeed</code> and return <code>_sortedAnchorFeed[_sortedAnchorFeed.length / 2]</code> if it’s odd, or the average of the two in the middle if it’s even.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/213#issuecomment-828464428\">strictly-scarce (vader) confirmed</a>:</strong></p>\n<blockquote>\n<p>Valid, although it is intended design to launch with 5, which cannot be reduced after, so disagree with severity.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/213#issuecomment-830579123\">Mervyn853 commented</a>:</strong></p>\n<blockquote>\n<p>Our decision matrix for severity:</p>\n<p>0: No-risk: Code style, clarity, off-chain monitoring (events etc), exclude gas-optimisations\n1: Low Risk: UX, state handling, function incorrect as to spec\n2: Funds-Not-At-Risk, but can impact the functioning of the protocol, or leak value with a hypothetical attack path with stated assumptions, but external requirements\n3: Funds can be stolen/lost directly, or indirectly if a valid attack path shown that does not have handwavey hypotheticals.</p>\n<p>Recommended: 2</p>\n</blockquote>\n<h2 id=\"l-11-listanchor-sets-_iscurated-to-true-but-forgets-other-parts-of-curation\" style=\"position:relative;\"><a href=\"#l-11-listanchor-sets-_iscurated-to-true-but-forgets-other-parts-of-curation\" aria-label=\"l 11 listanchor sets _iscurated to true but forgets other parts of curation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/271\">[L-11] <code>listAnchor</code> sets <code>_isCurated</code> to true but forgets other parts of curation</a></h2>\n<p>The function <code>listAnchor</code> sets <code>_isCurated</code> to true but does not update the <code>curatedPoolCount</code> and does not emit the Curated event. I don’t see this <code>curatedPoolCount</code> variable used anywhere so probably it’s just needed for the frontend consumption.</p>\n<p>Recommend that the best solution would be to replace <code>_isCurated[token] = true</code>; with call to function <code>curatePool</code>. It also skips if the same anchor is listed twice.</p>\n<h2 id=\"l-12-curatepool-emits-curated-event-no-matter-what\" style=\"position:relative;\"><a href=\"#l-12-curatepool-emits-curated-event-no-matter-what\" aria-label=\"l 12 curatepool emits curated event no matter what permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/274\">[L-12] <code>curatePool</code> emits Curated event no matter what</a></h2>\n<p>The function <code>curatePool</code> emits Curated event every time. It should emit this event only when the conditions are fulfilled.</p>\n<p>Recommend putting this event inside the most inner <code>if</code> block.</p>\n<h2 id=\"l-13-calculations-of-upgradedamount-is-not-overflow-protected\" style=\"position:relative;\"><a href=\"#l-13-calculations-of-upgradedamount-is-not-overflow-protected\" aria-label=\"l 13 calculations of upgradedamount is not overflow protected permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/277\">[L-13] calculations of <code>upgradedAmount</code> is not overflow protected</a></h2>\n<p>As contract Vether4 is using pragma solidity 0.6.4; SafeMath is not enabled by default, thus making this check inside function distribute avoidable (overflow):</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"6\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">upgradedAmount</span><span class=\"mtk1\"> += </span><span class=\"mtk12\">ownership</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">upgradedAmount</span><span class=\"mtk1\"> &lt;= </span><span class=\"mtk12\">maxEmissions</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;Must not send more than possible&quot;</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p>Of course, this function can only be called by the deployer (who is later expected to call <code>purgeDeployer()</code>) so the issue is only theoretical.</p>\n<p>Recommend using SafeMath here or just be informed about this theoretical issue.</p>\n<h2 id=\"l-14-flashproof-is-not-effective-at-the-start\" style=\"position:relative;\"><a href=\"#l-14-flashproof-is-not-effective-at-the-start\" aria-label=\"l 14 flashproof is not effective at the start permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/307\">[L-14] <code>flashProof</code> is not effective at the start</a></h2>\n<p>In contract USDV, <code>blockDelay</code> is not initialized and needs to be explicitly set by calling function <code>setParams()</code>. Otherwise, it gets a default value of 0 so <code>flashProof</code> is not effective unless the value is set.</p>\n<p>It depends on the intentions, you can initialize it in the constructor (or in the <code>init()</code> function) or maybe this precaution is intended to be turned on later.</p>\n<h2 id=\"l-15-token-can-be-burn-through-transfer\" style=\"position:relative;\"><a href=\"#l-15-token-can-be-burn-through-transfer\" aria-label=\"l 15 token can be burn through transfer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/262\">[L-15] Token can be burn through transfer</a></h2>\n<p>The token can be sent to <code>address(0)</code> through a normal <code>transfer()</code> without decreasing the <code>totalSupply</code> as it would with calling <code>burn()</code> and it could cause an unintentional burn.</p>\n<p>Recommend consider checking the recipient address to be != <code>address(0)</code>.</p>\n<h2 id=\"l-16-you-can-vote-for-proposal-still-not-existent\" style=\"position:relative;\"><a href=\"#l-16-you-can-vote-for-proposal-still-not-existent\" aria-label=\"l 16 you can vote for proposal still not existent permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/273\">[L-16] You can vote for proposal still not existent</a></h2>\n<p><code>voteProposal()</code> doesn’t check that <code>proposalID &#x3C;= proposalCount</code>.</p>\n<p>Recommend that in <code>voteProposal()</code>, <code>require(proposalID &#x3C;= proposalCount, \"Proposal not existent\")</code></p>\n<p>It should be ”&#x3C;=”, because <code>proposalCount</code> is updated before using it (e.g. <a href=\"https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/DAO.sol#L59\">https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/DAO.sol#L59</a>) in this way the proposal n. 0 is not assignable, although i’m not sure if it’s wanted or not.</p>\n<h2 id=\"l-17-out-of-bound-index-access-in-function-getanchorprice\" style=\"position:relative;\"><a href=\"#l-17-out-of-bound-index-access-in-function-getanchorprice\" aria-label=\"l 17 out of bound index access in function getanchorprice permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/313\">[L-17] Out-of-bound index access in function <code>getAnchorPrice</code></a></h2>\n<p>Out-of-bound index access is possible in the function <code>getAnchorPrice</code> of <code>Router.sol</code> if the number of anchors equals 1 or 2. Also, the returned anchor price is not the overall median in those situations. <a href=\"https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L288\">Router.sol#L288</a></p>\n<p>Recommend consider using <code>arrayPrices.length/2</code> as the index to get the median of prices.</p>\n<h2 id=\"l-18-erc20-race-condition-for-allowances\" style=\"position:relative;\"><a href=\"#l-18-erc20-race-condition-for-allowances\" aria-label=\"l 18 erc20 race condition for allowances permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/35\">[L-18] ERC20 race condition for allowances</a></h2>\n<p>Due to the implementation of the <code>approve()</code> function in Vader.sol, Vether.sol and mainnet Vether4 at 0x4Ba6dDd7b89ed838FEd25d208D4f644106E34279, it’s possible for a user to over spend their allowance in certain situations.</p>\n<p>The steps to the attack are as follows:</p>\n<ol>\n<li>Alice approves an allowance of 5000 VETH to Bob.</li>\n<li>Alice attempts to lower the allowance to 2500 VETH.</li>\n<li>Bob notices the transaction in the mempool and front-runs it by using up the full allowance with a <code>transferFrom</code> call.</li>\n<li>Alice’s lowered allowance is confirmed and Bob now has an allowance of 2500 VETH, which can be spent further for a total of 7500 VETH.</li>\n</ol>\n<p>Overall, Bob was supposed to be approved for at most 5000 VETH but got 7500 VETH. The POC code can be found here: <a href=\"https://gist.github.com/toastedsteaksandwich/db32472ae5c19c2eb188f07abddd02fa\">https://gist.github.com/toastedsteaksandwich/db32472ae5c19c2eb188f07abddd02fa</a></p>\n<p>Note that in the POC, Bob receives 7492.5 VETH instead of 7500 VETH due to transfer fees.</p>\n<p>Recommend that instead of having a direct setter for allowances, <code>decreaseAllowance</code> and <code>increaseAllowance</code> functions should be exposed which decreases and increases allowances for a recipient respectively. In this way, if the <code>decreaseAllowance</code> call is front-run, the call should revert as there is insufficient allowance to be decreased. This leaves Bob with at most 5000 VETH, the original allowance.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/35#issuecomment-827582108\">strictly-scarce (vader) acknowledged</a>:</strong></p>\n<blockquote>\n<p>This theoretical attack has been known about for a while but never actually observed meaningfully. Addressing it costs extra gas.</p>\n</blockquote>\n<h2 id=\"l-19-missing-input-validation-may-set-rewardaddress-to-zero-address-in-vadersol\" style=\"position:relative;\"><a href=\"#l-19-missing-input-validation-may-set-rewardaddress-to-zero-address-in-vadersol\" aria-label=\"l 19 missing input validation may set rewardaddress to zero address in vadersol permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/160\">[L-19] Missing input validation may set <code>rewardAddress</code> to zero-address in Vader.sol</a></h2>\n<p>The function <code>setRewardAddress</code> is used by DAO to change <code>rewardAddress</code> from USDV to something else. However, there is no zero-address validation on the address. This may accidentally mint rewards to zero-address.</p>\n<p>Recommend adding zero-address check to <code>setRewardAddress</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/160#issuecomment-830615075\">strictly-scarce (vader) confirmed</a>:</strong></p>\n<blockquote>\n<p>Sure, if this happened (and it wasn’t intentional) then it would be voted to the correct one. Low likelihood, disagree with severity.</p>\n</blockquote>\n<h2 id=\"l-20-default-value-of-curatedpoollimit-allows-only-one-curated-pool-in-routersol\" style=\"position:relative;\"><a href=\"#l-20-default-value-of-curatedpoollimit-allows-only-one-curated-pool-in-routersol\" aria-label=\"l 20 default value of curatedpoollimit allows only one curated pool in routersol permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/86\">[L-20] Default value of <code>curatedPoolLimit</code> allows only one curated pool in Router.sol</a></h2>\n<p>The default value of <code>curatedPoolLimit</code> only allows one curated pool at any time. This can be changed with <code>setParams()</code> but DAO does not have this functionality.</p>\n<p>This will affect the scalability of the protocol and significantly limit the liquidity pool value proposition.</p>\n<p>Recommend changeing <code>curatedPoolLimit</code> to a higher value on L85.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/86#issuecomment-830613369\">strictly-scarce (vader) acknowledged</a>:</strong></p>\n<blockquote>\n<p>Intended to be 5-10 as per discussion with community. The DAO will have extra functionality to expand.</p>\n<p>How is this medium-risk?</p>\n</blockquote>\n<h2 id=\"l-21-totalburnt-might-be-wrong\" style=\"position:relative;\"><a href=\"#l-21-totalburnt-might-be-wrong\" aria-label=\"l 21 totalburnt might be wrong permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/32\">[L-21] <code>totalBurnt</code> might be wrong</a></h2>\n<p><a href=\"https://etherscan.io/address/0x4Ba6dDd7b89ed838FEd25d208D4f644106E34279#code\">Vether.sol</a>\nis the 4th contract version. It takes the <code>totalBurnt</code> value of the 2nd version of the contract and continues on that.\nIt seem more logical to use the <code>totalBurnt</code> value of the 3rd version of the contract and continue on that. This way, the value of <code>totalBurnt</code> is probably not the real value.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"7\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">vether</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">contract</span><span class=\"mtk1\"> </span><span class=\"mtk12\">Vether4</span><span class=\"mtk1\"> </span><span class=\"mtk12\">is</span><span class=\"mtk1\"> </span><span class=\"mtk12\">ERC20</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\"> </span><span class=\"mtk11\">constructor</span><span class=\"mtk1\">() </span><span class=\"mtk12\">public</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">       ...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">vether2</span><span class=\"mtk1\"> = </span><span class=\"mtk7\">0x01217729940055011F17BeFE6270e6E59B7d0337</span><span class=\"mtk1\">;                               </span><span class=\"mtk3\">// Second Vether</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">vether3</span><span class=\"mtk1\"> = </span><span class=\"mtk7\">0x75572098dc462F976127f59F8c97dFa291f81d8b</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        ...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">totalBurnt</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">VETH</span><span class=\"mtk1\">(</span><span class=\"mtk12\">vether2</span><span class=\"mtk1\">).</span><span class=\"mtk11\">totalBurnt</span><span class=\"mtk1\">(); </span><span class=\"mtk12\">totalFees</span><span class=\"mtk1\"> = </span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span></span></code></pre>\n<p>Recommend checking if indeed vether3 should be used and update the code to use vether3.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/32#issuecomment-826845471\">strictly-scarce (vader) disputed</a>:</strong></p>\n<blockquote>\n<p>Vether is deployed code and can’t be changed.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/32#issuecomment-830582713\">Mervyn853 commented</a>:</strong></p>\n<blockquote>\n<p>Our decision matrix for severity:</p>\n<p>0: No-risk: Code style, clarity, off-chain monitoring (events etc), exclude gas-optimisations\n1: Low Risk: UX, state handling, function incorrect as to spec\n2: Funds-Not-At-Risk, but can impact the functioning of the protocol, or leak value with a hypothetical attack path with stated assumptions, but external requirements\n3: Funds can be stolen/lost directly, or indirectly if a valid attack path shown that does not have handwavey hypotheticals.</p>\n<p>Recommended: 0</p>\n</blockquote>\n<h2 id=\"l-22-missing-dao-functionality-to-call-setparams-function-in-usdvsol\" style=\"position:relative;\"><a href=\"#l-22-missing-dao-functionality-to-call-setparams-function-in-usdvsol\" aria-label=\"l 22 missing dao functionality to call setparams function in usdvsol permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/140\">[L-22] Missing DAO functionality to call <code>setParams()</code> function in USDV.sol</a></h2>\n<p><code>setParams()</code> is authorized to be called only from the DAO (per modifier) but DAO contract has no corresponding functionality to call <code>setParams()</code> function. As a result, <code>blockDelay</code> — a critical parameter used to prevent flash attacks, is stuck with initialized value and cannot be changed.</p>\n<p>Recommend adding functionality to DAO to be able to call <code>setParams()</code> of USDV.sol.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/140#issuecomment-830603451\">strictly-scarce (vader) commented</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/82\">https://github.com/code-423n4/2021-04-vader-findings/issues/82</a></p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/140#issuecomment-847841030\">dmvt (judge) commented</a>:</strong></p>\n<blockquote>\n<p>This can be easily addressed by updating the DAO address on Vader, even if it is deployed this way. Low risk and impact as a result.</p>\n</blockquote>\n<h2 id=\"l-23-events-can-be-emitted--even-after-failed-transaction\" style=\"position:relative;\"><a href=\"#l-23-events-can-be-emitted--even-after-failed-transaction\" aria-label=\"l 23 events can be emitted  even after failed transaction permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/6\">[L-23] events can be emitted  even after failed transaction</a></h2>\n<p>When a user tries to remove liquidity or initiate a swap, their transaction may fail. But, even though the transaction fails, events can still be emitted. This could be problematic if keeping track of the record off-chain.</p>\n<p>In Pools.sol:</p>\n<ul>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Pools.sol#L92\">https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Pools.sol#L92</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Pools.sol#L101\">https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Pools.sol#L101</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Pools.sol#L163\">https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Pools.sol#L163</a></li>\n</ul>\n<p>In the <code>_removeLiquidity()</code>, <code>swap()</code>, and <code>burnSynth()</code> functions; event is emitted before <code>transferOut()</code> function completes. This is because the <code>transferOut()</code> function does not check return value from transfer.\nAs such, the transaction might fail even though the event is emitted.</p>\n<p>Recommend checking return value from <code>transfer()</code> function in order to know whether transaction was successfully executed or not.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/6#issuecomment-826293590\">strictly-scarce (vader) disputed</a>:</strong></p>\n<blockquote>\n<p>Events are not used for tracking state. If a tx fails, the contract’s storage will not update. The contract state is the source of truth.</p>\n<p>Recommend: Close, no issue found.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/6#issuecomment-830582793\">Mervyn853 commented</a>:</strong></p>\n<blockquote>\n<p>Our decision matrix for severity:</p>\n<p>0: No-risk: Code style, clarity, off-chain monitoring (events etc), exclude gas-optimisations\n1: Low Risk: UX, state handling, function incorrect as to spec\n2: Funds-Not-At-Risk, but can impact the functioning of the protocol, or leak value with a hypothetical attack path with stated assumptions, but external requirements\n3: Funds can be stolen/lost directly, or indirectly if a valid attack path shown that does not have handwavey hypotheticals.</p>\n<p>Recommended: 0</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/6#issuecomment-849046134\">dmvt (judge) commented</a>:</strong></p>\n<blockquote>\n<p>This can and will cause cascading issues for third party dapps. At worst, completely hypothetically, this could cause a user to act as if they have funds they don’t or vise versa leading to reputational and economic impact. I recommend that the team treat event emission more seriously in general.</p>\n</blockquote>\n<h1 id=\"non-critical-findings\" style=\"position:relative;\"><a href=\"#non-critical-findings\" aria-label=\"non critical findings permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Non-Critical Findings</h1>\n<ul>\n<li><a href=\"https://github.com/code-423n42021-04-vader-findings/issues/20\">[N-01] Not always reason at require</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/24\">[N-02] Functions with implicit return values</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/25\">[N-03] Different pragma solidity</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/283\">[N-04] ERC20 specification declares decimals as uint8 type</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/285\">[N-05] [INFO] Code style suggestions</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/251\">[N-06] Difference from whitepaper</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/110\">[N-08] Public functions <code>getSynth()</code> and <code>isSynth()</code> are commented out in Factory.sol</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/50\">[N-09] Named return variable in <code>harvest()</code> and other functions of Vault.sol and contracts</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/230\">[N-10]  <code>Protection</code> event not used</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/212\">[N-11] Replacing an anchor does not reset <code>Pool.isAnchor</code></a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/317\">[N-12] Unrestricted <code>addLiquidity</code> could cause unintended results on front-end apps that listen to events.</a></li>\n</ul>\n<h1 id=\"gas-optimizations\" style=\"position:relative;\"><a href=\"#gas-optimizations\" aria-label=\"gas optimizations permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Gas Optimizations</h1>\n<ul>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/100\">[G-01] Gas savings by removing unnecessary conditional in <code>isCurated()</code> function of Router.sol</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/304\">[G-02] Unused ID field in structs</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/286\">[G-03] Use immutable for constant variables</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/14\">[G-04] Public function that could be declared external</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/111\">[G-05] Gas savings by moving inited bool state variable next to an address state variable declaration in Pools.sol</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/118\">[G-06] Gas savings by removing unused state variable <code>_isMember</code> and related getter function <code>isMember()</code> in Pools.sol</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/129\">[G-07] Gas savings by declaring state variables constant in USDV.sol</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/149\">[G-08] Gas savings by converting storage variable to immutable in Vader.sol</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/153\">[G-09] Gas savings by removing state variable baseline in Vader.sol</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/181\">[G-10] Gas savings by replacing public visibility with internal/private for <code>isEqual()</code> function of DAO.sol</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/182\">[G-11] Perform early input validation of zero-address for efficiency in DAO.sol</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/186\">[G-12] Unnecessary logic that will never get triggered in DAO.sol</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/43\">[G-13] Gas savings by avoiding re-initialization of POOLS variable in <code>init()</code> function of Vault.sol</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/78\">[G-14] Gas savings by removing unused state variable <code>repayDelay</code> in Router.sol</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/85\">[G-15] Gas savings by changing <code>getILProtection()</code> function’s public visibility to internal/private in Router.sol</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/90\">[G-16] Gas savings by saving state variable in a memory for loop access in <code>replaceAnchor()</code> of Router.sol</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/91\">[G-17] Gas savings by breaking from loop after <code>match+replace</code> in <code>replaceAnchor()</code> of Router.sol</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/232\">[G-18] cache <code>proposalCount</code> instead of accessing it three times in <code>newGrantProposal</code>/<code>newAddressProposal</code></a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/233\">[G-19] <code>DAO.mapPID_finalised</code> is never read in the contract, only written</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/236\">[G-20] Add anchor map</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/252\">[G-21] Store using Struct over multiple mappings</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/258\">[G-22] Use Keccak256 over Sha256 for string comparation</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/292\">[G-23] Some storage optimizations</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/312\">[G-24] Unused and Unnecessary code</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/17\">[G-25] Some  unused code</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/19\">[G-26] sortArray optimizable</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/22\">[G-27] Result of ERC20 transfer not checked</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/26\">[G-28] Optimization possible at _transfer</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/28\">[G-29] Pay double fees in addExcluded of Vether.sol</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/190\">[G-31] Gas Optimization: Remove Overflow Check in Vether.sol Since Solidity 0.8.x Disallows Implicit Overflows</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/191\">[G-32] Gas Optimization: Avoid Unnecessary Expensive SSTORE Calls In Vether.sol By Checking If _fee Is Non-Zero</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/197\">[G-33] Gas Optimization: Vader.sol Unnecessary Conditional</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/199\">[G-34] Gas Optimization: Utils.sol Make An Unnecessary Multiplication And Division By An Identical Value</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/200\">[G-35] Gas Optimization: DAO.sol Unnecessary Multiple Return Statements</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/287\">[G-36] Extra useless steps to calculate pooledVADER and pooledUSDV </a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/288\">[G-37] variable == false -> !variable</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/289\">[G-38] Extract mappings to a common struct</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/291\">[G-39] Cache duplicate calls or storage access</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/293\">[G-40] Fee on transfer conditions</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/256\">[G-42] Not needed check for uint > 0</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/302\">[G-43] You don’t need to recalculate exclusion fee every time</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/303\">[G-44] token == arrayAnchors[i]</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/253\">[G-45] Gas improvement</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/263\">[G-46] Function can be simplified</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/301\">[G-47] Function can be simplified</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/319\">[G-48] Unnecessary <code>else if</code> statement in <code>swapWithSynthsWithLimit</code></a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-vader-findings/issues/320\">[G-49] Unnecessary function calls in <code>addLiquidity</code></a></li>\n</ul>\n<h1 id=\"disclosures\" style=\"position:relative;\"><a href=\"#disclosures\" aria-label=\"disclosures permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Disclosures</h1>\n<p>C4 is an open organization governed by participants in the community.</p>\n<p>C4 Contests incentivize the discovery of exploits, vulnerabilities, and bugs in smart contracts. Security researchers are rewarded at an increasing rate for finding higher risk issues. Contest submissions are judged by a knowledgeable security researcher and solidity developer and disclosed to sponsoring developers. C4 does not conduct formal verification regarding the provided code, but instead provides final verification.</p>\n<p>C4 does not provide any guarantee or warranty regarding the security of this project. All smart contract software should be used at the sole risk and responsibility of users.</p>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n  .dark-default-dark {\n    background-color: #1E1E1E;\n    color: #D4D4D4;\n  }\n  .dark-default-dark .mtk11 { color: #DCDCAA; }\n  .dark-default-dark .mtk1 { color: #D4D4D4; }\n  .dark-default-dark .mtk12 { color: #9CDCFE; }\n  .dark-default-dark .mtk3 { color: #6A9955; }\n  .dark-default-dark .mtk15 { color: #C586C0; }\n  .dark-default-dark .mtk7 { color: #B5CEA8; }\n  .dark-default-dark .mtk8 { color: #CE9178; }\n  .dark-default-dark .grvsc-line-highlighted::before {\n    background-color: var(--grvsc-line-highlighted-background-color, rgba(255, 255, 255, 0.1));\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(255, 255, 255, 0.5));\n  }\n</style>",
  "toc": "<ul>\n<li>\n<p><a href=\"#overview\">Overview</a></p>\n<ul>\n<li><a href=\"#about-c4\">About C4</a></li>\n<li><a href=\"#wardens\">Wardens</a></li>\n</ul>\n</li>\n<li><a href=\"#summary\">Summary</a></li>\n<li><a href=\"#scope\">Scope</a></li>\n<li><a href=\"#severity-criteria\">Severity Criteria</a></li>\n<li>\n<p><a href=\"#high-risk-findings\">High Risk Findings</a></p>\n<ul>\n<li><a href=\"#h-01-unhandled-return-value-of-transfer-in-transferout-of-poolssol\">[H-01] Unhandled return value of transfer in <code>transferOut()</code> of Pools.sol</a></li>\n<li><a href=\"#h-02-flash-attack-mitigation-does-not-work-as-intended-in-usdvsol\">[H-02] Flash attack mitigation does not work as intended in USDV.sol</a></li>\n<li><a href=\"#h-03-missing-dao-functionality-to-call-changedao-function-in-vadersol\">[H-03] Missing DAO functionality to call <code>changeDAO()</code> function in Vader.sol</a></li>\n<li><a href=\"#h-04-proposals-can-be-cancelled\">[H-04] Proposals can be cancelled</a></li>\n<li><a href=\"#h-05-flash-loans-can-affect-governance-voting-in-daosol\">[H-05] Flash loans can affect governance voting in DAO.sol</a></li>\n<li><a href=\"#h-06-incorrect-burn-address-in-vadersol\">[H-06] Incorrect burn address in Vader.sol</a></li>\n<li><a href=\"#h-07-wrong-calcasymmetricshare-calculation\">[H-07] Wrong <code>calcAsymmetricShare</code> calculation</a></li>\n<li><a href=\"#h-08-wrong-liquidity-units-calculation\">[H-08] Wrong liquidity units calculation</a></li>\n<li><a href=\"#h-09-incorrect-initialization-gives-il-protection-of-only-1-second-instead-of-100-days-in-routersol\">[H-09] Incorrect initialization gives IL protection of only 1 second instead of 100 days in Router.sol</a></li>\n<li><a href=\"#h-10-anyone-can-list-anchors--curate-tokens\">[H-10] Anyone can list anchors / curate tokens</a></li>\n<li><a href=\"#h-11-swap-token-can-be-traded-as-fake-base-token\">[H-11] Swap token can be traded as fake base token</a></li>\n<li><a href=\"#h-12-getaddedamount-can-return-wrong-results\">[H-12] <code>getAddedAmount</code> can return wrong results</a></li>\n<li><a href=\"#h-13-4-synths-can-be-minted-with-fake-base-token\">[H-13] 4 Synths can be minted with fake base token</a></li>\n<li><a href=\"#h-14-missing-access-restriction-on-lockunitsunlockunits\">[H-14] Missing access restriction on <code>lockUnits/unlockUnits</code></a></li>\n<li><a href=\"#h-15-wrong-slippage-protection-on-token---token-trades\">[H-15] Wrong slippage protection on Token -> Token trades</a></li>\n<li><a href=\"#h-16-tokens-can-be-stolen-through-transferto\">[H-16] Tokens can be stolen through <code>transferTo</code></a></li>\n<li><a href=\"#h-17-transfer-fee-is-burned-on-wrong-accounts\">[H-17] Transfer fee is burned on wrong accounts</a></li>\n<li><a href=\"#h-18--vault-rewards-can-be-gamed\">[H-18]  Vault rewards can be gamed</a></li>\n<li><a href=\"#h-19-vault-rewards-last-claim-time-not-always-initialized\">[H-19] Vault rewards last claim time not always initialized</a></li>\n<li><a href=\"#h-20-vault-weight-accounting-is-wrong-for-withdrawals\">[H-20] Vault Weight accounting is wrong for withdrawals</a></li>\n<li><a href=\"#h-21-anyone-can-avoid-all-vether-transfer-fees-by-adding-their-address-to-the-vether-excludedaddresses-list\">[H-21] Anyone Can Avoid All Vether Transfer Fees By Adding Their Address to the Vether <code>ExcludedAddresses</code> List.</a></li>\n<li><a href=\"#h-22-users-may-unintentionally-remove-liquidity-under-a-phishing-attack\">[H-22] Users may unintentionally remove liquidity under a phishing attack.</a></li>\n<li><a href=\"#h-23-anyone-can-curate-pools-and-steal-rewards\">[H-23] Anyone can curate pools and steal rewards</a></li>\n<li><a href=\"#h-25-incorrect-initialization-causes-vader-emission-rate-of-1-second-instead-of-1-day-in-vadersol\">[H-25] Incorrect initialization causes VADER emission rate of 1 second instead of 1 day in Vader.sol</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#medium-risk-findings\">Medium Risk Findings</a></p>\n<ul>\n<li><a href=\"#m-01-user-may-not-get-il-protection-if-certain-functions-are-called-directly-in-poolssol\">[M-01] User may not get IL protection if certain functions are called directly in <code>Pools.sol</code></a></li>\n<li><a href=\"#m-02-undefined-behavior-for-dao-and-grant-vote-proposals-in-daosol\">[M-02] Undefined behavior for DAO and GRANT vote proposals in <code>DAO.sol</code></a></li>\n<li><a href=\"#m-03-lack-of-input-validation-in-replacepool-allows-curated-pool-limit-bypass-in-routersol\">[M-03] Lack of input validation in <code>replacePool()</code> allows curated pool limit bypass in <code>Router.sol</code></a></li>\n<li><a href=\"#m-04-flashproof-is-not-flash-proof\">[M-04] <code>flashProof</code> is not flash-proof</a></li>\n<li><a href=\"#m-05-interest-debt-is-capped-after-a-year\">[M-05] Interest debt is capped after a year</a></li>\n<li><a href=\"#m-06-canceled-proposals-can-still-be-executed\">[M-06] Canceled proposals can still be executed</a></li>\n<li><a href=\"#m-07-completed-proposals-can-be-voted-on-and-executed-again\">[M-07] Completed proposals can be voted on and executed again</a></li>\n<li><a href=\"#m-09-divide-before-multiply\">[M-09] Divide before multiply</a></li>\n<li><a href=\"#m-10-incorrect-operator-used-in-deploysynth-of-poolssol\">[M-10] Incorrect operator used in <code>deploySynth()</code> of <code>Pools.sol</code></a></li>\n<li><a href=\"#m-11-allowing-duplicated-anchors-could-cause-bias-on-anchor-price\">[M-11] Allowing duplicated anchors could cause bias on anchor price.</a></li>\n<li><a href=\"#m-12-transfer-fee-avoidance-\">[M-12] Transfer fee avoidance </a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#all-transfer-fees-can-be-avoided-by-routing-transfers-through-an-excluded-contract-an-estimated-140k-of-transfer-fees-was-accumulated-at-the-time-of-writing-these-fees-can-be-avoided-in-future-causing-an-indirect-loss-of-funds-for-the-contract\">All transfer fees can be avoided by routing transfers through an excluded contract. An estimated $140k of transfer fees was accumulated at the time of writing. These fees can be avoided in future, causing an indirect loss of funds for the contract.</a></p>\n<ul>\n<li><a href=\"#m-13-init-function-can-be-called-by-everyone\">[M-13] Init function can be called by everyone</a></li>\n<li><a href=\"#m-14-pool-functions-can-be-called-before-initialization-in-init-of-poolssol\">[M-14] Pool functions can be called before initialization in <em>`init</em>()` of Pools.sol</a></li>\n<li><a href=\"#m-15-changedao-should-be-a-two-step-process-in-vadersol\">[M-15] <code>changeDAO</code> should be a two-step process in Vader.sol</a></li>\n<li><a href=\"#m-16-copy-paste-bug-leading-to-incorrect-harvest-rewards-in-vaultsol\">[M-16] Copy-paste bug leading to incorrect harvest rewards in Vault.sol</a></li>\n<li><a href=\"#m-17-vaderredeemtomember-vulnerable-to-front-running\">[M-17] <code>Vader.redeemToMember()</code> vulnerable to front running</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#low-risk-findings\">Low Risk Findings</a></p>\n<ul>\n<li><a href=\"#l-01-missing-event-for-critical-init-function-in-factorysol\">[L-01] Missing event for critical <code>init()</code> function in Factory.sol</a></li>\n<li><a href=\"#l-02-uninitialized-variable-leads-to-zero-fees-for-first-transfer-in-vadersol\">[L-02] Uninitialized variable leads to zero-fees for first transfer in <code>Vader.sol</code></a></li>\n<li><a href=\"#l-03-misleading-comment-for-deposit-function-of-vaultsol\">[L-03] Misleading comment for <code>deposit()</code> function of <code>Vault.sol</code></a></li>\n<li><a href=\"#l-04-fee-can-be-at-most-1-and-dead-code\">[L-04] Fee can be at most 1% and dead code</a></li>\n<li><a href=\"#l-05-lack-of-zero-address-validation-in-init-function\">[L-05] Lack of zero address validation in <code>init()</code> function</a></li>\n<li><a href=\"#l-06-events-not-emitted\">[L-06] Events not emitted</a></li>\n<li><a href=\"#l-07-swap-fee-not-applied\">[L-07] Swap fee not applied</a></li>\n<li><a href=\"#l-08-the-calculation-for-nexteratime-drifts-causing-eras-to-occur-further-and-further-into-the-future\">[L-08] The Calculation For <code>nextEraTime</code> Drifts, Causing Eras To Occur Further And Further Into The Future</a></li>\n<li><a href=\"#l-09-_recordburn-does-not-handle-0-_eth-appropriately\">[L-09] <code>_recordBurn</code> does not handle 0 _eth appropriately</a></li>\n<li><a href=\"#l-10-getanchorprice-potentially-returns-the-wrong-median\">[L-10] <code>getAnchorPrice</code> potentially returns the wrong median</a></li>\n<li><a href=\"#l-11-listanchor-sets-_iscurated-to-true-but-forgets-other-parts-of-curation\">[L-11] <code>listAnchor</code> sets <code>_isCurated</code> to true but forgets other parts of curation</a></li>\n<li><a href=\"#l-12-curatepool-emits-curated-event-no-matter-what\">[L-12] <code>curatePool</code> emits Curated event no matter what</a></li>\n<li><a href=\"#l-13-calculations-of-upgradedamount-is-not-overflow-protected\">[L-13] calculations of <code>upgradedAmount</code> is not overflow protected</a></li>\n<li><a href=\"#l-14-flashproof-is-not-effective-at-the-start\">[L-14] <code>flashProof</code> is not effective at the start</a></li>\n<li><a href=\"#l-15-token-can-be-burn-through-transfer\">[L-15] Token can be burn through transfer</a></li>\n<li><a href=\"#l-16-you-can-vote-for-proposal-still-not-existent\">[L-16] You can vote for proposal still not existent</a></li>\n<li><a href=\"#l-17-out-of-bound-index-access-in-function-getanchorprice\">[L-17] Out-of-bound index access in function <code>getAnchorPrice</code></a></li>\n<li><a href=\"#l-18-erc20-race-condition-for-allowances\">[L-18] ERC20 race condition for allowances</a></li>\n<li><a href=\"#l-19-missing-input-validation-may-set-rewardaddress-to-zero-address-in-vadersol\">[L-19] Missing input validation may set <code>rewardAddress</code> to zero-address in Vader.sol</a></li>\n<li><a href=\"#l-20-default-value-of-curatedpoollimit-allows-only-one-curated-pool-in-routersol\">[L-20] Default value of <code>curatedPoolLimit</code> allows only one curated pool in Router.sol</a></li>\n<li><a href=\"#l-21-totalburnt-might-be-wrong\">[L-21] <code>totalBurnt</code> might be wrong</a></li>\n<li><a href=\"#l-22-missing-dao-functionality-to-call-setparams-function-in-usdvsol\">[L-22] Missing DAO functionality to call <code>setParams()</code> function in USDV.sol</a></li>\n<li><a href=\"#l-23-events-can-be-emitted--even-after-failed-transaction\">[L-23] events can be emitted  even after failed transaction</a></li>\n</ul>\n</li>\n<li><a href=\"#non-critical-findings\">Non-Critical Findings</a></li>\n<li><a href=\"#gas-optimizations\">Gas Optimizations</a></li>\n<li><a href=\"#disclosures\">Disclosures</a></li>\n</ul>",
  "md": "\n# Overview\n\n## About C4\n\nCode 432n4 (C4) is an open organization consisting of security researchers, auditors, developers, and individuals with domain expertise in smart contracts.\n\nA C4 code contest is an event in which community participants, referred to as Wardens, review, audit, or analyze smart contract logic in exchange for a bounty provided by sponsoring projects.\n\nDuring the code contest outlined in this document, C4 conducted an analysis of the Vader Protocol smart contract system written in Solidity. The code contest took place between April 21 and April 28, 2021.\n\n## Wardens\n\n10 Wardens contributed reports to the Vader code contest:\n- [cmichel](https://twitter.com/cmichelio)\n- [rajeev](https://twitter.com/0xRajeev)\n- [shw](https://github.com/x9453)\n- [pauliax](https://twitter.com/SolidityDev) (Thunder)\n- [jvaqa](https://twitter.com/jvaqa)\n- [s1m0](https://twitter.com/_smonica_)\n- [a_delamo](https://twitter.com/a_delamo)\n- [toastedsteaksandwich](https://twitter.com/AshiqAmien)\n- [mukesh jaiswal](https://twitter.com/MukeshJ_eth)\n- [gpersoon](https://twitter.com/gpersoon)\n\nThis contest was judged by [LSDan](https://twitter.com/lsdan_defi).\n\nFinal report assembled by [moneylegobatman](https://twitter.com/money_lego).\n\n# Summary\n\nThe C4 analysis yielded an aggregated total of 121 unique vulnerabilities. All of the issues presented here are linked back to their original finding.\n\nOf these vulnerabilities, 24 received a risk rating in the category of HIGH severity, 16 received a risk rating in the category of MEDIUM severity, and 23 received a risk rating in the category of LOW severity.\n\nC4 analysis also identified 60 non-critical recommendations including gas optimizations.\n\n# Scope\n\nThe code under review can be found within the [C4 vader code contest repository](https://github.com/code-423n4/2021-04-vader) and comprises 23  smart contracts written in the Solidity programming language.\n\n# Severity Criteria\n\nC4 assesses the severity of disclosed vulnerabilities according to a methodology based on [OWASP standards](https://owasp.org/www-community/OWASP_Risk_Rating_Methodology).\n\nVulnerabilities are divided into three primary risk categories: high, medium, and low.\n\nHigh-level considerations for vulnerabilities span the following key areas when conducting assessments:\n\n- Malicious Input Handling\n- Escalation of privileges\n- Arithmetic\n- Gas use\n\nFurther information regarding the severity criteria referenced throughout the submission review process, please refer to the documentation provided on [the C4 website](https://code423n4.com).\n\n\n# High Risk Findings\n## [[H-01] Unhandled return value of transfer in `transferOut()` of Pools.sol](https://github.com/code-423n4/2021-04-vader-findings/issues/128)\n\nERC20 implementations are not always consistent. Some implementations of transfer and `transferFrom` could return ‘false’ on failure instead of reverting. It is safer to wrap such calls into `require()` statements to handle these failures.\n\nThe transfer call [on L211](https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Pools.sol#L211) of `transferOut()` could be made on a user-supplied untrusted token address (from the different call sites) whose implementation can be malicious.\n\nFor reference, see similar finding from Consensys Diligence Audit of AAVE Protocol V2\n\nRecommend requirements to check the return value and revert on 0/false or use OpenZeppelin’s SafeERC20 wrapper functions.\n\n**[strictly-scarce (vader) disputed](https://github.com/code-423n4/2021-04-vader-findings/issues/128#issuecomment-830602601):**\n > Not valid. Since the funds came in, and did not revert, they can leave. If the call passes, then the transferout is valid.\n\n## [[H-02] Flash attack mitigation does not work as intended in USDV.sol](https://github.com/code-423n4/2021-04-vader-findings/issues/138)\n\nOne of the stated protocol (review) goals is to detect susceptibility to “Any attack vectors using flash loans on Anchor price, synths or lending.” As such, USDV contract aims to protect against flash attacks using `flashProof()` modifier which uses the following check in `isMature()` to determine if currently executing contract context is at least `blockDelay` duration ahead of the previous context: ```lastBlock[tx.origin] + blockDelay <= block.number```\n\nHowever, `blockDelay` state variable is not initialized which means it has a default uint value of 0. So unless it is set to >= 1 by `setParams()` which can be called only by the DAO (which currently does not have the capability to call `setParams()` function), `blockDelay` will be 0, which allows current executing context (`block.number`) to be the same as the previous one (`lastBlock[tx.origin]`). This effectively allows multiple calls on this contract to be executed in the same transaction of a block which enables flash attacks as opposed to what is expected as commented on [L41](https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/USDV.sol#L140-L142): \"// Stops an EOA from doing a flash attack in the same block\"\n\nEven if the DAO can call `setParams()` to change `blockDelay` to >= 1, there is a big window of opportunity for flash attacks until the DAO votes, finalizes and approves such a proposal. Moreover, such proposals can be cancelled by a DAO minority or replaced by a malicious DAO minority to launch flash attacks.\n\nRecommend initalizing `blockDelay` to >= 1 at declaration or in constructor.\n\n**[strictly-scarce (vader) confirmed](https://github.com/code-423n4/2021-04-vader-findings/issues/138#issuecomment-830606188):**\n\n> The actual issue is simply:\n\n> > `blockDelay` state variable is not initialized\n>\n> It is intended to be initialised to 1, so this is a bug. Severity: 2\n\n## [[H-03] Missing DAO functionality to call `changeDAO()` function in Vader.sol](https://github.com/code-423n4/2021-04-vader-findings/issues/161)\n\n`changeDAO()` is authorized to be called only from the DAO (per modifier) but DAO contract has no corresponding functionality to call `changeDAO()` function. As a result, DAO address cannot be changed ([L192-L196](https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L192-L196)).\n\nRecommend adding functionality to DAO to be able to call `changeDAO()` of Vader.sol.\n\n**[strictly-scarce (vader) commented](https://github.com/code-423n4/2021-04-vader-findings/issues/161#issuecomment-830606766)**:\n> [#46](https://github.com/code-423n4/2021-04-vader-findings/issues/46)\n\n**[dmvt (judge) commented](https://github.com/code-423n4/2021-04-vader-findings/issues/161#issuecomment-847848752)**:\n > Unlike in issues #140, #157, #158, & #159; without this functionality, missing functionality in the DAO becomes a very serious issue. As a result, this one is very high risk were it to be overlooked.\n\n## [[H-04] Proposals can be cancelled](https://github.com/code-423n4/2021-04-vader-findings/issues/227)\nAnyone can cancel any proposals by calling `DAO.cancelProposal(id, id)` with `oldProposalID == newProposalID`.\nThis always passes the minority check as the proposal was approved.\n\nAn attacker can launch a denial of service attack on the DAO governance and prevent any proposals from being executed.\n\nRecommend checking that `oldProposalID` == `newProposalID`\n\n**[strictly-scarce (vader) confirmed](https://github.com/code-423n4/2021-04-vader-findings/issues/227#issuecomment-828455719):**\n > This is valid, can fix with a `require()`\n\n\n**[strictly-scarce (vader) commented](https://github.com/code-423n4/2021-04-vader-findings/issues/227#issuecomment-830634810):**\n\n\n## [[H-05] Flash loans can affect governance voting in DAO.sol](https://github.com/code-423n4/2021-04-vader-findings/issues/187)\n\nFlash loans can significantly increase a single voter's weight and be used to impact the voting outcome. A voter can borrow a significant quantity of tokens to increase their voting weight in a transaction within which, they also deterministically  influence the voting outcome to their choice.\n\nThis has already happened in the case of MakerDAO governance where [a flash loan was used to affect voting outcome](https://forum.makerdao.com/t/urgent-flash-loans-and-securing-the-maker-protocol/4901) and noted by the Maker team as: “a practical example for the community that flash loans can and may impact system governance”\n\nGiven that flash loans are a noted concern, the impact of it to DAO governance which can control all critical protocol parameters should be mitigated as in other places.\n\nRecommend accounting for flash loans in `countMemberVotes()` by using weight from previous blocks or consider capping the weight of individual voters. ([L158-L163](https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/DAO.sol#L158-L163))\n\n**[strictly-scarce (vader) disputed](https://github.com/code-423n4/2021-04-vader-findings/issues/187#issuecomment-830608957):**\n > Not valid.\n> All pools use slip-based fees so flash loan attack by buying up USDV or synths is not going to work.\n\n**[dmvt (judge) commented](https://github.com/code-423n4/2021-04-vader-findings/issues/187#issuecomment-847890126):**\n > The funds to execute this attack do not need to come from a pool. It could be done as simply as malicious members pooling their funds in a flash loan contract, and each borrowing the funds in turn to vote.\n\n## [[H-06] Incorrect burn address in Vader.sol](https://github.com/code-423n4/2021-04-vader-findings/issues/202)\n\nThe `internal _transfer()` function is called from external facing `transfer()`, `transferFrom()`, and `transferTo()` functions all of which have different sender addresses. It is `msg.sender` for `transfer()`, sender parameter for `transferFrom()` and `tx.origin` for `transferTo()`.\n\nThese different senders are reflected in the sender parameter of `_transfer()` function. While this sender parameter is correctly used for transfer of tokens within `_transfer`, the call to `_burn()` on L129 incorrectly uses `msg.sender` as the burn address which is correct only in the case of the `transfer()` caller's context. This is incorrect for `transferFrom()` and `transferTo()` caller contexts.\n\nThis will incorrectly burn the fees from a different (intermediate contract) account for all users of the protocol interacting with the `transferTo()` and `transferFrom()` functions and lead to incorrect accounting of token balances or exceptional conditions. Protocol will break and lead to fund loss.\n\nRecommend changing L129 to: `_burn(sender, _fee);`\n\n**[strictly-scarce (vader) confirmed](https://github.com/code-423n4/2021-04-vader-findings/issues/202#issuecomment-830609535):**\n > Valid, disagree with severity though. Funds-not-at-risk.\n> Recommend: 2\n\n## [[H-07] Wrong `calcAsymmetricShare` calculation](https://github.com/code-423n4/2021-04-vader-findings/issues/214)\n\nThe inline-comment defines the number of asymmetric shares as `(u * U * (2 * A^2 - 2 * U * u + U^2))/U^3` but the `Utils.calcAsymmetricShare` function computes `(uA * 2U^2 - 2uU + u^2) / U^3` which is not equivalent as can be seen from the `A^2` term in the first term which does not occur in the second one.\n\nThe associativity on `P * part1` is wrong, and `part2` is not multiplied by `P`.\n\nThe math from the spec is not correctly implemented and could lead to the protocol being economically exploited, as the asymmetric share (which is used to determine the collateral value in base tokens) could be wrong. For example, it might be possible to borrow more than the collateral put up.\n\nRecommend clarifying if the comment or the code is correct and fix them if not.\n\n**[strictly-scarce (vader) confirmed](https://github.com/code-423n4/2021-04-vader-findings/issues/214#issuecomment-828468071):**\n > Valid\n\n**[strictly-scarce (vader) commented](https://github.com/code-423n4/2021-04-vader-findings/issues/214#issuecomment-830635568):**\n > Whilst the math is incorrect, in the current implementation it is not yet implemented, so disagree with Severity (funds not lost), recommend: 2\n\n## [[H-08] Wrong liquidity units calculation](https://github.com/code-423n4/2021-04-vader-findings/issues/204)\n\nThe spec defines the number of LP units to be minted as `units = (P (a B + A b))/(2 A B) * slipAdjustment = P * (part1 + part2) / part3 * slipAdjustments` but the `Utils.calcLiquidityUnits` function computes `((P * part1) + part2) / part3 * slipAdjustments`.\n\nThe associativity on `P * part1` is wrong, and `part2` is not multiplied by `P`.\n\nThe math from the spec is not correctly implemented and could lead to the protocol being economically exploited, as redeeming the minted LP tokens does not result in the initial tokens anymore.\n\nRecommend fixing the equation.\n\n**[strictly-scarce (vader) confirmed](https://github.com/code-423n4/2021-04-vader-findings/issues/204#issuecomment-830609695):**\n> Valid, but funds not at risk.\n\n## [[H-09] Incorrect initialization gives IL protection of only 1 second instead of 100 days in Router.sol](https://github.com/code-423n4/2021-04-vader-findings/issues/84)\n\nIncorrect initialization of `timeForFullProtection` to 1 sec instead of 8640000 secs (100 days) as indicated in code comments, appears to be a test setting mistakenly carried over for deployment. Therefore, unless `timeForFullProtection` is reset to 100 days by `setParams()` (calling this function is a missing functionality in the DAO currently), the Impermanent Loss (IL) protection \"rule\" of 100 days will not apply in `Utils.getProtection()`.\n\nThis breaks a key value proposition of the Vader protocol which is IL protection as indicated in the specification:\n> “Impermanent Loss Protection: The deposit value for each member is recorded when they deposit. When they go to withdraw, the redemption value is computed. If it is less than the deposit value, the member is paid the deficit from the reserve. The protection issued increases from 0 to 100% linearly for 100 days.”\n\nRecommend changing to ```“timeForFullProtection = 8640000; //100 days” ``` on L84\n\n**[strictly-scarce (vader) disputed](https://github.com/code-423n4/2021-04-vader-findings/issues/84#issuecomment-830597447):**\n> It's deliberately set to 1 second to conduct adequate testing.\n\n## [[H-10] Anyone can list anchors / curate tokens](https://github.com/code-423n4/2021-04-vader-findings/issues/211)\n\nThe `Router.listAnchor` function can be called by anyone and tokens can be added. The only check is that `require(iPOOLS(POOLS).isAnchor(token));` but this can easily be set by calling `Pools.addLiquidity(VADER, token, _)` once even without actually sending any tokens to the contract. This makes it an essentially useless check.\n\nThis only works initially as long as the `anchorLimit` has not been reached yet.\nHowever, the `replaceAnchor` can be used in the same way and flash loans can be used to get around the liquidity restrictions and push another anchor token out of the price range as these checks use the current reserves.\n\nAnchored pools are automatically curated pools and determine if a pool receives rewards. An attacker can remove rewards of a curated pool this way and add rewards to their own pool with a custom token they control.\n\nAfter a pool has been anchored through flash loans, liquidity can be withdrawn which could make the anchor price easy to manipulate in the next block and launch other attacks.\n\nRecommend revisiting the `_isAnchor[token] = true;` statement in `addLiquidity`, it seems strange without any further checks.\nConsider making `listAnchor` / `replaceAnchor` DAO-only functions and make them flash-loan secure.\nOne should probably use time-weighted prices for these pools for the bounds check.\n\n**[strictly-scarce (vader) disputed](https://github.com/code-423n4/2021-04-vader-findings/issues/211#issuecomment-828472672):**\n > The protocol is intended to be launched with 5 anchors so it can only be attacked by using `replaceAnchor()`, in which case slip-based fees apply for attacks and thwart the attack path.\n\n## [[H-11] Swap token can be traded as fake base token](https://github.com/code-423n4/2021-04-vader-findings/issues/205)\n\nThe `Pools.swap` function does not check if `base` is one of the base tokens. One can transfer `token`s to the pool and set `base=token` and call `swap(token, token, member, toBase=false)`\n\nThe `_actualInput = getAddedAmount(base, token);` will return the **token** amount added but use the ratio compared to the **base** reserve `calcSwapOutput(_actualInput=tokenInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]); = tokenIn / baseAmount * tokenAmount` which yields a wrong swap result.\n\nIt breaks the accounting for the pool as `token`s are transferred in, but the `base` balance is increased (and `token` balance decreased). LPs cannot correctly withdraw again, and others cannot correctly swap again.\n\nAnother example scenario is that the token pool amount can be stolen.\nSend `tokenIn=baseAmount` of tokens to the pool and call `swap(base=token, token, member, toBase=false)`. Depending on the price of `token` relative to `base` this could be cheaper than trading with the base tokens.\n\nRecommend checking that `base` is either `USDV` or `VADER`.\n\n**[strictly-scarce (vader) confirmed](https://github.com/code-423n4/2021-04-vader-findings/issues/205#issuecomment-830609893):**\n > Valid, funds can be lost\n\n## [[H-12] `getAddedAmount` can return wrong results](https://github.com/code-423n4/2021-04-vader-findings/issues/206)\n\nThe `getAddedAmount` function only works correctly when called with `(VADER/USDV, pool)` or `(pool, pool)`.\nHowever, when called with (`token, pool)` where `token` is neither `VADER/USDV/pool`, it returns the wrong results:\n\n1. It gets the `token` balance\n2. And subtracts it from the stored `mapToken_tokenAmount[_pool]` amount which can be that of a completely different token\n\nAnyone can break individual pairs by calling `sync(token1, token2)` where the `token1` balance is less than `mapToken_tokenAmount[token2]`. This will add the difference to `mapToken_tokenAmount[token2]` and break the accounting and result in a wrong swap logic.\n\nFurthermore, this can also be used to swap tokens without having to pay anthing with `swap(token1, token2, member, toBase=false)`.\n\nRecommend adding a require statement in the `else` branch that checks that `_token == _pool`.\n\n**[strictly-scarce (vader) confirmed](https://github.com/code-423n4/2021-04-vader-findings/issues/206#issuecomment-830610039):**\n > Valid, funds can be lost\n\n**[strictly-scarce (vader) commented](https://github.com/code-423n4/2021-04-vader-findings/issues/206#issuecomment-830610281):**\n > Would bundle this issue with:\n> https://github.com/code-423n4/2021-04-vader-findings/issues/205\n\n\n## [[H-13] 4 Synths can be minted with fake base token](https://github.com/code-423n4/2021-04-vader-findings/issues/207)\n\nThe `Pools.mintSynth` function does not check if `base` is one of the base tokens. One can transfer `token`s to the pool and set `base=token` and call `mintSynth(token, token, member)`.\n\nThe `_actualInput = getAddedAmount(base, token);` will return the **token** amount added but use the ratio compared to the **base** reserve `calcSwapOutput(_actualInput=tokenInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]); = tokenIn / baseAmount * tokenAmount` which yields a wrong swap result.\n\nIt breaks the accounting for the pool as `token`s are transferred in, but the `base` balance is increased.\n\nThe amount that is minted could also be inflated (cheaper than sending the actual base tokens), especially if `token` is a high-precision token or worth less than base.\n\nRecommend checking that `base` is either `USDV` or `VADER` in `mintSynth`.\n\n**[strictly-scarce (vader) confirmed](https://github.com/code-423n4/2021-04-vader-findings/issues/207#issuecomment-830610147):**\n > Valid, funds can be lost.\n\n**[strictly-scarce (vader) commented](https://github.com/code-423n4/2021-04-vader-findings/issues/207#issuecomment-830610260):**\n > would bundle this issue with:\n> https://github.com/code-423n4/2021-04-vader-findings/issues/205\n\n## [[H-14] Missing access restriction on `lockUnits/unlockUnits`](https://github.com/code-423n4/2021-04-vader-findings/issues/208)\n\nThe `Pool.lockUnits` allows anyone to steal pool tokens from a `member` and assign them to `msg.sender`. Anyone can steal pool tokens from any other user.\n\nRecommend adding access control and require that `msg.sender` is the router or another authorized party.\n\n**[strictly-scarce (vader) confirmed](https://github.com/code-423n4/2021-04-vader-findings/issues/208#issuecomment-828478127):**\n> Valid, although this is part of the partially-complete lending code.\n\n## [[H-15] Wrong slippage protection on Token -> Token trades](https://github.com/code-423n4/2021-04-vader-findings/issues/209)\nThe `Router.swapWithSynthsWithLimit` allows trading token to token and specifying slippage protection. A token to token trade consists of two trades:\n\n1. token to base\n2. base to token\n\nThe slippage protection of the second trade (base to token) is computed wrong:\n\n```solidity\nrequire(iUTILS(UTILS()).calcSwapSlip(\n    inputAmount, // should use outToken here from prev trade\n    iPOOLS(POOLS).getBaseAmount(outputToken)\n  ) <= slipLimit\n);\n```\n\nIt compares the **token** input amount (of the first trade) to the **base** reserve of the second pair.\n\nSlippage protection fails and either the trade is cancelled when it shouldn't be or it is accepted even though the user suffered more losses than expected.\n\nRecommend it should use the base output from the first trade to check for slippage protection. Note that this still just computes the slippage protection of each trade individually. An even better way would be to come up with a formula to compute the slippage on the two trades at once.\n\n**[strictly-scarce (vader) confirmed](https://github.com/code-423n4/2021-04-vader-findings/issues/209#issuecomment-828476313):**\n > Valid, although disagree with severity, the wrongly compute slip amount would just fail the trade or allow the second trade to go thru with no protection.\n\n**[Mervyn853 commented](https://github.com/code-423n4/2021-04-vader-findings/issues/209#issuecomment-830580592):**\n > Our decision matrix for severity:\n>\n> 0: No-risk: Code style, clarity, off-chain monitoring (events etc), exclude gas-optimisations\n> 1: Low Risk: UX, state handling, function incorrect as to spec\n> 2: Funds-Not-At-Risk, but can impact the functioning of the protocol, or leak value with a hypothetical attack path with stated assumptions, but external requirements\n> 3: Funds can be stolen/lost directly, or indirectly if a valid attack path shown that does not have handwavey hypotheticals.\n>\n> Recommended: 1\n\n## [[H-16] Tokens can be stolen through `transferTo`](https://github.com/code-423n4/2021-04-vader-findings/issues/217)\n\nI know that it's stated that:\n\n> VADER, USDV, SYNTHS all employ the `transferTo()` function, which interrogates for `tx.origin` and skips approvals. The author does not subscribe to the belief that this is dangerous\n\nIn my opinion, it can be very dangerous. Imagine the following scenario:\n\n1. I create a custom attacker ERC20 token that has a hook in the `_transfer` function that checks tx.origin for USDV/VADER/SYNTHS and calls `transferTo` to steal these funds.\n2. I set up a honeypot by providing liquidity to the `BASE <> ATTACKER` pool.\n3. I target high-profile accounts holdinging VADER/USDV/SYNTHS and airdrop them free tokens.\n4. Block explorers / Vader swap websites could show that this token has value and can be traded for actual `BASE` tokens.\n5. User wants to sell the airdropped `ATTACKER` token to receive valuable tokens through the Vader swap and has all their tokens (that are even completely unrelated to the tokens being swapped) stolen.\n\nIn general, a holder of any of the core assets of the protocol risks all their funds being stolen if they ever interact with an unvetted external contract/token.\nThis could even be completely unrelated to the VADER protocol.\n\nRecommend removing `transferTo` and use `permit` + `transferFrom` instead to move tokens from `tx.origin`.\n\n**[strictly-scarce (vader) acknowledged](https://github.com/code-423n4/2021-04-vader-findings/issues/217#issuecomment-828445128):**\n > This attack path has already been assessed as the most likely, no new information is being presented here.\n\n> Do not interact with attack contracts, interacting with an ERC20 is an attack contract.\n\n**[0xBrian commented](https://github.com/code-423n4/2021-04-vader-findings/issues/217#issuecomment-829142947):**\n > @strictly-scarce (vader) What would be the downside of adopting the suggested mitigation? Since we cannot communicate effectively with all users to tell them not to interact with certain kinds of contracts (and even if we could, they may not be able to discern which are OK and which aren't), we don't want to set up a thicket for fraudsters to operate. If the downside of the mitigation is not too bad, I think it could be worth it in order to deny fraudsters an opportunity to steal.\n\n**[Mervyn853 commented](https://github.com/code-423n4/2021-04-vader-findings/issues/217#issuecomment-830582387):**\n > Our decision matrix for severity:\n>\n> 0: No-risk: Code style, clarity, off-chain monitoring (events etc), exclude gas-optimisations\n> 1: Low Risk: UX, state handling, function incorrect as to spec\n> 2: Funds-Not-At-Risk, but can impact the functioning of the protocol, or leak value with a hypothetical attack path with stated assumptions, but external requirements\n> 3: Funds can be stolen/lost directly, or indirectly if a valid attack path shown that does not have handwavey hypotheticals.\n>\n> Recommended: 0\n\n## [[H-17] Transfer fee is burned on wrong accounts](https://github.com/code-423n4/2021-04-vader-findings/issues/220)\n\nThe `Vader._transfer` function burns the transfer fee on `msg.sender` but this address might not be involved in the transfer at all due to `transferFrom`.\n\nSmart contracts that simply relay transfers like aggregators have their Vader balance burned or the transaction fails because these accounts don't have any balance to burn, breaking the functionality.\n\nRecommend that It should first increase the balance of `recipient` by the full amount and then burn the fee on the `recipient`.\n\n**[strictly-scarce (vader) confirmed](https://github.com/code-423n4/2021-04-vader-findings/issues/220#issuecomment-828463080):**\n > For composabilty with the rest of the ecosystem, this should be addressed, although disagree with the severity, no funds are lost, just the aggregrator cannot transfer unless they first transfer to themselves, which most often do.\n\n**[Mervyn853 commented](https://github.com/code-423n4/2021-04-vader-findings/issues/220#issuecomment-830582199):**\n > Our decision matrix for severity:\n>\n> 0: No-risk: Code style, clarity, off-chain monitoring (events etc), exclude gas-optimisations\n> 1: Low Risk: UX, state handling, function incorrect as to spec\n> 2: Funds-Not-At-Risk, but can impact the functioning of the protocol, or leak value with a hypothetical attack path with stated assumptions, but external requirements\n> 3: Funds can be stolen/lost directly, or indirectly if a valid attack path shown that does not have handwavey hypotheticals.\n>\n> Recommended: 2\n\n## [[H-18]  Vault rewards can be gamed](https://github.com/code-423n4/2021-04-vader-findings/issues/222)\n\nThe `_deposit` function increases the member's _weight_ by `_weight = iUTILS(UTILS()).calcValueInBase(iSYNTH(_synth).TOKEN(), _amount);` which is the swap output amount when trading the deposited underlying synth amount.\n\nNotice that anyone can create synths of custom tokens by calling `Pools.deploySynth(customToken)`.\n\nTherefore an attacker can deposit valueless custom tokens and inflate their member weight as follows:\n\n1. Create a custom token and issue lots of tokens to the attacker\n2. Create synth of this token\n3. Add liquidity for the `TOKEN <> BASE` pair by providing a single wei of `TOKEN` and `10^18` BASE tokens. This makes the `TOKEN` price very expensive.\n4. Mint some synths by paying BASE to the pool\n5. Deposit the fake synth, `_weight` will be very high because the token pool price is so high.\n\nCall `harvest(realSynth)` with a synth with actual value. This will increase the synth balance and it can be withdrawn later.\n\nAnyone can inflate their member weight through depositing a custom synth and earn almost all vault rewards by calling `harvest(realSynth)` with a valuable \"real\" synth.\nThe rewards are distributed pro rata to the member weight which is independent of the actual synth deposited.\n\nThe `calcReward` function completely disregards the `synth` parameter which seems odd.\nRecommend thinking about making the rewards based on the actual synths deposited instead of a \"global\" weight tracker.\nAlternatively, whitelist certain synths that count toward the weight, or don't let anyone create synths.\n\n**[strictly-scarce (vader) confirmed](https://github.com/code-423n4/2021-04-vader-findings/issues/222#issuecomment-828453323):**\n > This is a valid attack path.\n>\n> The counter is two fold:\n>\n> 1) In the vault, `require(isCurated(token))` this will only allow synths of curated tokens to be deposited for rewards. [The curation logic ](https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L234) does a check for liquidity depth, so only deep pools can become synths. Thus an attacker would need to deposit a lot of BASE.\n>\n> 2) In the vaults, use `_weight = iUTILS(UTILS()).calcSwapValueInBase(iSYNTH(_synth).TOKEN(), _amount);`, which computes the weight with respect to slip, so a small manipulated pool cannot be eligible. The pool would need to be deep.\n>\n> ---\n>\n> The Vault converts all synths back to common accounting asset - USDV, so member weight can be tracked.\n>\n**[strictly-scarce (vader) commented](https://github.com/code-423n4/2021-04-vader-findings/issues/222#issuecomment-830635200):**\n > Disagree with severity, since the daily rewards can be claimed by anyone in a fee-bidding war but no actual extra inflation occurs.\n>\n> Severity: 2\n\n## [[H-19] Vault rewards last claim time not always initialized](https://github.com/code-423n4/2021-04-vader-findings/issues/223)\n\nThe `harvest` calls `calcCurrentReward` which computes `_secondsSinceClaim = block.timestamp - mapMemberSynth_lastTime[member][synth];`.  As one can claim different synths than the synths that they deposited, `mapMemberSynth_lastTime[member][synth]` might still be uninitialized and the `_secondsSinceClaim` becomes the current block timestamp.\n\nThe larger the `_secondsSinceClaim` the larger the rewards.\nThis bug allows claiming a huge chunk of the rewards.\n\nRecommend letting users only harvest synths that they deposited.\n\n**[strictly-scarce (vader) confirmed](https://github.com/code-423n4/2021-04-vader-findings/issues/223#issuecomment-828461277):**\n > This is valid.\n>\n> The member should only claim against synths they have deposited, where the time would be initialised.\n>\n\n**[strictly-scarce (vader) commented](https://github.com/code-423n4/2021-04-vader-findings/issues/223#issuecomment-830635006):**\n > Would place this as severity: 2, since the anyone can participate in claiming rewards, but no extra inflation occurs.\n\n\n## [[H-20] Vault Weight accounting is wrong for withdrawals](https://github.com/code-423n4/2021-04-vader-findings/issues/224)\n\n\nWhen depositing two different synths, their weight is added to the same `mapMember_weight[_member]` storage variable.\nWhen withdrawing the full amount of one synth with `_processWithdraw(synth, member, basisPoints=10000` the full weight is decreased.\n\nThe second deposited synth is now essentially weightless.\n\nUsers that deposited more than one synth can not claim their fair share of rewards after a withdrawal.\n\nRecommed that the weight should be indexed by the synth as well.\n\n**[strictly-scarce (vader) confirmed](https://github.com/code-423n4/2021-04-vader-findings/issues/224#issuecomment-828457510):**\n > This is valid.\n>\n> The weight should be reduced only as applied to a specific synth\n>\n> There is no loss of funds, just less rewards for that member, disputing severity level.\n\n**[Mervyn853 commented](https://github.com/code-423n4/2021-04-vader-findings/issues/224#issuecomment-830578796):**\n > Our decision matrix for severity:\n>\n> 0: No-risk: Code style, clarity, off-chain monitoring (events etc), exclude gas-optimisations\n> 1: Low Risk: UX, state handling, function incorrect as to spec\n> 2: Funds-Not-At-Risk, but can impact the functioning of the protocol, or leak value with a hypothetical attack path with stated assumptions, but external requirements\n> 3: Funds can be stolen/lost directly, or indirectly if a valid attack path shown that does not have handwavey hypotheticals.\n>\n> Recommended: 2\n\n**[dmvt (judge) commented](https://github.com/code-423n4/2021-04-vader-findings/issues/224#issuecomment-849037439):**\n > My viewpoint on this and the last several reward based high risk issues is that loss of rewards is loss of funds. High risk is appropriate.\n\n\n## [[H-21] Anyone Can Avoid All Vether Transfer Fees By Adding Their Address to the Vether `ExcludedAddresses` List.](https://github.com/code-423n4/2021-04-vader-findings/issues/189)\n\n`Vether.sol` implements a fee on every token transfer, unless either the sender or the recipient exists on a list of excluded addresses `(mapAddress_Excluded)`. However, the `addExcluded()` function in `Vether.sol` has no restrictions on who can call it.\nSo any user can call `addExcluded` with their own address as the argument, and bypass all transfer fees.\n\nAlice calls:\n\n(1) ```Vether.addExcluded(aliceAddress)```, which adds Alice's address to `mapAddress_Excluded`.\n(2) Alice can now freely transfer Vether with no fees.\n\nRecommend adding restrictions to who can call `addExcluded`, perhaps by restricting it to a caller set by `DAO.sol`\n\n**[strictly-scarce (vader) commented](https://github.com/code-423n4/2021-04-vader-findings/issues/189#issuecomment-830609051):**\n > Vether contract is outside of contest\n\n**[dmvt (judge) commented](https://github.com/code-423n4/2021-04-vader-findings/issues/189#issuecomment-849162113):**\n > https://github.com/code-423n4/2021-04-vader-findings/issues/3#issuecomment-849043144\n>\n> > The warden should be paid out on this issue, in my opinion, because the code was included in the repo to be reviewed. The work to review the contract was done despite the fact that the team has addressed the issue and has already deployed `vether.sol`. I do not think that any issues related to `Vether.sol` should be included in the final report generated by @code423n4.\n>\n> It was unclear to me (and obviously most of the wardens) that `Vether.sol` was considered out of scope.\n\n**moneylegobatman (C4 Editor) commented:**\n> Leaving report and discussion in for transparency, since finding was awarded.\n\n## [[H-22] Users may unintentionally remove liquidity under a phishing attack.](https://github.com/code-423n4/2021-04-vader-findings/issues/316)\nThe `removeLiquidity` function in `Pools.sol` uses `tx.origin` to determine the person who wants to remove liquidity. However, such a design is dangerous since the pool assumes that this function is called from the router, which may not be true if the user is under a phishing attack, and he could unintentionally remove liquidity.\n\nReferenced code: [Pool.sol#L77-L79](https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Pools.sol#L77-L79)\n\nRecommend consider making the function `_removeLiquidity` external, which can be utilized by the router, providing information of which person removes his liquidity.\n\n**[strictly-scarce (vader) acknowledged](https://github.com/code-423n4/2021-04-vader-findings/issues/316#issuecomment-830571343):**\n > If a user has been phished, consider all their funds already stolen.\n\n> Vader's security assumption is a user is not phished.\n\n**[Mervyn853 commented](https://github.com/code-423n4/2021-04-vader-findings/issues/316#issuecomment-830578243):**\n > Our decision matrix for severity:\n>\n> 0: No-risk: Code style, clarity, off-chain monitoring (events etc), exclude gas-optimisations\n> 1: Low Risk: UX, state handling, function incorrect as to spec\n> 2: Funds-Not-At-Risk, but can impact the functioning of the protocol, or leak value with a hypothetical attack path with stated assumptions, but external requirements\n> 3: Funds can be stolen/lost directly, or indirectly if a valid attack path shown that does not have handwavey hypotheticals.\n>\n> Recommended: 0\n\n**[dmvt (judge) commented](https://github.com/code-423n4/2021-04-vader-findings/issues/316#issuecomment-849061196):**\n > This is reasonably easy to mitigate as an issue and failure to do so does leave an attack vector open. If exploited it will result in a loss of user funds.\n\n## [[H-23] Anyone can curate pools and steal rewards](https://github.com/code-423n4/2021-04-vader-findings/issues/210)\n\nThe `Router.curatePool` and `replacePool` don't have any access restriction.\nAn attacker can get a flash loan of base tokens and replace existing curated pools with their own curated pools.\n\nCurated pools determine if a pool receives rewards. An attacker can remove rewards of a curated pool this way and add rewards to their own pool with a custom token they control.\nThey can then go ahead and game the reward system by repeatedly swapping in their custom pool with useless tokens, withdraw liquidity, and in the end, pay back the base flashloan.\n\nRecommend preventing the replacing of curations through flash loans. Also, consider making pool curations DAO-exclusive actions.\n\n**[strictly-scarce (vader) disputed](https://github.com/code-423n4/2021-04-vader-findings/issues/210#issuecomment-828473380):**\n > Slip-based pools cannot be attacked with flash loans.\n\n**[dmvt (judge) commented](https://github.com/code-423n4/2021-04-vader-findings/issues/210#issuecomment-849131582):**\n > Further comment from @cmichelio:\n>\n> I can curate my custom token using `curatePool` without using a flashloan or using replacePool by temporarily providing liquidity to the pool without trading in it and getting slip-fee'd. I'm not trading in the pool, and don't think providing/removing liquidity comes with a fee. I think this is still an issue.\n\n## [[H-25] Incorrect initialization causes VADER emission rate of 1 second instead of 1 day in Vader.sol](https://github.com/code-423n4/2021-04-vader-findings/issues/155)\n\nIncorrect initialization (perhaps testing parameterization mistakenly carried over to deployment) of `secondsPerEra` to 1 sec instead of 86400 secs (1 day) causes what should be the daily emission rate to be a secondly emission rate.\n\nThis causes inflation of VADER token and likely breaks VADER<>USDV peg and other protocol invariants. Protocol will break and funds will be lost.\n\nRecommend Initializing `secondsPerEra` to 86400 on L67.\n\n**[strictly-scarce (vader) acknowledged](https://github.com/code-423n4/2021-04-vader-findings/issues/155#issuecomment-830606416):**\n > This is purely for testing purposes.\n\n# Medium Risk Findings\n## [[M-01] User may not get IL protection if certain functions are called directly in `Pools.sol`](https://github.com/code-423n4/2021-04-vader-findings/issues/120)\n\nFunctions `removeLiquidity()` and `removeLiquidityDirectly()` when called directly, do not provide the the user with IL protection unlike when calling the corresponding `removeLiquidity()` function in `Router.sol`. This should be prevented, at least for `removeLiquidity()` or highlighted in the specification and user documentation.\n\nRecommend adding access control (e.g. via a modifier `onlyRouter`) so `removeLiquidity()` function of Pools contract can be called only from corresponding Router contract’s `removeLiquidity()` function which provides IL protection. Alternatively, highlight in the specification and user documentation about which contract interfaces provide IL protection to users.\n\n**[strictly-scarce (vader) acknowledged](https://github.com/code-423n4/2021-04-vader-findings/issues/120#issuecomment-830613596):**\n > User should use the Router, as designed.\n\n## [[M-02] Undefined behavior for DAO and GRANT vote proposals in `DAO.sol`](https://github.com/code-423n4/2021-04-vader-findings/issues/183)\n\nGiven that there are only three proposal types (GRANT, UTILS, REWARD) that are actionable, it is unclear if 'DAO' type checked in `voteProposal()` is a typographical error and should really be 'GRANT'. Otherwise, GRANT proposals will only require quorum (33%) and not majority (50%).\n\nRecommend changing ‘DAO’ on L83 to ‘GRANT’ or if not, specify what DAO proposals are and how GRANT proposals should be handled with quorum or majority.\n\nAlso, check and enforce that `mapPID_types` are only these three actionable proposal types: GRANT, UTILS, REWARD.\n\n**[strictly-scarce (vader) acknowledged](https://github.com/code-423n4/2021-04-vader-findings/issues/183#issuecomment-830615194):**\n > DAO not yet fully implemented\n\n## [[M-03] Lack of input validation in `replacePool()` allows curated pool limit bypass in `Router.sol`](https://github.com/code-423n4/2021-04-vader-findings/issues/87)\n\nThere is no input validation in `replacePool()` function to check if `oldToken` exists and is curated. Using a non-existing `oldToken` (even 0 address) passes the check on L236 (because `Pools.getBaseAmount()` will return 0 for the non-existing token) and `newToken` will be made curated. This can be used to bypass the `curatedPoolLimit` enforced only in `curatePool() function`.\n\nRecommend checking if `oldToken` exists and is curated as part of input validation in `replacePool()` function.\n\n**[strictly-scarce (vader) confirmed](https://github.com/code-423n4/2021-04-vader-findings/issues/87#issuecomment-830613505):**\n > Valid\n\n## [[M-04] `flashProof` is not flash-proof](https://github.com/code-423n4/2021-04-vader-findings/issues/218)\n\nThe `flashProof` modifier is supposed to prevent flash-loan attacks by disallowing performing several sensitive functions in the same block.\n\nHowever, it performs this check on `tx.origin` and not on an individual user address basis. This only prevents flash loan attacks from happening within a single transaction.\n\nBut flash loan attacks are theoretically not limited to the same transaction but to the same block as miners have full control of the block and include several vulnerable transactions back to back. (Think transaction _bundles_ similar to flashbot bundles that most mining pools currently offer.)\n\nA miner can deploy a proxy smart contract relaying all contract calls and call it from a different EOA each time bypassing the `tx.origin` restriction.\n\nThe `flashProof` modifier does not serve its purpose.\n\nRecommend trying to apply the modifier to individual addresses that interact with the protocol instead of `tx.origin`.\n\nFurthermore, attacks possible with flash loans are usually also possible for whales, making it debatable if adding flash-loan prevention logic is a good practice.\n\n**[strictly-scarce (vader) confirmed](https://github.com/code-423n4/2021-04-vader-findings/issues/218#issuecomment-830616044):**\n > Flash loans with the help of miners *was not intended to be countered*, although a check for `msg.sender` AND `tx.origin` will be applied.\n\n## [[M-05] Interest debt is capped after a year](https://github.com/code-423n4/2021-04-vader-findings/issues/219)\n\nThe `Utils.getInterestOwed` function computes the `_interestPayment` as:\n\n```solidity\nuint256 _interestPayment =\n  calcShare(\n      timeElapsed,\n      _year,\n      getInterestPayment(collateralAsset, debtAsset)\n  ); // Share of the payment over 1 year\n```\n\nHowever, `calcShare` caps `timeElpased` to `_year` and therefore the owed interest does not grow after a year has elapsed.\n\nThe impact is probably small because the only call so far computes the elapsed time as `block.timestamp - mapCollateralAsset_NextEra[collateralAsset][debtAsset];` which most likely will never go beyond a year.\n\nIt's still recommended to fix the logic bug in case more functions will be added that use the broken function.\n\nRecommend using a different function than `calcShare` that does not cap.\n\n**[strictly-scarce (vader) confirmed](https://github.com/code-423n4/2021-04-vader-findings/issues/219#issuecomment-830616264):**\n > A member who doesn't interact with the contract for more than a year misses out on some rewards, so severity:1\n\n## [[M-06] Canceled proposals can still be executed](https://github.com/code-423n4/2021-04-vader-findings/issues/228)\n\nProposals that passed the threshold (\"finalized\") can be cancelled by a minority again using the `cancelProposal` functions.\nIt only sets `mapPID_votes` to zero but `mapPID_timeStart` and `mapPID_finalising` stay the same and pass the checks in `finaliseProposal` which queues them for execution.\n\nProposals cannot be cancelled.\n\nRecommend setting a cancel flag and check for it in `finaliseProposal` and in execution.\n\n**[strictly-scarce (vader) confirmed](https://github.com/code-423n4/2021-04-vader-findings/issues/228#issuecomment-830616938):**\n > Valid\n\n## [[M-07] Completed proposals can be voted on and executed again](https://github.com/code-423n4/2021-04-vader-findings/issues/229)\n\nA proposal that is completed has its state reset, including the votes.\nUsers can just vote on it again and it can be executed again.\n\nCompleted proposals should most likely not be allowed to be voted on / executed again.\nThis could also lead to issues in backend scripts that don't expect any voting/execution events to be fired again after the `FinalisedProposal` event has fired.\n\nRecommend adding an `executed` flag to the proposals and disallow voting/finalising on already executed proposals.\n\n**[strictly-scarce (vader) disputed](https://github.com/code-423n4/2021-04-vader-findings/issues/229#issuecomment-830617230):**\n > It might be intended to have repeated proposals.\n\n## [[M-09] Divide before multiply](https://github.com/code-423n4/2021-04-vader-findings/issues/255)\n\nHere you have more information: https://gist.github.com/alexon1234/e5038a9f66136ae210be692f8803d874\n\n**[strictly-scarce (vader) questioned](https://github.com/code-423n4/2021-04-vader-findings/issues/255#issuecomment-830631408):**\n > Can't quite understand the assertion that a division is made before a multiply in the code outlined\n>\n> ```\n> uint _units = (((P * part1) + part2) / part3);\n>     return (_units * slipAdjustment) / one;  // Divide by 10**18\n>  ```\n>\n>  `_units` will be `0 -> 2**256`.\n>  `slipAdjustment` will be `0 -> 10**18`\n>  `one` is `10**18`\n>  ```\n>  // returns 0\n>   return (0 * 10**18) / 10**18;\n>   return (2**256 * 0) / 10**18;\n>  return (<10**9 * <10**9) / 10**18;\n>    // returns  non-zero\n>   return (>=10**9 * >=10**9) / 10**18;\n>  ```\n\n## [[M-10] Incorrect operator used in `deploySynth()` of `Pools.sol`](https://github.com/code-423n4/2021-04-vader-findings/issues/124)\n\nThe `deploySynth()` function in `Pools.sol` is expected to perform a check on the token parameter to determine that it is neither VADER or USDV before calling Factory’s `deploySynth()` function.\n\nHowever, the `require()` incorrectly uses the ‘||’ operator instead of ‘&&’ which allows both VADER and USDV to be supplied as the token parameters. This will allow an attacker to deploy either VADER or USDV as a Synth which will break assumptions throughout the entire protocol. Protocol will break and funds may be lost.\n\nRecommend changing ‘||’ operator to ‘&&’ in the require statement:\n```require(token != VADER && token != USDV);```\n\n**[strictly-scarce (vader) addressed](https://github.com/code-423n4/2021-04-vader-findings/issues/124#issuecomment-830601704):**\n > Duplicate\n> https://github.com/code-423n4/2021-04-vader-findings/issues/21\n\n**[0xBrian commented](https://github.com/code-423n4/2021-04-vader-findings/issues/124#issuecomment-837805692):**\n > https://github.com/vetherasset/vaderprotocol-contracts/pull/159/commits/2f69f8317ce98846fbe227a3bf6ca1b644d01ff2#diff-5de3130299a0ddc914d7a906802a4cc093ed18d7a89c52a4aafefc8a11ac3f54R193\n\n\n## [[M-11] Allowing duplicated anchors could cause bias on anchor price.](https://github.com/code-423n4/2021-04-vader-findings/issues/314)\n\nIn `Router.sol`, the setup of the five anchors can be interrupted by anyone adding a new anchor due to the lack of access control of the `listAnchor` function. Also, duplicate anchors are allowed. If the same anchor is added three times, then this anchor biases the result of `getAnchorPrice`.\n\nReferenced code:\n[Router.sol#L245-L252](https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L245-L252)\n\nPoC: [Link to PoC](https://drive.google.com/drive/folders/1W3jhlWIIh7FxTLZET3z49yA0DBvlbcPg?usp=sharing)\nSee the file `200_listAnchor.js` for a PoC of this attack. To run it, use `npx hardhat test 200_listAnchor.js`.\n\nRecommend only allowing `listAnchor` to be called from the deployer by adding a `require` statement. Also, check if an anchor is added before by `require(_isCurated == false)`.\n\n**[strictly-scarce (vader) acknowledged](https://github.com/code-423n4/2021-04-vader-findings/issues/314#issuecomment-830633778):**\n > Deployer will list the anchors, seems highly unlikely they will get griefed in practice. Severity: 1\n\n## [[M-12] Transfer fee avoidance ](https://github.com/code-423n4/2021-04-vader-findings/issues/33)\n\nThe `Vether4.addExcluded()` function on mainnet (0x4Ba6dDd7b89ed838FEd25d208D4f644106E34279) allows a user to exclude an address from transfer fees for a cost of 128 VETH. By exploiting the conditions in which fees are taken, it is possible to set up a contract for a once-off cost in which all users can use to avoid transfer fees.\n\n#All transfer fees can be avoided by routing transfers through an excluded contract. An estimated \\$140k of transfer fees was accumulated at the time of writing. These fees can be avoided in future, causing an indirect loss of funds for the contract.\n\nRecommend that the `_transfer()` function should be updated to only exclude transfer fees if the sender has been excluded, not both the sender and the recipient. This would prevent any user from being able to set up a central transfer forwarder as demonstrated. Moreover, the `Transfer(_from, address(this), _fee);` event should only be emitted if the sender has been excluded from transfer fees.\n\n**[strictly-scarce (vader) disputed](https://github.com/code-423n4/2021-04-vader-findings/issues/33)**\n\n## [[M-13] Init function can be called by everyone](https://github.com/code-423n4/2021-04-vader-findings/issues/18)\n\nMost of the solidity contracts have an init function that everyone can call.\nThis could lead to a race condition when the contract is deployed. At that moment a hacker could call the `init` function and make the deployed contracts useless. Then it would have to be redeployed, costing a lot of gas.\n\n```\nDAO.sol:    function init(address _vader, address _usdv, address _vault) public {\nFactory.sol:    function init(address _pool) public {\nPools.sol:    function init(address _vader, address _usdv, address _router, address _factory) public {\nRouter.sol:    function init(address _vader, address _usdv, address _pool) public {\nUSDV.sol:    function init(address _vader, address _vault, address _router) external {\nUtils.sol:    function init(address _vader, address _usdv, address _router, address _pools, address _factory) public {\nVader.sol:    function init(address _vether, address _USDV, address _utils) external {\nVault.sol:    function init(address _vader, address _usdv, address _router, address _factory, address _pool) public {\n```\n\nRecommend adding a check to the `init` function, for example that only the deployer can call the function.\n\n**[strictly-scarce (vader) confirmed](https://github.com/code-423n4/2021-04-vader-findings/issues/18#issuecomment-826910451):**\n > Yes, but only once. Could add a deployer check tho\n\n**[dmvt (judge) commented](https://github.com/code-423n4/2021-04-vader-findings/issues/18#issuecomment-847760153):**\n > After considerable evaluation and seeing the wide range of threat factors that were put forward by wardens related to this issue, I've decided that the potential threat here does extend beyond gas.\n>\n> A worst case scenario could cause significant damage.\n>\n> It is extremely unlikely that an attacker could successfully time this type of attack.\n>\n> An attacker would have to successfully intercept more than one init due to the highly coupled nature of the contract. If they did so incorrectly, the entire system would not function. Presuming they succeeded, the team would also have to overlook the failure of or forget to make multiple critical transaction calls in their deployment scripts. To realize significant financial gains, the attacker would have to leave their exploit code in place for an extended period of time.\n>\n> The likelihood is extremely low, but the impact would be critical. For this reason, I'm normalizing all of these reports to a Medium Risk.\n\n## [[M-14] Pool functions can be called before initialization in _`init_()` of Pools.sol](https://github.com/code-423n4/2021-04-vader-findings/issues/114)\n\nAll the external/public functions of `Pools.sol` can be called by other contracts even before `Pools.sol`contract is initialized. This can lead to exceptions, state corruption or incorrect accounting in other contracts, which may require redeployment of said contract.\n\nRecommend using a factory pattern that will deploy and initialize atomically to prevent front-running of the initialization,\n\nOR\n\nGiven that contracts are not using `delegatecall` proxy pattern, it is not required to use a separate `init()` function to initialize parameters when the same can be done in a constructor. If the reason for doing so is to get the deployment addresses of the various contracts, which may not all be available at the same time, then consider rearchitecting to create a “globals” contract which can hold all the globally required addresses of various contracts. see [Maple protocol’s](https://github.com/maple-labs/maple-core/blob/develop/contracts/MapleGlobals.sol) for example.\n\nOR\n\nPrevent external/public functions from being called until after initialization is done by checking initialization state tracked by the inited variable.\n\n**[strictly-scarce (vader) dipsuted](https://github.com/code-423n4/2021-04-vader-findings/issues/114#issuecomment-830598388):**\n > https://github.com/code-423n4/2021-04-vader-findings/issues/39\n\n**[dmvt (judge) commented](https://github.com/code-423n4/2021-04-vader-findings/issues/114#issuecomment-847769580):**\n > Same general comments apply to this issue as with issue #18, but it is a separate type of exploit that would be slightly less detectable. This increase in risk is balanced against the exploit being much harder to effect and the likely impact being lower.\n\n## [[M-15] `changeDAO` should be a two-step process in Vader.sol](https://github.com/code-423n4/2021-04-vader-findings/issues/162)\n\n`changeDAO()` updates DAO address in one-step. If an incorrect address is mistakenly used (and voted upon) then future administrative access or recovering from this mistake is prevented because `onlyDAO` modifier is used for `changeDAO()`, which requires `msg.sender` to be the incorrectly used DAO address (for which private keys may not be available to sign transactions). See [finding #6 from Trail of Bits audit of Hermez Network](https://github.com/trailofbits/publications/blob/master/reviews/hermez.pdf).\n\nRecommend using a two-step process where the old DAO address first proposes new ownership in one transaction; and then, accepts ownership from the newly proposed DAO address in a second transaction. A mistake in the first step can be recovered by granting with a new correct address again before the new DAO address accepts ownership. Ideally, there should also be a timelock enforced before the new DAO takes effect.\n\n**[strictly-scarce (vader) confirmed](https://github.com/code-423n4/2021-04-vader-findings/issues/162#issuecomment-830607270):**\n > A lot has to go wrong to get to this point, so disagree with severity (funds not at risk).\n>\n> Two step-process seems wise though.\n\n**[dmvt (judge) commented](https://github.com/code-423n4/2021-04-vader-findings/issues/162#issuecomment-847850118):**\n > Risk lowered because of the extremely low probability\n\n## [[M-16] Copy-paste bug leading to incorrect harvest rewards in Vault.sol](https://github.com/code-423n4/2021-04-vader-findings/issues/51)\n\nThe conditional in `calcReward()` function uses the same code in both if/else parts with repeated use of `reserveUSDV`, `reserveVADER` and `getUSDVAmount` leading to incorrect computed value of `_adjustedReserve` in the else part.\n\nThis will affect harvest rewards for all users of the protocol and lead to incorrect accounting. Protocol will break and lead to fund loss.\n\nRecommend changing variables and function calls from using USDV to VADER in the else part of the conditional which has to return the adjusted reserves when synth is not an asset i.e. an anchor and therefore base is VADER. L144 should be changed to:\n```uint _adjustedReserve = iROUTER(ROUTER).getVADERAmount(reserveUSDV()) + reserveVADER();```\n\n**[strictly-scarce (vader) confirmed](https://github.com/code-423n4/2021-04-vader-findings/issues/51#issuecomment-830576589):**\n > Funds are not at-risk, just that some users will get less rewards, some will get more.\n>\n> Recommend: 2\n\n**[Mervyn853 commented](https://github.com/code-423n4/2021-04-vader-findings/issues/51#issuecomment-830582964):**\n > Our decision matrix for severity:\n>\n> 0: No-risk: Code style, clarity, off-chain monitoring (events etc), exclude gas-optimisations\n> 1: Low Risk: UX, state handling, function incorrect as to spec\n> 2: Funds-Not-At-Risk, but can impact the functioning of the protocol, or leak value with a hypothetical attack path with stated assumptions, but external requirements\n> 3: Funds can be stolen/lost directly, or indirectly if a valid attack path shown that does not have handwavey hypotheticals.\n>\n> Recommended: 2\n\n## [[M-17] `Vader.redeemToMember()` vulnerable to front running](https://github.com/code-423n4/2021-04-vader-findings/issues/36)\n\nThe USDV balance of the Vader contract is vulnerable to theft through the `Vader.redeemToMember()` function. A particular case is through USDV redemption front-running. Users can redeem USDV for Vader through the `USDV.redeemForMember()` function or the `Vader.redeemToMember()` function. In the case of `Vader.redeemToMember()`, a user would need to send their USDV to the contract before redemption. However, as this process does not happen in a single call, the victim's call is vulnerable to front running and could have their redeemed USDV stolen by an attacker.\n\nUser's redeem USDV could be stolen by an attacker front running their `Vader.redeemToMember()` call.\n\nThe steps are as follows:\n\n1) User sends USDV to Vader contract to be redeemed\n2) User calls `Vader.redeemToMember()`\n3) The `Vader.redeemToMember()` call is detected by an attacker, who front-runs the call by calling `Vader.redeemToMember()` specifying their own address as the member parameter.\n4) The full USDV balance of the Vader contract is redeemed and sent to the attacker.\n\nNote that while this particular case is front running a redemption call, any USDV balance could be stolen in this manner. Please find the POC showing the above steps here: https://gist.github.com/toastedsteaksandwich/39bfed78b21d7e6c02fe13ea5b2023c3\n\n\nRecommend that the `Vader.redeemToMember()` function should be restricted so that only the USDV contract can call it. Moreover, the amount parameter from `USDV.redeem()` or `USDV.redeemForMember()` should also be passed to `Vader.redeemToMember()` to avoid the need to sweep the entire USDV balance. In this way, the member's redemption happens in a single tx, and would only be allocated as much Vader as redeemed in USDV.\n\n**[strictly-scarce (vader) disputed](https://github.com/code-423n4/2021-04-vader-findings/issues/36#issuecomment-827577253):**\n > Vader complies with a monetary security policy of \"money in, money out\". Contracts will only send out funds if they are first sent funds.\n>\n> This is the case for the entire system, not just `Vader.redeemToMember()`, such as swaps and adding liquidity. Vader is not designed to be interacted with directly, it should be wrapped. In this case, users should convert and redeem only thru the USDV contract, which first sends funds.\n>\n> Incidentally this is the same mechanism that uniswap employs for withdrawing liquidity, or syncing funds to balances. You can also get front-runned if you do it in two tx, it should be wrapped in 1 tx.\n\n**[Mervyn853 commented](https://github.com/code-423n4/2021-04-vader-findings/issues/36#issuecomment-830582247):**\n > Our decision matrix for severity:\n>\n> 0: No-risk: Code style, clarity, off-chain monitoring (events etc), exclude gas-optimisations\n> 1: Low Risk: UX, state handling, function incorrect as to spec\n> 2: Funds-Not-At-Risk, but can impact the functioning of the protocol, or leak value with a hypothetical attack path with stated assumptions, but external requirements\n> 3: Funds can be stolen/lost directly, or indirectly if a valid attack path shown that does not have handwavey hypotheticals.\n>\n> Recommended: 0\n\n# Low Risk Findings\n## [[L-01] Missing event for critical `init()` function in Factory.sol](https://github.com/code-423n4/2021-04-vader-findings/issues/108)\n\nThe `init()` function initializes critical POOLS protocol address for this contract but is missing an event emission for off-chain monitoring tools to monitor this on-chain change.\n\nRecommend adding an init event and emit that at the end of `init()` function.\n\n## [[L-02] Uninitialized variable leads to zero-fees for first transfer in `Vader.sol`](https://github.com/code-423n4/2021-04-vader-findings/issues/203)\n\nThe state variables `feeOnTransfer` is never initialized which leads to a default uint value of 0. When it is used on L126 in the first call to `_transfer()`, it will lead to a zero fee. `feeOnTransfer` is updated only in function `_checkEmission()` whose call happens later on [L133](https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vader.sol#L133), after which it has a value as calculated in that function. This causes only the first transfer to be a zero-fee transfer.\n\nRecommend initializing `feeOnTransfer` suitably on declaration, in constructor, or `init()` function.\n\n## [[L-03] Misleading comment for `deposit()` function of `Vault.sol`](https://github.com/code-423n4/2021-04-vader-findings/issues/48)\n\nUse of accurate comments helps users read, audit and maintain code. Inaccurate comments can be misleading, obstruct the flagging of vulnerabilities, or even introduce them.\n\nMisleading comment on [L76](https://github.com/code-423n4/2021-04-vader/blob/3041f20c920821b89d01f652867d5207d18c8703/vader-protocol/contracts/Vault.sol#L76-L77) that says `deposit()` function allows USDV and Synths, but the code only allows Synths.\n\nRecommend using accurate and descriptive comments (even NatSpec) correctly describing the function behavior, parameters and return values.\n\n## [[L-04] Fee can be at most 1% and dead code](https://github.com/code-423n4/2021-04-vader-findings/issues/221)\n\nThe `Vader._checkEmission` functions caps the fee at `1000` = 10% but the max fee that can be returned from the `iUTILS(UTILS).getFeeOnTransfer` call is `100`.\n\n```solidity\n// returns value between 0 and 100\nfeeOnTransfer = iUTILS(UTILS).getFeeOnTransfer(\n    totalSupply,\n    maxSupply\n); // UpdateFeeOnTransfer\nif (feeOnTransfer > 1000) {\n    feeOnTransfer = 1000;\n} // Max 10% if UTILS corrupted\n```\n\nIt seems like there is a misunderstanding in whether the fee should be at most 1% (`Utils.sol`) or 10% (`Vader.sol`).\n\nRecommend clarifying what the max fee should be, and then adjusting either `Utils.getFeeOnTransfer` or the `Vader._checkEmission` cap.\n\n\n## [[L-05] Lack of zero address validation in `init()` function](https://github.com/code-423n4/2021-04-vader-findings/issues/12)\n\nThe parameters that are used in `init()` function to initialize the state variable, these state variable are used in other function to perform operation. since it lacks zero address validation, it will be problematic if there is error in these state variable. some of the function will loss their functionality which can cause the redeployment of contract.\n\nRecommend adding require condition which check zero address validation\n\n**[strictly-scarce (vader) acknowledged](https://github.com/code-423n4/2021-04-vader-findings/issues/12#issuecomment-826295256):**\n > Same as: https://github.com/code-423n4/2021-04-vader-findings/issues/13#issuecomment-826294937\n>\n> No issue found\n\n## [[L-06] Events not emitted](https://github.com/code-423n4/2021-04-vader-findings/issues/250)\nEvents not emitted for important state changes.\n\n**[strictly-scarce (vader) acknowledged](https://github.com/code-423n4/2021-04-vader-findings/issues/250#issuecomment-830629461):**\n > The ethereum state machine isn't a parking lot for event data\n>\n> * `setParams()` - no, plenty events in DAO\n> * `setAnchorParams()` - no, plenty events in DAO\n>\n> But these are warranted, purely for off-chain metrics:\n> * `addDepositData()` - valid for off-chain IL tracking\n> * `removeDepositData()` - valid for off-chain IL tracking\n\n**[strictly-scarce (vader) commented](https://github.com/code-423n4/2021-04-vader-findings/issues/250#issuecomment-830629536):**\n > Severity: 0, no impact to protocol itself\n\n## [[L-07] Swap fee not applied](https://github.com/code-423n4/2021-04-vader-findings/issues/272)\n\nHere you have more information: https://gist.github.com/alexon1234/a2d3619fb3faa4e5676329f70bd565d3\n\n## [[L-08] The Calculation For `nextEraTime` Drifts, Causing Eras To Occur Further And Further Into The Future](https://github.com/code-423n4/2021-04-vader-findings/issues/193)\n\nIn `Vader.sol`, eras are intended to occur every 24 hours. This means that a correct implementation would add 24 hours to the end-time of the previous era in order to find the end-time of the next era. However, the current method for calculating the next era's end-time uses `block.timestamp`, rather than the previous era's end-time.\n\nThis line of code will cause a perpetual drift of era times, causing each era to actually be 24 hours plus the time between when the last era ended and when `Vader._transfer()` is next called.\n\n\nRecommend that In `Vader.sol`, change this:\n\n`nextEraTime = block.timestamp + secondsPerEra;`\n\nto this:\n\n`nextEraTime = nextEraTime + secondsPerEra;`\n\n## [[L-09] `_recordBurn` does not handle 0 _eth appropriately](https://github.com/code-423n4/2021-04-vader-findings/issues/269)\n\nContract Vether4 function `_recordBurn` does not check that ```_eth > 0```, thus it is possible to pass this check multiple times:\n\n`if (mapEraDay_MemberUnits[_era][_day][_member] == 0)`\n\nIf the user hasn't contributed to this day yet, it updates `mapMemberEra_Days`, `mapEraDay_MemberCount`, and `mapEraDay_Members`. However, when `msg.value` is 0, it is possible to trigger this condition again and again as `mapEraDay_MemberUnits` still remains 0.\n\nRecommend either not allowing burns of 0 _eth, or add an extra check in the if statement.\n\n## [[L-10] `getAnchorPrice` potentially returns the wrong median](https://github.com/code-423n4/2021-04-vader-findings/issues/213)\n\nThe `Router.getAnchorPrice` sorts the `arrayPrices` array and always returns the third element `_sortedAnchorFeed[2]`.\nThis only returns the median if `_sortedAnchorFeed` is of length 5, but it can be anything from `0` to `anchorLimit`.\n\nIf not enough anchors are listed initially, it might become out-of-bounds and break all contract functionality due to revert, or return a wrong median. If `anchorLimit` is set to a different value than 5, it's also wrong.\n\nrecommend checking the length of `_sortedAnchorFeed` and return `_sortedAnchorFeed[_sortedAnchorFeed.length / 2]` if it's odd, or the average of the two in the middle if it's even.\n\n**[strictly-scarce (vader) confirmed](https://github.com/code-423n4/2021-04-vader-findings/issues/213#issuecomment-828464428):**\n > Valid, although it is intended design to launch with 5, which cannot be reduced after, so disagree with severity.\n\n**[Mervyn853 commented](https://github.com/code-423n4/2021-04-vader-findings/issues/213#issuecomment-830579123):**\n > Our decision matrix for severity:\n>\n> 0: No-risk: Code style, clarity, off-chain monitoring (events etc), exclude gas-optimisations\n> 1: Low Risk: UX, state handling, function incorrect as to spec\n> 2: Funds-Not-At-Risk, but can impact the functioning of the protocol, or leak value with a hypothetical attack path with stated assumptions, but external requirements\n> 3: Funds can be stolen/lost directly, or indirectly if a valid attack path shown that does not have handwavey hypotheticals.\n>\n> Recommended: 2\n\n## [[L-11] `listAnchor` sets `_isCurated` to true but forgets other parts of curation](https://github.com/code-423n4/2021-04-vader-findings/issues/271)\n\nThe function `listAnchor` sets `_isCurated` to true but does not update the `curatedPoolCount` and does not emit the Curated event. I don't see this `curatedPoolCount` variable used anywhere so probably it's just needed for the frontend consumption.\n\nRecommend that the best solution would be to replace ```_isCurated[token] = true```; with call to function `curatePool`. It also skips if the same anchor is listed twice.\n\n## [[L-12] `curatePool` emits Curated event no matter what](https://github.com/code-423n4/2021-04-vader-findings/issues/274)\n\nThe function `curatePool` emits Curated event every time. It should emit this event only when the conditions are fulfilled.\n\nRecommend putting this event inside the most inner `if` block.\n\n## [[L-13] calculations of `upgradedAmount` is not overflow protected](https://github.com/code-423n4/2021-04-vader-findings/issues/277)\n\nAs contract Vether4 is using pragma solidity 0.6.4; SafeMath is not enabled by default, thus making this check inside function distribute avoidable (overflow):\n\n```solidity\nupgradedAmount += ownership[i];\nrequire(upgradedAmount <= maxEmissions, \"Must not send more than possible\");\n```\nOf course, this function can only be called by the deployer (who is later expected to call `purgeDeployer()`) so the issue is only theoretical.\n\nRecommend using SafeMath here or just be informed about this theoretical issue.\n\n## [[L-14] `flashProof` is not effective at the start](https://github.com/code-423n4/2021-04-vader-findings/issues/307)\n\nIn contract USDV, `blockDelay` is not initialized and needs to be explicitly set by calling function `setParams()`. Otherwise, it gets a default value of 0 so `flashProof` is not effective unless the value is set.\n\nIt depends on the intentions, you can initialize it in the constructor (or in the `init()` function) or maybe this precaution is intended to be turned on later.\n\n## [[L-15] Token can be burn through transfer](https://github.com/code-423n4/2021-04-vader-findings/issues/262)\n\nThe token can be sent to `address(0)` through a normal `transfer()` without decreasing the `totalSupply` as it would with calling `burn()` and it could cause an unintentional burn.\n\nRecommend consider checking the recipient address to be != `address(0)`.\n\n## [[L-16] You can vote for proposal still not existent](https://github.com/code-423n4/2021-04-vader-findings/issues/273)\n\n`voteProposal()` doesn't check that ```proposalID <= proposalCount```.\n\nRecommend that in `voteProposal()`, ```require(proposalID <= proposalCount, \"Proposal not existent\")```\n\nIt should be \"<=\", because `proposalCount` is updated before using it (e.g. https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/DAO.sol#L59) in this way the proposal n. 0 is not assignable, although i'm not sure if it's wanted or not.\n\n## [[L-17] Out-of-bound index access in function `getAnchorPrice`](https://github.com/code-423n4/2021-04-vader-findings/issues/313)\n\nOut-of-bound index access is possible in the function `getAnchorPrice` of `Router.sol` if the number of anchors equals 1 or 2. Also, the returned anchor price is not the overall median in those situations. [Router.sol#L288](https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Router.sol#L288)\n\nRecommend consider using `arrayPrices.length/2` as the index to get the median of prices.\n\n## [[L-18] ERC20 race condition for allowances](https://github.com/code-423n4/2021-04-vader-findings/issues/35)\n\nDue to the implementation of the `approve()` function in Vader.sol, Vether.sol and mainnet Vether4 at 0x4Ba6dDd7b89ed838FEd25d208D4f644106E34279, it's possible for a user to over spend their allowance in certain situations.\n\nThe steps to the attack are as follows:\n\n1. Alice approves an allowance of 5000 VETH to Bob.\n2. Alice attempts to lower the allowance to 2500 VETH.\n3. Bob notices the transaction in the mempool and front-runs it by using up the full allowance with a `transferFrom` call.\n4. Alice's lowered allowance is confirmed and Bob now has an allowance of 2500 VETH, which can be spent further for a total of 7500 VETH.\n\nOverall, Bob was supposed to be approved for at most 5000 VETH but got 7500 VETH. The POC code can be found here: https://gist.github.com/toastedsteaksandwich/db32472ae5c19c2eb188f07abddd02fa\n\nNote that in the POC, Bob receives 7492.5 VETH instead of 7500 VETH due to transfer fees.\n\nRecommend that instead of having a direct setter for allowances, `decreaseAllowance` and `increaseAllowance` functions should be exposed which decreases and increases allowances for a recipient respectively. In this way, if the `decreaseAllowance` call is front-run, the call should revert as there is insufficient allowance to be decreased. This leaves Bob with at most 5000 VETH, the original allowance.\n\n**[strictly-scarce (vader) acknowledged](https://github.com/code-423n4/2021-04-vader-findings/issues/35#issuecomment-827582108):**\n > This theoretical attack has been known about for a while but never actually observed meaningfully. Addressing it costs extra gas.\n\n## [[L-19] Missing input validation may set `rewardAddress` to zero-address in Vader.sol](https://github.com/code-423n4/2021-04-vader-findings/issues/160)\n\nThe function `setRewardAddress` is used by DAO to change `rewardAddress` from USDV to something else. However, there is no zero-address validation on the address. This may accidentally mint rewards to zero-address.\n\nRecommend adding zero-address check to `setRewardAddress`.\n\n**[strictly-scarce (vader) confirmed](https://github.com/code-423n4/2021-04-vader-findings/issues/160#issuecomment-830615075):**\n > Sure, if this happened (and it wasn't intentional) then it would be voted to the correct one. Low likelihood, disagree with severity.\n\n## [[L-20] Default value of `curatedPoolLimit` allows only one curated pool in Router.sol](https://github.com/code-423n4/2021-04-vader-findings/issues/86)\n\nThe default value of `curatedPoolLimit` only allows one curated pool at any time. This can be changed with `setParams()` but DAO does not have this functionality.\n\nThis will affect the scalability of the protocol and significantly limit the liquidity pool value proposition.\n\nRecommend changeing `curatedPoolLimit` to a higher value on L85.\n\n**[strictly-scarce (vader) acknowledged](https://github.com/code-423n4/2021-04-vader-findings/issues/86#issuecomment-830613369):**\n > Intended to be 5-10 as per discussion with community. The DAO will have extra functionality to expand.\n>\n> How is this medium-risk?\n\n## [[L-21] `totalBurnt` might be wrong](https://github.com/code-423n4/2021-04-vader-findings/issues/32)\n\n[Vether.sol](https://etherscan.io/address/0x4Ba6dDd7b89ed838FEd25d208D4f644106E34279#code)\nis the 4th contract version. It takes the `totalBurnt` value of the 2nd version of the contract and continues on that.\nIt seem more logical to use the `totalBurnt` value of the 3rd version of the contract and continue on that. This way, the value of `totalBurnt` is probably not the real value.\n\n```solidity\nvether.sol:\ncontract Vether4 is ERC20 {\n constructor() public {\n       ...\n        vether2 = 0x01217729940055011F17BeFE6270e6E59B7d0337;                               // Second Vether\n        vether3 = 0x75572098dc462F976127f59F8c97dFa291f81d8b;\n        ...\n        totalBurnt = VETH(vether2).totalBurnt(); totalFees = 0;\n```\n\nRecommend checking if indeed vether3 should be used and update the code to use vether3.\n\n**[strictly-scarce (vader) disputed](https://github.com/code-423n4/2021-04-vader-findings/issues/32#issuecomment-826845471):**\n > Vether is deployed code and can't be changed.\n\n**[Mervyn853 commented](https://github.com/code-423n4/2021-04-vader-findings/issues/32#issuecomment-830582713):**\n > Our decision matrix for severity:\n>\n> 0: No-risk: Code style, clarity, off-chain monitoring (events etc), exclude gas-optimisations\n> 1: Low Risk: UX, state handling, function incorrect as to spec\n> 2: Funds-Not-At-Risk, but can impact the functioning of the protocol, or leak value with a hypothetical attack path with stated assumptions, but external requirements\n> 3: Funds can be stolen/lost directly, or indirectly if a valid attack path shown that does not have handwavey hypotheticals.\n>\n> Recommended: 0\n\n## [[L-22] Missing DAO functionality to call `setParams()` function in USDV.sol](https://github.com/code-423n4/2021-04-vader-findings/issues/140)\n\n`setParams()` is authorized to be called only from the DAO (per modifier) but DAO contract has no corresponding functionality to call `setParams()` function. As a result, `blockDelay` — a critical parameter used to prevent flash attacks, is stuck with initialized value and cannot be changed.\n\nRecommend adding functionality to DAO to be able to call `setParams()` of USDV.sol.\n\n**[strictly-scarce (vader) commented](https://github.com/code-423n4/2021-04-vader-findings/issues/140#issuecomment-830603451):**\n > https://github.com/code-423n4/2021-04-vader-findings/issues/82\n\n**[dmvt (judge) commented](https://github.com/code-423n4/2021-04-vader-findings/issues/140#issuecomment-847841030):**\n > This can be easily addressed by updating the DAO address on Vader, even if it is deployed this way. Low risk and impact as a result.\n\n## [[L-23] events can be emitted  even after failed transaction](https://github.com/code-423n4/2021-04-vader-findings/issues/6)\n\nWhen a user tries to remove liquidity or initiate a swap, their transaction may fail. But, even though the transaction fails, events can still be emitted. This could be problematic if keeping track of the record off-chain.\n\nIn Pools.sol:\n* https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Pools.sol#L92\n* https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Pools.sol#L101\n* https://github.com/code-423n4/2021-04-vader/blob/main/vader-protocol/contracts/Pools.sol#L163\n\nIn the `_removeLiquidity()`, `swap()`, and `burnSynth()` functions; event is emitted before `transferOut()` function completes. This is because the `transferOut()` function does not check return value from transfer.\nAs such, the transaction might fail even though the event is emitted.\n\nRecommend checking return value from `transfer()` function in order to know whether transaction was successfully executed or not.\n\n**[strictly-scarce (vader) disputed](https://github.com/code-423n4/2021-04-vader-findings/issues/6#issuecomment-826293590):**\n > Events are not used for tracking state. If a tx fails, the contract's storage will not update. The contract state is the source of truth.\n>\n> Recommend: Close, no issue found.\n\n**[Mervyn853 commented](https://github.com/code-423n4/2021-04-vader-findings/issues/6#issuecomment-830582793):**\n > Our decision matrix for severity:\n>\n> 0: No-risk: Code style, clarity, off-chain monitoring (events etc), exclude gas-optimisations\n> 1: Low Risk: UX, state handling, function incorrect as to spec\n> 2: Funds-Not-At-Risk, but can impact the functioning of the protocol, or leak value with a hypothetical attack path with stated assumptions, but external requirements\n> 3: Funds can be stolen/lost directly, or indirectly if a valid attack path shown that does not have handwavey hypotheticals.\n>\n> Recommended: 0\n\n**[dmvt (judge) commented](https://github.com/code-423n4/2021-04-vader-findings/issues/6#issuecomment-849046134):**\n > This can and will cause cascading issues for third party dapps. At worst, completely hypothetically, this could cause a user to act as if they have funds they don't or vise versa leading to reputational and economic impact. I recommend that the team treat event emission more seriously in general.\n\n# Non-Critical Findings\n\n- [[N-01] Not always reason at require](https://github.com/code-423n42021-04-vader-findings/issues/20)\n- [[N-02] Functions with implicit return values](https://github.com/code-423n4/2021-04-vader-findings/issues/24)\n- [[N-03] Different pragma solidity](https://github.com/code-423n4/2021-04-vader-findings/issues/25)\n- [[N-04] ERC20 specification declares decimals as uint8 type](https://github.com/code-423n4/2021-04-vader-findings/issues/283)\n- [[N-05] [INFO] Code style suggestions](https://github.com/code-423n4/2021-04-vader-findings/issues/285)\n- [[N-06] Difference from whitepaper](https://github.com/code-423n4/2021-04-vader-findings/issues/251)\n- [[N-08] Public functions `getSynth()` and `isSynth()` are commented out in Factory.sol](https://github.com/code-423n4/2021-04-vader-findings/issues/110)\n- [[N-09] Named return variable in `harvest()` and other functions of Vault.sol and contracts](https://github.com/code-423n4/2021-04-vader-findings/issues/50)\n- [[N-10]  `Protection` event not used](https://github.com/code-423n4/2021-04-vader-findings/issues/230)\n- [[N-11] Replacing an anchor does not reset `Pool.isAnchor`](https://github.com/code-423n4/2021-04-vader-findings/issues/212)\n- [[N-12] Unrestricted `addLiquidity` could cause unintended results on front-end apps that listen to events.](https://github.com/code-423n4/2021-04-vader-findings/issues/317)\n\n# Gas Optimizations\n\n- [[G-01] Gas savings by removing unnecessary conditional in `isCurated()` function of Router.sol](https://github.com/code-423n4/2021-04-vader-findings/issues/100)\n- [[G-02] Unused ID field in structs](https://github.com/code-423n4/2021-04-vader-findings/issues/304)\n- [[G-03] Use immutable for constant variables](https://github.com/code-423n4/2021-04-vader-findings/issues/286)\n- [[G-04] Public function that could be declared external](https://github.com/code-423n4/2021-04-vader-findings/issues/14)\n- [[G-05] Gas savings by moving inited bool state variable next to an address state variable declaration in Pools.sol](https://github.com/code-423n4/2021-04-vader-findings/issues/111)\n- [[G-06] Gas savings by removing unused state variable `_isMember` and related getter function `isMember()` in Pools.sol](https://github.com/code-423n4/2021-04-vader-findings/issues/118)\n- [[G-07] Gas savings by declaring state variables constant in USDV.sol](https://github.com/code-423n4/2021-04-vader-findings/issues/129)\n- [[G-08] Gas savings by converting storage variable to immutable in Vader.sol](https://github.com/code-423n4/2021-04-vader-findings/issues/149)\n- [[G-09] Gas savings by removing state variable baseline in Vader.sol](https://github.com/code-423n4/2021-04-vader-findings/issues/153)\n- [[G-10] Gas savings by replacing public visibility with internal/private for `isEqual()` function of DAO.sol](https://github.com/code-423n4/2021-04-vader-findings/issues/181)\n- [[G-11] Perform early input validation of zero-address for efficiency in DAO.sol](https://github.com/code-423n4/2021-04-vader-findings/issues/182)\n- [[G-12] Unnecessary logic that will never get triggered in DAO.sol](https://github.com/code-423n4/2021-04-vader-findings/issues/186)\n- [[G-13] Gas savings by avoiding re-initialization of POOLS variable in `init()` function of Vault.sol](https://github.com/code-423n4/2021-04-vader-findings/issues/43)\n- [[G-14] Gas savings by removing unused state variable `repayDelay` in Router.sol](https://github.com/code-423n4/2021-04-vader-findings/issues/78)\n- [[G-15] Gas savings by changing `getILProtection()` function’s public visibility to internal/private in Router.sol](https://github.com/code-423n4/2021-04-vader-findings/issues/85)\n- [[G-16] Gas savings by saving state variable in a memory for loop access in `replaceAnchor()` of Router.sol](https://github.com/code-423n4/2021-04-vader-findings/issues/90)\n- [[G-17] Gas savings by breaking from loop after ```match+replace``` in `replaceAnchor()` of Router.sol](https://github.com/code-423n4/2021-04-vader-findings/issues/91)\n- [[G-18] cache `proposalCount` instead of accessing it three times in `newGrantProposal`/`newAddressProposal`](https://github.com/code-423n4/2021-04-vader-findings/issues/232)\n- [[G-19] `DAO.mapPID_finalised` is never read in the contract, only written](https://github.com/code-423n4/2021-04-vader-findings/issues/233)\n- [[G-20] Add anchor map](https://github.com/code-423n4/2021-04-vader-findings/issues/236)\n- [[G-21] Store using Struct over multiple mappings](https://github.com/code-423n4/2021-04-vader-findings/issues/252)\n- [[G-22] Use Keccak256 over Sha256 for string comparation](https://github.com/code-423n4/2021-04-vader-findings/issues/258)\n- [[G-23] Some storage optimizations](https://github.com/code-423n4/2021-04-vader-findings/issues/292)\n- [[G-24] Unused and Unnecessary code](https://github.com/code-423n4/2021-04-vader-findings/issues/312)\n- [[G-25] Some  unused code](https://github.com/code-423n4/2021-04-vader-findings/issues/17)\n- [[G-26] sortArray optimizable](https://github.com/code-423n4/2021-04-vader-findings/issues/19)\n- [[G-27] Result of ERC20 transfer not checked](https://github.com/code-423n4/2021-04-vader-findings/issues/22)\n- [[G-28] Optimization possible at _transfer](https://github.com/code-423n4/2021-04-vader-findings/issues/26)\n- [[G-29] Pay double fees in addExcluded of Vether.sol](https://github.com/code-423n4/2021-04-vader-findings/issues/28)\n- [[G-31] Gas Optimization: Remove Overflow Check in Vether.sol Since Solidity 0.8.x Disallows Implicit Overflows](https://github.com/code-423n4/2021-04-vader-findings/issues/190)\n- [[G-32] Gas Optimization: Avoid Unnecessary Expensive SSTORE Calls In Vether.sol By Checking If _fee Is Non-Zero](https://github.com/code-423n4/2021-04-vader-findings/issues/191)\n- [[G-33] Gas Optimization: Vader.sol Unnecessary Conditional](https://github.com/code-423n4/2021-04-vader-findings/issues/197)\n- [[G-34] Gas Optimization: Utils.sol Make An Unnecessary Multiplication And Division By An Identical Value](https://github.com/code-423n4/2021-04-vader-findings/issues/199)\n- [[G-35] Gas Optimization: DAO.sol Unnecessary Multiple Return Statements](https://github.com/code-423n4/2021-04-vader-findings/issues/200)\n- [[G-36] Extra useless steps to calculate pooledVADER and pooledUSDV ](https://github.com/code-423n4/2021-04-vader-findings/issues/287)\n- [[G-37] variable == false -> !variable](https://github.com/code-423n4/2021-04-vader-findings/issues/288)\n- [[G-38] Extract mappings to a common struct](https://github.com/code-423n4/2021-04-vader-findings/issues/289)\n- [[G-39] Cache duplicate calls or storage access](https://github.com/code-423n4/2021-04-vader-findings/issues/291)\n- [[G-40] Fee on transfer conditions](https://github.com/code-423n4/2021-04-vader-findings/issues/293)\n- [[G-42] Not needed check for uint > 0](https://github.com/code-423n4/2021-04-vader-findings/issues/256)\n- [[G-43] You don't need to recalculate exclusion fee every time](https://github.com/code-423n4/2021-04-vader-findings/issues/302)\n- [[G-44] token == arrayAnchors[i]](https://github.com/code-423n4/2021-04-vader-findings/issues/303)\n- [[G-45] Gas improvement](https://github.com/code-423n4/2021-04-vader-findings/issues/253)\n- [[G-46] Function can be simplified](https://github.com/code-423n4/2021-04-vader-findings/issues/263)\n- [[G-47] Function can be simplified](https://github.com/code-423n4/2021-04-vader-findings/issues/301)\n- [[G-48] Unnecessary `else if` statement in `swapWithSynthsWithLimit`](https://github.com/code-423n4/2021-04-vader-findings/issues/319)\n- [[G-49] Unnecessary function calls in `addLiquidity`](https://github.com/code-423n4/2021-04-vader-findings/issues/320)\n\n# Disclosures\n\nC4 is an open organization governed by participants in the community.\n\nC4 Contests incentivize the discovery of exploits, vulnerabilities, and bugs in smart contracts. Security researchers are rewarded at an increasing rate for finding higher risk issues. Contest submissions are judged by a knowledgeable security researcher and solidity developer and disclosed to sponsoring developers. C4 does not conduct formal verification regarding the provided code, but instead provides final verification.\n\nC4 does not provide any guarantee or warranty regarding the security of this project. All smart contract software should be used at the sole risk and responsibility of users.\n"
}