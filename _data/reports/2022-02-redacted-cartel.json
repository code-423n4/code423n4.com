{
  "circa": {
    "title": "Redacted Cartel contest",
    "sponsor": "Redacted Cartel",
    "slug": "2022-02-redacted-cartel",
    "date": "2022-05-11",
    "findings": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues",
    "contest": 87
  },
  "html": "<h1 id=\"overview\" style=\"position:relative;\"><a href=\"#overview\" aria-label=\"overview permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Overview</h1>\n<h2 id=\"about-c4\" style=\"position:relative;\"><a href=\"#about-c4\" aria-label=\"about c4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>About C4</h2>\n<p>Code4rena (C4) is an open organization consisting of security researchers, auditors, developers, and individuals with domain expertise in smart contracts.</p>\n<p>A C4 audit contest is an event in which community participants, referred to as Wardens, review, audit, or analyze smart contract logic in exchange for a bounty provided by sponsoring projects.</p>\n<p>During the audit contest outlined in this document, C4 conducted an analysis of the Redacted Cartel smart contract system written in Solidity. The audit contest took place between February 15—February 17 2022.</p>\n<h2 id=\"wardens\" style=\"position:relative;\"><a href=\"#wardens\" aria-label=\"wardens permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Wardens</h2>\n<p>37 Wardens contributed reports to the Redacted Cartel contest:</p>\n<ol>\n<li><a href=\"https://twitter.com/csanuragjain\">csanuragjain</a></li>\n<li>WatchPug (<a href=\"https://github.com/jack-the-pug\">jtp</a> and <a href=\"https://github.com/mingwatch\">ming</a>)</li>\n<li><a href=\"https://twitter.com/SolidityDev\">pauliax</a></li>\n<li><a href=\"https://twitter.com/HickupH\">hickuphh3</a></li>\n<li><a href=\"https://twitter.com/gzeon\">gzeon</a></li>\n<li><a href=\"https://twitter.com/cmichelio\">cmichel</a></li>\n<li><a href=\"https://twitter.com/liam_eastwood13\">leastwood</a></li>\n<li>cccz</li>\n<li><a href=\"https://twitter.com/danbinnun\">danb</a></li>\n<li><a href=\"https://twitter.com/omikomikomik\">Omik</a></li>\n<li><a href=\"https://www.instagram.com/riyan_rfa/\">rfa</a></li>\n<li><a href=\"https://twitter.com/kirkthebaird\">kirk-baird</a></li>\n<li>0x1f8b</li>\n<li>SolidityScan (<a href=\"https://twitter.com/cyberboyIndia\">cyberboy</a> and <a href=\"https://blog.dixitaditya.com/\">zombie</a>)</li>\n<li>hyh</li>\n<li>Czar102</li>\n<li><a href=\"https://twitter.com/JustDravee\">Dravee</a></li>\n<li><a href=\"https://twitter.com/_ye0lde\">ye0lde</a></li>\n<li>kenta</li>\n<li><a href=\"https://twitter.com/KenzoAgada\">kenzo</a></li>\n<li>Jujic</li>\n<li>IllIllI</li>\n<li><a href=\"https://github.com/z3s/\">z3s</a></li>\n<li><a href=\"https://twitter.com/0xruhum\">Ruhum</a></li>\n<li>jayjonah8</li>\n<li><a href=\"https://twitter.com/defsec_\">defsec</a></li>\n<li>robee</li>\n<li>0x0x0x</li>\n<li>NoamYakov</li>\n<li>peritoflores</li>\n<li><a href=\"https://twitter.com/0xliumin\">0xliumin</a></li>\n<li>p4st13r4 (<a href=\"https://github.com/0x69e8\">0x69e8</a> and 0xb4bb4)</li>\n<li>d4rk</li>\n<li><a href=\"https://twitter.com/meidhiwirara\">Tomio</a></li>\n</ol>\n<p>This contest was judged by <a href=\"https://twitter.com/GalloDaSballo\">Alex the Entreprenerd</a>. The judge also competed in the contest as a warden, but forfeited their winnings.</p>\n<p>Final report assembled by <a href=\"https://twitter.com/liveactionllama\">liveactionllama</a>.</p>\n<h1 id=\"summary\" style=\"position:relative;\"><a href=\"#summary\" aria-label=\"summary permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Summary</h1>\n<p>The C4 analysis yielded an aggregated total of 18 unique vulnerabilities. Of these vulnerabilities, 0 received a risk rating in the category of HIGH severity and 18 received a risk rating in the category of MEDIUM severity.</p>\n<p>Additionally, C4 analysis included 25 reports detailing issues with a risk rating of LOW severity or non-critical. There were also 18 reports recommending gas optimizations.</p>\n<p>All of the issues presented here are linked back to their original finding.</p>\n<h1 id=\"scope\" style=\"position:relative;\"><a href=\"#scope\" aria-label=\"scope permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Scope</h1>\n<p>The code under review can be found within the <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel\">C4 Redacted Cartel contest repository</a>, and is composed of 4 smart contracts written in the Solidity programming language and includes 699 lines of Solidity code.</p>\n<h1 id=\"severity-criteria\" style=\"position:relative;\"><a href=\"#severity-criteria\" aria-label=\"severity criteria permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Severity Criteria</h1>\n<p>C4 assesses the severity of disclosed vulnerabilities according to a methodology based on <a href=\"https://owasp.org/www-community/OWASP_Risk_Rating_Methodology\">OWASP standards</a>.</p>\n<p>Vulnerabilities are divided into three primary risk categories: high, medium, and low/non-critical.</p>\n<p>High-level considerations for vulnerabilities span the following key areas when conducting assessments:</p>\n<ul>\n<li>Malicious Input Handling</li>\n<li>Escalation of privileges</li>\n<li>Arithmetic</li>\n<li>Gas use</li>\n</ul>\n<p>Further information regarding the severity criteria referenced throughout the submission review process, please refer to the documentation provided on <a href=\"https://code423n4.com\">the C4 website</a>.</p>\n<h1 id=\"medium-risk-findings-18\" style=\"position:relative;\"><a href=\"#medium-risk-findings-18\" aria-label=\"medium risk findings 18 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Medium Risk Findings (18)</h1>\n<h2 id=\"m-01-manipulations-of-setfee\" style=\"position:relative;\"><a href=\"#m-01-manipulations-of-setfee\" aria-label=\"m 01 manipulations of setfee permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/113\">[M-01] Manipulations of <code>setFee</code></a></h2>\n<p><em>Submitted by pauliax</em></p>\n<p><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L104-L113\">BribeVault.sol#L104-L113</a><br>\n<a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L164\">BribeVault.sol#L164</a><br>\n<a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L213\">BribeVault.sol#L213</a><br>\n<a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L256\">BribeVault.sol#L256</a><br></p>\n<p>If we consider that the fee variable is meaningfully applied, there will still be several problems with this:</p>\n<ol>\n<li>Admin can setFee up to 100%. This is bad for users, fees should have a reasonable upper limit, e.g. 30% to prevent potential griefing.</li>\n<li>Tokens are transferred in a separate function called transferBribes, which means that depositBribe txs have already settled. setFee can happen anytime, so an admin can change fees for already made deposits. I think this is again bad for users, as you need extra trust on an admin to not exploit this, and smart contracts should aim for as little external trust as possible.</li>\n<li>Even if a fee would be applied in depositBribe, function setFee could frontrun user deposits. Consider using a timelock, so that users have time to react and adjust.</li>\n</ol>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/113#issuecomment-1043705156\">kphed (Redacted Cartel) disagreed with Medium severity and commented</a>:</strong></p>\n<blockquote>\n<p>We will likely set an upper bound as recommended, to ease user concerns. The admin being the Redacted multisig should also instill much trust and address most concerns.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/113#issuecomment-1052867924\">Alex the Entreprenerd (judge) commented</a>:</strong></p>\n<blockquote>\n<p>The warden identified a potential admin privilege that would allow to set the fee to 100%.</p>\n<p>I agree with the finding and severity.</p>\n</blockquote>\n<hr>\n<h2 id=\"m-02-depositor_role-can-be-granted-by-the-deployer-of-bribevault-and-transfer-bribers-approved-erc20-tokens-to-bribevault-by-specifying-any-bribeidentifier-and-rewardidentifier\" style=\"position:relative;\"><a href=\"#m-02-depositor_role-can-be-granted-by-the-deployer-of-bribevault-and-transfer-bribers-approved-erc20-tokens-to-bribevault-by-specifying-any-bribeidentifier-and-rewardidentifier\" aria-label=\"m 02 depositor_role can be granted by the deployer of bribevault and transfer bribers approved erc20 tokens to bribevault by specifying any bribeidentifier and rewardidentifier permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/1\">[M-02] DEPOSITOR_ROLE can be granted by the deployer of <code>BribeVault</code> and transfer briber’s approved ERC20 tokens to <code>bribeVault</code> by specifying any <code>bribeIdentifier</code> and <code>rewardIdentifier</code></a></h2>\n<p><em>Submitted by cccz</em></p>\n<p>In the depositBribeERC20() function of the TokemakBribe contract, the briber can specify a proposal, and then call the depositBribeERC20 function of the bribeVault contract to deposit the reward.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"\" data-index=\"0\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">    function depositBribeERC20(</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        address proposal,</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        address token,</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        uint256 amount</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    ) external {</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        uint256 currentRound = _round;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        require(</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">            proposalDeadlines[proposal] &gt; block.timestamp,</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">            &quot;Proposal deadline has passed&quot;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        );</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        require(token != address(0), &quot;Invalid token&quot;);</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        require(amount &gt; 0, &quot;Bribe amount must be greater than 0&quot;);</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        bytes32 bribeIdentifier = generateBribeVaultIdentifier(</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">            proposal,</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">            currentRound,</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">            token</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        );</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        bytes32 rewardIdentifier = generateRewardIdentifier(</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">            currentRound,</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">            token</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        );</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        IBribeVault(bribeVault).depositBribeERC20(</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">            bribeIdentifier,</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">            rewardIdentifier,</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">            token,</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">            amount,</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">            msg.sender</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        );</span></span></code></pre>\n<p>But in the depositBribeERC20 function of the bribeVault contract, the address with DEPOSITOR_ROLE can transfer the briber’s approved ERC20 tokens to bribeVault by specifying any bribeIdentifier and rewardIdentifier via safeTransferFrom.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"\" data-index=\"1\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">    function depositBribeERC20(</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        bytes32 bribeIdentifier,</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        bytes32 rewardIdentifier,</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        address token,</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        uint256 amount,</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        address briber</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    ) external onlyRole(DEPOSITOR_ROLE) {</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        require(bribeIdentifier.length &gt; 0, &quot;Invalid bribeIdentifier&quot;);</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        require(rewardIdentifier.length &gt; 0, &quot;Invalid rewardIdentifier&quot;);</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        require(token != address(0), &quot;Invalid token&quot;);</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        require(amount &gt; 0, &quot;Amount must be greater than 0&quot;);</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        require(briber != address(0), &quot;Invalid briber&quot;);</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        Bribe storage b = bribes[bribeIdentifier];</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        address currentToken = b.token;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        require(</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">            // If bribers want to bribe with a different token they need a new identifier</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">            currentToken == address(0) || currentToken == token,</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">            &quot;Cannot change token&quot;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        );</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        // Since this method is called by a depositor contract, we must transfer from the account</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        // that called the depositor contract - amount must be approved beforehand</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        IERC20(token).safeTransferFrom(briber, address(this), amount);</span></span></code></pre>\n<p>DEPOSITOR_ROLE can be granted by the deployer of BribeVault.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"\" data-index=\"2\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">    function grantDepositorRole(address depositor)</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        external</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        onlyRole(DEFAULT_ADMIN_ROLE)</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    {</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        require(depositor != address(0), &quot;Invalid depositor&quot;);</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        _grantRole(DEPOSITOR_ROLE, depositor);</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        emit GrantDepositorRole(depositor);</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    }</span></span></code></pre>\n<h3 id=\"proof-of-concept\" style=\"position:relative;\"><a href=\"#proof-of-concept\" aria-label=\"proof of concept permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h3>\n<p><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L164-L205\">BribeVault.sol#L164-L205</a></p>\n<h3 id=\"recommended-mitigation-steps\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps\" aria-label=\"recommended mitigation steps permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h3>\n<p>The depositBribeERC20 function of the TokemakBribe contract needs to first transfer the briber’s tokens to the TokemakBribe contract, and then transfer the tokens to the bribeVault contract in the depositBribeERC20 function of the bribeVault contract. Make sure the first parameter of safeTransferFrom is msg.sender.</p>\n<p>TokemakBribe.depositBribeERC20()</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"\" data-index=\"3\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">    function depositBribeERC20(</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        address proposal,</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        address token,</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        uint256 amount</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    ) external {</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        uint256 currentRound = _round;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        require(</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">            proposalDeadlines[proposal] &gt; block.timestamp,</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">            &quot;Proposal deadline has passed&quot;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        );</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        require(token != address(0), &quot;Invalid token&quot;);</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        require(amount &gt; 0, &quot;Bribe amount must be greater than 0&quot;);</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        bytes32 bribeIdentifier = generateBribeVaultIdentifier(</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">            proposal,</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">            currentRound,</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">            token</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        );</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        bytes32 rewardIdentifier = generateRewardIdentifier(</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">            currentRound,</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">            token</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        );</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">+       IERC20(token).safeTransferFrom(msg.sender, address(this), amount);</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        IBribeVault(bribeVault).depositBribeERC20(</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">            bribeIdentifier,</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">            rewardIdentifier,</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">            token,</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">            amount,</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">            msg.sender</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        );</span></span></code></pre>\n<p>bribeVault.depositBribeERC20()</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"\" data-index=\"4\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">    function depositBribeERC20(</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        bytes32 bribeIdentifier,</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        bytes32 rewardIdentifier,</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        address token,</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        uint256 amount,</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        address briber</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    ) external onlyRole(DEPOSITOR_ROLE) {</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        require(bribeIdentifier.length &gt; 0, &quot;Invalid bribeIdentifier&quot;);</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        require(rewardIdentifier.length &gt; 0, &quot;Invalid rewardIdentifier&quot;);</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        require(token != address(0), &quot;Invalid token&quot;);</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        require(amount &gt; 0, &quot;Amount must be greater than 0&quot;);</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        require(briber != address(0), &quot;Invalid briber&quot;);</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        Bribe storage b = bribes[bribeIdentifier];</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        address currentToken = b.token;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        require(</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">            // If bribers want to bribe with a different token they need a new identifier</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">            currentToken == address(0) || currentToken == token,</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">            &quot;Cannot change token&quot;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        );</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        // Since this method is called by a depositor contract, we must transfer from the account</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        // that called the depositor contract - amount must be approved beforehand</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">-       IERC20(token).safeTransferFrom(briber, address(this), amount);</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">+\tIERC20(token).safeTransferFrom(msg.sender, address(this), amount);</span></span></code></pre>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/1#issuecomment-1040452376\">kphed (Redacted Cartel) disputed and commented</a>:</strong></p>\n<blockquote>\n<p>This isn’t a concern since the “depositor” role can only be granted by admin (protocol multisig) - depositors will only be bribe contracts that we’ve written and deployed.</p>\n<p>In the future, we may grant the depositor role to contracts that are written and deployed by 3rd parties, but they would all be thoroughly vetted in some manner and need to conform to the BribeVault’s interface. </p>\n<p>Thanks again for participating in our contest cccz, looking forward to more feedback/suggestions/comments.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/1#issuecomment-1059778323\">Alex the Entreprenerd (judge) commented</a>:</strong></p>\n<blockquote>\n<p>While this may not be a concern for the sponsor, the smart contract is supposed to be given allowance, this allowance can then be used by the <code>DEPOSITOR_ROLE</code> to perform a transfer.</p>\n<p>The smart can then allow the <code>DEFAULT_ADMIN_ROLE</code> to withdraw the funds.</p>\n<p>Ultimately the ability to deposit being permissioned and it’s ability to pull unlimited funds is a strong admin privilege, which I’d recommend the sponsor to remove.</p>\n<p>A similar deposit flow with less strict permissions can be found in most Yield Farming Vaults, see Badger Vaults for example: <a href=\"https://github.com/Badger-Finance/badger-sett-1.5/blob/86a586cf30b806dc1ab7ea090f002e06a59d0706/contracts/Vault.sol#L671\">Badger-Finance/Vault.sol#L671</a>.</p>\n</blockquote>\n<hr>\n<h2 id=\"m-03-default_admin_role-of-bribevault-can-steal-tokens-from-users-wallets\" style=\"position:relative;\"><a href=\"#m-03-default_admin_role-of-bribevault-can-steal-tokens-from-users-wallets\" aria-label=\"m 03 default_admin_role of bribevault can steal tokens from users wallets permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/86\">[M-03] <code>DEFAULT_ADMIN_ROLE</code> of <code>BribeVault</code> can steal tokens from users’ wallets</a></h2>\n<p><em>Submitted by WatchPug, also found by danb, Dravee, Alex the Entreprenerd, gzeon, IllIllI, jayjonah8, kenzo, pauliax, cmichel, csanuragjain, and z3s</em></p>\n<p>The current design/implementation allows the <code>DEFAULT_ADMIN_ROLE</code> of <code>BribeVault</code> to steal funds from any address that approved this contract up to allowance:</p>\n<p>As a <code>DEFAULT_ADMIN_ROLE</code>, the attack is simply do the following steps:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"\" data-index=\"5\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">1. `grantDepositorRole()` to self;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">2. `BribeVault#depositBribeERC20()` and transfer funds from victim&#39;s wallet;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">3. `emergencyWithdrawERC20()`.</span></span></code></pre>\n<p>This can be effectively used as a backdoor/attack vector for a malicious/compromised wallet with <code>DEFAULT_ADMIN_ROLE</code> of <code>BribeVault</code> to steal all the tokens from users’ wallets for these users who have approved <code>BribeVault</code>.</p>\n<p><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L164-L187\">BribeVault.sol#L164-L187</a><br></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"6\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">depositBribeERC20</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">bytes32</span><span class=\"mtk1\"> </span><span class=\"mtk12\">bribeIdentifier</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">bytes32</span><span class=\"mtk1\"> </span><span class=\"mtk12\">rewardIdentifier</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">token</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">amount</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">briber</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">onlyRole</span><span class=\"mtk1\">(</span><span class=\"mtk12\">DEPOSITOR_ROLE</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">bribeIdentifier</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk7\">0</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;Invalid bribeIdentifier&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">rewardIdentifier</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk7\">0</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;Invalid rewardIdentifier&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">token</span><span class=\"mtk1\"> != </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">), </span><span class=\"mtk8\">&quot;Invalid token&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">amount</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk7\">0</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;Amount must be greater than 0&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">briber</span><span class=\"mtk1\"> != </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">), </span><span class=\"mtk8\">&quot;Invalid briber&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">Bribe</span><span class=\"mtk1\"> </span><span class=\"mtk12\">storage</span><span class=\"mtk1\"> </span><span class=\"mtk12\">b</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">bribes</span><span class=\"mtk1\">[</span><span class=\"mtk12\">bribeIdentifier</span><span class=\"mtk1\">];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">currentToken</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">b</span><span class=\"mtk1\">.</span><span class=\"mtk12\">token</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// If bribers want to bribe with a different token they need a new identifier</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">currentToken</span><span class=\"mtk1\"> == </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">) || </span><span class=\"mtk12\">currentToken</span><span class=\"mtk1\"> == </span><span class=\"mtk12\">token</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk8\">&quot;Cannot change token&quot;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    );</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// Since this method is called by a depositor contract, we must transfer from the account</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// that called the depositor contract - amount must be approved beforehand</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">IERC20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">token</span><span class=\"mtk1\">).</span><span class=\"mtk11\">safeTransferFrom</span><span class=\"mtk1\">(</span><span class=\"mtk12\">briber</span><span class=\"mtk1\">, </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">), </span><span class=\"mtk12\">amount</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    ...</span></span></span></code></pre>\n<p><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L80-L88\">BribeVault.sol#L80-L88</a><br></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"7\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">grantDepositorRole</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">depositor</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">external</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">onlyRole</span><span class=\"mtk1\">(</span><span class=\"mtk12\">DEFAULT_ADMIN_ROLE</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">{</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">depositor</span><span class=\"mtk1\"> != </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">), </span><span class=\"mtk8\">&quot;Invalid depositor&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">_grantRole</span><span class=\"mtk1\">(</span><span class=\"mtk12\">DEPOSITOR_ROLE</span><span class=\"mtk1\">, </span><span class=\"mtk12\">depositor</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">emit</span><span class=\"mtk1\"> </span><span class=\"mtk11\">GrantDepositorRole</span><span class=\"mtk1\">(</span><span class=\"mtk12\">depositor</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<h3 id=\"proof-of-concept-1\" style=\"position:relative;\"><a href=\"#proof-of-concept-1\" aria-label=\"proof of concept 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h3>\n<p>Given:</p>\n<ul>\n<li>Alice (the victim) has approved <code>BribeVault</code> to spend <code>WBTC</code>;</li>\n<li>Alice has <code>100e8 WBTC</code> in their wallet balance.</li>\n</ul>\n<p>A malicious/compromised <code>DEFAULT_ADMIN_ROLE</code> of <code>BribeVault</code> can do the following to steal tokens from users’ wallets.</p>\n<ol>\n<li><code>grantDepositorRole()</code> to self;</li>\n<li><code>depositBribeERC20()</code> with: <code>token</code> = <code>WBTC</code>, <code>amount</code> = <code>100e8</code>, and <code>briber</code> = Alice;</li>\n<li><code>emergencyWithdrawERC20()</code> with:  <code>token</code> = <code>WBTC</code>, <code>amount</code> = <code>100e8</code>.</li>\n</ol>\n<p>As a result, the <code>100e8 WBTC</code> belongs Alice is now stolen by the Hacker.</p>\n<p>The steps above can be repeated for all tokens and users, effectively stealing all the token balances from all the wallets that approved <code>BribeVault</code> up to the allowance limit, which usually is unlimited.</p>\n<h3 id=\"recommended-mitigation-steps-1\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-1\" aria-label=\"recommended mitigation steps 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h3>\n<ol>\n<li>Consider using <code>TokemakBribe</code> instead of <code>BribeVault</code> to hold users’ allowances;</li>\n<li>Consider making sure that the <code>from</code> parameter of <code>transferFrom</code> can only be <code>msg.sender</code>;</li>\n<li>Consider using a multi-sig for the <code>DEFAULT_ADMIN_ROLE</code> of <code>BribeVault</code>.</li>\n</ol>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/86#issuecomment-1059801248\">Alex the Entreprenerd (judge) decreased severity to Medium and commented</a>:</strong></p>\n<blockquote>\n<p>Fully agree with the finding and appreciate the level of detail.</p>\n<p>Because the exploit is contingent on a malicious owner, I believe Medium Severity to be more appropriate.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/86#issuecomment-1059801440\">Alex the Entreprenerd (judge) commented</a>:</strong></p>\n<blockquote>\n<p>The <code>emergencyWithdrawERC20</code> without any check is a rug vector, protected exclusively by the multisig.<br>\nWhile depositors may opt into this system, that doesn’t mean that it’s trust is fully reliant on the mulsitig, which means the code has trust assumptions by design.</p>\n<p>These trust assumptions make medium severity appropriate.</p>\n</blockquote>\n<hr>\n<h2 id=\"m-04-send-ether-with-call-instead-of-transfer\" style=\"position:relative;\"><a href=\"#m-04-send-ether-with-call-instead-of-transfer\" aria-label=\"m 04 send ether with call instead of transfer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/2\">[M-04] Send ether with call instead of transfer</a></h2>\n<p><em>Submitted by kenta, also found by Dravee, hyh, Jujic, leastwood, and z3s</em></p>\n<p>Use call instead of transfer to send ether. And return value must be checked if sending ether is successful or not.\nSending ether with the transfer is no longer recommended.</p>\n<h3 id=\"proof-of-concept-2\" style=\"position:relative;\"><a href=\"#proof-of-concept-2\" aria-label=\"proof of concept 2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h3>\n<p><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L181\">RewardDistributor.sol#L181</a></p>\n<h3 id=\"recommended-mitigation-steps-2\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-2\" aria-label=\"recommended mitigation steps 2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h3>\n<p>(bool result, ) = payable(_account).call{value: _amount}(\"\");\nrequire(result, “Failed to send Ether”);</p>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/2\">kphed (Redacted Cartel) confirmed</a></strong></p>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/2#issuecomment-1059781616\">Alex the Entreprenerd (judge) commented</a>:</strong></p>\n<blockquote>\n<p>I believe the function would actually work with most Smart Contract Wallets and proxies. However this could change in the future.</p>\n<p>Agree with the finding.</p>\n</blockquote>\n<hr>\n<h2 id=\"m-05-wrong-slippage-check\" style=\"position:relative;\"><a href=\"#m-05-wrong-slippage-check\" aria-label=\"m 05 wrong slippage check permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/35\">[M-05] Wrong slippage check</a></h2>\n<p><em>Submitted by cmichel, also found by danb, Alex the Entreprenerd, hickuphh3, hyh, and WatchPug</em></p>\n<p>The <code>ThecosomataETH.addLiquidity</code> function computes the <code>expectedAmount</code> and then subtracts a slippage percentage from it.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"8\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">addLiquidity</span><span class=\"mtk1\">(</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">ethAmount</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">btrflyAmount</span><span class=\"mtk1\">) </span><span class=\"mtk11\">internal</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\">[</span><span class=\"mtk7\">2</span><span class=\"mtk1\">] </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">amounts</span><span class=\"mtk1\"> = [</span><span class=\"mtk12\">ethAmount</span><span class=\"mtk1\">, </span><span class=\"mtk12\">btrflyAmount</span><span class=\"mtk1\">];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">expectedAmount</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">ICurveCryptoPool</span><span class=\"mtk1\">(</span><span class=\"mtk12\">CURVEPOOL</span><span class=\"mtk1\">).</span><span class=\"mtk11\">calc_token_amount</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">amounts</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    );</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">minAmount</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">expectedAmount</span><span class=\"mtk1\"> - ((</span><span class=\"mtk12\">expectedAmount</span><span class=\"mtk1\"> * </span><span class=\"mtk12\">slippage</span><span class=\"mtk1\">) / </span><span class=\"mtk7\">1000</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">ICurveCryptoPool</span><span class=\"mtk1\">(</span><span class=\"mtk12\">CURVEPOOL</span><span class=\"mtk1\">).</span><span class=\"mtk11\">add_liquidity</span><span class=\"mtk1\">(</span><span class=\"mtk12\">amounts</span><span class=\"mtk1\">, </span><span class=\"mtk12\">minAmount</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p>According to the <a href=\"https://curve.readthedocs.io/_/downloads/en/latest/pdf/\">Curve docs 21.4</a>, this amount is already exact and takes the slippage into account (but not fees).</p>\n<p>If the pool is imbalanced, the <code>calc_token_amount</code> will already return a wrong amount and the additional slippage check on the wrong amount is unnecessary (except for the fees).</p>\n<h3 id=\"recommended-mitigation-steps-3\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-3\" aria-label=\"recommended mitigation steps 3 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h3>\n<p>Consider computing the minimum expected LP tokens off-chain and pass them to the <code>performUpkeep</code> function as a parameter to prevent sandwich attacks.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/35#issuecomment-1041827707\">drahrealm (Redacted Cartel) confirmed and commented</a>:</strong></p>\n<blockquote>\n<p>Thanks for the finding. Confirmed that this is not the right way for handling slippage. Will be updating the flow a little bit to allow externally sourced data for the expected amount.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/35#issuecomment-1059166618\">kphed (Redacted Cartel) disputed and commented</a>:</strong></p>\n<blockquote>\n<p>Changing to “sponsor disputed” since using values derived off-chain doesn’t prevent sandwich attacks and could make it easier to get sandwiched: using the off-chain calculation method, a MEV operator would only need to parse the tx input when deciding to front run us (vs. needing to simulate the tx if we were to do our calculations on-chain).</p>\n<p>Additionally, we’re not using the <code>StableSwap</code> contract referenced in the warden’s comment.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/35#issuecomment-1059785983\">Alex the Entreprenerd (judge) commented</a>:</strong></p>\n<blockquote>\n<p>I think the sponsor’s perspective is interesting in that I believe any MEV researcher could write a simple algorithm to check for the tx inputs to detect a slippage check.</p>\n<p>However in practice they’d still have to run a simulation as you could input the off-chain price with any variation (different decimals, as ETH, as USD, as BTC, multiply by 2 or 5 or w/e)</p>\n<p>Additionally while there can be arguments made as to how to mitigate, the finding is still valid.</p>\n<p>Asking Curve for the <code>calc_token_amount</code> will return whatever price the pool can offer at that time, because tx are atomic that means that any front-running or price manipulation would have already happened in a tx before the request.</p>\n<p>This means that at worst you could directly use the output from <code>calc_token_amount</code> (multiplication has no impact).</p>\n<p>What the finding also implies, is that if the pool were to be completely imbalances (99% of in asset, 1% of out asset) the price you’d get would be very low, and the code wouldn’t be able to detect it (the code is effectively same as having 0 * .95)</p>\n<p>Because the finding has to do with potential value extraction, I believe the finding to be valid and of medium severity.</p>\n<p>As for mitigation, there are 2 viable options:</p>\n<ol>\n<li>Use Chainlink Price Feed to get an accurate price</li>\n<li>Provide the price as a parameter</li>\n</ol>\n<p>For option 2, I don’t believe that argument to be valid for the examples above (just shift, multiply or obfuscate the param)\nAdditionally, while you may never get a guarantee of perfect pricing, providing a price will give you a guarantee of a minimum price, this ensures you can opt-in into the slippage you’d be willing to tolerate.</p>\n<p>To give further details, let’s look at using Flashbots (Flashbots RPC or a private mempool, either is a great idea).</p>\n<p>By using a private tx with the code provided for this contest, in the case of low liquidity, you’d still loose a considerable amount of value. No front-run needs to happen as in asking the price to the pool, you’ll always get a valid response.</p>\n<p>This has happened to Yield Farming Aggregators (last I remember was yearn with StakeDAO token or similar). To summarize: Asking the price to the pool in the same tx is the same as having a 0 slippage check, which means you can loose value even without being front-run.</p>\n<p>Now let’s add the idea of being front-run while using Flashbots RPC:<br>\n-> You have calculate the off-chain Price, which means there’ a require that will revert if the tx will fail, which means (because Flashbots is awesome) the tx won’t be mined unless the tx goes through (miner get’s a tip).<br>\nThis means you can be extremely strict with your slippage check, providing you with as much MEV protection as possible.</p>\n<p>For these reasons I believe the finding to be valid and I recommend you do explore:</p>\n<ul>\n<li>Flashbots (private TXs)</li>\n<li>Price as parameter</li>\n<li>Chainlink Price Feeds</li>\n</ul>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/35#issuecomment-1059802427\">kphed (Redacted Cartel) commented</a>:</strong></p>\n<blockquote>\n<blockquote>\n<p>I think the sponsor’s perspective is interesting in that I believe any MEV researcher could write a simple algorithm to check for the tx inputs to detect a slippage check.</p>\n</blockquote>\n<p>That was my point, that it lowers the difficulty threshold.</p>\n<p>Thanks, the warden’s recommended solution makes more sense now after your elaboration. We were planning on using Flashbots Protect and will look into your other suggestions as well.</p>\n</blockquote>\n<hr>\n<h2 id=\"m-06-safeerc20sol-is-imported-but-not-used-in-the-transferbribes-function-\" style=\"position:relative;\"><a href=\"#m-06-safeerc20sol-is-imported-but-not-used-in-the-transferbribes-function-\" aria-label=\"m 06 safeerc20sol is imported but not used in the transferbribes function  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/4\">[M-06] <code>SafeERC20.sol</code> is imported but not used in the <code>transferBribes()</code> function </a></h2>\n<p><em>Submitted by jayjonah8, also found by cccz, cmichel, Dravee, gzeon, hyh, IllIllI, leastwood, NoamYakov, and Omik</em></p>\n<p>In BribeVault.sol the transferBribes() function uses token.transfer() instead of token.safeTransfer.\nTokens that don’t correctly implement the latest EIP20 spec, like USDT, will be unusable in the protocol as they revert the transaction because of the missing return value.  The fact that the SafeERC20.sol library is imported at the top of the BribeVault.sol implies that safeTransfer should be being used but may have been forgotten.</p>\n<h3 id=\"proof-of-concept-3\" style=\"position:relative;\"><a href=\"#proof-of-concept-3\" aria-label=\"proof of concept 3 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h3>\n<p><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L296\">BribeVault.sol#L296</a><br></p>\n<h3 id=\"recommended-mitigation-steps-4\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-4\" aria-label=\"recommended mitigation steps 4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h3>\n<p>It’s recommended to use OpenZeppelin’s SafeERC20 versions with the safeTransfer and safeTransferFrom functions that handle the return value check as well as non-standard-compliant tokens.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/4#issuecomment-1040506429\">kphed (Redacted Cartel) confirmed and commented</a>:</strong></p>\n<blockquote>\n<p>Good catch!</p>\n<p>Thanks again for participating in our contest jayjonah8, looking forward to more feedback/suggestions/comments.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/4#issuecomment-1059786452\">Alex the Entreprenerd (judge) decreased severity to Medium and commented</a>:</strong></p>\n<blockquote>\n<p>Agree with the finding, because this is contingent on the specific token failing. I believe Medium severity to be more appropriate.</p>\n</blockquote>\n<hr>\n<h2 id=\"m-07-changing-bribevault-in-rewarddistributorsol-will-lock-current-eth-rewards\" style=\"position:relative;\"><a href=\"#m-07-changing-bribevault-in-rewarddistributorsol-will-lock-current-eth-rewards\" aria-label=\"m 07 changing bribevault in rewarddistributorsol will lock current eth rewards permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/7\">[M-07] Changing <code>bribeVault</code> in <code>RewardDistributor.sol</code> will Lock Current ETH Rewards</a></h2>\n<p><em>Submitted by kirk-baird, also found by WatchPug</em></p>\n<p><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L178-#L182\">RewardDistributor.sol#L178-#L182</a><br>\n<a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L65-#L73\">RewardDistributor.sol#L65-#L73</a></p>\n<p>Claiming of the ETH native currency requires <code>token</code> to be set to <code>bribeVault</code>. If the <code>bribeVault</code> is modified in <code>setBribeVault()</code> then users who have ETH rewards will now be considered to have <code>ERC20(bribeVault)</code> tokens. Since <code>bribeVault</code> is not an ERC20 token the <code>transfer()</code> call will fail and the users will not be able to claim their funds.</p>\n<h3 id=\"recommended-mitigation-steps-5\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-5\" aria-label=\"recommended mitigation steps 5 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h3>\n<p>Consider removing the functionality to change the <code>bribeVault</code> or ensuring all funds have been withdraw i.e. <code>balanceOf(address(this)) == 0</code> before changing the <code>bribeVault</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/7#issuecomment-1040568870\">kphed (Redacted Cartel) confirmed and commented</a>:</strong></p>\n<blockquote>\n<p>Good find, we’re going to address this by making <code>bribeVault</code> immutable and removing the setter.</p>\n<p>Thanks again for participating in our contest kirk-baird, looking forward to more feedback/suggestions/comments.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/7#issuecomment-1059788677\">Alex the Entreprenerd (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Agree with the finding, ultimately preventing <code>bribeVault</code> from changing will provide users further security guarantees.</p>\n<p>An alternative solution would be to use a different code for ETH (I’ve seen protocols use address(0) or perhaps 0xeeeeeeee).</p>\n<p>However I believe that making <code>bribeVault</code> immutable will provide the stronger guarantees.</p>\n</blockquote>\n<hr>\n<h2 id=\"m-08-admin-privilege---owner-can-rug-via-thecosomataethwithdraw\" style=\"position:relative;\"><a href=\"#m-08-admin-privilege---owner-can-rug-via-thecosomataethwithdraw\" aria-label=\"m 08 admin privilege   owner can rug via thecosomataethwithdraw permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/39\">[M-08] Admin Privilege - Owner can rug via <code>ThecosomataETH.withdraw</code></a></h2>\n<p><em>Submitted by Alex the Entreprenerd, also found by gzeon</em></p>\n<p>Due to the generalized nature of <code>withdraw</code> the function is a clear rug-vector, allowing the <code>owner</code> to steal all funds.</p>\n<p>Ideally, you should add some validation logic to limit the tokens or the amounts that the owner can withdraw.</p>\n<p>Additionally, it’s important that you disclose the level of admin privilege and the risk it can cause to your users and depositors.</p>\n<h3 id=\"recommended-mitigation-steps-6\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-6\" aria-label=\"recommended mitigation steps 6 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h3>\n<p>Disclose the admin privilege in your docs.<br>\nRefactor the code to reduce it.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/39#issuecomment-1042428554\">kphed (Redacted Cartel) disputed and commented</a>:</strong></p>\n<blockquote>\n<p>The <code>owner</code> is our protocol multisig which has proven itself to be a trustworthy steward of funds (e.g. manages the Redacted treasury funds).</p>\n<p>The <code>withdraw</code> method is simply a utility to remove any ERC20 tokens that are unintentionally received. There won’t be any funds to steal since it’s not intended for the Thecosomata contract to custody funds for any extended period of time: our keepers will constantly poll the contract so that any BTRFLY received gets paired with ETH and added to our Curve LP immediately - any excess is burned.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/39#issuecomment-1051071492\">Alex the Entreprenerd (judge) closed as Invalid and commented</a>:</strong></p>\n<blockquote>\n<p>It should be noted that I have submitted the finding, and in being judge of the contest am forfeiting my potential winnings.</p>\n<p>Personally, I don’t believe a multisig gives any particular security guarantee to depositors beside the fact that it takes X amount of people to agree on how to move funds.</p>\n<p>The sponsor is making it clear that the <code>owner</code> in this case is also the depositor of funds.<br>\nThis means that the multi-sig is self custodying the funds into the contract.</p>\n<p>As such, the finding doesn’t prove any additional security risk beside those that comes with a multi-sig.</p>\n<p>For those reasons, the finding is invalid.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/39#issuecomment-1051158419\">kphed (Redacted Cartel) commented</a>:</strong></p>\n<blockquote>\n<p>Thanks for following up with your thoughts @Alex the Entreprenerd.</p>\n<p>NOTE: Mistakenly made comment below because I thought this was referring to the BribeVault contract.</p>\n<blockquote>\n<p>The sponsor is making it clear that the owner in this case is also the depositor of funds.\nThis means that the multi-sig is self custodying the funds into the contract.</p>\n</blockquote>\n<p>Just to clear up any miscommunication or misunderstandings, we’ve never stated that the owner is the depositor of funds - the funds are deposited by bribers. The owner/admin only whitelists contracts that have permission to call the BribeVault’s deposit methods but those contracts do not custody funds beyond the deposit transactions (this is also only the case when a briber deposits a native token).</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/39#issuecomment-1051192536\">Alex the Entreprenerd (judge) reopened as Valid and commented</a>:</strong></p>\n<blockquote>\n<p>Thank you for the clarification @kphed.</p>\n<p>If the bribers are not the same as the owner then the owner technically has the ability of withdrawing funds at any time, which puts the depositors under the risk of the owner rugging.</p>\n<p>Typically a Vault Protocol (Yearn, Badger) would have a check for “protectedTokens”, in this case BTRFLY and WETH to prevent taking that type of operation.</p>\n<p>As it stands, the multisig can move the funds at any time, technically can frontrun the <code>keeper</code> and steal the funds.</p>\n<p>Also notice that you said that there will be a keeper for <code>performUpkeep</code> but the modifier is <code>onlyOwner</code> which either means you’ll have an EOA as the owner, or you may want to change the access control checker (or remove it as Chainlink docs would require you to).</p>\n<p>With the information I have, I’m inclined to revert back to medium severity.</p>\n<p>While there’s always the counter-argument that the multisig or governance will not rug, the only guarantee for it is the inability to rug by structuring the smart contract in a way that makes it impossible to move funds (e.g. add a check against moving BTRFLY and WETH, allow sweeping of other “random” tokens)</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/39#issuecomment-1051525527\">kphed (Redacted Cartel) commented</a>:</strong></p>\n<blockquote>\n<p>Sorry, disregard my last comment, I mistakenly read your comment as one directed towards BribeVault (which also has a method to withdraw tokens). You’re correct, BTRFLY is minted by our protocol for ThecosomataETH. That said, we still don’t consider the possibility of admin-rugging a real concern.</p>\n<blockquote>\n<p>Typically a Vault Protocol (Yearn, Badger) would have a check for “protectedTokens”, in this case BTRFLY and WETH to prevent taking that type of operation.</p>\n</blockquote>\n<p>This is a potential idea, thanks, I’ll share it with the team.</p>\n<blockquote>\n<p>Also notice that you said that there will be a keeper for performUpkeep but the modifier is onlyOwner which either means you’ll have an EOA as the owner, or you may want to change the access control checker (or remove it as Chainlink docs would require you to).</p>\n</blockquote>\n<p>Tagging @drahrealm as he’s implementing ThecosomataETH. Your comment about <code>onlyOwner</code> is a good one though - it does appear to be a mistake or can be improved tremendously (e.g. use AccessControl and add a role limited to calling this and not the withdraw method).</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/39#issuecomment-1059793149\">Alex the Entreprenerd (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Would highly recommend limiting the withdrawal to specific tokens (ideally exclude important tokens), this would provide strong security guarantees against a rug.</p>\n<p>Also limiting roles can help reduce trust, however, it wouldn’t address the underlying issue that “someone” can move the funds.</p>\n<p>With the information I have, I believe Medium Severity to be appropriate, and believe the sponsor has set motion to minimize trust as well as add additional security guarantees.</p>\n</blockquote>\n<hr>\n<h2 id=\"m-09-improper-control-over-the-versions-of-distributions-metadata-may-lead-to-repeated-claims-of-rewards\" style=\"position:relative;\"><a href=\"#m-09-improper-control-over-the-versions-of-distributions-metadata-may-lead-to-repeated-claims-of-rewards\" aria-label=\"m 09 improper control over the versions of distributions metadata may lead to repeated claims of rewards permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/89\">[M-09] Improper control over the versions of distributions’ metadata may lead to repeated claims of rewards</a></h2>\n<p><em>Submitted by WatchPug</em></p>\n<p><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L317-L324\">BribeVault.sol#L317-L324</a><br></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"9\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">updateRewardsMetadata</span><span class=\"mtk1\">(Common.Distribution[] </span><span class=\"mtk12\">calldata</span><span class=\"mtk1\"> </span><span class=\"mtk12\">distributions</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">external</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">onlyRole</span><span class=\"mtk1\">(</span><span class=\"mtk12\">DEFAULT_ADMIN_ROLE</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">{</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">distributions</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk7\">0</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;Invalid distributions&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">IRewardDistributor</span><span class=\"mtk1\">(</span><span class=\"mtk12\">distributor</span><span class=\"mtk1\">).</span><span class=\"mtk11\">updateRewardsMetadata</span><span class=\"mtk1\">(</span><span class=\"mtk12\">distributions</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p>In the current implementation, <code>DEFAULT_ADMIN_ROLE</code> of <code>BribeVault</code> can call <code>updateRewardsMetadata()</code> to update the rewards metadata for the specified identifiers.</p>\n<p>When a distribution’s metadata is updated, it will also increase the <code>updateCount</code> and reset the claimed tracker.</p>\n<p><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/RewardDistributor.sol#L97-L119\">RewardDistributor.sol#L97-L119</a><br></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"10\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">updateRewardsMetadata</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        Common.Distribution[] </span><span class=\"mtk12\">calldata</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_distributions</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    ) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\"> == </span><span class=\"mtk12\">bribeVault</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;Invalid access&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_distributions</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk7\">0</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;Invalid _distributions&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk15\">for</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">i</span><span class=\"mtk1\"> = </span><span class=\"mtk7\">0</span><span class=\"mtk1\">; </span><span class=\"mtk12\">i</span><span class=\"mtk1\"> &lt; </span><span class=\"mtk12\">_distributions</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span><span class=\"mtk1\">; </span><span class=\"mtk12\">i</span><span class=\"mtk1\">++) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk3\">// Update the metadata and also increment the update to reset the claimed tracker</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk12\">Reward</span><span class=\"mtk1\"> </span><span class=\"mtk12\">storage</span><span class=\"mtk1\"> </span><span class=\"mtk12\">reward</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">rewards</span><span class=\"mtk1\">[</span><span class=\"mtk12\">_distributions</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">].</span><span class=\"mtk12\">rewardIdentifier</span><span class=\"mtk1\">];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk12\">reward</span><span class=\"mtk1\">.</span><span class=\"mtk12\">token</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_distributions</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">].</span><span class=\"mtk12\">token</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk12\">reward</span><span class=\"mtk1\">.</span><span class=\"mtk12\">merkleRoot</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_distributions</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">].</span><span class=\"mtk12\">merkleRoot</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk12\">reward</span><span class=\"mtk1\">.</span><span class=\"mtk12\">proof</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_distributions</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">].</span><span class=\"mtk12\">proof</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk12\">reward</span><span class=\"mtk1\">.</span><span class=\"mtk12\">updateCount</span><span class=\"mtk1\"> += </span><span class=\"mtk7\">1</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk12\">emit</span><span class=\"mtk1\"> </span><span class=\"mtk11\">RewardMetadataUpdated</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">                </span><span class=\"mtk12\">_distributions</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">].</span><span class=\"mtk12\">rewardIdentifier</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">                </span><span class=\"mtk12\">_distributions</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">].</span><span class=\"mtk12\">token</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">                </span><span class=\"mtk12\">_distributions</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">].</span><span class=\"mtk12\">merkleRoot</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">                </span><span class=\"mtk12\">_distributions</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">].</span><span class=\"mtk12\">proof</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">                </span><span class=\"mtk12\">reward</span><span class=\"mtk1\">.</span><span class=\"mtk12\">updateCount</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            );</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span></code></pre>\n<p>However, when the network is congested, <code>DEFAULT_ADMIN_ROLE</code> of <code>BribeVault</code> may mistakenly send 2 <code>updateRewardsMetadata()</code> txs, and the transactions can be packaged into different blocks.</p>\n<p>Let’s say there 2 <code>updateRewardsMetadata()</code> tx with the same calldata, if someone claims rewards in between the two txs, then they can claim again after the second transaction.</p>\n<h3 id=\"proof-of-concept-4\" style=\"position:relative;\"><a href=\"#proof-of-concept-4\" aria-label=\"proof of concept 4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h3>\n<p>Given:</p>\n<ul>\n<li><code>distributionA</code>’s proof is set wrong in <code>transferBribes()</code></li>\n<li><code>Alice</code> is eligible for rewards in <code>distributionA</code></li>\n<li>the network is congested</li>\n<li>current block number = 10000</li>\n<li><code>DEFAULT_ADMIN_ROLE</code> of <code>BribeVault</code> tries to call <code>updateRewardsMetadata()</code> and update <code>distributionA</code>’s proof;</li>\n<li>After a while, since the prev tx is stucked, <code>DEFAULT_ADMIN_ROLE</code> of <code>BribeVault</code> calls <code>updateRewardsMetadata()</code> again with same calldata;</li>\n<li>The first tx got packed into block 10010;</li>\n<li><code>Alice</code> calls <code>claim()</code> and got the reward;</li>\n<li>The 2nd tx got packed into block 10020;</li>\n<li><code>Alice</code> calls <code>claim()</code> again and get the reward again.</li>\n</ul>\n<h3 id=\"recommended-mitigation-steps-7\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-7\" aria-label=\"recommended mitigation steps 7 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h3>\n<p>Change to:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"11\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">struct</span><span class=\"mtk1\"> </span><span class=\"mtk12\">UpdateDistribution</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">bytes32</span><span class=\"mtk1\"> </span><span class=\"mtk12\">rewardIdentifier</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">token</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">bytes32</span><span class=\"mtk1\"> </span><span class=\"mtk12\">merkleRoot</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">bytes32</span><span class=\"mtk1\"> </span><span class=\"mtk12\">proof</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">prevUpdateCount</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">updateRewardsMetadata</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    Common.UpdateDistribution[] </span><span class=\"mtk12\">calldata</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_distributions</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\"> == </span><span class=\"mtk12\">bribeVault</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;Invalid access&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_distributions</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk7\">0</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;Invalid _distributions&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">for</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">i</span><span class=\"mtk1\"> = </span><span class=\"mtk7\">0</span><span class=\"mtk1\">; </span><span class=\"mtk12\">i</span><span class=\"mtk1\"> &lt; </span><span class=\"mtk12\">_distributions</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span><span class=\"mtk1\">; </span><span class=\"mtk12\">i</span><span class=\"mtk1\">++) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">reward</span><span class=\"mtk1\">.</span><span class=\"mtk12\">updateCount</span><span class=\"mtk1\"> == </span><span class=\"mtk12\">_distributions</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">].</span><span class=\"mtk12\">prevUpdateCount</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;Invalid updateCount&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// Update the metadata and also increment the update to reset the claimed tracker</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">Reward</span><span class=\"mtk1\"> </span><span class=\"mtk12\">storage</span><span class=\"mtk1\"> </span><span class=\"mtk12\">reward</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">rewards</span><span class=\"mtk1\">[</span><span class=\"mtk12\">_distributions</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">].</span><span class=\"mtk12\">rewardIdentifier</span><span class=\"mtk1\">];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">reward</span><span class=\"mtk1\">.</span><span class=\"mtk12\">token</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_distributions</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">].</span><span class=\"mtk12\">token</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">reward</span><span class=\"mtk1\">.</span><span class=\"mtk12\">merkleRoot</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_distributions</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">].</span><span class=\"mtk12\">merkleRoot</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">reward</span><span class=\"mtk1\">.</span><span class=\"mtk12\">proof</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_distributions</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">].</span><span class=\"mtk12\">proof</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">reward</span><span class=\"mtk1\">.</span><span class=\"mtk12\">updateCount</span><span class=\"mtk1\"> += </span><span class=\"mtk7\">1</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">emit</span><span class=\"mtk1\"> </span><span class=\"mtk11\">RewardMetadataUpdated</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk12\">_distributions</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">].</span><span class=\"mtk12\">rewardIdentifier</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk12\">_distributions</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">].</span><span class=\"mtk12\">token</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk12\">_distributions</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">].</span><span class=\"mtk12\">merkleRoot</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk12\">_distributions</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">].</span><span class=\"mtk12\">proof</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk12\">reward</span><span class=\"mtk1\">.</span><span class=\"mtk12\">updateCount</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        );</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/89#issuecomment-1043630034\">kphed (Redacted Cartel) disputed and commented</a>:</strong></p>\n<blockquote>\n<blockquote>\n<p>However, when the network is congested, DEFAULT<em>ADMIN</em>ROLE of BribeVault may mistakenly send 2 updateRewardsMetadata() txs, and the transactions can be packaged into different blocks.</p>\n</blockquote>\n<p>The tx is executed via a multisig - we won’t accidentally call it twice.</p>\n<blockquote>\n<p>After a while, since the prev tx is stucked, DEFAULT<em>ADMIN</em>ROLE of BribeVault calls updateRewardsMetadata() again with same calldata;</p>\n</blockquote>\n<p>In the scenario where we wanted to call <code>updateRewardsMetadata</code> again with the same calldata, we would use the same nonce as the stuck transaction.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/89#issuecomment-1059802903\">Alex the Entreprenerd (judge) decreased severity to Medium and commented</a>:</strong></p>\n<blockquote>\n<p>I agree with both the warden and the sponsor in that I believe that:</p>\n<ol>\n<li>the <code>DEFAULT_ADMIN_ROLE</code> can set metadata back to allow further (arbitrary) claims</li>\n<li>This can be used by the admin to grief or alter the claimable rewards</li>\n</ol>\n<p>At the same time I have to agree that the Sponsor wouldn’t be calling this “accidentally”.</p>\n<p>I believe this finding to be valid, and to shed light into Admin Privilege, in that the Admin can set the metadata to whatever they want, allowing or denying claims at their will.</p>\n<p>As such I believe the finding to be valid, and Medium Severity to be more appropriate.</p>\n</blockquote>\n<hr>\n<h2 id=\"m-10-distributions-must-not-match-actual-bribes\" style=\"position:relative;\"><a href=\"#m-10-distributions-must-not-match-actual-bribes\" aria-label=\"m 10 distributions must not match actual bribes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/33\">[M-10] Distributions must not match actual bribes</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The <code>BribeVault.transferBribes</code> transfers tokens for distribution.<br>\nAll parameters (<code>amounts</code>, <code>distributions</code>) are blindly accepted by the function and never verified to match the actual bribes that were deposited for the <code>distributions[i].rewardIdentifier</code>.</p>\n<p>The <code>distributions[i].token</code> must not match the <code>distributions[i].rewardIdentifier</code>’s token (included in the reward identifier hash), and the <code>amounts[i]</code> (and fees) must not match the <code>bribes[bribeIdentifier].amount</code>.</p>\n<p>The admin can submit arbitrary values and create distributions that don’t reflect the bribe the distribution is actually for.\nIt’s easy to under-or overreport amounts for a bribe, take amounts from a different bribe, or steal all amounts from users by using 100% fees, distribute the same bribe over and over, etc.</p>\n<h3 id=\"recommended-mitigation-steps-8\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-8\" aria-label=\"recommended mitigation steps 8 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h3>\n<p>Reduce the trust that users need to have in the admin by validating the <code>Common.Distribution[] calldata distributions</code>,  <code>uint256[] calldata amounts</code>, <code>uint256[] calldata fees</code> parameters against the deposited bribes.</p>\n<p>For example:</p>\n<ul>\n<li>Check that the <code>distributions[i].token</code> matches the <code>distributions[i].rewardIdentifier</code></li>\n<li>The amount + fees equal the <code>bribes[bribeIdentifier].amount</code>, then reset the <code>bribes[bribeIdentifier].amount</code>.</li>\n</ul>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/33#issuecomment-1041726853\">kphed (Redacted Cartel) disagreed with High severity and commented</a>:</strong></p>\n<blockquote>\n<p>We will be adding validation to the <code>transferBribes</code> method to provide peace of mind to our users, however, we consider this low-risk for the reasons below.</p>\n<blockquote>\n<p>All parameters (amounts, distributions) are blindly accepted by the function and never verified to match the actual bribes that were deposited for the distributions[i].rewardIdentifier.\n…</p>\n</blockquote>\n<p>Compilation and thorough validation of the data necessary for calling <code>transferBribes</code> will be done off-chain using a publicly auditable set of scripts in our repo.</p>\n<p>Additionally, since the method can only be called by the protocol multisig (i.e. admin), signers will have the opportunity to review the data prior to submitting their signature. In conjunction with the above, they can generate their own data using the script and compare it against what is to be submitted.</p>\n<p>Thanks again for participating in our contest cmichel, looking forward to more feedback/suggestions/comments.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/33#issuecomment-1059803795\">Alex the Entreprenerd (judge) decreased severity to Medium and commented</a>:</strong></p>\n<blockquote>\n<p>I agree with the finding, the math for onChain bribes is not validated, while the math for bribes distribution is blindly trusted.</p>\n<p>This finding highlights a type of admin privilege, in which the admin can set arbitrary claims which do not reflect the actual state of the system.</p>\n<p>For this reason, as well as the eloquence of the warden, am going to mark this as valid and of medium severity.</p>\n</blockquote>\n<hr>\n<h2 id=\"m-11-depositor-can-spend-funds-of-another-depositor\" style=\"position:relative;\"><a href=\"#m-11-depositor-can-spend-funds-of-another-depositor\" aria-label=\"m 11 depositor can spend funds of another depositor permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/11\">[M-11] Depositor can spend funds of another Depositor</a></h2>\n<p><em>Submitted by csanuragjain</em></p>\n<ol>\n<li>One depositor can spend funds of another depositor</li>\n<li>Depositor can deposit in expired proposal</li>\n<li>rewardIdentifier and bribeIdentifier can point to different rounds/tokens</li>\n</ol>\n<h3 id=\"proof-of-concept-5\" style=\"position:relative;\"><a href=\"#proof-of-concept-5\" aria-label=\"proof of concept 5 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h3>\n<p>One depositor can spend funds of another depositor:</p>\n<ol>\n<li>Malicious depositor can call depositBribeERC20 at BribeVault.sol#L164 with briber as User B (Malicious user can generate bribeIdentifier with his own proposal)</li>\n<li>Assume this User B has approved amount x to this contract</li>\n<li>BribeVault.sol#L187 (IERC20(token).safeTransferFrom(briber, address(this), amount);) will transfer this amount x to the contract due to call at step 1. All this happen without User B knowledge</li>\n</ol>\n<p>Expired Proposal:</p>\n<ol>\n<li>Malicious depositor can generate bribeIdentifier of an expired proposal (proposalDeadlines[proposal] &#x3C; block.timestamp) using generateBribeVaultIdentifier at TokemakBribe.sol#L166</li>\n<li>Malicious depositor can then simply call depositBribeERC20 at BribeVault.sol#L164</li>\n<li>Since there is no deadline check and this function blindly trusts bribeIdentifier, user deposit will be success even though the associated proposal already expired</li>\n</ol>\n<p>RewardIdentifier and bribeIdentifier can point to different rounds/tokens:</p>\n<ol>\n<li>Similar to expired proposal, depositor can generate bribeIdentifier and RewardIdentifier with different tokens and rounds.</li>\n<li>Depositor now calls epositBribeERC20 at BribeVault.sol#L164 with the generated bribeIdentifier and RewardIdentifier</li>\n<li>rewardToBribes[rewardIdentifier].push(bribeIdentifier); will update reward for round x and bribeIdentifier will point to round y which is incorrect</li>\n</ol>\n<h3 id=\"recommended-mitigation-steps-9\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-9\" aria-label=\"recommended mitigation steps 9 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h3>\n<p>depositBribeERC20 at <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L164\">BribeVault.sol#L164</a> should only be allowed to be called via TokemakBribe.sol</p>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/11#issuecomment-1040409839\">kphed (Redacted Cartel) disputed and commented</a>:</strong></p>\n<blockquote>\n<blockquote>\n<p>depositBribeERC20 at BribeVault.sol#L164 should only be allowed to be called via TokemakBribe.sol</p>\n</blockquote>\n<p>Only those with the “depositor” role can call the deposit bribe methods (<code>depositBribeERC20</code> and <code>depositBribe</code>). We only grant the role to bribe contracts we own such as TokemakBribe.sol.</p>\n<p>Thanks again for participating in our contest csanuragjain, looking forward to more feedback/suggestions/comments.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/11#issuecomment-1059804225\">Alex the Entreprenerd (judge) decreased severity to Medium and commented</a>:</strong></p>\n<blockquote>\n<p>While the finding is similar to M-02, I believe this more eloquently shows the specific types of admin privileges that the <code>DEPOSITOR_ROLE</code> has for the function <code>depositBribeERC20</code>.</p>\n<p>Ultimately the finding is highlighting how things can go wrong and how the <code>DEPOSITOR_ROLE</code> provides a high level of admin privilege.</p>\n<p>Because this is contingent on a malicious admin, I believe Medium Severity to be more appropriate.</p>\n</blockquote>\n<hr>\n<h2 id=\"m-12-users-can-frontrun-calls-to-updaterewardsmetadata-and-claim-tokens-twice\" style=\"position:relative;\"><a href=\"#m-12-users-can-frontrun-calls-to-updaterewardsmetadata-and-claim-tokens-twice\" aria-label=\"m 12 users can frontrun calls to updaterewardsmetadata and claim tokens twice permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/118\">[M-12] Users Can Frontrun Calls to <code>updateRewardsMetadata()</code> And Claim Tokens Twice</a></h2>\n<p><em>Submitted by leastwood</em></p>\n<p>The <code>updateRewardsMetadata()</code> function is called by the <code>BribeVault</code> contract by the admin role. The function will take a list of distributions which are used to update the associated reward metadata. It is expected that the merkle root will be updated to correctly identify which claimers have already claimed tokens.</p>\n<p><code>reward.updateCount</code> is incremented to reset the claimed tracker, allowing users that may have previously claimed, to claim their updated reward. However, there is potential for mis-use if users frontrun calls to <code>updateRewardsMetadata()</code> and claim their reward after the new merkle root has been calculated and updated by the admin role. This may allow the claimer to double claim their rewards or lead to a loss in rewards if the reward metadata completely replaces the previous list of claimers.</p>\n<h3 id=\"proof-of-concept-6\" style=\"position:relative;\"><a href=\"#proof-of-concept-6\" aria-label=\"proof of concept 6 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h3>\n<p><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L97-L119\">RewardDistributor.sol#L97-L119</a><br>\n<a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L127-L209\">RewardDistributor.sol#L127-L209</a><br></p>\n<h3 id=\"recommended-mitigation-steps-10\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-10\" aria-label=\"recommended mitigation steps 10 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h3>\n<p>Consider implementing a delay where users cannot claim rewards before a call to <code>updateRewardsMetadata()</code> is made. This should ensure the admin role can construct a merkle tree based on the most up-to-date and correct data.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/118#issuecomment-1043693014\">kphed (Redacted Cartel) confirmed and commented</a>:</strong></p>\n<blockquote>\n<p>After speaking with leastwood via Discord, I now believe this issue to be meaningfully different from issue M-09 and is a valid attack vector. His recommended solution above inspired a fix which we both agreed would solve the problem (i.e. set a “blank” merkle root, evaluate the users who claimed with the previous merkle root, and construct a new one accordingly).</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/118#issuecomment-1059807830\">Alex the Entreprenerd (judge) decreased severity to Medium and commented</a>:</strong></p>\n<blockquote>\n<p>I appreciate the nuance from the sponsor over this finding.</p>\n<p>Ultimately when using a merkle proof system, the new proof is calculated at a certain time. (ProofX)</p>\n<p>If UserA didn’t claim when the proof was generated, they technically have time between when the proof is generated and the proof is published to claim for the first time.</p>\n<p>Because the new Merkle Proof (ProofX) was built to allow UserA to claim, they will be able to claim again.</p>\n<p>The only way I can think of to avoid this is to always only have one proof per set of claims, as to avoid getting front-run.</p>\n<p>There is merit to make this finding separate, although ultimately the reason why this is possible is because of the Admin ability to change the proofs at any time.</p>\n<p>So I’m going to suggest that this finding is similar to M-09, it’s mitigation should be basically the same, however I’ll mark as separate to give credit where it’s due.</p>\n<p>Because the finding is contingent on external conditions (owner getting frontrun or owner being malicious), I believe medium severity to be appropriate.</p>\n<p>A mitigation could be to push new proofs via Flashbots, and use a snapshot like system to check that no claims where made in the time between the proof generation and the proof being set.</p>\n</blockquote>\n<hr>\n<h2 id=\"m-13-reentrancy-in-depositbribeerc20-function\" style=\"position:relative;\"><a href=\"#m-13-reentrancy-in-depositbribeerc20-function\" aria-label=\"m 13 reentrancy in depositbribeerc20 function permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/122\">[M-13] Reentrancy in <code>depositBribeERC20</code> function</a></h2>\n<p><em>Submitted by Czar102, also found by 0x1f8b and SolidityScan</em></p>\n<p><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L164-L205\">BribeVault.sol#L164-L205</a></p>\n<p><code>depositBribeERC20</code> function in <code>BriveVault</code> is reentrant in line 187, where an address supplied by the caller is called.</p>\n<p>A bad actor that has <code>DEPOSITOR_ROLE</code> and is a contract can execute a folowing attack:</p>\n<ol>\n<li>Create a dummy token contract, reentrant in the transferFrom() function. All tokens are approved to the <code>BriveVault</code> and the attacker contract has unlimited tokens. Reentrancy aims back to a function in the attacker contract, which calls <code>depositBribeERC20</code> again.</li>\n<li>The first call by the contract must use a novel <code>bribeIdentifier</code>. <code>token</code> is set to a dummy contract and <code>amount</code> to <code>uint(-2)</code>.</li>\n<li>All checks pass, <code>transferFrom</code> is called, which calls attacker contract, which can call <code>depositBribeERC20</code> again, this time will transfer 1 wei of a valuable token, using the same <code>bribeIdentifier</code>. All checks pass as the previous token hasn’t been registered yet. Then, a valid transfer happens. After that, the amount is set to 1 wei and the token is saved. Event is emitted and the function returns value. Then, attacker function returns and dummy token returns. The operation is to increment amount in storage by the transfer value, which increases <code>b.amount</code> to the maximum integer. The token is nonzero, so the if statement is passed.</li>\n</ol>\n<p>Thus, an attacker can grant any amount of tokens from <code>BriveVault</code> to a certain bribe, stealing all the funds once the bribe will be withdrawn.</p>\n<h3 id=\"recommended-mitigation-steps-11\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-11\" aria-label=\"recommended mitigation steps 11 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h3>\n<p>Set bribe token before the transfer is made.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/122#issuecomment-1059989503\">Alex the Entreprenerd (judge) decreased severity to Medium and commented</a>:</strong></p>\n<blockquote>\n<p>I do believe re-entrancy is possible, so I recommend the sponsor to add the <code>nonReentrant</code> modifier to the deposit function.</p>\n<p>I’ll keep the finding separate [from M-02] as this deals with reEntrancy.<br>\nMitigation would be to enforce a bribeIdentifier to be used for a specific token (and it being enforced), as well as adding <code>nonReentrant</code>.</p>\n<p>Because the function is permissioned, I believe medium severity to be more appropriate.</p>\n</blockquote>\n<hr>\n<h2 id=\"m-14-transferbribes-could-transfer-before-proposal-deadline--input-validation\" style=\"position:relative;\"><a href=\"#m-14-transferbribes-could-transfer-before-proposal-deadline--input-validation\" aria-label=\"m 14 transferbribes could transfer before proposal deadline  input validation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/14\">[M-14] transferBribes could transfer before proposal deadline + Input validation</a></h2>\n<p><em>Submitted by csanuragjain, also found by gzeon and WatchPug</em></p>\n<p>It seems that Admin can call transferBribes even when proposals belonging to this rewardIdentifier have not expired. Also due to lack of input validation, token in distributions[i].rewardIdentifier might differ from distributions[i].token and also amount is not validated</p>\n<h3 id=\"proof-of-concept-7\" style=\"position:relative;\"><a href=\"#proof-of-concept-7\" aria-label=\"proof of concept 7 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h3>\n<p>transferBribes could transfer before proposal deadline:</p>\n<ol>\n<li>Observe the transferBribes function at <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L256\">BribeVault.sol#L256</a></li>\n<li>This is directly distributing the rewards for a rewardIdentifier even though proposal (bribeIdentifier) linked to this rewardToBribes[rewardIdentifier] might not have expired. This means users are still depositing and Admin transferred reward early</li>\n</ol>\n<p>Input Validation:</p>\n<ol>\n<li>Observe the transferBribes function at <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L256\">BribeVault.sol#L256</a></li>\n<li>amounts object is directly passed by Admin and there is no verification to see that sum amount of all proposals under rewardToBribes[rewardIdentifier] is equal to amount provided by admin in argument</li>\n<li>distributions[i].token is directly passed by Admin and there is no verification to see that token under distributions[i].rewardIdentifier is equal to the one provided by admin in argument</li>\n</ol>\n<h3 id=\"recommended-mitigation-steps-12\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-12\" aria-label=\"recommended mitigation steps 12 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h3>\n<p>Perform input validation.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/14#issuecomment-1040720186\">kphed (Redacted Cartel) disagreed with Medium severity and commented</a>:</strong></p>\n<blockquote>\n<blockquote>\n<p>transferBribes could transfer before proposal deadline:<br>\n…</p>\n</blockquote>\n<p>Much of the validation will be handled off-chain at the time we compute the proofs and merkle roots (we still need to write the script for that). The reason for that approach is because we will have many similar contracts (but not exactly alike - e.g. some may not have deadlines) to TokemakBribe that will interact with BribeVault. It wouldn’t be feasible to validate all the different constraints on-chain. That said, the admin is a multisig and the signers will have to agree on timing and correctness of the data to prevent this from happening.</p>\n<blockquote>\n<p>Input Validation:<br>\n…</p>\n</blockquote>\n<p>Thanks, we’ll implement #2 and #3 to provide peace of mind to our users.</p>\n<p>Thanks again for participating in our contest csanuragjain, looking forward to more feedback/suggestions/comments.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/14#issuecomment-1059990041\">Alex the Entreprenerd (judge) commented</a>:</strong></p>\n<blockquote>\n<p>While I understand the sponsor’s reasoning, any validation that is not enforced by the Smart Contract can’t be verified.\nIt requires trust which could be minimized, if not removed, if the contract enforced those conditions.</p>\n<p><code>bribeIdentifier</code>, it’s relation with <code>token</code>, the fact that a bribe was transferred or not, all these events can be tracked onChain, offering clear paths for funds, which ultimately give more security guarantees to end users.</p>\n<p>Because this ultimately is a trust issue, I believe medium severity to be appropriate.</p>\n</blockquote>\n<hr>\n<h2 id=\"m-15-fees-can-be-any-amount\" style=\"position:relative;\"><a href=\"#m-15-fees-can-be-any-amount\" aria-label=\"m 15 fees can be any amount permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/74\">[M-15] Fees can be any amount</a></h2>\n<p><em>Submitted by danb, also found by pauliax</em></p>\n<p>In <code>transferBribes</code>, the fees are user input, rather than  calculation using <code>fee</code> (state var).<br>\nCurrently, <code>fee</code> is unused:\n<a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L23\">BribeVault.sol#L23</a>.<br></p>\n<p>Therefore the fees amounts might be wrong.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/74#issuecomment-1059990473\">Alex the Entreprenerd (judge) decreased severity to Medium and commented</a>:</strong></p>\n<blockquote>\n<p>I don’t believe M-14 mentions validation of fees, as such will mark this finding as unique.</p>\n<p>Ultimately the function trusts the Admin input instead of using the storage variable, giving less security guarantees as to the fairness of the Distribution of the Bribes.</p>\n<p>Because this is contingent on a malicious admin, I believe medium severity to be appropriate.</p>\n</blockquote>\n<hr>\n<h2 id=\"m-16-depositor_role-can-manipulate-bamount-value\" style=\"position:relative;\"><a href=\"#m-16-depositor_role-can-manipulate-bamount-value\" aria-label=\"m 16 depositor_role can manipulate bamount value permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/95\">[M-16] <code>DEPOSITOR_ROLE</code> can manipulate <code>b.amount</code> value</a></h2>\n<p><em>Submitted by rfa, also found by Omik</em></p>\n<p><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L187\">BribeVault.sol#L187</a><br></p>\n<p>Malicious <code>DEPOSITOR_ROLE</code> can doing self transfer and manipulate <code>b.amount</code></p>\n<h3 id=\"proof-of-concept-8\" style=\"position:relative;\"><a href=\"#proof-of-concept-8\" aria-label=\"proof of concept 8 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h3>\n<p>In case malicious <code>DEPOSITOR_ROLE</code> inputing <code>WETH</code> address and putting <code>briber</code> == address(this) in <code>safeTransferFrom</code> argument (which is self transfering). Therefore, it is posible to increase <code>b.amount</code> without any cost.</p>\n<p>WETH token contract:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"\" data-index=\"12\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">//Line 62 WETH contract</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">function transferFrom(address src, address dst, uint wad)</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        public</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        returns (bool)</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    {</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        require(balanceOf[src] &gt;= wad);</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        if (src != msg.sender &amp;&amp; allowance[src][msg.sender] != uint(-1)) { </span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">            require(allowance[src][msg.sender] &gt;= wad); </span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">            allowance[src][msg.sender] -= wad; // &lt;----------- this line won&#39;t executed</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        }</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        balanceOf[src] -= wad;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        balanceOf[dst] += wad;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        Transfer(src, dst, wad);</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        return true;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    }</span></span></code></pre>\n<p>If the condition didn’t pass (in this case msg.sender != <code>src</code> ), the transaction will treated like a transfer (doesn’t need an allowance), Therefore its possible to do self transfer</p>\n<h3 id=\"recommended-mitigation-steps-13\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-13\" aria-label=\"recommended mitigation steps 13 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h3>\n<p>I recommend to validate that bribe != Address(this)</p>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/95#issuecomment-1059993804\">Alex the Entreprenerd (judge) commented</a>:</strong></p>\n<blockquote>\n<p>I’m marking the finding as unique because of the interesting mechanic.<br>\nSome ERC20 will revert on trying to transfer to yourself, however the warden showed a specific exploit, using WETH, that could be used against the vault.</p>\n</blockquote>\n<hr>\n<h2 id=\"m-17-thecosomataeth-oracle-price-can-be-better-secured-freshness--tamper-resistance\" style=\"position:relative;\"><a href=\"#m-17-thecosomataeth-oracle-price-can-be-better-secured-freshness--tamper-resistance\" aria-label=\"m 17 thecosomataeth oracle price can be better secured freshness  tamper resistance permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/49\">[M-17] ThecosomataETH: Oracle price can be better secured (freshness + tamper-resistance)</a></h2>\n<p><em>Submitted by hickuphh3</em></p>\n<p><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L94-L110\">ThecosomataETH.sol#L94-L110</a><br></p>\n<p>The <code>ThecosomataETH</code> contract adds ETH and BTRFLY tokens as liquidity into the <a href=\"https://etherscan.io/address/0xf43b15ab692fde1f9c24a9fce700adcc809d5391\">ETH-BTRFLY curve crypto pool</a>. The <code>calculateAmountRequiredForLP()</code> function relies on the <code>price_oracle</code> value returned by the pool to calculate the ETH and BTRFLY amounts to be added as liquidity. It is therefore important to ensure that <code>price_oracle</code> is accurate.</p>\n<p>At the time of writing, the pool has about $5M in liquidity, which is comparable to that of the <a href=\"https://info.uniswap.org/#/pools/0xdf9ab3c649005ebfdf682d2302ca1f673e0d37a2\">liquidity provided on UniswapV3</a>. Flash loan attacks are therefore possible, but ineffective (explained further later).</p>\n<p>In the <a href=\"https://curve.fi/files/crypto-pools-paper.pdf\">curve v2 whitepaper</a>, the price oracle mechanism is explained briefly in the “Algorithm for repegging” section. It is reproduced below for convenience.</p>\n<blockquote>\n<p>Internally, we have a price oracle given by an exponential moving average (EMA) applied in N-dimensional price space. Suppose that the last reported price is <code>pLast</code>, and the update happened <code>t</code> seconds ago while the half-time of the EMA is <code>T1/2</code>. Then the oracle price <code>p_new</code> is given as:</p>\n</blockquote>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"jsx\" data-index=\"13\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">α</span><span class=\"mtk1\"> = </span><span class=\"mtk7\">2</span><span class=\"mtk1\">^(− </span><span class=\"mtk12\">t</span><span class=\"mtk1\"> / </span><span class=\"mtk12\">T1</span><span class=\"mtk1\">/</span><span class=\"mtk7\">2</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">p_new</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">pLast</span><span class=\"mtk1\"> * (</span><span class=\"mtk7\">1</span><span class=\"mtk1\"> - </span><span class=\"mtk12\">α</span><span class=\"mtk1\">) + </span><span class=\"mtk12\">α</span><span class=\"mtk1\"> * </span><span class=\"mtk12\">p_old</span><span class=\"mtk1\"> </span><span class=\"mtk3\">// p_old = current price_oracle</span></span></span></code></pre>\n<h3 id=\"impact\" style=\"position:relative;\"><a href=\"#impact\" aria-label=\"impact permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h3>\n<p>With oracles (curve pool now, to be switched to chainlink based oracle as per comment in L27), there is an inverse correlation between freshness and tamper-resistance.</p>\n<p>We can expect <code>price_oracle</code> to be relatively fresh as trades will occur whenever arbitrage opportunities arise against the UniV3 pool which has comparable liquidity. Note that the <code>ETH-BTRFLY</code> pool has a half-time of 10 minutes (<code>T1/2 = 600</code>). This means that after exactly 10 mins, both <code>pLast</code> and <code>p_old</code> have equal weightage.</p>\n<p>It is unclear how resistant the EMA oracle is against manipulation. Flash loan attacks, while possible, will be ineffective because <code>t</code> will be zero (<code>pLast</code> will be ignored in the update). However, a sophisticated attacker could possibly skew the price oracle by inflating the price of <code>BTRFLY</code> a couple of blocks before the <code>performUpkeep()</code> transaction to get the treasury to deposit more <code>ETH</code> / burn more <code>BTRFLY</code> than necessary.</p>\n<h3 id=\"recommended-mitigation-steps-14\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-14\" aria-label=\"recommended mitigation steps 14 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h3>\n<p>In my opinion, both freshness and tamper-resistance can be better secured.</p>\n<p>This can be done by:</p>\n<ol>\n<li>Ensuring that the price was updated within a certain limit.</li>\n</ol>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"jsx\" data-index=\"14\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// eg. last price update / trade must have been executed within the past hour</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">lastPricesTimestamp</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">ICurveCryptoPool</span><span class=\"mtk1\">(</span><span class=\"mtk12\">CURVEPOOL</span><span class=\"mtk1\">).</span><span class=\"mtk11\">last_prices_timestamp</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">block</span><span class=\"mtk1\">.</span><span class=\"mtk12\">timestamp</span><span class=\"mtk1\"> - </span><span class=\"mtk12\">lastPricesTimestamp</span><span class=\"mtk1\"> &lt;= </span><span class=\"mtk7\">1</span><span class=\"mtk1\"> </span><span class=\"mtk12\">hours</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&#39;stale price&#39;</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<ol start=\"2\">\n<li>Checking that the last reported price <code>pLast</code> has not deviated too far from the current oracle price <code>p_old</code>. One can argue that it would be safer to add liquidity when the market isn’t volatile.</li>\n</ol>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"jsx\" data-index=\"15\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">lastPrice</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">ICurveCryptoPool</span><span class=\"mtk1\">(</span><span class=\"mtk12\">CURVEPOOL</span><span class=\"mtk1\">).</span><span class=\"mtk11\">last_prices</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">oraclePrice</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">ICurveCryptoPool</span><span class=\"mtk1\">(</span><span class=\"mtk12\">CURVEPOOL</span><span class=\"mtk1\">).</span><span class=\"mtk11\">price_oracle</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">percentDiff</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// eg. require difference in prices to be within 5%</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">lastPrice</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk12\">oraclePrice</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">percentDiff</span><span class=\"mtk1\"> = (</span><span class=\"mtk12\">lastPrice</span><span class=\"mtk1\"> - </span><span class=\"mtk12\">oraclePrice</span><span class=\"mtk1\">) * </span><span class=\"mtk7\">1e18</span><span class=\"mtk1\"> / </span><span class=\"mtk12\">oraclePrice</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">} </span><span class=\"mtk15\">else</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">percentDiff</span><span class=\"mtk1\"> = (</span><span class=\"mtk12\">oraclePrice</span><span class=\"mtk1\"> - </span><span class=\"mtk12\">lastPrice</span><span class=\"mtk1\">) * </span><span class=\"mtk7\">1e18</span><span class=\"mtk1\"> / </span><span class=\"mtk12\">oraclePrice</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">percentDiff</span><span class=\"mtk1\"> &lt;= </span><span class=\"mtk7\">5e16</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&#39;volatile market&#39;</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/49#issuecomment-1042571538\">drahrealm (Redacted Cartel) commented</a>:</strong></p>\n<blockquote>\n<p>Idem with M-05, we will proceed with doing calculating the min token amount off-chain, then specify it when calling <code>performUpKeep</code>.</p>\n<p>Thanks for the finding.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/49#issuecomment-1060059235\">Alex the Entreprenerd (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Agree that solution is based off of M-05.<br>\nWhile I believe simpler solutions where highlighted, I feel the warden put in the extra effort to make a valuable submission.</p>\n<p>As such, I’ll mark the finding as unique.</p>\n<p>Personally I would not trust Curve Pricing model over a Price Feed at this time, however am happy to be proven wrong.</p>\n</blockquote>\n<hr>\n<h2 id=\"m-18-rewards-can-be-lost\" style=\"position:relative;\"><a href=\"#m-18-rewards-can-be-lost\" aria-label=\"m 18 rewards can be lost permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/13\">[M-18] Rewards can be lost</a></h2>\n<p><em>Submitted by csanuragjain</em></p>\n<p>Reward can be lost if bribeVault calls the updateRewardsMetadata on same rewardIdentifier again before user can claim his reward (since merkleRoot and proof will get updated).</p>\n<h3 id=\"proof-of-concept-9\" style=\"position:relative;\"><a href=\"#proof-of-concept-9\" aria-label=\"proof of concept 9 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h3>\n<ol>\n<li>bribeVault calls the updateRewardsMetadata at <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L97\">RewardDistributor.sol#L97</a> using rewardIdentifier X</li>\n<li>Assume  _distributions[i].proof contains merkle proof for User A</li>\n<li>User A fails to call claim function</li>\n<li>bribeVault again calls the updateRewardsMetadata at RewardDistributor.sol#L97 using rewardIdentifier X updating  _distributions[i].proof  which might not contain merkle proof of User A now. So User A loses his rewards</li>\n</ol>\n<h3 id=\"recommended-mitigation-steps-15\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-15\" aria-label=\"recommended mitigation steps 15 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h3>\n<p>bribeVault should only make second call to updateRewardsMetadata on same rewardIdentifier when all claimers have made their claims.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/13#issuecomment-1040595384\">kphed (Redacted Cartel) disputed and commented</a>:</strong></p>\n<blockquote>\n<p>We would only call <code>updateRewardsMetadata</code> again if there was an issue with the originally-set merkle root(s). The recommended mitigation steps above would block us from setting the correct merkle roots until after claimers claimed the wrong amounts.</p>\n<p>Thanks again for participating in our contest csanuragjain, looking forward to more feedback/suggestions/comments.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/13#issuecomment-1060063884\">Alex the Entreprenerd (judge) commented</a>:</strong></p>\n<blockquote>\n<p>The finding highlights the consequences of admin privilege, in that the admin can use <code>updateRewardsMetadata</code> to deny claims.</p>\n<p>While I believe the warden could have done a better job at expressing the risks involved for users, I believe the finding to be valid. </p>\n</blockquote>\n<hr>\n<h1 id=\"low-risk-and-non-critical-issues\" style=\"position:relative;\"><a href=\"#low-risk-and-non-critical-issues\" aria-label=\"low risk and non critical issues permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Low Risk and Non-Critical Issues</h1>\n<p>For this contest, 25 reports were submitted by wardens detailing low risk and non-critical issues. The <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/47\">report highlighted below</a> by warden <strong>hickuphh3</strong> received the top score from the judge.</p>\n<p><em>The following wardens also submitted reports: <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/103\">ye0lde</a>, <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/66\">kenzo</a>, <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/115\">pauliax</a>, <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/37\">Ruhum</a>, <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/83\">WatchPug</a>, <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/32\">cmichel</a>, <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/42\">0x0x0x</a>, <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/10\">csanuragjain</a>, <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/101\">defsec</a>, <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/72\">gzeon</a>, <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/17\">kenta</a>, <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/97\">SolidityScan</a>, <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/19\">cccz</a>, <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/44\">IllIllI</a>, <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/117\">peritoflores</a>, <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/26\">0x1f8b</a>, <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/41\">0xliumin</a>, <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/123\">hyh</a>, <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/111\">Omik</a>, <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/27\">robee</a>, <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/58\">Dravee</a>, <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/3\">jayjonah8</a>, <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/93\">p4st13r4</a>, and <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/78\">danb</a>.</em></p>\n<h2 id=\"codebase-impressions--summary\" style=\"position:relative;\"><a href=\"#codebase-impressions--summary\" aria-label=\"codebase impressions  summary permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Codebase Impressions &#x26; Summary</h2>\n<p>This audit scope consisted of 4 contracts. Overall, the code quality is great. Inline comments and documentation provided was adequate. Various parties / roles and contract interactions were well explained.</p>\n<p>Most issues raised are minor improvements to improve the security of the contracts. The only notable findings made had to do with the usage of the curve crypto pool’s price oracle, and protection against sandwich attacks when adding liquidity.</p>\n<p>In addition, I made a suggestion regarding the syncing of Tokemak’s rounds with the <code>TokemakBribe</code> contract.</p>\n<p>Note that I refrained raising issues regarding FoT tokens because I assume they are not meant to be supported.</p>\n<h2 id=\"l-01-rewarddistributor-change-payableaccounttransfer-to-call-for-native-fund-transfers\" style=\"position:relative;\"><a href=\"#l-01-rewarddistributor-change-payableaccounttransfer-to-call-for-native-fund-transfers\" aria-label=\"l 01 rewarddistributor change payableaccounttransfer to call for native fund transfers permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-01] RewardDistributor: Change <code>payable(account).transfer()</code> to <code>.call()</code> for native fund transfers</h2>\n<h3 id=\"line-references\" style=\"position:relative;\"><a href=\"#line-references\" aria-label=\"line references permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Line References</h3>\n<p><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L181\">RewardDistributor.sol#L181</a><br></p>\n<h3 id=\"description\" style=\"position:relative;\"><a href=\"#description\" aria-label=\"description permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Description</h3>\n<p><code>BribeVault</code> uses <code>.call()</code> for native fund transfers, but <code>RewardDistributor</code> uses <code>.transfer()</code>. They should be standardized to <code>.call()</code>, the currently recommended method since <a href=\"https://solidity-by-example.org/sending-ether/\"><code>.transfer()</code> fowards 2300 gas whereas <code>.call()</code> forwards all / set gas.</a></p>\n<h3 id=\"recommended-mitigation-steps-16\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-16\" aria-label=\"recommended mitigation steps 16 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h3>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"jsx\" data-index=\"16\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">(</span><span class=\"mtk12\">bool</span><span class=\"mtk1\"> </span><span class=\"mtk12\">sentAccount</span><span class=\"mtk1\">, ) = </span><span class=\"mtk12\">_account</span><span class=\"mtk1\">.</span><span class=\"mtk12\">call</span><span class=\"mtk1\">{value: </span><span class=\"mtk12\">_amount</span><span class=\"mtk1\">}(</span><span class=\"mtk8\">&quot;&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">sentAccount</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;Failed to transfer to _account&quot;</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<h2 id=\"l-02-bribevault-use-safetransfer-for-tokens\" style=\"position:relative;\"><a href=\"#l-02-bribevault-use-safetransfer-for-tokens\" aria-label=\"l 02 bribevault use safetransfer for tokens permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-02] BribeVault: Use <code>safeTransfer</code> for tokens</h2>\n<h3 id=\"line-references-1\" style=\"position:relative;\"><a href=\"#line-references-1\" aria-label=\"line references 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Line References</h3>\n<p><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L296-L297\">BribeVault.sol#L296-L297</a><br>\n<a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L337\">BribeVault.sol#L337</a></p>\n<h3 id=\"description-1\" style=\"position:relative;\"><a href=\"#description-1\" aria-label=\"description 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Description</h3>\n<p>Some ERC20 tokens like ZRX don’t revert if the transfer fails. Since the <code>SafeERC20</code> has already been imported and the <code>safeTransferFrom</code> method used, the same should be done for token transfers.</p>\n<h3 id=\"recommended-mitigation-steps-17\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-17\" aria-label=\"recommended mitigation steps 17 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h3>\n<p>Replace <code>transfer</code> with <code>safeTransfer</code>.</p>\n<h2 id=\"l-03-rewarddistributor-limit-native-fund-transfers-to-bribevault\" style=\"position:relative;\"><a href=\"#l-03-rewarddistributor-limit-native-fund-transfers-to-bribevault\" aria-label=\"l 03 rewarddistributor limit native fund transfers to bribevault permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-03] RewardDistributor: Limit native fund transfers to <code>bribeVault</code></h2>\n<h3 id=\"line-references-2\" style=\"position:relative;\"><a href=\"#line-references-2\" aria-label=\"line references 2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Line References</h3>\n<p><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L58-L59\">RewardDistributor.sol#L58-L59</a></p>\n<h3 id=\"description-2\" style=\"position:relative;\"><a href=\"#description-2\" aria-label=\"description 2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Description</h3>\n<p>Since the only source of native fund transfers is expected to be the <code>bribeVault</code> contract, it would be good to restrict incoming fund transfers from other sources to prevent accidental transfers.</p>\n<h3 id=\"recommended-mitigation-steps-18\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-18\" aria-label=\"recommended mitigation steps 18 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h3>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"jsx\" data-index=\"17\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">receive</span><span class=\"mtk1\">() </span><span class=\"mtk12\">external</span><span class=\"mtk1\"> </span><span class=\"mtk12\">payable</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\"> == </span><span class=\"mtk12\">bribeVault</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&#39;only bribeVault&#39;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<h2 id=\"l-04-tokemakbribe-sync-rounds-with-tokemaks-manager-instead-of-manually-setting-rounds-via-setround\" style=\"position:relative;\"><a href=\"#l-04-tokemakbribe-sync-rounds-with-tokemaks-manager-instead-of-manually-setting-rounds-via-setround\" aria-label=\"l 04 tokemakbribe sync rounds with tokemaks manager instead of manually setting rounds via setround permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-04] TokemakBribe: Sync rounds with Tokemak’s manager instead of manually setting rounds via <code>setRound()</code></h2>\n<h3 id=\"line-references-3\" style=\"position:relative;\"><a href=\"#line-references-3\" aria-label=\"line references 3 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Line References</h3>\n<p><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L104-L110\">TokemakBribe.sol#L104-L110</a></p>\n<h3 id=\"description-3\" style=\"position:relative;\"><a href=\"#description-3\" aria-label=\"description 3 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Description</h3>\n<p>Instead of manually setting rounds, consider fetching the round number directly from Tokemak’s manager contract via <code>[manager.currentCycleIndex()](https://etherscan.io/address/0xa86e412109f77c45a3bc1c5870b880492fb86a14#readProxyContract)</code>. While I initially wrote an issue about being able to set previous round numbers, after having chatted with the sponsor, it is intended to be a feature, not a bug.</p>\n<h3 id=\"recommended-mitigation-steps-19\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-19\" aria-label=\"recommended mitigation steps 19 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h3>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"jsx\" data-index=\"18\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// TODO: change _round to getRound() wherever it is called in other internal functions</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">getRound</span><span class=\"mtk1\">() </span><span class=\"mtk11\">public</span><span class=\"mtk1\"> </span><span class=\"mtk11\">view</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk3\">// if round is overridden, return set value</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">_round</span><span class=\"mtk1\"> != </span><span class=\"mtk7\">0</span><span class=\"mtk1\">) </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_round</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk3\">// otherwise, if value is 0, use Tokemak&#39;s currentCycleIndex()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk3\">// Tokemak manager at 0xa86e412109f77c45a3bc1c5870b880492fb86a14</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk12\">manager</span><span class=\"mtk1\">.</span><span class=\"mtk11\">currentCycleIndex</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<h2 id=\"n-01-tokemakbribe-getbribe-has-incorrect-description\" style=\"position:relative;\"><a href=\"#n-01-tokemakbribe-getbribe-has-incorrect-description\" aria-label=\"n 01 tokemakbribe getbribe has incorrect description permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[N-01] TokemakBribe: <code>getBribe()</code> has incorrect description</h2>\n<h3 id=\"line-references-4\" style=\"position:relative;\"><a href=\"#line-references-4\" aria-label=\"line references 4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Line References</h3>\n<p><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L188-L194\">TokemakBribe.sol#L188-L194</a></p>\n<h3 id=\"description-4\" style=\"position:relative;\"><a href=\"#description-4\" aria-label=\"description 4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Description</h3>\n<ul>\n<li>Missing <code>round</code> param</li>\n<li><code>bribeAmount</code> has incorrect description</li>\n</ul>\n<h3 id=\"recommended-mitigation-steps-20\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-20\" aria-label=\"recommended mitigation steps 20 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h3>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"jsx\" data-index=\"19\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">/**</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">\t  </span><span class=\"mtk4\">@notice</span><span class=\"mtk3\"> Get bribe from BribeVault</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">\t  </span><span class=\"mtk4\">@param</span><span class=\"mtk3\">  </span><span class=\"mtk12\">proposal</span><span class=\"mtk3\">            address  Proposal</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">          </span><span class=\"mtk4\">@param</span><span class=\"mtk3\">  </span><span class=\"mtk12\">round</span><span class=\"mtk3\">               uint256  Round</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">\t  </span><span class=\"mtk4\">@param</span><span class=\"mtk3\">  </span><span class=\"mtk12\">token</span><span class=\"mtk3\">               address  Token</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">\t  </span><span class=\"mtk4\">@return</span><span class=\"mtk3\"> bribeToken          address  Bribe token address</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">\t  </span><span class=\"mtk4\">@return</span><span class=\"mtk3\"> bribeAmount         uint256  Bribe token amount</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">*/</span></span></span></code></pre>\n<h2 id=\"n-02-emit-relevant-events-in-constructor-methods-when-variables-are-set-or-abstract-to-internal-functions\" style=\"position:relative;\"><a href=\"#n-02-emit-relevant-events-in-constructor-methods-when-variables-are-set-or-abstract-to-internal-functions\" aria-label=\"n 02 emit relevant events in constructor methods when variables are set or abstract to internal functions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[N-02] Emit relevant events in constructor methods when variables are set, or abstract to internal functions</h2>\n<h3 id=\"line-references-5\" style=\"position:relative;\"><a href=\"#line-references-5\" aria-label=\"line references 5 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Line References</h3>\n<p><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L59-L74\">BribeVault.sol#L59-L74</a><br></p>\n<p><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L51-L56\">RewardDistributor.sol#L51-L56</a></p>\n<h3 id=\"description-5\" style=\"position:relative;\"><a href=\"#description-5\" aria-label=\"description 5 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Description</h3>\n<p>Some variables are set in the constructor method but do not emit events, unlike their setter counterparts. For instance, <code>bribeVault</code> in the <code>RewardDistributor</code> contract fails to emit the <code>SetBribeVault</code> event, but this is emitted in the <code>setBribeVault()</code> function.</p>\n<h3 id=\"recommended-mitigation-steps-21\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-21\" aria-label=\"recommended mitigation steps 21 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h3>\n<p>Either emit the events in the constructor, or make the setter functions public and have the constructor call it.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/47#issuecomment-1045048948\">kphed (Redacted Cartel) confirmed and commented</a>:</strong></p>\n<blockquote>\n<blockquote>\n<p>Overall, the code quality is great. Inline comments and documentation provided was adequate. Various parties / roles and contract interactions were well explained.</p>\n</blockquote>\n<p>Thanks for the compliment and the thorough code review! Both are greatly appreciated.</p>\n<blockquote>\n<p>[L-01] RewardDistributor: Change payable(account).transfer() to .call() for native fund transfers<br>\n[L-02] BribeVault: Use safeTransfer for tokens<br>\n[L-03] RewardDistributor: Limit native fund transfers to bribeVault<br>\n[N-01] TokemakBribe: getBribe() has incorrect description<br>\n[N-02] Emit relevant events in constructor methods when variables are set, or abstract to internal functions</p>\n</blockquote>\n<p>Thank you, we’re planning on implementing all of the above.</p>\n<blockquote>\n<p>[L-04] TokemakBribe: Sync rounds with Tokemak’s manager instead of manually setting rounds via setRound()</p>\n</blockquote>\n<p>This was an option we’ve considered but we opted for setting the round manually since our schedule may not always be in lockstep with Tokemak’s (e.g. there may be off-chain activities - governance, disputes, etc. - that may result in us taking delayed action). That said, your recommended implementation is a great middle ground solution, thank you for that.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/47#issuecomment-1045081504\">kphed (Redacted Cartel) commented</a>:</strong></p>\n<blockquote>\n<p>Your comment has inspired a potentially more streamlined solution without needing <code>round</code>: using a proposal’s deadline to segregate the token deposits for a general time period (i.e. voting round). Thank you!</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/47#issuecomment-1052808940\">Alex the Entreprenerd (judge) commented</a>:</strong></p>\n<blockquote>\n<p>The report is great, gives some general considerations as well as specific advice to implement.<br>\nGreat submission.</p>\n<p>Only negative note is the warden missed re-entrancy, beside that, this is how I think a QA report should be done.</p>\n<p>Score: 7/10</p>\n</blockquote>\n<hr>\n<h1 id=\"gas-optimizations\" style=\"position:relative;\"><a href=\"#gas-optimizations\" aria-label=\"gas optimizations permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Gas Optimizations</h1>\n<p>For this contest, 18 reports were submitted by wardens detailing gas optimizations. The <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/84\">report highlighted below</a> by warden team <strong>WatchPug</strong> received the top score from the judge.</p>\n<p><em>The following wardens also submitted reports: <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/8\">csanuragjain</a>, <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/12\">0x1f8b</a>, <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/53\">Jujic</a>, <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/79\">ye0lde</a>, <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/46\">hickuphh3</a>, <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/59\">IllIllI</a>, <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/116\">pauliax</a>, <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/16\">kenta</a>, <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/28\">robee</a>, <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/71\">gzeon</a>, <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/110\">Omik</a>, <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/99\">rfa</a>, <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/63\">z3s</a>, <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/50\">d4rk</a>, <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/94\">SolidityScan</a>, <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/124\">Tomio</a>, and <a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/100\">defsec</a>.</em></p>\n<h2 id=\"g-01-adding-unchecked-directive-can-save-gas\" style=\"position:relative;\"><a href=\"#g-01-adding-unchecked-directive-can-save-gas\" aria-label=\"g 01 adding unchecked directive can save gas permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[G-01] Adding unchecked directive can save gas</h2>\n<p><em>Note: minor optimation, the amount of gas saved is minor, change when you see fit.</em></p>\n<p>For the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.</p>\n<p>For example:</p>\n<p><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L118-L118\">ThecosomataETH.sol#L118-L118</a></p>\n<h2 id=\"g-02-using-immutable-variable-can-save-gas\" style=\"position:relative;\"><a href=\"#g-02-using-immutable-variable-can-save-gas\" aria-label=\"g 02 using immutable variable can save gas permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[G-02] Using immutable variable can save gas</h2>\n<p><em>Note: Suggested optimation, save a decent amount of gas without compromising readability.</em></p>\n<p><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L28-L28\">TokemakBribe.sol#L28-L28</a><br></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"20\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">public</span><span class=\"mtk1\"> </span><span class=\"mtk12\">bribeVault</span><span class=\"mtk1\">;</span></span></span></code></pre>\n<p><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L60-L65\">TokemakBribe.sol#L60-L65</a><br></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"21\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">constructor</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_bribeVault</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_bribeVault</span><span class=\"mtk1\"> != </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">), </span><span class=\"mtk8\">&quot;Invalid bribeVault&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">bribeVault</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_bribeVault</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">_setupRole</span><span class=\"mtk1\">(</span><span class=\"mtk12\">DEFAULT_ADMIN_ROLE</span><span class=\"mtk1\">, </span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span></code></pre>\n<p>Considering that <code>bribeVault</code> will never change, changing it to immutable variable instead of storage variable can save gas.</p>\n<h2 id=\"g-03-remove-redundant-access-control-checks-can-save-gas\" style=\"position:relative;\"><a href=\"#g-03-remove-redundant-access-control-checks-can-save-gas\" aria-label=\"g 03 remove redundant access control checks can save gas permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[G-03] Remove redundant access control checks can save gas</h2>\n<p><em>Note: suggested optimation, save a decent amount of gas without compromising readability.</em></p>\n<p><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L125-L135\">TokemakBribe.sol#L125-L135</a><br></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"22\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">setProposal</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">proposal</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">deadline</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">public</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">onlyAuthorized</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">proposal</span><span class=\"mtk1\"> != </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">), </span><span class=\"mtk8\">&quot;Invalid proposal&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">deadline</span><span class=\"mtk1\"> &gt;= </span><span class=\"mtk12\">block</span><span class=\"mtk1\">.</span><span class=\"mtk12\">timestamp</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;Deadline must be in the future&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">proposalDeadlines</span><span class=\"mtk1\">[</span><span class=\"mtk12\">proposal</span><span class=\"mtk1\">] = </span><span class=\"mtk12\">deadline</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">emit</span><span class=\"mtk1\"> </span><span class=\"mtk11\">SetProposal</span><span class=\"mtk1\">(</span><span class=\"mtk12\">proposal</span><span class=\"mtk1\">, </span><span class=\"mtk12\">deadline</span><span class=\"mtk1\">, </span><span class=\"mtk12\">_round</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span></code></pre>\n<p><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L142-L157\">TokemakBribe.sol#L142-L157</a><br></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"23\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">setProposals</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">address</span><span class=\"mtk1\">[] </span><span class=\"mtk12\">calldata</span><span class=\"mtk1\"> </span><span class=\"mtk12\">proposals</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\">[] </span><span class=\"mtk12\">calldata</span><span class=\"mtk1\"> </span><span class=\"mtk12\">deadlines</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    ) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">onlyAuthorized</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">proposals</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk7\">0</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;Need at least 1 proposal&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk12\">proposals</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span><span class=\"mtk1\"> == </span><span class=\"mtk12\">deadlines</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk8\">&quot;Must be equal # of proposals and deadlines&quot;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        );</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk15\">for</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">i</span><span class=\"mtk1\"> = </span><span class=\"mtk7\">0</span><span class=\"mtk1\">; </span><span class=\"mtk12\">i</span><span class=\"mtk1\"> &lt; </span><span class=\"mtk12\">proposals</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span><span class=\"mtk1\">; </span><span class=\"mtk12\">i</span><span class=\"mtk1\"> += </span><span class=\"mtk7\">1</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk11\">setProposal</span><span class=\"mtk1\">(</span><span class=\"mtk12\">proposals</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">], </span><span class=\"mtk12\">deadlines</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">]);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">emit</span><span class=\"mtk1\"> </span><span class=\"mtk11\">SetProposals</span><span class=\"mtk1\">(</span><span class=\"mtk12\">proposals</span><span class=\"mtk1\">, </span><span class=\"mtk12\">deadlines</span><span class=\"mtk1\">, </span><span class=\"mtk12\">_round</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span></code></pre>\n<p><code>setProposal()</code> already got <code>onlyAuthorized</code> check, and <code>setProposals()</code> will check it again multiple times.</p>\n<p>Consider creating <code>_setProposal()</code> private function without access control and call it inside the public functions.</p>\n<h3 id=\"recommended-mitigation-steps-22\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-22\" aria-label=\"recommended mitigation steps 22 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h3>\n<p>Change to:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"24\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">_setProposal</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">proposal</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">deadline</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">private</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">proposal</span><span class=\"mtk1\"> != </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">), </span><span class=\"mtk8\">&quot;Invalid proposal&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">deadline</span><span class=\"mtk1\"> &gt;= </span><span class=\"mtk12\">block</span><span class=\"mtk1\">.</span><span class=\"mtk12\">timestamp</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;Deadline must be in the future&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">proposalDeadlines</span><span class=\"mtk1\">[</span><span class=\"mtk12\">proposal</span><span class=\"mtk1\">] = </span><span class=\"mtk12\">deadline</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">/**</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">        </span><span class=\"mtk4\">@notice</span><span class=\"mtk3\"> Set a single proposal</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">        </span><span class=\"mtk4\">@param</span><span class=\"mtk3\">  </span><span class=\"mtk12\">proposal</span><span class=\"mtk3\">  addresss Proposal address</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">        </span><span class=\"mtk4\">@param</span><span class=\"mtk3\">  </span><span class=\"mtk12\">deadline</span><span class=\"mtk3\">  uint256  Proposal deadline</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">     */</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">setProposal</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">proposal</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">deadline</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">public</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">onlyAuthorized</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">_setProposal</span><span class=\"mtk1\">(</span><span class=\"mtk12\">proposal</span><span class=\"mtk1\">, </span><span class=\"mtk12\">deadline</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">emit</span><span class=\"mtk1\"> </span><span class=\"mtk11\">SetProposal</span><span class=\"mtk1\">(</span><span class=\"mtk12\">proposal</span><span class=\"mtk1\">, </span><span class=\"mtk12\">deadline</span><span class=\"mtk1\">, </span><span class=\"mtk12\">_round</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">/**</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">        </span><span class=\"mtk4\">@notice</span><span class=\"mtk3\"> Set multiple proposals</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">        </span><span class=\"mtk4\">@param</span><span class=\"mtk3\">  </span><span class=\"mtk12\">proposals</span><span class=\"mtk3\">  address[]  Proposal addresses</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">        </span><span class=\"mtk4\">@param</span><span class=\"mtk3\">  </span><span class=\"mtk12\">deadlines</span><span class=\"mtk3\">  uint256[]  Proposal deadlines</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">     */</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">setProposals</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">address</span><span class=\"mtk1\">[] </span><span class=\"mtk12\">calldata</span><span class=\"mtk1\"> </span><span class=\"mtk12\">proposals</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\">[] </span><span class=\"mtk12\">calldata</span><span class=\"mtk1\"> </span><span class=\"mtk12\">deadlines</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    ) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">onlyAuthorized</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">proposals</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk7\">0</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;Need at least 1 proposal&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk12\">proposals</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span><span class=\"mtk1\"> == </span><span class=\"mtk12\">deadlines</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk8\">&quot;Must be equal # of proposals and deadlines&quot;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        );</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk15\">for</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">i</span><span class=\"mtk1\"> = </span><span class=\"mtk7\">0</span><span class=\"mtk1\">; </span><span class=\"mtk12\">i</span><span class=\"mtk1\"> &lt; </span><span class=\"mtk12\">proposals</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span><span class=\"mtk1\">; </span><span class=\"mtk12\">i</span><span class=\"mtk1\"> += </span><span class=\"mtk7\">1</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk11\">_setProposal</span><span class=\"mtk1\">(</span><span class=\"mtk12\">proposals</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">], </span><span class=\"mtk12\">deadlines</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">]);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">emit</span><span class=\"mtk1\"> </span><span class=\"mtk11\">SetProposals</span><span class=\"mtk1\">(</span><span class=\"mtk12\">proposals</span><span class=\"mtk1\">, </span><span class=\"mtk12\">deadlines</span><span class=\"mtk1\">, </span><span class=\"mtk12\">_round</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span></code></pre>\n<h2 id=\"g-04-validation-can-be-done-earlier-to-save-gas\" style=\"position:relative;\"><a href=\"#g-04-validation-can-be-done-earlier-to-save-gas\" aria-label=\"g 04 validation can be done earlier to save gas permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[G-04] Validation can be done earlier to save gas</h2>\n<p><em>Note: suggested optimation, save a decent amount of gas without compromising readability.</em></p>\n<p>Check if <code>ethLiquidity > 0 &#x26;&#x26; btrflyLiquidity > 0</code> earlier can avoid unnecessary external call (<code>IRedactedTreasury(TREASURY).manage(WETH, ethLiquidity);</code>) when this check failed.</p>\n<p><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L124-L155\">ThecosomataETH.sol#L124-L155</a><br></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"25\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">performUpkeep</span><span class=\"mtk1\">() </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">onlyOwner</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk11\">checkUpkeep</span><span class=\"mtk1\">(), </span><span class=\"mtk8\">&quot;Invalid upkeep state&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">btrfly</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">IBTRFLY</span><span class=\"mtk1\">(</span><span class=\"mtk12\">BTRFLY</span><span class=\"mtk1\">).</span><span class=\"mtk11\">balanceOf</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">));</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">ethAmount</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">calculateAmountRequiredForLP</span><span class=\"mtk1\">(</span><span class=\"mtk12\">btrfly</span><span class=\"mtk1\">, </span><span class=\"mtk4\">true</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">ethCap</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">IERC20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">WETH</span><span class=\"mtk1\">).</span><span class=\"mtk11\">balanceOf</span><span class=\"mtk1\">(</span><span class=\"mtk12\">TREASURY</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">ethLiquidity</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">ethCap</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk12\">ethAmount</span><span class=\"mtk1\"> ? </span><span class=\"mtk12\">ethAmount</span><span class=\"mtk1\"> : </span><span class=\"mtk12\">ethCap</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// Use BTRFLY balance if remaining capacity is enough, otherwise, calculate BTRFLY amount</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">btrflyLiquidity</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">ethCap</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk12\">ethAmount</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            ? </span><span class=\"mtk12\">btrfly</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            : </span><span class=\"mtk11\">calculateAmountRequiredForLP</span><span class=\"mtk1\">(</span><span class=\"mtk12\">ethLiquidity</span><span class=\"mtk1\">, </span><span class=\"mtk4\">false</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">IRedactedTreasury</span><span class=\"mtk1\">(</span><span class=\"mtk12\">TREASURY</span><span class=\"mtk1\">).</span><span class=\"mtk11\">manage</span><span class=\"mtk1\">(</span><span class=\"mtk12\">WETH</span><span class=\"mtk1\">, </span><span class=\"mtk12\">ethLiquidity</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// Only complete upkeep only on sufficient amounts</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">ethLiquidity</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk7\">0</span><span class=\"mtk1\"> &amp;&amp; </span><span class=\"mtk12\">btrflyLiquidity</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk7\">0</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;Insufficient amounts&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// ...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span></code></pre>\n<h3 id=\"recommended-mitigation-steps-23\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-23\" aria-label=\"recommended mitigation steps 23 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h3>\n<p>Change to:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"26\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">performUpkeep</span><span class=\"mtk1\">() </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">onlyOwner</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk11\">checkUpkeep</span><span class=\"mtk1\">(), </span><span class=\"mtk8\">&quot;Invalid upkeep state&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">btrfly</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">IBTRFLY</span><span class=\"mtk1\">(</span><span class=\"mtk12\">BTRFLY</span><span class=\"mtk1\">).</span><span class=\"mtk11\">balanceOf</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">));</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">ethAmount</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">calculateAmountRequiredForLP</span><span class=\"mtk1\">(</span><span class=\"mtk12\">btrfly</span><span class=\"mtk1\">, </span><span class=\"mtk4\">true</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">ethCap</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">IERC20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">WETH</span><span class=\"mtk1\">).</span><span class=\"mtk11\">balanceOf</span><span class=\"mtk1\">(</span><span class=\"mtk12\">TREASURY</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">ethLiquidity</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">ethCap</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk12\">ethAmount</span><span class=\"mtk1\"> ? </span><span class=\"mtk12\">ethAmount</span><span class=\"mtk1\"> : </span><span class=\"mtk12\">ethCap</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// Use BTRFLY balance if remaining capacity is enough, otherwise, calculate BTRFLY amount</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">btrflyLiquidity</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">ethCap</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk12\">ethAmount</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            ? </span><span class=\"mtk12\">btrfly</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            : </span><span class=\"mtk11\">calculateAmountRequiredForLP</span><span class=\"mtk1\">(</span><span class=\"mtk12\">ethLiquidity</span><span class=\"mtk1\">, </span><span class=\"mtk4\">false</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// Only complete upkeep only on sufficient amounts</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">ethLiquidity</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk7\">0</span><span class=\"mtk1\"> &amp;&amp; </span><span class=\"mtk12\">btrflyLiquidity</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk7\">0</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;Insufficient amounts&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">IRedactedTreasury</span><span class=\"mtk1\">(</span><span class=\"mtk12\">TREASURY</span><span class=\"mtk1\">).</span><span class=\"mtk11\">manage</span><span class=\"mtk1\">(</span><span class=\"mtk12\">WETH</span><span class=\"mtk1\">, </span><span class=\"mtk12\">ethLiquidity</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// ...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span></code></pre>\n<h2 id=\"g-05-typeuint256max-is-more-gas-efficient-than-2256---1\" style=\"position:relative;\"><a href=\"#g-05-typeuint256max-is-more-gas-efficient-than-2256---1\" aria-label=\"g 05 typeuint256max is more gas efficient than 2256   1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[G-05] <code>type(uint256).max</code> is more gas efficient than <code>2**256 - 1</code></h2>\n<p><em>Note: minor optimation, the amount of gas saved is minor, change when you see fit.</em></p>\n<p><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L68-L69\">ThecosomataETH.sol#L68-L69</a></p>\n<h2 id=\"g-06-10e18-is-more-gas-efficient-than-1018\" style=\"position:relative;\"><a href=\"#g-06-10e18-is-more-gas-efficient-than-1018\" aria-label=\"g 06 10e18 is more gas efficient than 1018 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[G-06] <code>10e18</code> is more gas efficient than <code>10**18</code></h2>\n<p><em>Note: minor optimation, the amount of gas saved is minor, change when you see fit.</em></p>\n<p><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L102-L108\">ThecosomataETH.sol#L102-L108</a></p>\n<h2 id=\"g-07-cache-array-length-in-for-loops-can-save-gas\" style=\"position:relative;\"><a href=\"#g-07-cache-array-length-in-for-loops-can-save-gas\" aria-label=\"g 07 cache array length in for loops can save gas permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[G-07] Cache array length in for loops can save gas</h2>\n<p><em>Note: suggested optimation, save a decent amount of gas without compromising readability.</em></p>\n<p>Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.</p>\n<p>Caching the array length in the stack saves around 3 gas per iteration.</p>\n<p>Instances include:</p>\n<p><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L147-L152\">TokemakBribe.sol#L147-L152</a></p>\n<p><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L261-L275\">BribeVault.sol#L261-L275</a></p>\n<p><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/RewardDistributor.sol#L80-L82\">RewardDistributor.sol#L80-L82</a></p>\n<h2 id=\"g-08-avoid-unnecessary-storage-read-can-save-gas\" style=\"position:relative;\"><a href=\"#g-08-avoid-unnecessary-storage-read-can-save-gas\" aria-label=\"g 08 avoid unnecessary storage read can save gas permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[G-08] Avoid unnecessary storage read can save gas</h2>\n<p><em>Note: Suggested optimation, save a decent amount of gas without compromising readability</em></p>\n<p><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L213-L248\">BribeVault.sol#L213-L248</a><br></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"27\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">depositBribe</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">bytes32</span><span class=\"mtk1\"> </span><span class=\"mtk12\">bribeIdentifier</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">bytes32</span><span class=\"mtk1\"> </span><span class=\"mtk12\">rewardIdentifier</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">briber</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    ) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">payable</span><span class=\"mtk1\"> </span><span class=\"mtk11\">onlyRole</span><span class=\"mtk1\">(</span><span class=\"mtk12\">DEPOSITOR_ROLE</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">bribeIdentifier</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk7\">0</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;Invalid bribeIdentifier&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">rewardIdentifier</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk7\">0</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;Invalid rewardIdentifier&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">briber</span><span class=\"mtk1\"> != </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">), </span><span class=\"mtk8\">&quot;Invalid briber&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">value</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk7\">0</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;Value must be greater than 0&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">Bribe</span><span class=\"mtk1\"> </span><span class=\"mtk12\">storage</span><span class=\"mtk1\"> </span><span class=\"mtk12\">b</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">bribes</span><span class=\"mtk1\">[</span><span class=\"mtk12\">bribeIdentifier</span><span class=\"mtk1\">];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">currentToken</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">b</span><span class=\"mtk1\">.</span><span class=\"mtk12\">token</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk3\">// For native tokens, the token address is set to this contract to prevent</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk3\">// overwriting storage - the address can be anything but address(this) safer</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk12\">currentToken</span><span class=\"mtk1\"> == </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">) || </span><span class=\"mtk12\">currentToken</span><span class=\"mtk1\"> == </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">),</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk8\">&quot;Cannot change token&quot;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        );</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">b</span><span class=\"mtk1\">.</span><span class=\"mtk12\">amount</span><span class=\"mtk1\"> += </span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">value</span><span class=\"mtk1\">; </span><span class=\"mtk3\">// Allow bribers to increase bribe</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// Only set the token address and update the reward-to-bribe mapping if not yet set</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">currentToken</span><span class=\"mtk1\"> == </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">)) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk12\">b</span><span class=\"mtk1\">.</span><span class=\"mtk12\">token</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk12\">rewardToBribes</span><span class=\"mtk1\">[</span><span class=\"mtk12\">rewardIdentifier</span><span class=\"mtk1\">].</span><span class=\"mtk11\">push</span><span class=\"mtk1\">(</span><span class=\"mtk12\">bribeIdentifier</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">emit</span><span class=\"mtk1\"> </span><span class=\"mtk11\">DepositBribe</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk12\">bribeIdentifier</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk12\">rewardIdentifier</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk12\">b</span><span class=\"mtk1\">.</span><span class=\"mtk12\">token</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">value</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk12\">b</span><span class=\"mtk1\">.</span><span class=\"mtk12\">amount</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk12\">briber</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        );</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span></code></pre>\n<p>Based on L224<del>L230, L235</del>L236, we know that <code>b.token == address(this)</code>, therefore at L243 <code>b.token</code> can be replaced with <code>address(this)</code>.</p>\n<p>Use <code>address(this)</code> directly can avoid unnecessary storage read of <code>b.token</code> and save some gas.</p>\n<h3 id=\"recommended-mitigation-steps-24\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-24\" aria-label=\"recommended mitigation steps 24 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h3>\n<p>Replace:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"28\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">emit</span><span class=\"mtk1\"> </span><span class=\"mtk11\">DepositBribe</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">bribeIdentifier</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">rewardIdentifier</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">b</span><span class=\"mtk1\">.</span><span class=\"mtk12\">token</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">value</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">b</span><span class=\"mtk1\">.</span><span class=\"mtk12\">amount</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">briber</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">);</span></span></span></code></pre>\n<p>with:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"29\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">emit</span><span class=\"mtk1\"> </span><span class=\"mtk11\">DepositBribe</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">bribeIdentifier</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">rewardIdentifier</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">),</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">value</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">b</span><span class=\"mtk1\">.</span><span class=\"mtk12\">amount</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">briber</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">);</span></span></span></code></pre>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/84#issuecomment-1045947596\">drahrealm (Redacted Cartel) confirmed and commented</a>:</strong></p>\n<blockquote>\n<p>Some new gas optimization tricks confirmed 👍 </p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/84#issuecomment-1051415615\">Alex the Entreprenerd (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Submission is really good.</p>\n<p>Adding the exact gas savings would be the cherry on top.</p>\n<p>Additionally adding a list of all the places in which to apply the optimization would have made this the best finding.</p>\n<p>Pretty good.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/84#issuecomment-1051421241\">Alex the Entreprenerd (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Best submission 8/10</p>\n<p>To improve:</p>\n<ul>\n<li>Actual Gas Savings math (sort findings by impact)</li>\n<li>List of all spots to fix (So the sponsor can implement instead of it being a puzzle)</li>\n</ul>\n</blockquote>\n<hr>\n<h1 id=\"disclosures\" style=\"position:relative;\"><a href=\"#disclosures\" aria-label=\"disclosures permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Disclosures</h1>\n<p>C4 is an open organization governed by participants in the community.</p>\n<p>C4 Contests incentivize the discovery of exploits, vulnerabilities, and bugs in smart contracts. Security researchers are rewarded at an increasing rate for finding higher-risk issues. Contest submissions are judged by a knowledgeable security researcher and solidity developer and disclosed to sponsoring developers. C4 does not conduct formal verification regarding the provided code but instead provides final verification.</p>\n<p>C4 does not provide any guarantee or warranty regarding the security of this project. All smart contract software should be used at the sole risk and responsibility of users.</p>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n  .dark-default-dark {\n    background-color: #1E1E1E;\n    color: #D4D4D4;\n  }\n  .dark-default-dark .mtk4 { color: #569CD6; }\n  .dark-default-dark .mtk1 { color: #D4D4D4; }\n  .dark-default-dark .mtk11 { color: #DCDCAA; }\n  .dark-default-dark .mtk12 { color: #9CDCFE; }\n  .dark-default-dark .mtk7 { color: #B5CEA8; }\n  .dark-default-dark .mtk8 { color: #CE9178; }\n  .dark-default-dark .mtk3 { color: #6A9955; }\n  .dark-default-dark .mtk15 { color: #C586C0; }\n  .dark-default-dark .grvsc-line-highlighted::before {\n    background-color: var(--grvsc-line-highlighted-background-color, rgba(255, 255, 255, 0.1));\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(255, 255, 255, 0.5));\n  }\n</style>",
  "toc": "<ul>\n<li>\n<p><a href=\"#overview\">Overview</a></p>\n<ul>\n<li><a href=\"#about-c4\">About C4</a></li>\n<li><a href=\"#wardens\">Wardens</a></li>\n</ul>\n</li>\n<li><a href=\"#summary\">Summary</a></li>\n<li><a href=\"#scope\">Scope</a></li>\n<li><a href=\"#severity-criteria\">Severity Criteria</a></li>\n<li>\n<p><a href=\"#medium-risk-findings-18\">Medium Risk Findings (18)</a></p>\n<ul>\n<li><a href=\"#m-01-manipulations-of-setfee\">[M-01] Manipulations of <code>setFee</code></a></li>\n<li><a href=\"#m-02-depositor_role-can-be-granted-by-the-deployer-of-bribevault-and-transfer-bribers-approved-erc20-tokens-to-bribevault-by-specifying-any-bribeidentifier-and-rewardidentifier\">[M-02] DEPOSITOR_ROLE can be granted by the deployer of <code>BribeVault</code> and transfer briber’s approved ERC20 tokens to <code>bribeVault</code> by specifying any <code>bribeIdentifier</code> and <code>rewardIdentifier</code></a></li>\n<li><a href=\"#m-03-default_admin_role-of-bribevault-can-steal-tokens-from-users-wallets\">[M-03] <code>DEFAULT_ADMIN_ROLE</code> of <code>BribeVault</code> can steal tokens from users’ wallets</a></li>\n<li><a href=\"#m-04-send-ether-with-call-instead-of-transfer\">[M-04] Send ether with call instead of transfer</a></li>\n<li><a href=\"#m-05-wrong-slippage-check\">[M-05] Wrong slippage check</a></li>\n<li><a href=\"#m-06-safeerc20sol-is-imported-but-not-used-in-the-transferbribes-function-\">[M-06] <code>SafeERC20.sol</code> is imported but not used in the <code>transferBribes()</code> function </a></li>\n<li><a href=\"#m-07-changing-bribevault-in-rewarddistributorsol-will-lock-current-eth-rewards\">[M-07] Changing <code>bribeVault</code> in <code>RewardDistributor.sol</code> will Lock Current ETH Rewards</a></li>\n<li><a href=\"#m-08-admin-privilege---owner-can-rug-via-thecosomataethwithdraw\">[M-08] Admin Privilege - Owner can rug via <code>ThecosomataETH.withdraw</code></a></li>\n<li><a href=\"#m-09-improper-control-over-the-versions-of-distributions-metadata-may-lead-to-repeated-claims-of-rewards\">[M-09] Improper control over the versions of distributions’ metadata may lead to repeated claims of rewards</a></li>\n<li><a href=\"#m-10-distributions-must-not-match-actual-bribes\">[M-10] Distributions must not match actual bribes</a></li>\n<li><a href=\"#m-11-depositor-can-spend-funds-of-another-depositor\">[M-11] Depositor can spend funds of another Depositor</a></li>\n<li><a href=\"#m-12-users-can-frontrun-calls-to-updaterewardsmetadata-and-claim-tokens-twice\">[M-12] Users Can Frontrun Calls to <code>updateRewardsMetadata()</code> And Claim Tokens Twice</a></li>\n<li><a href=\"#m-13-reentrancy-in-depositbribeerc20-function\">[M-13] Reentrancy in <code>depositBribeERC20</code> function</a></li>\n<li><a href=\"#m-14-transferbribes-could-transfer-before-proposal-deadline--input-validation\">[M-14] transferBribes could transfer before proposal deadline + Input validation</a></li>\n<li><a href=\"#m-15-fees-can-be-any-amount\">[M-15] Fees can be any amount</a></li>\n<li><a href=\"#m-16-depositor_role-can-manipulate-bamount-value\">[M-16] <code>DEPOSITOR_ROLE</code> can manipulate <code>b.amount</code> value</a></li>\n<li><a href=\"#m-17-thecosomataeth-oracle-price-can-be-better-secured-freshness--tamper-resistance\">[M-17] ThecosomataETH: Oracle price can be better secured (freshness + tamper-resistance)</a></li>\n<li><a href=\"#m-18-rewards-can-be-lost\">[M-18] Rewards can be lost</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#low-risk-and-non-critical-issues\">Low Risk and Non-Critical Issues</a></p>\n<ul>\n<li><a href=\"#codebase-impressions--summary\">Codebase Impressions &#x26; Summary</a></li>\n<li><a href=\"#l-01-rewarddistributor-change-payableaccounttransfer-to-call-for-native-fund-transfers\">L-01 RewardDistributor: Change <code>payable(account).transfer()</code> to <code>.call()</code> for native fund transfers</a></li>\n<li><a href=\"#l-02-bribevault-use-safetransfer-for-tokens\">L-02 BribeVault: Use <code>safeTransfer</code> for tokens</a></li>\n<li><a href=\"#l-03-rewarddistributor-limit-native-fund-transfers-to-bribevault\">L-03 RewardDistributor: Limit native fund transfers to <code>bribeVault</code></a></li>\n<li><a href=\"#l-04-tokemakbribe-sync-rounds-with-tokemaks-manager-instead-of-manually-setting-rounds-via-setround\">L-04 TokemakBribe: Sync rounds with Tokemak’s manager instead of manually setting rounds via <code>setRound()</code></a></li>\n<li><a href=\"#n-01-tokemakbribe-getbribe-has-incorrect-description\">N-01 TokemakBribe: <code>getBribe()</code> has incorrect description</a></li>\n<li><a href=\"#n-02-emit-relevant-events-in-constructor-methods-when-variables-are-set-or-abstract-to-internal-functions\">N-02 Emit relevant events in constructor methods when variables are set, or abstract to internal functions</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#gas-optimizations\">Gas Optimizations</a></p>\n<ul>\n<li><a href=\"#g-01-adding-unchecked-directive-can-save-gas\">G-01 Adding unchecked directive can save gas</a></li>\n<li><a href=\"#g-02-using-immutable-variable-can-save-gas\">G-02 Using immutable variable can save gas</a></li>\n<li><a href=\"#g-03-remove-redundant-access-control-checks-can-save-gas\">G-03 Remove redundant access control checks can save gas</a></li>\n<li><a href=\"#g-04-validation-can-be-done-earlier-to-save-gas\">G-04 Validation can be done earlier to save gas</a></li>\n<li><a href=\"#g-05-typeuint256max-is-more-gas-efficient-than-2256---1\">G-05 <code>type(uint256).max</code> is more gas efficient than <code>2**256 - 1</code></a></li>\n<li><a href=\"#g-06-10e18-is-more-gas-efficient-than-1018\">G-06 <code>10e18</code> is more gas efficient than <code>10**18</code></a></li>\n<li><a href=\"#g-07-cache-array-length-in-for-loops-can-save-gas\">G-07 Cache array length in for loops can save gas</a></li>\n<li><a href=\"#g-08-avoid-unnecessary-storage-read-can-save-gas\">G-08 Avoid unnecessary storage read can save gas</a></li>\n</ul>\n</li>\n<li><a href=\"#disclosures\">Disclosures</a></li>\n</ul>",
  "md": "\n# Overview\n\n## About C4\n\nCode4rena (C4) is an open organization consisting of security researchers, auditors, developers, and individuals with domain expertise in smart contracts.\n\nA C4 audit contest is an event in which community participants, referred to as Wardens, review, audit, or analyze smart contract logic in exchange for a bounty provided by sponsoring projects.\n\nDuring the audit contest outlined in this document, C4 conducted an analysis of the Redacted Cartel smart contract system written in Solidity. The audit contest took place between February 15—February 17 2022.\n\n## Wardens\n\n37 Wardens contributed reports to the Redacted Cartel contest:\n\n  1. [csanuragjain](https://twitter.com/csanuragjain)\n  1. WatchPug ([jtp](https://github.com/jack-the-pug) and [ming](https://github.com/mingwatch))\n  1. [pauliax](https://twitter.com/SolidityDev)\n  1. [hickuphh3](https://twitter.com/HickupH)\n  1. [gzeon](https://twitter.com/gzeon)\n  1. [cmichel](https://twitter.com/cmichelio)\n  1. [leastwood](https://twitter.com/liam_eastwood13)\n  1. cccz\n  1. [danb](https://twitter.com/danbinnun)\n  1. [Omik](https://twitter.com/omikomikomik)\n  1. [rfa](https://www.instagram.com/riyan_rfa/)\n  1. [kirk-baird](https://twitter.com/kirkthebaird)\n  1. 0x1f8b\n  1. SolidityScan ([cyberboy](https://twitter.com/cyberboyIndia) and [zombie](https://blog.dixitaditya.com/))\n  1. hyh\n  1. Czar102\n  1. [Dravee](https://twitter.com/JustDravee)\n  1. [ye0lde](https://twitter.com/_ye0lde)\n  1. kenta\n  1. [kenzo](https://twitter.com/KenzoAgada)\n  1. Jujic\n  1. IllIllI\n  1. [z3s](https://github.com/z3s/)\n  1. [Ruhum](https://twitter.com/0xruhum)\n  1. jayjonah8\n  1. [defsec](https://twitter.com/defsec_)\n  1. robee\n  1. 0x0x0x\n  1. NoamYakov\n  1. peritoflores\n  1. [0xliumin](https://twitter.com/0xliumin)\n  1. p4st13r4 ([0x69e8](https://github.com/0x69e8) and 0xb4bb4)\n  1. d4rk\n  1. [Tomio](https://twitter.com/meidhiwirara)\n\nThis contest was judged by [Alex the Entreprenerd](https://twitter.com/GalloDaSballo). The judge also competed in the contest as a warden, but forfeited their winnings.\n\nFinal report assembled by [liveactionllama](https://twitter.com/liveactionllama).\n\n# Summary\n\nThe C4 analysis yielded an aggregated total of 18 unique vulnerabilities. Of these vulnerabilities, 0 received a risk rating in the category of HIGH severity and 18 received a risk rating in the category of MEDIUM severity.\n\nAdditionally, C4 analysis included 25 reports detailing issues with a risk rating of LOW severity or non-critical. There were also 18 reports recommending gas optimizations.\n\nAll of the issues presented here are linked back to their original finding.\n\n# Scope\n\nThe code under review can be found within the [C4 Redacted Cartel contest repository](https://github.com/code-423n4/2022-02-redacted-cartel), and is composed of 4 smart contracts written in the Solidity programming language and includes 699 lines of Solidity code.\n\n# Severity Criteria\n\nC4 assesses the severity of disclosed vulnerabilities according to a methodology based on [OWASP standards](https://owasp.org/www-community/OWASP_Risk_Rating_Methodology).\n\nVulnerabilities are divided into three primary risk categories: high, medium, and low/non-critical.\n\nHigh-level considerations for vulnerabilities span the following key areas when conducting assessments:\n\n- Malicious Input Handling\n- Escalation of privileges\n- Arithmetic\n- Gas use\n\nFurther information regarding the severity criteria referenced throughout the submission review process, please refer to the documentation provided on [the C4 website](https://code423n4.com).\n\n# Medium Risk Findings (18)\n## [[M-01] Manipulations of `setFee`](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/113)\n_Submitted by pauliax_\n\n[BribeVault.sol#L104-L113](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L104-L113)<br>\n[BribeVault.sol#L164](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L164)<br>\n[BribeVault.sol#L213](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L213)<br>\n[BribeVault.sol#L256](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L256)<br>\n\nIf we consider that the fee variable is meaningfully applied, there will still be several problems with this:\n\n1.  Admin can setFee up to 100%. This is bad for users, fees should have a reasonable upper limit, e.g. 30% to prevent potential griefing.\n2.  Tokens are transferred in a separate function called transferBribes, which means that depositBribe txs have already settled. setFee can happen anytime, so an admin can change fees for already made deposits. I think this is again bad for users, as you need extra trust on an admin to not exploit this, and smart contracts should aim for as little external trust as possible.\n3.  Even if a fee would be applied in depositBribe, function setFee could frontrun user deposits. Consider using a timelock, so that users have time to react and adjust.\n\n**[kphed (Redacted Cartel) disagreed with Medium severity and commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/113#issuecomment-1043705156):**\n > We will likely set an upper bound as recommended, to ease user concerns. The admin being the Redacted multisig should also instill much trust and address most concerns.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/113#issuecomment-1052867924):**\n > The warden identified a potential admin privilege that would allow to set the fee to 100%.\n> \n> I agree with the finding and severity.\n\n\n\n***\n\n## [[M-02] DEPOSITOR_ROLE can be granted by the deployer of `BribeVault` and transfer briber's approved ERC20 tokens to `bribeVault` by specifying any `bribeIdentifier` and `rewardIdentifier`](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/1)\n_Submitted by cccz_\n\nIn the depositBribeERC20() function of the TokemakBribe contract, the briber can specify a proposal, and then call the depositBribeERC20 function of the bribeVault contract to deposit the reward.\n\n        function depositBribeERC20(\n            address proposal,\n            address token,\n            uint256 amount\n        ) external {\n            uint256 currentRound = _round;\n            require(\n                proposalDeadlines[proposal] > block.timestamp,\n                \"Proposal deadline has passed\"\n            );\n            require(token != address(0), \"Invalid token\");\n            require(amount > 0, \"Bribe amount must be greater than 0\");\n\n            bytes32 bribeIdentifier = generateBribeVaultIdentifier(\n                proposal,\n                currentRound,\n                token\n            );\n            bytes32 rewardIdentifier = generateRewardIdentifier(\n                currentRound,\n                token\n            );\n\n            IBribeVault(bribeVault).depositBribeERC20(\n                bribeIdentifier,\n                rewardIdentifier,\n                token,\n                amount,\n                msg.sender\n            );\n\nBut in the depositBribeERC20 function of the bribeVault contract, the address with DEPOSITOR_ROLE can transfer the briber's approved ERC20 tokens to bribeVault by specifying any bribeIdentifier and rewardIdentifier via safeTransferFrom.\n\n        function depositBribeERC20(\n            bytes32 bribeIdentifier,\n            bytes32 rewardIdentifier,\n            address token,\n            uint256 amount,\n            address briber\n        ) external onlyRole(DEPOSITOR_ROLE) {\n            require(bribeIdentifier.length > 0, \"Invalid bribeIdentifier\");\n            require(rewardIdentifier.length > 0, \"Invalid rewardIdentifier\");\n            require(token != address(0), \"Invalid token\");\n            require(amount > 0, \"Amount must be greater than 0\");\n            require(briber != address(0), \"Invalid briber\");\n\n            Bribe storage b = bribes[bribeIdentifier];\n            address currentToken = b.token;\n            require(\n                // If bribers want to bribe with a different token they need a new identifier\n                currentToken == address(0) || currentToken == token,\n                \"Cannot change token\"\n            );\n\n            // Since this method is called by a depositor contract, we must transfer from the account\n            // that called the depositor contract - amount must be approved beforehand\n            IERC20(token).safeTransferFrom(briber, address(this), amount);\n\nDEPOSITOR_ROLE can be granted by the deployer of BribeVault.\n\n```\n\n    function grantDepositorRole(address depositor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(depositor != address(0), \"Invalid depositor\");\n        _grantRole(DEPOSITOR_ROLE, depositor);\n\n        emit GrantDepositorRole(depositor);\n    }\n\n```\n\n### Proof of Concept\n\n[BribeVault.sol#L164-L205](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L164-L205)\n\n### Recommended Mitigation Steps\n\nThe depositBribeERC20 function of the TokemakBribe contract needs to first transfer the briber's tokens to the TokemakBribe contract, and then transfer the tokens to the bribeVault contract in the depositBribeERC20 function of the bribeVault contract. Make sure the first parameter of safeTransferFrom is msg.sender.\n\nTokemakBribe.depositBribeERC20()\n\n        function depositBribeERC20(\n            address proposal,\n            address token,\n            uint256 amount\n        ) external {\n            uint256 currentRound = _round;\n            require(\n                proposalDeadlines[proposal] > block.timestamp,\n                \"Proposal deadline has passed\"\n            );\n            require(token != address(0), \"Invalid token\");\n            require(amount > 0, \"Bribe amount must be greater than 0\");\n\n            bytes32 bribeIdentifier = generateBribeVaultIdentifier(\n                proposal,\n                currentRound,\n                token\n            );\n            bytes32 rewardIdentifier = generateRewardIdentifier(\n                currentRound,\n                token\n            );\n    +       IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n\n            IBribeVault(bribeVault).depositBribeERC20(\n                bribeIdentifier,\n                rewardIdentifier,\n                token,\n                amount,\n                msg.sender\n            );\n\nbribeVault.depositBribeERC20()\n\n```\n    function depositBribeERC20(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address token,\n        uint256 amount,\n        address briber\n    ) external onlyRole(DEPOSITOR_ROLE) {\n        require(bribeIdentifier.length > 0, \"Invalid bribeIdentifier\");\n        require(rewardIdentifier.length > 0, \"Invalid rewardIdentifier\");\n        require(token != address(0), \"Invalid token\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(briber != address(0), \"Invalid briber\");\n\n        Bribe storage b = bribes[bribeIdentifier];\n        address currentToken = b.token;\n        require(\n            // If bribers want to bribe with a different token they need a new identifier\n            currentToken == address(0) || currentToken == token,\n            \"Cannot change token\"\n        );\n\n        // Since this method is called by a depositor contract, we must transfer from the account\n        // that called the depositor contract - amount must be approved beforehand\n-       IERC20(token).safeTransferFrom(briber, address(this), amount);\n+\tIERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n\n```\n\n**[kphed (Redacted Cartel) disputed and commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/1#issuecomment-1040452376):**\n > This isn't a concern since the \"depositor\" role can only be granted by admin (protocol multisig) - depositors will only be bribe contracts that we've written and deployed.\n>\n> In the future, we may grant the depositor role to contracts that are written and deployed by 3rd parties, but they would all be thoroughly vetted in some manner and need to conform to the BribeVault's interface. \n>\n> Thanks again for participating in our contest cccz, looking forward to more feedback/suggestions/comments.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/1#issuecomment-1059778323):**\n > While this may not be a concern for the sponsor, the smart contract is supposed to be given allowance, this allowance can then be used by the `DEPOSITOR_ROLE` to perform a transfer.\n> \n> The smart can then allow the `DEFAULT_ADMIN_ROLE` to withdraw the funds.\n> \n> Ultimately the ability to deposit being permissioned and it's ability to pull unlimited funds is a strong admin privilege, which I'd recommend the sponsor to remove.\n> \n> A similar deposit flow with less strict permissions can be found in most Yield Farming Vaults, see Badger Vaults for example: [Badger-Finance/Vault.sol#L671](https://github.com/Badger-Finance/badger-sett-1.5/blob/86a586cf30b806dc1ab7ea090f002e06a59d0706/contracts/Vault.sol#L671).\n\n\n\n***\n\n## [[M-03] `DEFAULT_ADMIN_ROLE` of `BribeVault` can steal tokens from users' wallets](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/86)\n_Submitted by WatchPug, also found by danb, Dravee, Alex the Entreprenerd, gzeon, IllIllI, jayjonah8, kenzo, pauliax, cmichel, csanuragjain, and z3s_\n\nThe current design/implementation allows the `DEFAULT_ADMIN_ROLE` of `BribeVault` to steal funds from any address that approved this contract up to allowance:\n\nAs a `DEFAULT_ADMIN_ROLE`, the attack is simply do the following steps:\n\n    1. `grantDepositorRole()` to self;\n    2. `BribeVault#depositBribeERC20()` and transfer funds from victim's wallet;\n    3. `emergencyWithdrawERC20()`.\n\nThis can be effectively used as a backdoor/attack vector for a malicious/compromised wallet with `DEFAULT_ADMIN_ROLE` of `BribeVault` to steal all the tokens from users' wallets for these users who have approved `BribeVault`.\n\n[BribeVault.sol#L164-L187](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L164-L187)<br>\n\n```solidity\nfunction depositBribeERC20(\n    bytes32 bribeIdentifier,\n    bytes32 rewardIdentifier,\n    address token,\n    uint256 amount,\n    address briber\n) external onlyRole(DEPOSITOR_ROLE) {\n    require(bribeIdentifier.length > 0, \"Invalid bribeIdentifier\");\n    require(rewardIdentifier.length > 0, \"Invalid rewardIdentifier\");\n    require(token != address(0), \"Invalid token\");\n    require(amount > 0, \"Amount must be greater than 0\");\n    require(briber != address(0), \"Invalid briber\");\n\n    Bribe storage b = bribes[bribeIdentifier];\n    address currentToken = b.token;\n    require(\n        // If bribers want to bribe with a different token they need a new identifier\n        currentToken == address(0) || currentToken == token,\n        \"Cannot change token\"\n    );\n\n    // Since this method is called by a depositor contract, we must transfer from the account\n    // that called the depositor contract - amount must be approved beforehand\n    IERC20(token).safeTransferFrom(briber, address(this), amount);\n    ...\n```\n\n[BribeVault.sol#L80-L88](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L80-L88)<br>\n\n```solidity\nfunction grantDepositorRole(address depositor)\n    external\n    onlyRole(DEFAULT_ADMIN_ROLE)\n{\n    require(depositor != address(0), \"Invalid depositor\");\n    _grantRole(DEPOSITOR_ROLE, depositor);\n\n    emit GrantDepositorRole(depositor);\n}\n```\n\n### Proof of Concept\n\nGiven:\n\n*   Alice (the victim) has approved `BribeVault` to spend `WBTC`;\n*   Alice has `100e8 WBTC` in their wallet balance.\n\nA malicious/compromised `DEFAULT_ADMIN_ROLE` of `BribeVault` can do the following to steal tokens from users' wallets.\n\n1.  `grantDepositorRole()` to self;\n2.  `depositBribeERC20()` with: `token` = `WBTC`, `amount` = `100e8`, and `briber` = Alice;\n3.  `emergencyWithdrawERC20()` with:  `token` = `WBTC`, `amount` = `100e8`.\n\nAs a result, the `100e8 WBTC` belongs Alice is now stolen by the Hacker.\n\nThe steps above can be repeated for all tokens and users, effectively stealing all the token balances from all the wallets that approved `BribeVault` up to the allowance limit, which usually is unlimited.\n\n### Recommended Mitigation Steps\n\n1.  Consider using `TokemakBribe` instead of `BribeVault` to hold users' allowances;\n2.  Consider making sure that the `from` parameter of `transferFrom` can only be `msg.sender`;\n3.  Consider using a multi-sig for the `DEFAULT_ADMIN_ROLE` of `BribeVault`.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/86#issuecomment-1059801248):**\n > Fully agree with the finding and appreciate the level of detail.\n> \n> Because the exploit is contingent on a malicious owner, I believe Medium Severity to be more appropriate.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/86#issuecomment-1059801440):**\n > The `emergencyWithdrawERC20` without any check is a rug vector, protected exclusively by the multisig.<br>\n> While depositors may opt into this system, that doesn't mean that it's trust is fully reliant on the mulsitig, which means the code has trust assumptions by design.\n> \n> These trust assumptions make medium severity appropriate.\n\n\n\n***\n\n## [[M-04] Send ether with call instead of transfer](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/2)\n_Submitted by kenta, also found by Dravee, hyh, Jujic, leastwood, and z3s_\n\nUse call instead of transfer to send ether. And return value must be checked if sending ether is successful or not.\nSending ether with the transfer is no longer recommended.\n\n### Proof of Concept\n\n[RewardDistributor.sol#L181](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L181)\n\n### Recommended Mitigation Steps\n\n(bool result, ) = payable(\\_account).call{value: \\_amount}(\"\");\nrequire(result, \"Failed to send Ether\");\n\n**[kphed (Redacted Cartel) confirmed](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/2)**\n\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/2#issuecomment-1059781616):**\n > I believe the function would actually work with most Smart Contract Wallets and proxies. However this could change in the future.\n> \n> Agree with the finding.\n\n\n\n***\n\n## [[M-05] Wrong slippage check](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/35)\n_Submitted by cmichel, also found by danb, Alex the Entreprenerd, hickuphh3, hyh, and WatchPug_\n\nThe `ThecosomataETH.addLiquidity` function computes the `expectedAmount` and then subtracts a slippage percentage from it.\n\n```solidity\nfunction addLiquidity(uint256 ethAmount, uint256 btrflyAmount) internal {\n    uint256[2] memory amounts = [ethAmount, btrflyAmount];\n    uint256 expectedAmount = ICurveCryptoPool(CURVEPOOL).calc_token_amount(\n        amounts\n    );\n    uint256 minAmount = expectedAmount - ((expectedAmount * slippage) / 1000);\n\n    ICurveCryptoPool(CURVEPOOL).add_liquidity(amounts, minAmount);\n}\n```\n\nAccording to the [Curve docs 21.4](https://curve.readthedocs.io/\\_/downloads/en/latest/pdf/), this amount is already exact and takes the slippage into account (but not fees).\n\nIf the pool is imbalanced, the `calc_token_amount` will already return a wrong amount and the additional slippage check on the wrong amount is unnecessary (except for the fees).\n\n### Recommended Mitigation Steps\n\nConsider computing the minimum expected LP tokens off-chain and pass them to the `performUpkeep` function as a parameter to prevent sandwich attacks.\n\n**[drahrealm (Redacted Cartel) confirmed and commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/35#issuecomment-1041827707):**\n > Thanks for the finding. Confirmed that this is not the right way for handling slippage. Will be updating the flow a little bit to allow externally sourced data for the expected amount.\n\n**[kphed (Redacted Cartel) disputed and commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/35#issuecomment-1059166618):**\n > Changing to \"sponsor disputed\" since using values derived off-chain doesn't prevent sandwich attacks and could make it easier to get sandwiched: using the off-chain calculation method, a MEV operator would only need to parse the tx input when deciding to front run us (vs. needing to simulate the tx if we were to do our calculations on-chain).\n> \n> Additionally, we're not using the `StableSwap` contract referenced in the warden's comment.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/35#issuecomment-1059785983):**\n > I think the sponsor's perspective is interesting in that I believe any MEV researcher could write a simple algorithm to check for the tx inputs to detect a slippage check.\n> \n> However in practice they'd still have to run a simulation as you could input the off-chain price with any variation (different decimals, as ETH, as USD, as BTC, multiply by 2 or 5 or w/e)\n> \n> Additionally while there can be arguments made as to how to mitigate, the finding is still valid.\n> \n> Asking Curve for the `calc_token_amount` will return whatever price the pool can offer at that time, because tx are atomic that means that any front-running or price manipulation would have already happened in a tx before the request.\n> \n> This means that at worst you could directly use the output from `calc_token_amount` (multiplication has no impact).\n> \n> What the finding also implies, is that if the pool were to be completely imbalances (99% of in asset, 1% of out asset) the price you'd get would be very low, and the code wouldn't be able to detect it (the code is effectively same as having 0 * .95)\n> \n> Because the finding has to do with potential value extraction, I believe the finding to be valid and of medium severity.\n> \n> As for mitigation, there are 2 viable options:\n> 1) Use Chainlink Price Feed to get an accurate price\n> 2) Provide the price as a parameter\n> \n> For option 2, I don't believe that argument to be valid for the examples above (just shift, multiply or obfuscate the param)\n> Additionally, while you may never get a guarantee of perfect pricing, providing a price will give you a guarantee of a minimum price, this ensures you can opt-in into the slippage you'd be willing to tolerate.\n> \n> To give further details, let's look at using Flashbots (Flashbots RPC or a private mempool, either is a great idea).\n> \n> By using a private tx with the code provided for this contest, in the case of low liquidity, you'd still loose a considerable amount of value. No front-run needs to happen as in asking the price to the pool, you'll always get a valid response.\n> \n> This has happened to Yield Farming Aggregators (last I remember was yearn with StakeDAO token or similar). To summarize: Asking the price to the pool in the same tx is the same as having a 0 slippage check, which means you can loose value even without being front-run.\n> \n> Now let's add the idea of being front-run while using Flashbots RPC:<br>\n> -> You have calculate the off-chain Price, which means there' a require that will revert if the tx will fail, which means (because Flashbots is awesome) the tx won't be mined unless the tx goes through (miner get's a tip).<br>\n> This means you can be extremely strict with your slippage check, providing you with as much MEV protection as possible.\n> \n> For these reasons I believe the finding to be valid and I recommend you do explore:\n> - Flashbots (private TXs)\n> - Price as parameter\n> - Chainlink Price Feeds\n> \n\n**[kphed (Redacted Cartel) commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/35#issuecomment-1059802427):**\n > > I think the sponsor's perspective is interesting in that I believe any MEV researcher could write a simple algorithm to check for the tx inputs to detect a slippage check.\n> \n> That was my point, that it lowers the difficulty threshold.\n> \n> Thanks, the warden's recommended solution makes more sense now after your elaboration. We were planning on using Flashbots Protect and will look into your other suggestions as well.\n\n\n\n***\n\n## [[M-06] `SafeERC20.sol` is imported but not used in the `transferBribes()` function ](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/4)\n_Submitted by jayjonah8, also found by cccz, cmichel, Dravee, gzeon, hyh, IllIllI, leastwood, NoamYakov, and Omik_\n\nIn BribeVault.sol the transferBribes() function uses token.transfer() instead of token.safeTransfer.\nTokens that don’t correctly implement the latest EIP20 spec, like USDT, will be unusable in the protocol as they revert the transaction because of the missing return value.  The fact that the SafeERC20.sol library is imported at the top of the BribeVault.sol implies that safeTransfer should be being used but may have been forgotten.\n\n### Proof of Concept\n\n[BribeVault.sol#L296](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L296)<br>\n\n### Recommended Mitigation Steps\n\nIt's recommended to use OpenZeppelin’s SafeERC20 versions with the safeTransfer and safeTransferFrom functions that handle the return value check as well as non-standard-compliant tokens.\n\n**[kphed (Redacted Cartel) confirmed and commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/4#issuecomment-1040506429):**\n > Good catch!\n> \n> Thanks again for participating in our contest jayjonah8, looking forward to more feedback/suggestions/comments.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/4#issuecomment-1059786452):**\n > Agree with the finding, because this is contingent on the specific token failing. I believe Medium severity to be more appropriate.\n\n\n\n***\n\n## [[M-07] Changing `bribeVault` in `RewardDistributor.sol` will Lock Current ETH Rewards](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/7)\n_Submitted by kirk-baird, also found by WatchPug_\n\n[RewardDistributor.sol#L178-#L182](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L178-#L182)<br>\n[RewardDistributor.sol#L65-#L73](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L65-#L73)\n\nClaiming of the ETH native currency requires `token` to be set to `bribeVault`. If the `bribeVault` is modified in `setBribeVault()` then users who have ETH rewards will now be considered to have `ERC20(bribeVault)` tokens. Since `bribeVault` is not an ERC20 token the `transfer()` call will fail and the users will not be able to claim their funds.\n\n### Recommended Mitigation Steps\n\nConsider removing the functionality to change the `bribeVault` or ensuring all funds have been withdraw i.e. `balanceOf(address(this)) == 0` before changing the `bribeVault`.\n\n**[kphed (Redacted Cartel) confirmed and commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/7#issuecomment-1040568870):**\n > Good find, we're going to address this by making `bribeVault` immutable and removing the setter.\n> \n> Thanks again for participating in our contest kirk-baird, looking forward to more feedback/suggestions/comments.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/7#issuecomment-1059788677):**\n > Agree with the finding, ultimately preventing `bribeVault` from changing will provide users further security guarantees.\n> \n> An alternative solution would be to use a different code for ETH (I've seen protocols use address(0) or perhaps 0xeeeeeeee).\n> \n> However I believe that making `bribeVault` immutable will provide the stronger guarantees.\n\n\n\n***\n\n## [[M-08] Admin Privilege - Owner can rug via `ThecosomataETH.withdraw`](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/39)\n_Submitted by Alex the Entreprenerd, also found by gzeon_\n\nDue to the generalized nature of `withdraw` the function is a clear rug-vector, allowing the `owner` to steal all funds.\n\nIdeally, you should add some validation logic to limit the tokens or the amounts that the owner can withdraw.\n\nAdditionally, it's important that you disclose the level of admin privilege and the risk it can cause to your users and depositors.\n\n### Recommended Mitigation Steps\n\nDisclose the admin privilege in your docs.<br>\nRefactor the code to reduce it.\n\n**[kphed (Redacted Cartel) disputed and commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/39#issuecomment-1042428554):**\n > The `owner` is our protocol multisig which has proven itself to be a trustworthy steward of funds (e.g. manages the Redacted treasury funds).\n> \n> The `withdraw` method is simply a utility to remove any ERC20 tokens that are unintentionally received. There won't be any funds to steal since it's not intended for the Thecosomata contract to custody funds for any extended period of time: our keepers will constantly poll the contract so that any BTRFLY received gets paired with ETH and added to our Curve LP immediately - any excess is burned.\n\n**[Alex the Entreprenerd (judge) closed as Invalid and commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/39#issuecomment-1051071492):**\n > It should be noted that I have submitted the finding, and in being judge of the contest am forfeiting my potential winnings.\n> \n> Personally, I don't believe a multisig gives any particular security guarantee to depositors beside the fact that it takes X amount of people to agree on how to move funds.\n> \n> The sponsor is making it clear that the `owner` in this case is also the depositor of funds.<br>\n> This means that the multi-sig is self custodying the funds into the contract.\n> \n> As such, the finding doesn't prove any additional security risk beside those that comes with a multi-sig.\n> \n> For those reasons, the finding is invalid.\n\n**[kphed (Redacted Cartel) commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/39#issuecomment-1051158419):**\n > Thanks for following up with your thoughts @Alex the Entreprenerd.\n> \n> NOTE: Mistakenly made comment below because I thought this was referring to the BribeVault contract.\n> \n> > The sponsor is making it clear that the owner in this case is also the depositor of funds.\n> This means that the multi-sig is self custodying the funds into the contract.\n> \n> Just to clear up any miscommunication or misunderstandings, we've never stated that the owner is the depositor of funds - the funds are deposited by bribers. The owner/admin only whitelists contracts that have permission to call the BribeVault's deposit methods but those contracts do not custody funds beyond the deposit transactions (this is also only the case when a briber deposits a native token).\n\n**[Alex the Entreprenerd (judge) reopened as Valid and commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/39#issuecomment-1051192536):**\n > Thank you for the clarification @kphed.\n> \n> If the bribers are not the same as the owner then the owner technically has the ability of withdrawing funds at any time, which puts the depositors under the risk of the owner rugging.\n> \n> Typically a Vault Protocol (Yearn, Badger) would have a check for \"protectedTokens\", in this case BTRFLY and WETH to prevent taking that type of operation.\n> \n> As it stands, the multisig can move the funds at any time, technically can frontrun the `keeper` and steal the funds.\n> \n> Also notice that you said that there will be a keeper for `performUpkeep` but the modifier is `onlyOwner` which either means you'll have an EOA as the owner, or you may want to change the access control checker (or remove it as Chainlink docs would require you to).\n> \n> With the information I have, I'm inclined to revert back to medium severity.\n> \n> While there's always the counter-argument that the multisig or governance will not rug, the only guarantee for it is the inability to rug by structuring the smart contract in a way that makes it impossible to move funds (e.g. add a check against moving BTRFLY and WETH, allow sweeping of other \"random\" tokens)\n\n**[kphed (Redacted Cartel) commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/39#issuecomment-1051525527):**\n > Sorry, disregard my last comment, I mistakenly read your comment as one directed towards BribeVault (which also has a method to withdraw tokens). You're correct, BTRFLY is minted by our protocol for ThecosomataETH. That said, we still don't consider the possibility of admin-rugging a real concern.\n> \n> > Typically a Vault Protocol (Yearn, Badger) would have a check for \"protectedTokens\", in this case BTRFLY and WETH to prevent taking that type of operation.\n> \n> This is a potential idea, thanks, I'll share it with the team.\n> \n> > Also notice that you said that there will be a keeper for performUpkeep but the modifier is onlyOwner which either means you'll have an EOA as the owner, or you may want to change the access control checker (or remove it as Chainlink docs would require you to).\n> \n> Tagging @drahrealm as he's implementing ThecosomataETH. Your comment about `onlyOwner` is a good one though - it does appear to be a mistake or can be improved tremendously (e.g. use AccessControl and add a role limited to calling this and not the withdraw method).\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/39#issuecomment-1059793149):**\n > Would highly recommend limiting the withdrawal to specific tokens (ideally exclude important tokens), this would provide strong security guarantees against a rug.\n> \n> Also limiting roles can help reduce trust, however, it wouldn't address the underlying issue that \"someone\" can move the funds.\n> \n> With the information I have, I believe Medium Severity to be appropriate, and believe the sponsor has set motion to minimize trust as well as add additional security guarantees.\n\n\n\n***\n\n## [[M-09] Improper control over the versions of distributions' metadata may lead to repeated claims of rewards](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/89)\n_Submitted by WatchPug_\n\n[BribeVault.sol#L317-L324](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L317-L324)<br>\n\n```solidity\nfunction updateRewardsMetadata(Common.Distribution[] calldata distributions)\n    external\n    onlyRole(DEFAULT_ADMIN_ROLE)\n{\n    require(distributions.length > 0, \"Invalid distributions\");\n    IRewardDistributor(distributor).updateRewardsMetadata(distributions);\n}\n```\n\nIn the current implementation, `DEFAULT_ADMIN_ROLE` of `BribeVault` can call `updateRewardsMetadata()` to update the rewards metadata for the specified identifiers.\n\nWhen a distribution's metadata is updated, it will also increase the `updateCount` and reset the claimed tracker.\n\n[RewardDistributor.sol#L97-L119](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/RewardDistributor.sol#L97-L119)<br>\n\n```solidity\nfunction updateRewardsMetadata(\n        Common.Distribution[] calldata _distributions\n    ) external {\n        require(msg.sender == bribeVault, \"Invalid access\");\n        require(_distributions.length > 0, \"Invalid _distributions\");\n\n        for (uint256 i = 0; i < _distributions.length; i++) {\n            // Update the metadata and also increment the update to reset the claimed tracker\n            Reward storage reward = rewards[_distributions[i].rewardIdentifier];\n            reward.token = _distributions[i].token;\n            reward.merkleRoot = _distributions[i].merkleRoot;\n            reward.proof = _distributions[i].proof;\n            reward.updateCount += 1;\n\n            emit RewardMetadataUpdated(\n                _distributions[i].rewardIdentifier,\n                _distributions[i].token,\n                _distributions[i].merkleRoot,\n                _distributions[i].proof,\n                reward.updateCount\n            );\n        }\n    }\n```\n\nHowever, when the network is congested, `DEFAULT_ADMIN_ROLE` of `BribeVault` may mistakenly send 2 `updateRewardsMetadata()` txs, and the transactions can be packaged into different blocks.\n\nLet's say there 2 `updateRewardsMetadata()` tx with the same calldata, if someone claims rewards in between the two txs, then they can claim again after the second transaction.\n\n### Proof of Concept\n\nGiven:\n\n*   `distributionA`'s proof is set wrong in `transferBribes()`\n*   `Alice` is eligible for rewards in `distributionA`\n*   the network is congested\n*   current block number = 10000\n\n1.  `DEFAULT_ADMIN_ROLE` of `BribeVault` tries to call `updateRewardsMetadata()` and update `distributionA`'s proof;\n2.  After a while, since the prev tx is stucked, `DEFAULT_ADMIN_ROLE` of `BribeVault` calls `updateRewardsMetadata()` again with same calldata;\n3.  The first tx got packed into block 10010;\n4.  `Alice` calls `claim()` and got the reward;\n5.  The 2nd tx got packed into block 10020;\n6.  `Alice` calls `claim()` again and get the reward again.\n\n### Recommended Mitigation Steps\n\nChange to:\n\n```solidity\nstruct UpdateDistribution {\n    bytes32 rewardIdentifier;\n    address token;\n    bytes32 merkleRoot;\n    bytes32 proof;\n    uint256 prevUpdateCount;\n}\n\nfunction updateRewardsMetadata(\n    Common.UpdateDistribution[] calldata _distributions\n) external {\n    require(msg.sender == bribeVault, \"Invalid access\");\n    require(_distributions.length > 0, \"Invalid _distributions\");\n\n    for (uint256 i = 0; i < _distributions.length; i++) {\n        require(reward.updateCount == _distributions[i].prevUpdateCount, \"Invalid updateCount\");\n        // Update the metadata and also increment the update to reset the claimed tracker\n        Reward storage reward = rewards[_distributions[i].rewardIdentifier];\n        reward.token = _distributions[i].token;\n        reward.merkleRoot = _distributions[i].merkleRoot;\n        reward.proof = _distributions[i].proof;\n        reward.updateCount += 1;\n\n        emit RewardMetadataUpdated(\n            _distributions[i].rewardIdentifier,\n            _distributions[i].token,\n            _distributions[i].merkleRoot,\n            _distributions[i].proof,\n            reward.updateCount\n        );\n    }\n}\n```\n\n**[kphed (Redacted Cartel) disputed and commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/89#issuecomment-1043630034):**\n > > However, when the network is congested, DEFAULT_ADMIN_ROLE of BribeVault may mistakenly send 2 updateRewardsMetadata() txs, and the transactions can be packaged into different blocks.\n> \n> The tx is executed via a multisig - we won't accidentally call it twice.\n> \n> > After a while, since the prev tx is stucked, DEFAULT_ADMIN_ROLE of BribeVault calls updateRewardsMetadata() again with same calldata;\n> \n> In the scenario where we wanted to call `updateRewardsMetadata` again with the same calldata, we would use the same nonce as the stuck transaction.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/89#issuecomment-1059802903):**\n > I agree with both the warden and the sponsor in that I believe that:\n> 1) the `DEFAULT_ADMIN_ROLE` can set metadata back to allow further (arbitrary) claims\n> 2) This can be used by the admin to grief or alter the claimable rewards\n> \n> At the same time I have to agree that the Sponsor wouldn't be calling this \"accidentally\".\n> \n> I believe this finding to be valid, and to shed light into Admin Privilege, in that the Admin can set the metadata to whatever they want, allowing or denying claims at their will.\n> \n> As such I believe the finding to be valid, and Medium Severity to be more appropriate.\n\n\n\n***\n\n## [[M-10] Distributions must not match actual bribes](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/33)\n_Submitted by cmichel_\n\nThe `BribeVault.transferBribes` transfers tokens for distribution.<br>\nAll parameters (`amounts`, `distributions`) are blindly accepted by the function and never verified to match the actual bribes that were deposited for the `distributions[i].rewardIdentifier`.\n\nThe `distributions[i].token` must not match the `distributions[i].rewardIdentifier`'s token (included in the reward identifier hash), and the `amounts[i]` (and fees) must not match the `bribes[bribeIdentifier].amount`.\n\nThe admin can submit arbitrary values and create distributions that don't reflect the bribe the distribution is actually for.\nIt's easy to under-or overreport amounts for a bribe, take amounts from a different bribe, or steal all amounts from users by using 100% fees, distribute the same bribe over and over, etc.\n\n### Recommended Mitigation Steps\n\nReduce the trust that users need to have in the admin by validating the `Common.Distribution[] calldata distributions`,  `uint256[] calldata amounts`, `uint256[] calldata fees` parameters against the deposited bribes.\n\nFor example:\n\n*   Check that the `distributions[i].token` matches the `distributions[i].rewardIdentifier`\n*   The amount + fees equal the `bribes[bribeIdentifier].amount`, then reset the `bribes[bribeIdentifier].amount`.\n\n**[kphed (Redacted Cartel) disagreed with High severity and commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/33#issuecomment-1041726853):**\n > We will be adding validation to the `transferBribes` method to provide peace of mind to our users, however, we consider this low-risk for the reasons below.\n> \n> > All parameters (amounts, distributions) are blindly accepted by the function and never verified to match the actual bribes that were deposited for the distributions[i].rewardIdentifier.\n> > ...\n> \n> Compilation and thorough validation of the data necessary for calling `transferBribes` will be done off-chain using a publicly auditable set of scripts in our repo.\n> \n> Additionally, since the method can only be called by the protocol multisig (i.e. admin), signers will have the opportunity to review the data prior to submitting their signature. In conjunction with the above, they can generate their own data using the script and compare it against what is to be submitted.\n> \n> Thanks again for participating in our contest cmichel, looking forward to more feedback/suggestions/comments.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/33#issuecomment-1059803795):**\n > I agree with the finding, the math for onChain bribes is not validated, while the math for bribes distribution is blindly trusted.\n> \n> This finding highlights a type of admin privilege, in which the admin can set arbitrary claims which do not reflect the actual state of the system.\n> \n> For this reason, as well as the eloquence of the warden, am going to mark this as valid and of medium severity.\n\n\n\n***\n\n## [[M-11] Depositor can spend funds of another Depositor](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/11)\n_Submitted by csanuragjain_\n\n1.  One depositor can spend funds of another depositor\n2.  Depositor can deposit in expired proposal\n3.  rewardIdentifier and bribeIdentifier can point to different rounds/tokens\n\n### Proof of Concept\n\nOne depositor can spend funds of another depositor:\n\n1.  Malicious depositor can call depositBribeERC20 at BribeVault.sol#L164 with briber as User B (Malicious user can generate bribeIdentifier with his own proposal)\n\n2.  Assume this User B has approved amount x to this contract\n\n3.  BribeVault.sol#L187 (IERC20(token).safeTransferFrom(briber, address(this), amount);) will transfer this amount x to the contract due to call at step 1. All this happen without User B knowledge\n\nExpired Proposal:\n\n1.  Malicious depositor can generate bribeIdentifier of an expired proposal (proposalDeadlines\\[proposal] < block.timestamp) using generateBribeVaultIdentifier at TokemakBribe.sol#L166\n\n2.  Malicious depositor can then simply call depositBribeERC20 at BribeVault.sol#L164\n\n3.  Since there is no deadline check and this function blindly trusts bribeIdentifier, user deposit will be success even though the associated proposal already expired\n\nRewardIdentifier and bribeIdentifier can point to different rounds/tokens:\n\n1.  Similar to expired proposal, depositor can generate bribeIdentifier and RewardIdentifier with different tokens and rounds.\n\n2.  Depositor now calls epositBribeERC20 at BribeVault.sol#L164 with the generated bribeIdentifier and RewardIdentifier\n\n3.  rewardToBribes\\[rewardIdentifier].push(bribeIdentifier); will update reward for round x and bribeIdentifier will point to round y which is incorrect\n\n### Recommended Mitigation Steps\n\ndepositBribeERC20 at [BribeVault.sol#L164](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L164) should only be allowed to be called via TokemakBribe.sol\n\n**[kphed (Redacted Cartel) disputed and commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/11#issuecomment-1040409839):**\n > > depositBribeERC20 at BribeVault.sol#L164 should only be allowed to be called via TokemakBribe.sol\n> \n> Only those with the \"depositor\" role can call the deposit bribe methods (`depositBribeERC20` and `depositBribe`). We only grant the role to bribe contracts we own such as TokemakBribe.sol.\n> \n> Thanks again for participating in our contest csanuragjain, looking forward to more feedback/suggestions/comments.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/11#issuecomment-1059804225):**\n > While the finding is similar to M-02, I believe this more eloquently shows the specific types of admin privileges that the `DEPOSITOR_ROLE` has for the function `depositBribeERC20`.\n> \n> Ultimately the finding is highlighting how things can go wrong and how the `DEPOSITOR_ROLE` provides a high level of admin privilege.\n> \n> Because this is contingent on a malicious admin, I believe Medium Severity to be more appropriate.\n\n\n\n***\n\n## [[M-12] Users Can Frontrun Calls to `updateRewardsMetadata()` And Claim Tokens Twice](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/118)\n_Submitted by leastwood_\n\nThe `updateRewardsMetadata()` function is called by the `BribeVault` contract by the admin role. The function will take a list of distributions which are used to update the associated reward metadata. It is expected that the merkle root will be updated to correctly identify which claimers have already claimed tokens.\n\n`reward.updateCount` is incremented to reset the claimed tracker, allowing users that may have previously claimed, to claim their updated reward. However, there is potential for mis-use if users frontrun calls to `updateRewardsMetadata()` and claim their reward after the new merkle root has been calculated and updated by the admin role. This may allow the claimer to double claim their rewards or lead to a loss in rewards if the reward metadata completely replaces the previous list of claimers.\n\n### Proof of Concept\n\n[RewardDistributor.sol#L97-L119](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L97-L119)<br>\n[RewardDistributor.sol#L127-L209](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L127-L209)<br>\n\n### Recommended Mitigation Steps\n\nConsider implementing a delay where users cannot claim rewards before a call to `updateRewardsMetadata()` is made. This should ensure the admin role can construct a merkle tree based on the most up-to-date and correct data.\n\n**[kphed (Redacted Cartel) confirmed and commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/118#issuecomment-1043693014):**\n> After speaking with leastwood via Discord, I now believe this issue to be meaningfully different from issue M-09 and is a valid attack vector. His recommended solution above inspired a fix which we both agreed would solve the problem (i.e. set a \"blank\" merkle root, evaluate the users who claimed with the previous merkle root, and construct a new one accordingly).\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/118#issuecomment-1059807830):**\n > I appreciate the nuance from the sponsor over this finding.\n> \n> Ultimately when using a merkle proof system, the new proof is calculated at a certain time. (ProofX)\n> \n> If UserA didn't claim when the proof was generated, they technically have time between when the proof is generated and the proof is published to claim for the first time.\n> \n> Because the new Merkle Proof (ProofX) was built to allow UserA to claim, they will be able to claim again.\n> \n> The only way I can think of to avoid this is to always only have one proof per set of claims, as to avoid getting front-run.\n> \n> There is merit to make this finding separate, although ultimately the reason why this is possible is because of the Admin ability to change the proofs at any time.\n> \n> So I'm going to suggest that this finding is similar to M-09, it's mitigation should be basically the same, however I'll mark as separate to give credit where it's due.\n> \n> Because the finding is contingent on external conditions (owner getting frontrun or owner being malicious), I believe medium severity to be appropriate.\n> \n> A mitigation could be to push new proofs via Flashbots, and use a snapshot like system to check that no claims where made in the time between the proof generation and the proof being set.\n\n\n\n***\n\n## [[M-13] Reentrancy in `depositBribeERC20` function](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/122)\n_Submitted by Czar102, also found by 0x1f8b and SolidityScan_\n\n[BribeVault.sol#L164-L205](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L164-L205)\n\n`depositBribeERC20` function in `BriveVault` is reentrant in line 187, where an address supplied by the caller is called.\n\nA bad actor that has `DEPOSITOR_ROLE` and is a contract can execute a folowing attack:\n\n1.  Create a dummy token contract, reentrant in the transferFrom() function. All tokens are approved to the `BriveVault` and the attacker contract has unlimited tokens. Reentrancy aims back to a function in the attacker contract, which calls `depositBribeERC20` again.\n2.  The first call by the contract must use a novel `bribeIdentifier`. `token` is set to a dummy contract and `amount` to `uint(-2)`.\n3.  All checks pass, `transferFrom` is called, which calls attacker contract, which can call `depositBribeERC20` again, this time will transfer 1 wei of a valuable token, using the same `bribeIdentifier`. All checks pass as the previous token hasn't been registered yet. Then, a valid transfer happens. After that, the amount is set to 1 wei and the token is saved. Event is emitted and the function returns value. Then, attacker function returns and dummy token returns. The operation is to increment amount in storage by the transfer value, which increases `b.amount` to the maximum integer. The token is nonzero, so the if statement is passed.\n\nThus, an attacker can grant any amount of tokens from `BriveVault` to a certain bribe, stealing all the funds once the bribe will be withdrawn.\n\n### Recommended Mitigation Steps\n\nSet bribe token before the transfer is made.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/122#issuecomment-1059989503):**\n > I do believe re-entrancy is possible, so I recommend the sponsor to add the `nonReentrant` modifier to the deposit function.\n> \n> I'll keep the finding separate [from M-02] as this deals with reEntrancy.<br>\n> Mitigation would be to enforce a bribeIdentifier to be used for a specific token (and it being enforced), as well as adding `nonReentrant`.\n> \n> Because the function is permissioned, I believe medium severity to be more appropriate.\n\n\n\n***\n\n## [[M-14] transferBribes could transfer before proposal deadline + Input validation](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/14)\n_Submitted by csanuragjain, also found by gzeon and WatchPug_\n\nIt seems that Admin can call transferBribes even when proposals belonging to this rewardIdentifier have not expired. Also due to lack of input validation, token in distributions\\[i].rewardIdentifier might differ from distributions\\[i].token and also amount is not validated\n\n### Proof of Concept\n\ntransferBribes could transfer before proposal deadline:\n\n1.  Observe the transferBribes function at [BribeVault.sol#L256](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L256)\n2.  This is directly distributing the rewards for a rewardIdentifier even though proposal (bribeIdentifier) linked to this rewardToBribes\\[rewardIdentifier] might not have expired. This means users are still depositing and Admin transferred reward early\n\nInput Validation:\n\n1.  Observe the transferBribes function at [BribeVault.sol#L256](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L256)\n2.  amounts object is directly passed by Admin and there is no verification to see that sum amount of all proposals under rewardToBribes\\[rewardIdentifier] is equal to amount provided by admin in argument\n3.  distributions\\[i].token is directly passed by Admin and there is no verification to see that token under distributions\\[i].rewardIdentifier is equal to the one provided by admin in argument\n\n### Recommended Mitigation Steps\n\nPerform input validation.\n\n**[kphed (Redacted Cartel) disagreed with Medium severity and commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/14#issuecomment-1040720186):**\n > > transferBribes could transfer before proposal deadline:<br>\n> > ...\n> \n> Much of the validation will be handled off-chain at the time we compute the proofs and merkle roots (we still need to write the script for that). The reason for that approach is because we will have many similar contracts (but not exactly alike - e.g. some may not have deadlines) to TokemakBribe that will interact with BribeVault. It wouldn't be feasible to validate all the different constraints on-chain. That said, the admin is a multisig and the signers will have to agree on timing and correctness of the data to prevent this from happening.\n> \n> > Input Validation:<br>\n> > ...\n> \n> Thanks, we'll implement #2 and #3 to provide peace of mind to our users.\n> \n> Thanks again for participating in our contest csanuragjain, looking forward to more feedback/suggestions/comments.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/14#issuecomment-1059990041):**\n > While I understand the sponsor's reasoning, any validation that is not enforced by the Smart Contract can't be verified.\n> It requires trust which could be minimized, if not removed, if the contract enforced those conditions.\n> \n> `bribeIdentifier`, it's relation with `token`, the fact that a bribe was transferred or not, all these events can be tracked onChain, offering clear paths for funds, which ultimately give more security guarantees to end users.\n> \n> Because this ultimately is a trust issue, I believe medium severity to be appropriate.\n\n\n\n***\n\n## [[M-15] Fees can be any amount](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/74)\n_Submitted by danb, also found by pauliax_\n\nIn `transferBribes`, the fees are user input, rather than  calculation using `fee` (state var).<br>\nCurrently, `fee` is unused:\n[BribeVault.sol#L23](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L23).<br>\n\nTherefore the fees amounts might be wrong.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/74#issuecomment-1059990473):**\n > I don't believe M-14 mentions validation of fees, as such will mark this finding as unique.\n>\n> Ultimately the function trusts the Admin input instead of using the storage variable, giving less security guarantees as to the fairness of the Distribution of the Bribes.\n> \n> Because this is contingent on a malicious admin, I believe medium severity to be appropriate.\n\n\n\n***\n\n## [[M-16] `DEPOSITOR_ROLE` can manipulate `b.amount` value](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/95)\n_Submitted by rfa, also found by Omik_\n\n[BribeVault.sol#L187](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L187)<br>\n\nMalicious `DEPOSITOR_ROLE` can doing self transfer and manipulate `b.amount`\n\n### Proof of Concept\n\nIn case malicious `DEPOSITOR_ROLE` inputing `WETH` address and putting `briber` == address(this) in `safeTransferFrom` argument (which is self transfering). Therefore, it is posible to increase `b.amount` without any cost.\n\nWETH token contract:\n\n    //Line 62 WETH contract\n    function transferFrom(address src, address dst, uint wad)\n            public\n            returns (bool)\n        {\n            require(balanceOf[src] >= wad);\n\n            if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) { \n                require(allowance[src][msg.sender] >= wad); \n                allowance[src][msg.sender] -= wad; // <----------- this line won't executed\n            }\n\n            balanceOf[src] -= wad;\n            balanceOf[dst] += wad;\n\n            Transfer(src, dst, wad);\n\n            return true;\n        }\n\nIf the condition didn't pass (in this case msg.sender != `src` ), the transaction will treated like a transfer (doesn't need an allowance), Therefore its possible to do self transfer\n\n### Recommended Mitigation Steps\n\nI recommend to validate that bribe != Address(this)\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/95#issuecomment-1059993804):**\n > I'm marking the finding as unique because of the interesting mechanic.<br>\n> Some ERC20 will revert on trying to transfer to yourself, however the warden showed a specific exploit, using WETH, that could be used against the vault.\n\n\n\n***\n\n## [[M-17] ThecosomataETH: Oracle price can be better secured (freshness + tamper-resistance)](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/49)\n_Submitted by hickuphh3_\n\n[ThecosomataETH.sol#L94-L110](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/ThecosomataETH.sol#L94-L110)<br>\n\nThe `ThecosomataETH` contract adds ETH and BTRFLY tokens as liquidity into the [ETH-BTRFLY curve crypto pool](https://etherscan.io/address/0xf43b15ab692fde1f9c24a9fce700adcc809d5391). The `calculateAmountRequiredForLP()` function relies on the `price_oracle` value returned by the pool to calculate the ETH and BTRFLY amounts to be added as liquidity. It is therefore important to ensure that `price_oracle` is accurate.\n\nAt the time of writing, the pool has about \\$5M in liquidity, which is comparable to that of the [liquidity provided on UniswapV3](https://info.uniswap.org/#/pools/0xdf9ab3c649005ebfdf682d2302ca1f673e0d37a2). Flash loan attacks are therefore possible, but ineffective (explained further later).\n\nIn the [curve v2 whitepaper](https://curve.fi/files/crypto-pools-paper.pdf), the price oracle mechanism is explained briefly in the “Algorithm for repegging” section. It is reproduced below for convenience.\n\n> Internally, we have a price oracle given by an exponential moving average (EMA) applied in N-dimensional price space. Suppose that the last reported price is `pLast`, and the update happened `t` seconds ago while the half-time of the EMA is `T1/2`. Then the oracle price `p_new` is given as:\n\n```jsx\nα = 2^(− t / T1/2);\np_new = pLast * (1 - α) + α * p_old // p_old = current price_oracle\n```\n\n### Impact\n\nWith oracles (curve pool now, to be switched to chainlink based oracle as per comment in L27), there is an inverse correlation between freshness and tamper-resistance.\n\nWe can expect `price_oracle` to be relatively fresh as trades will occur whenever arbitrage opportunities arise against the UniV3 pool which has comparable liquidity. Note that the `ETH-BTRFLY` pool has a half-time of 10 minutes (`T1/2 = 600`). This means that after exactly 10 mins, both `pLast` and `p_old` have equal weightage.\n\nIt is unclear how resistant the EMA oracle is against manipulation. Flash loan attacks, while possible, will be ineffective because `t` will be zero (`pLast` will be ignored in the update). However, a sophisticated attacker could possibly skew the price oracle by inflating the price of `BTRFLY` a couple of blocks before the `performUpkeep()` transaction to get the treasury to deposit more `ETH` / burn more `BTRFLY` than necessary.\n\n### Recommended Mitigation Steps\n\nIn my opinion, both freshness and tamper-resistance can be better secured.\n\nThis can be done by:\n\n1.  Ensuring that the price was updated within a certain limit.\n\n```jsx\n// eg. last price update / trade must have been executed within the past hour\nuint256 lastPricesTimestamp = ICurveCryptoPool(CURVEPOOL).last_prices_timestamp();\nrequire(block.timestamp - lastPricesTimestamp <= 1 hours, 'stale price');\n```\n\n2.  Checking that the last reported price `pLast` has not deviated too far from the current oracle price `p_old`. One can argue that it would be safer to add liquidity when the market isn’t volatile.\n\n```jsx\nuint256 lastPrice = ICurveCryptoPool(CURVEPOOL).last_prices();\nuint256 oraclePrice = ICurveCryptoPool(CURVEPOOL).price_oracle();\nuint256 percentDiff;\n// eg. require difference in prices to be within 5%\nif (lastPrice > oraclePrice) {\n  percentDiff = (lastPrice - oraclePrice) * 1e18 / oraclePrice;\n} else {\n  percentDiff = (oraclePrice - lastPrice) * 1e18 / oraclePrice;\n}\nrequire(percentDiff <= 5e16, 'volatile market');\n```\n\n**[drahrealm (Redacted Cartel) commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/49#issuecomment-1042571538):**\n > Idem with M-05, we will proceed with doing calculating the min token amount off-chain, then specify it when calling `performUpKeep`.\n> \n> Thanks for the finding.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/49#issuecomment-1060059235):**\n > Agree that solution is based off of M-05.<br> \n> While I believe simpler solutions where highlighted, I feel the warden put in the extra effort to make a valuable submission.\n> \n> As such, I'll mark the finding as unique.\n> \n> Personally I would not trust Curve Pricing model over a Price Feed at this time, however am happy to be proven wrong.\n\n\n\n***\n\n## [[M-18] Rewards can be lost](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/13)\n_Submitted by csanuragjain_\n\nReward can be lost if bribeVault calls the updateRewardsMetadata on same rewardIdentifier again before user can claim his reward (since merkleRoot and proof will get updated).\n\n### Proof of Concept\n\n1.  bribeVault calls the updateRewardsMetadata at [RewardDistributor.sol#L97](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L97) using rewardIdentifier X\n2.  Assume  \\_distributions\\[i].proof contains merkle proof for User A\n3.  User A fails to call claim function\n4.  bribeVault again calls the updateRewardsMetadata at RewardDistributor.sol#L97 using rewardIdentifier X updating  \\_distributions\\[i].proof  which might not contain merkle proof of User A now. So User A loses his rewards\n\n### Recommended Mitigation Steps\n\nbribeVault should only make second call to updateRewardsMetadata on same rewardIdentifier when all claimers have made their claims.\n\n**[kphed (Redacted Cartel) disputed and commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/13#issuecomment-1040595384):**\n > We would only call `updateRewardsMetadata` again if there was an issue with the originally-set merkle root(s). The recommended mitigation steps above would block us from setting the correct merkle roots until after claimers claimed the wrong amounts.\n> \n> Thanks again for participating in our contest csanuragjain, looking forward to more feedback/suggestions/comments.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/13#issuecomment-1060063884):**\n > The finding highlights the consequences of admin privilege, in that the admin can use `updateRewardsMetadata` to deny claims.\n> \n> While I believe the warden could have done a better job at expressing the risks involved for users, I believe the finding to be valid. \n\n\n\n***\n\n# Low Risk and Non-Critical Issues\n\nFor this contest, 25 reports were submitted by wardens detailing low risk and non-critical issues. The [report highlighted below](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/47) by warden **hickuphh3** received the top score from the judge.\n\n_The following wardens also submitted reports: [ye0lde](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/103), [kenzo](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/66), [pauliax](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/115), [Ruhum](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/37), [WatchPug](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/83), [cmichel](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/32), [0x0x0x](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/42), [csanuragjain](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/10), [defsec](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/101), [gzeon](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/72), [kenta](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/17), [SolidityScan](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/97), [cccz](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/19), [IllIllI](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/44), [peritoflores](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/117), [0x1f8b](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/26), [0xliumin](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/41), [hyh](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/123), [Omik](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/111), [robee](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/27), [Dravee](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/58), [jayjonah8](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/3), [p4st13r4](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/93), and [danb](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/78)._\n\n## Codebase Impressions & Summary\n\nThis audit scope consisted of 4 contracts. Overall, the code quality is great. Inline comments and documentation provided was adequate. Various parties / roles and contract interactions were well explained.\n\nMost issues raised are minor improvements to improve the security of the contracts. The only notable findings made had to do with the usage of the curve crypto pool’s price oracle, and protection against sandwich attacks when adding liquidity.\n\nIn addition, I made a suggestion regarding the syncing of Tokemak’s rounds with the `TokemakBribe` contract.\n\nNote that I refrained raising issues regarding FoT tokens because I assume they are not meant to be supported.\n\n## [L-01] RewardDistributor: Change `payable(account).transfer()` to `.call()` for native fund transfers\n\n### Line References\n\n[RewardDistributor.sol#L181](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L181)<br>\n\n### Description\n\n`BribeVault` uses `.call()` for native fund transfers, but `RewardDistributor` uses `.transfer()`. They should be standardized to `.call()`, the currently recommended method since [`.transfer()` fowards 2300 gas whereas `.call()` forwards all / set gas.](https://solidity-by-example.org/sending-ether/)\n\n### Recommended Mitigation Steps\n\n```jsx\n(bool sentAccount, ) = _account.call{value: _amount}(\"\");\nrequire(sentAccount, \"Failed to transfer to _account\");\n```\n\n## [L-02] BribeVault: Use `safeTransfer` for tokens\n\n### Line References\n\n[BribeVault.sol#L296-L297](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L296-L297)<br>\n[BribeVault.sol#L337](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L337)\n\n### Description\n\nSome ERC20 tokens like ZRX don’t revert if the transfer fails. Since the `SafeERC20` has already been imported and the `safeTransferFrom` method used, the same should be done for token transfers.\n\n### Recommended Mitigation Steps\n\nReplace `transfer` with `safeTransfer`.\n\n## [L-03] RewardDistributor: Limit native fund transfers to `bribeVault`\n\n### Line References\n\n[RewardDistributor.sol#L58-L59](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L58-L59)\n\n### Description\n\nSince the only source of native fund transfers is expected to be the `bribeVault` contract, it would be good to restrict incoming fund transfers from other sources to prevent accidental transfers.\n\n### Recommended Mitigation Steps\n\n```jsx\nreceive() external payable {\n  require(msg.sender == bribeVault, 'only bribeVault');\n}\n```\n\n## [L-04] TokemakBribe: Sync rounds with Tokemak’s manager instead of manually setting rounds via `setRound()`\n\n### Line References\n\n[TokemakBribe.sol#L104-L110](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L104-L110)\n\n### Description\n\nInstead of manually setting rounds, consider fetching the round number directly from Tokemak’s manager contract via `[manager.currentCycleIndex()](https://etherscan.io/address/0xa86e412109f77c45a3bc1c5870b880492fb86a14#readProxyContract)`. While I initially wrote an issue about being able to set previous round numbers, after having chatted with the sponsor, it is intended to be a feature, not a bug.\n\n### Recommended Mitigation Steps\n\n```jsx\n// TODO: change _round to getRound() wherever it is called in other internal functions\nfunction getRound() public view returns (uint256) {\n  // if round is overridden, return set value\n  if (_round != 0) return _round;\n  // otherwise, if value is 0, use Tokemak's currentCycleIndex()\n  // Tokemak manager at 0xa86e412109f77c45a3bc1c5870b880492fb86a14\n  return manager.currentCycleIndex();\n}\n```\n\n## [N-01] TokemakBribe: `getBribe()` has incorrect description\n\n### Line References\n\n[TokemakBribe.sol#L188-L194](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/TokemakBribe.sol#L188-L194)\n\n### Description\n\n*   Missing `round` param\n*   `bribeAmount` has incorrect description\n\n### Recommended Mitigation Steps\n\n```jsx\n/**\n\t  @notice Get bribe from BribeVault\n\t  @param  proposal            address  Proposal\n          @param  round               uint256  Round\n\t  @param  token               address  Token\n\t  @return bribeToken          address  Bribe token address\n\t  @return bribeAmount         uint256  Bribe token amount\n*/\n```\n\n## [N-02] Emit relevant events in constructor methods when variables are set, or abstract to internal functions\n\n### Line References\n\n[BribeVault.sol#L59-L74](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L59-L74)<br>\n\n[RewardDistributor.sol#L51-L56](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L51-L56)\n\n### Description\n\nSome variables are set in the constructor method but do not emit events, unlike their setter counterparts. For instance, `bribeVault` in the `RewardDistributor` contract fails to emit the `SetBribeVault` event, but this is emitted in the `setBribeVault()` function.\n\n### Recommended Mitigation Steps\n\nEither emit the events in the constructor, or make the setter functions public and have the constructor call it.\n\n**[kphed (Redacted Cartel) confirmed and commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/47#issuecomment-1045048948):**\n > > Overall, the code quality is great. Inline comments and documentation provided was adequate. Various parties / roles and contract interactions were well explained.\n> \n> Thanks for the compliment and the thorough code review! Both are greatly appreciated.\n> \n> > [L-01] RewardDistributor: Change payable(account).transfer() to .call() for native fund transfers<br>\n> > [L-02] BribeVault: Use safeTransfer for tokens<br>\n> > [L-03] RewardDistributor: Limit native fund transfers to bribeVault<br>\n> > [N-01] TokemakBribe: getBribe() has incorrect description<br>\n> > [N-02] Emit relevant events in constructor methods when variables are set, or abstract to internal functions\n> \n> Thank you, we're planning on implementing all of the above.\n> \n> > [L-04] TokemakBribe: Sync rounds with Tokemak’s manager instead of manually setting rounds via setRound()\n> \n> This was an option we've considered but we opted for setting the round manually since our schedule may not always be in lockstep with Tokemak's (e.g. there may be off-chain activities - governance, disputes, etc. - that may result in us taking delayed action). That said, your recommended implementation is a great middle ground solution, thank you for that.\n\n**[kphed (Redacted Cartel) commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/47#issuecomment-1045081504):**\n > Your comment has inspired a potentially more streamlined solution without needing `round`: using a proposal's deadline to segregate the token deposits for a general time period (i.e. voting round). Thank you!\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/47#issuecomment-1052808940):**\n > The report is great, gives some general considerations as well as specific advice to implement.<br>\n> Great submission.\n> \n> Only negative note is the warden missed re-entrancy, beside that, this is how I think a QA report should be done.\n>\n> Score: 7/10\n\n\n\n***\n\n# Gas Optimizations\n\nFor this contest, 18 reports were submitted by wardens detailing gas optimizations. The [report highlighted below](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/84) by warden team **WatchPug** received the top score from the judge.\n\n_The following wardens also submitted reports: [csanuragjain](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/8), [0x1f8b](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/12), [Jujic](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/53), [ye0lde](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/79), [hickuphh3](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/46), [IllIllI](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/59), [pauliax](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/116), [kenta](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/16), [robee](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/28), [gzeon](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/71), [Omik](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/110), [rfa](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/99), [z3s](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/63), [d4rk](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/50), [SolidityScan](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/94), [Tomio](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/124), and [defsec](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/100)._\n\n## [G-01] Adding unchecked directive can save gas\n\n_Note: minor optimation, the amount of gas saved is minor, change when you see fit._\n\nFor the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.\n\nFor example:\n\n[ThecosomataETH.sol#L118-L118](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L118-L118)\n\n## [G-02] Using immutable variable can save gas\n\n_Note: Suggested optimation, save a decent amount of gas without compromising readability._\n\n[TokemakBribe.sol#L28-L28](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L28-L28)<br>\n\n```solidity\n    address public bribeVault;\n```\n\n[TokemakBribe.sol#L60-L65](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L60-L65)<br>\n\n```solidity\n    constructor(address _bribeVault) {\n        require(_bribeVault != address(0), \"Invalid bribeVault\");\n        bribeVault = _bribeVault;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n```\n\nConsidering that `bribeVault` will never change, changing it to immutable variable instead of storage variable can save gas.\n\n## [G-03] Remove redundant access control checks can save gas\n\n_Note: suggested optimation, save a decent amount of gas without compromising readability._\n\n[TokemakBribe.sol#L125-L135](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L125-L135)<br>\n\n```solidity\n    function setProposal(address proposal, uint256 deadline)\n        public\n        onlyAuthorized\n    {\n        require(proposal != address(0), \"Invalid proposal\");\n        require(deadline >= block.timestamp, \"Deadline must be in the future\");\n\n        proposalDeadlines[proposal] = deadline;\n\n        emit SetProposal(proposal, deadline, _round);\n    }\n```\n\n[TokemakBribe.sol#L142-L157](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L142-L157)<br>\n\n```solidity\n    function setProposals(\n        address[] calldata proposals,\n        uint256[] calldata deadlines\n    ) external onlyAuthorized {\n        require(proposals.length > 0, \"Need at least 1 proposal\");\n        require(\n            proposals.length == deadlines.length,\n            \"Must be equal # of proposals and deadlines\"\n        );\n\n        for (uint256 i = 0; i < proposals.length; i += 1) {\n            setProposal(proposals[i], deadlines[i]);\n        }\n\n        emit SetProposals(proposals, deadlines, _round);\n    }\n```\n\n`setProposal()` already got `onlyAuthorized` check, and `setProposals()` will check it again multiple times.\n\nConsider creating `_setProposal()` private function without access control and call it inside the public functions.\n\n### Recommended Mitigation Steps\n\nChange to:\n\n```solidity\n    function _setProposal(address proposal, uint256 deadline)\n        private\n    {\n        require(proposal != address(0), \"Invalid proposal\");\n        require(deadline >= block.timestamp, \"Deadline must be in the future\");\n\n        proposalDeadlines[proposal] = deadline;\n    }\n\n    /**\n        @notice Set a single proposal\n        @param  proposal  addresss Proposal address\n        @param  deadline  uint256  Proposal deadline\n     */\n    function setProposal(address proposal, uint256 deadline)\n        public\n        onlyAuthorized\n    {\n        _setProposal(proposal, deadline);\n        emit SetProposal(proposal, deadline, _round);\n    }\n\n    /**\n        @notice Set multiple proposals\n        @param  proposals  address[]  Proposal addresses\n        @param  deadlines  uint256[]  Proposal deadlines\n     */\n    function setProposals(\n        address[] calldata proposals,\n        uint256[] calldata deadlines\n    ) external onlyAuthorized {\n        require(proposals.length > 0, \"Need at least 1 proposal\");\n        require(\n            proposals.length == deadlines.length,\n            \"Must be equal # of proposals and deadlines\"\n        );\n\n        for (uint256 i = 0; i < proposals.length; i += 1) {\n            _setProposal(proposals[i], deadlines[i]);\n        }\n\n        emit SetProposals(proposals, deadlines, _round);\n    }\n```\n\n## [G-04] Validation can be done earlier to save gas\n\n_Note: suggested optimation, save a decent amount of gas without compromising readability._\n\nCheck if `ethLiquidity > 0 && btrflyLiquidity > 0` earlier can avoid unnecessary external call (`IRedactedTreasury(TREASURY).manage(WETH, ethLiquidity);`) when this check failed.\n\n[ThecosomataETH.sol#L124-L155](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L124-L155)<br>\n\n```solidity\n    function performUpkeep() external onlyOwner {\n        require(checkUpkeep(), \"Invalid upkeep state\");\n\n        uint256 btrfly = IBTRFLY(BTRFLY).balanceOf(address(this));\n        uint256 ethAmount = calculateAmountRequiredForLP(btrfly, true);\n        uint256 ethCap = IERC20(WETH).balanceOf(TREASURY);\n        uint256 ethLiquidity = ethCap > ethAmount ? ethAmount : ethCap;\n\n        // Use BTRFLY balance if remaining capacity is enough, otherwise, calculate BTRFLY amount\n        uint256 btrflyLiquidity = ethCap > ethAmount\n            ? btrfly\n            : calculateAmountRequiredForLP(ethLiquidity, false);\n\n        IRedactedTreasury(TREASURY).manage(WETH, ethLiquidity);\n\n        // Only complete upkeep only on sufficient amounts\n        require(ethLiquidity > 0 && btrflyLiquidity > 0, \"Insufficient amounts\");\n        // ...\n    }\n```\n\n### Recommended Mitigation Steps\n\nChange to:\n\n```solidity\n    function performUpkeep() external onlyOwner {\n        require(checkUpkeep(), \"Invalid upkeep state\");\n\n        uint256 btrfly = IBTRFLY(BTRFLY).balanceOf(address(this));\n        uint256 ethAmount = calculateAmountRequiredForLP(btrfly, true);\n        uint256 ethCap = IERC20(WETH).balanceOf(TREASURY);\n        uint256 ethLiquidity = ethCap > ethAmount ? ethAmount : ethCap;\n\n        // Use BTRFLY balance if remaining capacity is enough, otherwise, calculate BTRFLY amount\n        uint256 btrflyLiquidity = ethCap > ethAmount\n            ? btrfly\n            : calculateAmountRequiredForLP(ethLiquidity, false);\n\n        // Only complete upkeep only on sufficient amounts\n        require(ethLiquidity > 0 && btrflyLiquidity > 0, \"Insufficient amounts\");\n\n        IRedactedTreasury(TREASURY).manage(WETH, ethLiquidity);\n\n        // ...\n    }\n```\n\n## [G-05] `type(uint256).max` is more gas efficient than `2**256 - 1`\n\n_Note: minor optimation, the amount of gas saved is minor, change when you see fit._\n\n[ThecosomataETH.sol#L68-L69](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L68-L69)\n\n## [G-06] `10e18` is more gas efficient than `10**18`\n\n_Note: minor optimation, the amount of gas saved is minor, change when you see fit._\n\n[ThecosomataETH.sol#L102-L108](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/ThecosomataETH.sol#L102-L108)\n\n## [G-07] Cache array length in for loops can save gas\n\n_Note: suggested optimation, save a decent amount of gas without compromising readability._\n\nReading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.\n\nCaching the array length in the stack saves around 3 gas per iteration.\n\nInstances include:\n\n[TokemakBribe.sol#L147-L152](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/TokemakBribe.sol#L147-L152)\n\n[BribeVault.sol#L261-L275](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L261-L275)\n\n[RewardDistributor.sol#L80-L82](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/RewardDistributor.sol#L80-L82)\n\n## [G-08] Avoid unnecessary storage read can save gas\n\n_Note: Suggested optimation, save a decent amount of gas without compromising readability_\n\n[BribeVault.sol#L213-L248](https://github.com/code-423n4/2022-02-redacted-cartel/blob/92c4d5810df7b9de15eae55dc7641c8b36cd799d/contracts/BribeVault.sol#L213-L248)<br>\n\n```solidity\n    function depositBribe(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address briber\n    ) external payable onlyRole(DEPOSITOR_ROLE) {\n        require(bribeIdentifier.length > 0, \"Invalid bribeIdentifier\");\n        require(rewardIdentifier.length > 0, \"Invalid rewardIdentifier\");\n        require(briber != address(0), \"Invalid briber\");\n        require(msg.value > 0, \"Value must be greater than 0\");\n\n        Bribe storage b = bribes[bribeIdentifier];\n        address currentToken = b.token;\n        require(\n            // For native tokens, the token address is set to this contract to prevent\n            // overwriting storage - the address can be anything but address(this) safer\n            currentToken == address(0) || currentToken == address(this),\n            \"Cannot change token\"\n        );\n\n        b.amount += msg.value; // Allow bribers to increase bribe\n\n        // Only set the token address and update the reward-to-bribe mapping if not yet set\n        if (currentToken == address(0)) {\n            b.token = address(this);\n            rewardToBribes[rewardIdentifier].push(bribeIdentifier);\n        }\n\n        emit DepositBribe(\n            bribeIdentifier,\n            rewardIdentifier,\n            b.token,\n            msg.value,\n            b.amount,\n            briber\n        );\n    }\n```\n\nBased on L224~~L230, L235~~L236, we know that `b.token == address(this)`, therefore at L243 `b.token` can be replaced with `address(this)`.\n\nUse `address(this)` directly can avoid unnecessary storage read of `b.token` and save some gas.\n\n### Recommended Mitigation Steps\n\nReplace:\n\n```solidity\nemit DepositBribe(\n    bribeIdentifier,\n    rewardIdentifier,\n    b.token,\n    msg.value,\n    b.amount,\n    briber\n);\n```\n\nwith:\n\n```solidity\nemit DepositBribe(\n    bribeIdentifier,\n    rewardIdentifier,\n    address(this),\n    msg.value,\n    b.amount,\n    briber\n);\n```\n\n**[drahrealm (Redacted Cartel) confirmed and commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/84#issuecomment-1045947596):**\n > Some new gas optimization tricks confirmed 👍 \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/84#issuecomment-1051415615):**\n > Submission is really good.\n> \n> Adding the exact gas savings would be the cherry on top.\n> \n> Additionally adding a list of all the places in which to apply the optimization would have made this the best finding.\n> \n> Pretty good.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/84#issuecomment-1051421241):**\n > Best submission 8/10\n> \n> To improve:\n> - Actual Gas Savings math (sort findings by impact)\n> - List of all spots to fix (So the sponsor can implement instead of it being a puzzle)\n\n\n\n***\n\n# Disclosures\n\nC4 is an open organization governed by participants in the community.\n\nC4 Contests incentivize the discovery of exploits, vulnerabilities, and bugs in smart contracts. Security researchers are rewarded at an increasing rate for finding higher-risk issues. Contest submissions are judged by a knowledgeable security researcher and solidity developer and disclosed to sponsoring developers. C4 does not conduct formal verification regarding the provided code but instead provides final verification.\n\nC4 does not provide any guarantee or warranty regarding the security of this project. All smart contract software should be used at the sole risk and responsibility of users.\n"
}