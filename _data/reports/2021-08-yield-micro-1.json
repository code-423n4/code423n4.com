{
  "circa": {
    "title": "Yield micro contest #1",
    "sponsor": "Yield",
    "slug": "2021-08-yield",
    "date": "2021-09-17",
    "findings": "https://github.com/code-423n4/2021-08-yield-findings/issues",
    "contest": 25
  },
  "html": "<h1 id=\"overview\" style=\"position:relative;\"><a href=\"#overview\" aria-label=\"overview permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Overview</h1>\n<h2 id=\"about-c4\" style=\"position:relative;\"><a href=\"#about-c4\" aria-label=\"about c4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>About C4</h2>\n<p>Code 432n4 (C4) is an open organization consisting of security researchers, auditors, developers, and individuals with domain expertise in smart contracts.</p>\n<p>A C4 code contest is an event in which community participants, referred to as Wardens, review, audit, or analyze smart contract logic in exchange for a bounty provided by sponsoring projects.</p>\n<p>During the code contest outlined in this document, C4 conducted an analysis of the Yield smart contract system written in Solidity. The code contest took place between August 11—August 14 2021.</p>\n<h2 id=\"wardens\" style=\"position:relative;\"><a href=\"#wardens\" aria-label=\"wardens permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Wardens</h2>\n<p>8 Wardens contributed reports to the Yield micro code contest:</p>\n<ol>\n<li><a href=\"https://twitter.com/cmichelio\">cmichel</a></li>\n<li><a href=\"https://github.com/x9453\">shw</a></li>\n<li><a href=\"https://twitter.com/jonjonclark\">moose-code</a></li>\n<li><a href=\"https://twitter.com/0xRajeev\">0xRajeev</a></li>\n<li><a href=\"https://twitter.com/HickupH\">hickuphh3</a></li>\n<li><a href=\"https://twitter.com/gpersoon\">gpersoon</a></li>\n<li><a href=\"https://twitter.com/MukeshJ_eth\">Jmukesh</a></li>\n<li><a href=\"https://twitter.com/PierrickGT\">PierrickGT</a></li>\n</ol>\n<p>This contest was judged by <a href=\"https://twitter.com/ghoulsol\">ghoul.sol</a>.</p>\n<p>Final report assembled by <a href=\"https://twitter.com/money_lego\">moneylegobatman</a> and <a href=\"https://twitter.com/_ninek_\">ninek</a>.</p>\n<h1 id=\"summary\" style=\"position:relative;\"><a href=\"#summary\" aria-label=\"summary permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Summary</h1>\n<p>The C4 analysis yielded an aggregated total of 21 unique vulnerabilities and 48 total findings.   All of the issues presented here are linked back to their original finding</p>\n<p>Of these vulnerabilities, 5 received a risk rating in the category of HIGH severity, 4 received a risk rating in the category of MEDIUM severity, and 12 received a risk rating in the category of LOW severity.</p>\n<p>C4 analysis also identified 9 non-critical recommendations and 18 gas optimizations.</p>\n<h1 id=\"scope\" style=\"position:relative;\"><a href=\"#scope\" aria-label=\"scope permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Scope</h1>\n<p>The code under review can be found within the <a href=\"https://github.com/code-423n4/2021-08-yield\">C4 Yield micro code contest repository</a> is comprised of 61 smart contracts written in the Solidity programming language and includes 4,115 lines of Solidity code.</p>\n<h1 id=\"severity-criteria\" style=\"position:relative;\"><a href=\"#severity-criteria\" aria-label=\"severity criteria permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Severity Criteria</h1>\n<p>C4 assesses the severity of disclosed vulnerabilities according to a methodology based on <a href=\"https://owasp.org/www-community/OWASP_Risk_Rating_Methodology\">OWASP standards</a>.</p>\n<p>Vulnerabilities are divided into three primary risk categories: high, medium, and low.</p>\n<p>High-level considerations for vulnerabilities span the following key areas when conducting assessments:</p>\n<ul>\n<li>Malicious Input Handling</li>\n<li>Escalation of privileges</li>\n<li>Arithmetic</li>\n<li>Gas use</li>\n</ul>\n<p>Further information regarding the severity criteria referenced throughout the submission review process, please refer to the documentation provided on <a href=\"https://code423n4.com\">the C4 website</a>.</p>\n<h1 id=\"high-risk-findings-5\" style=\"position:relative;\"><a href=\"#high-risk-findings-5\" aria-label=\"high risk findings 5 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>High Risk Findings (5)</h1>\n<h2 id=\"h-01-compositemultioracle-returns-wrong-decimals-for-prices\" style=\"position:relative;\"><a href=\"#h-01-compositemultioracle-returns-wrong-decimals-for-prices\" aria-label=\"h 01 compositemultioracle returns wrong decimals for prices permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/26\">[H-01] <code>CompositeMultiOracle</code> returns wrong decimals for prices?</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The <code>CompositeMultiOracle.peek/get</code> functions seem to return wrong prices.\nIt’s unclear what decimals <code>source.decimals</code> refers to in this case. Does it refer to <code>source.source</code> token decimals?</p>\n<p>It chains the price arguments through <code>_peek</code> function calls and a single price is computed as:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"0\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">(</span><span class=\"mtk12\">priceOut</span><span class=\"mtk1\">, </span><span class=\"mtk12\">updateTimeOut</span><span class=\"mtk1\">) = </span><span class=\"mtk11\">IOracle</span><span class=\"mtk1\">(</span><span class=\"mtk12\">source</span><span class=\"mtk1\">.</span><span class=\"mtk12\">source</span><span class=\"mtk1\">).</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">(</span><span class=\"mtk12\">base</span><span class=\"mtk1\">, </span><span class=\"mtk12\">quote</span><span class=\"mtk1\">, </span><span class=\"mtk7\">10</span><span class=\"mtk1\"> ** </span><span class=\"mtk12\">source</span><span class=\"mtk1\">.</span><span class=\"mtk12\">decimals</span><span class=\"mtk1\">);   </span><span class=\"mtk3\">// Get price for one unit</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// @audit shouldn&#39;t this divide by 10 ** IOracle(source.source).decimals() instead?</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">priceOut</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">priceIn</span><span class=\"mtk1\"> * </span><span class=\"mtk12\">priceOut</span><span class=\"mtk1\"> / (</span><span class=\"mtk7\">10</span><span class=\"mtk1\"> ** </span><span class=\"mtk12\">source</span><span class=\"mtk1\">.</span><span class=\"mtk12\">decimals</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p>Assume all oracles use 18 decimals (<code>oracle.decimals()</code> returns 18) and <code>source.decimals</code> refers to the <em>token decimals</em> of <code>source.source</code>.</p>\n<p>Then going from <code>USDC -> DAI -> USDT</code> (<code>path = [DAI]</code>) starts with a price of <code>1e18</code> in <code>peek</code>:</p>\n<ul>\n<li><code>_peek(USDC, DAI, 1e18)</code>: Gets the price of <code>1e6 USDC</code> (as USDC has 6 decimals) in DAI with 18 decimals precision (because all oracle precision is set to 18): <code>priceOut = priceIn * 1e18 / 1e6 = 1e18 * 1e18 / 1e6 = 1e30</code></li>\n<li><code>_peek(DAI, USDT, 1e30)</code>: Gets the price of <code>1e18 DAI</code> (DAI has 18 decimals) with 18 decimals precision: <code>priceOut = priceIn * 1e18 / 1e18 = priceIn = 1e30</code></li>\n</ul>\n<p>It then uses <code>1e30</code> as the price to go from <code>USDC</code> to <code>USDT</code>: <code>value = price * amount / 1e18 = 1e30 * (1.0 USDC) / 1e18 = 1e30 * 1e6 / 1e18 = 1e18 = 1e12 * 1e6 = 1_000_000_000_000.0 USDT</code>. Inflating the actual <code>USDT</code> amount.</p>\n<p>The issue is that <code>peek</code> assumes that the final price is in 18 decimals in the <code>value = price * amount / 1e18</code> division by <code>1e18</code>.\nBut <code>_peek</code> (and <code>_get</code>) don’t enforce this.</p>\n<p>Recommend that <code>_peek</code> should scale the prices to <code>1e18</code> by doing:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"1\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">(</span><span class=\"mtk12\">priceOut</span><span class=\"mtk1\">, </span><span class=\"mtk12\">updateTimeOut</span><span class=\"mtk1\">) = </span><span class=\"mtk11\">IOracle</span><span class=\"mtk1\">(</span><span class=\"mtk12\">source</span><span class=\"mtk1\">.</span><span class=\"mtk12\">source</span><span class=\"mtk1\">).</span><span class=\"mtk11\">get</span><span class=\"mtk1\">(</span><span class=\"mtk12\">base</span><span class=\"mtk1\">, </span><span class=\"mtk12\">quote</span><span class=\"mtk1\">, </span><span class=\"mtk7\">10</span><span class=\"mtk1\"> ** </span><span class=\"mtk12\">source</span><span class=\"mtk1\">.</span><span class=\"mtk12\">decimals</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// priceOut will have same decimals as priceIn if we divide by oracle decimals</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">priceOut</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">priceIn</span><span class=\"mtk1\"> * </span><span class=\"mtk12\">priceOut</span><span class=\"mtk1\"> / (</span><span class=\"mtk7\">10</span><span class=\"mtk1\"> ** </span><span class=\"mtk11\">IOracle</span><span class=\"mtk1\">(</span><span class=\"mtk12\">source</span><span class=\"mtk1\">.</span><span class=\"mtk12\">source</span><span class=\"mtk1\">).</span><span class=\"mtk11\">decimals</span><span class=\"mtk1\">());</span></span></span></code></pre>\n<p>It does not need to divide by the <code>source.source</code> <em>token precision</em> (<code>source.decimals</code>), but by the oracle precision (<code>IOracle(source.source).decimals()</code>).</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/26#issuecomment-898819530\">alcueca (Yield) acknowledged</a>:</strong></p>\n<blockquote>\n<p>It’s confusing to deal with all these decimals, I should at least comment the code better, and try to make it easier to understand.</p>\n<blockquote>\n<p>It’s unclear what decimals source.decimals refers to in this case. Does it refer to source.source token decimals?</p>\n</blockquote>\n<p>CompositeMultiOracle takes IOracle contracts as sources, so <code>source.decimals</code> refers to the token decimals of the oracle, not of the data source one level below.</p>\n<blockquote>\n<p>It does not need to divide by the source.source token precision (source.decimals), but by the oracle precision (IOracle(source.source).decimals()).</p>\n</blockquote>\n<p>The source.source token precision would be <code>IChainlinkAggregatorV3(source.source()).decimals()</code>, the source oracle precision is <code>source.decimals()</code>. CompositeMultiOracle cannot make an assumption on any fields present on <code>source.source</code>, and must  work only with the underlying <code>source</code> IOracles.</p>\n<p>I’m still not disputing this finding. I need to dig further to make sure the decimals are right when different IOracle sources have different decimals, and I’ve hardcoded a few <code>1e18</code> in there. Those are code smells.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/26#issuecomment-900850053\">alcueca (Yield) patched</a>:</strong></p>\n<blockquote>\n<p>Sent me into a wild goose chase to support IOracle of multiple decimals as sources to CompositeMultiOracle, only to realize that we create all IOracles and we always create them with 18 decimals, converting from the underlying data source if needed.</p>\n<p>Ended up making CompositeMultiOracle require that underlying oracles have 18 decimals. <a href=\"https://github.com/yieldprotocol/vault-v2/commit/621b680f893436f88f7668164b2942dbb94d1ca2\">Done</a>.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/26#issuecomment-900850053\">alcueca (Yield) further patched</a>:</strong></p>\n<blockquote>\n<p>Further <a href=\"https://github.com/yieldprotocol/vault-v2/pull/276\">refactored all oracles so that decimals are handled properly</a>, and work on taking an amount of base as input, and returning an amount of quote as output. Our oracles don’t have decimals themselves anymore as a state variable, since the return values are in the decimals of quote. This means that CompositeMultiOracle is agnostic with regards to decimals, and doesn’t even need to know about them.</p>\n</blockquote>\n<h2 id=\"h-02-erc20rewards-returns-wrong-rewards-if-no-tokens-initially-exist\" style=\"position:relative;\"><a href=\"#h-02-erc20rewards-returns-wrong-rewards-if-no-tokens-initially-exist\" aria-label=\"h 02 erc20rewards returns wrong rewards if no tokens initially exist permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/28\">[H-02] <code>ERC20Rewards</code> returns wrong rewards if no tokens initially exist</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The <code>ERC20Rewards._updateRewardsPerToken</code> function exits without updating <code>rewardsPerToken_.lastUpdated</code> if <code>totalSupply</code> is zero, i.e., if there are no tokens initially.</p>\n<p>This leads to an error if there is an active rewards period but no tokens have been minted yet.</p>\n<p><strong>Example:</strong> <code>rewardsPeriod.start: 1 month ago</code>, <code>rewardsPeriod.end: in 1 month</code>, <code>totalSupply == 0</code>.</p>\n<p>The first mint leads to the user (mintee) receiving all rewards for the past period (50% of the total rewards in this case).</p>\n<ul>\n<li><code>_mint</code> is called, calls <code>_updateRewardsPerToken</code> which short-circuits. <code>rewardsPerToken.lastUpdated</code> is still set to <code>rewardsPeriod.start</code> from the constructor. Then <code>_updateUserRewards</code> is called and does not currently yield any rewards. (because both balance and the index diff are zero). User has now minted the tokens, <code>totalSupply</code> increases and user balance is set.</li>\n<li>User performs a <code>claim</code>: <code>_updateRewardsPerToken</code> is called and <code>timeSinceLastUpdated = end - rewardsPerToken_.lastUpdated = block.timestamp - rewardsPeriod.start = 1 month</code>. Contract “issues” rewards for the past month. The first mintee receives all of it.</li>\n</ul>\n<p>The first mintee receives all pending rewards when they should not receive any past rewards.\nThis can easily happen if the token is new, the reward period has already been initialized and is running, but the protocol has not officially launched yet.\nNote that <code>setRewards</code> also allows setting a date in the past which would also be fatal in this case.</p>\n<p>Recommend that the <code>rewardsPerToken_.lastUpdated</code> field must always be updated in <code>_updateRewardsPerToken</code> to the current time (or <code>end</code>) even if <code>_totalSupply == 0</code>. Don’t return early.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/28#issuecomment-898824250\">alcueca (Yield) confirmed</a>:</strong></p>\n<blockquote>\n<p>You are right, that’s a great finding. For the record, I think that this is what <a href=\"https://github.com/k06a/Unipool/blob/bb1843b454bbb10b3b1ccf48edf5e72a80b2acfe/contracts/Unipool.sol#L70\">this line in Unipool.sol</a> does:</p>\n</blockquote>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"2\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">rewardPerToken</span><span class=\"mtk1\">() </span><span class=\"mtk11\">public</span><span class=\"mtk1\"> </span><span class=\"mtk11\">view</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk11\">totalSupply</span><span class=\"mtk1\">() == </span><span class=\"mtk7\">0</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk12\">rewardPerTokenStored</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  }</span></span></span></code></pre>\n<blockquote>\n<p>I’ll apply the mitigation step suggested, with a conditional to not do the <code>rewardsPerToken_.accumulated</code> math that would revert.</p>\n<p>Now I know the feeling of the devs that fork a known project and leave a pesky conditional out, thanks again :D</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/28#issuecomment-899370816\">alcueca (Yield) patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/yieldprotocol/yield-utils-v2/commit/d2ad343f40d375baf492131d9b1c7e288b5825d6\">Fix</a></p>\n</blockquote>\n<h2 id=\"h-03-erc20rewards-breaks-when-setting-a-different-token\" style=\"position:relative;\"><a href=\"#h-03-erc20rewards-breaks-when-setting-a-different-token\" aria-label=\"h 03 erc20rewards breaks when setting a different token permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/29\">[H-03] <code>ERC20Rewards</code> breaks when setting a different token</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The <code>setRewards</code> function allows setting a different token.\nHolders of a previous reward period cannot all be paid out and will receive <strong>their old reward amount</strong> in the new token.</p>\n<p>This leads to issues when the new token is more (less) valuable, or uses different decimals.</p>\n<p><strong>Example:</strong> Assume the first reward period paid out in <code>DAI</code> which has 18 decimals. Someone would have received <code>1.0 DAI = 1e18 DAI</code> if they called <code>claim</code> now. Instead, they wait until the new period starts with <code>USDC</code> (using only 6 decimals) and can <code>claim</code> their <code>1e18</code> reward amount in USDC which would equal <code>1e12 USDC</code>, one trillion USD.</p>\n<p>Changing the reward token only works if old and new tokens use the same decimals and have the exact same value. Otherwise, users that claim too late/early will lose out.</p>\n<p>Recommend disallowing changing the reward token, or clearing user’s pending rewards of the old token. The second approach requires more code changes and keeping track of what token a user last claimed.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/29#issuecomment-898821371\">alcueca (Yield) confirmed</a>:</strong></p>\n<blockquote>\n<p>Maybe I should have used stronger language:\n<code>// If changed in a new rewards program, any unclaimed rewards from the last one will be served in the new token</code></p>\n<p>The issue is known, but you are right in pointing it out. There are few situations in which changing the rewards token would make sense (such as replacing a faulty rewards token by a fixed one). I think it would be best to just disallow changing the token.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/29#issuecomment-899366677\">alcueca (Yield) patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/yieldprotocol/yield-utils-v2/commit/6df51f81a36e8f9b26b4946ac1aeda90eff6ffda\">Fix</a></p>\n</blockquote>\n<h2 id=\"h-04-rewards-accumulated-can-stay-constant-and-often-not-increment\" style=\"position:relative;\"><a href=\"#h-04-rewards-accumulated-can-stay-constant-and-often-not-increment\" aria-label=\"h 04 rewards accumulated can stay constant and often not increment permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/65\">[H-04] Rewards accumulated can stay constant and often not increment</a></h2>\n<p><em>Submitted by moose-code</em></p>\n<p><code>rewardsPerToken_.accumulated</code> can stay constant while <code>rewardsPerToken_.lastUpdated</code> is continually updated, leading to no actual rewards being distributed. I.e. No rewards accumulate.</p>\n<p>Line 115, <code>rewardsPerToken_.accumulated</code> could stay constant if there are very quick update intervals, a relatively low <code>rewardsPerToken_.rate</code> and a decent supply of the ERC20 token.</p>\n<p>I.e. imagine the token supply is 1 billion tokens (quite a common amount, note even if a supply of only say 1 million tokens this is still relevant). i.e. 1e27 wei.</p>\n<p>Line 115 has</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"3\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">1e18</span><span class=\"mtk1\"> * </span><span class=\"mtk12\">timeSinceLastUpdated</span><span class=\"mtk1\"> * </span><span class=\"mtk12\">rewardsPerToken_</span><span class=\"mtk1\">.</span><span class=\"mtk12\">rate</span><span class=\"mtk1\"> / </span><span class=\"mtk12\">_totalSupply</span></span></span></code></pre>\n<p><code>timeSinceLastUpdated</code> can be crafted to be arbitrarily small by simply transferring or burning tokens, so lets exclude this term (it could be 10 seconds etc). Imagine total supply is 1e27 as mentioned.</p>\n<p>Therefore, <code>1e18 * rewardsPerToken_.rate / 1e27</code>, which shows that if the <code>rewardsPerToken_.rate</code> is &#x3C; 1e9, something which is very likely, then the accumulated amount won’t increment, as there are no decimals in solidity and this line of code will evaluate to adding zero. While this is rounded down to zero, critically, <code>rewardsPerToken_.lastUpdated = end;</code> is updated.</p>\n<p>The reason I have labelled this as a high risk is the express purpose of this contract is to reward users with tokens, yet a user could potentially quite easily exploit this line to ensure no one ever gets rewards and the accumulated amount never increases.</p>\n<p>Given a fairly large token supply, and a relatively low emissions rate is set, that satisfies the above equation, for the entire duration of the rewards period, the user simply sends tokens back and forth every couple seconds (gas limitations, but layer 2), to keep the delta <code>timeSinceLastUpdated</code> close to 1.</p>\n<p>This way the accumulated amount will never tick up, but time keeps being counted.</p>\n<p>Furthermore, I would say this is high risk as this wouldn’t even need an attacker. Given the transfer function is likely often being called by users, <code>timeSinceLastUpdated</code> will naturally be very low anyways.</p>\n<p>Even if not so extreme as the above case, Alberto points out that “rounding can eat into the rewards” which is likely to be prevalent in the current scenario and make a big impact over time on the targeted vs actual distribution.</p>\n<p>Again, this problem is more likely to occur in naturally liquid tokens where lots of transfer, mint or burn events occur.</p>\n<p>As suggested by Alberto, the simplest it to probably not update the <code>rewardsPerToken_.lastUpdated</code> field if <code>rewardsPerToken_.accumulated</code> does not change. Although this change should be closely scrutinized to see it doesn’t introduce bugs elsewhere.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/65#issuecomment-900485268\">alcueca (Yield) acknowledged and disagreed with severity</a>:</strong></p>\n<blockquote>\n<p>While the issue exists, it’s not as severe as portrayed, and doesn’t need fixing.</p>\n<p>There is an error in the assessment, and it is that the <code>rate</code> refers to the rewards amount distributed per second among all token holders. It is not the rewards amount distributed per token per second (that’s dynamically calculated).</p>\n<p>Also, it needs to be taken into account that <code>rewardsPerToken.accumulated</code> is stored scaled up by 1e18, to avoid losing much ground to rounding.</p>\n</blockquote>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"4\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">struct</span><span class=\"mtk1\"> </span><span class=\"mtk12\">RewardsPerToken</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">uint128</span><span class=\"mtk1\"> </span><span class=\"mtk12\">accumulated</span><span class=\"mtk1\">;                            </span><span class=\"mtk3\">// Accumulated rewards per token for the period, scaled up by 1e18</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">uint32</span><span class=\"mtk1\"> </span><span class=\"mtk12\">lastUpdated</span><span class=\"mtk1\">;                             </span><span class=\"mtk3\">// Last time the rewards per token accumulator was updated</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">uint96</span><span class=\"mtk1\"> </span><span class=\"mtk12\">rate</span><span class=\"mtk1\">;                                    </span><span class=\"mtk3\">// Wei rewarded per second among all token holders</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<blockquote>\n<p>One of the largest cap tokens is Dai, with a distribution close to 1e28.\nIf ERC20Rewards were to distribute 1 cent/second among all token holders (which wouldn’t be very exciting), and block times were of 1 second, the accumulator would still accumulate.</p>\n<p><code>accumulator += 1e18 (scaling) * 1 (seconds per block) * 1e16 (Dai wei / second) / 1e28 (Dai total supply)</code>\nThe increase to the <code>accumulator</code> is of 1e6, which gives plenty of precision. I would expect a rewards program on Dai holders would be at least 1e6 larger per second.</p>\n<p>On the other hand, <code>accumulator</code> is an <code>uint128</code>, which holds amounts of up to 1e38. To overflow it we would need a low cap token (let’s say USDC, with 1e15), and a high distribution (1e12 per second, which is unreal), and we run the program for 3 years, or 1e9, to make it easy.</p>\n<p>The accumulator at the end of the ten years would be:\n<code>accumulator = 1e18 (scaling) * 1e9 (seconds) * 1e12 (distribution) / 1e15 (supply) = 1e24</code>\nWhich doesn’t overflow.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/65#issuecomment-913864410\">ghoul-sol (judge) commented</a>:</strong></p>\n<blockquote>\n<p>I’ll keep high risk as there should be no scenario where the math breaks.</p>\n</blockquote>\n<h2 id=\"h-05-exchange-rates-from-compound-are-assumed-with-18-decimals\" style=\"position:relative;\"><a href=\"#h-05-exchange-rates-from-compound-are-assumed-with-18-decimals\" aria-label=\"h 05 exchange rates from compound are assumed with 18 decimals permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/38\">[H-05] Exchange rates from Compound are assumed with 18 decimals</a></h2>\n<p><em>Submitted by shw</em></p>\n<p>The <code>CTokenMultiOracle</code> contract assumes the exchange rates (borrowing rate) of Compound always have 18 decimals, while, however, which is not true. According to the <a href=\"https://compound.finance/docs/ctokens#exchange-rate\">Compound documentation</a>, the exchange rate returned from the <code>exchangeRateCurrent</code> function is scaled by <code>1 * 10^(18 - 8 + Underlying Token Decimals)</code> (and so does <code>exchangeRateStored</code>). Using a wrong decimal number on the exchange rate could cause incorrect pricing on tokens. See <a href=\"https://github.com/code-423n4/2021-08-yield/blob/main/contracts/oracles/compound/CTokenMultiOracle.sol#L110\"><code>CTokenMultiOracle.sol</code> #L110</a>.</p>\n<p>Recommend following the documentation and getting the decimals of the underlying tokens to set the correct decimal of a <code>Source</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/38#issuecomment-899063337\">alcueca (Yield) confirmed</a>:</strong></p>\n<blockquote>\n<p>Thanks a lot for coming up with this. I had looked into how Compound defined the decimals and couldn’t find it.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/38#issuecomment-901201555\">alcueca (Yield) patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/yieldprotocol/vault-v2/commit/e9c1ee5532c946e9ab2fc8912039829e190fbb64\">Fix</a></p>\n</blockquote>\n<h1 id=\"medium-risk-findings-4\" style=\"position:relative;\"><a href=\"#medium-risk-findings-4\" aria-label=\"medium risk findings 4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Medium Risk Findings (4)</h1>\n<h2 id=\"m-01-no-erc20-safe-versions-called\" style=\"position:relative;\"><a href=\"#m-01-no-erc20-safe-versions-called\" aria-label=\"m 01 no erc20 safe versions called permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/31\">[M-01] No ERC20 safe* versions called</a></h2>\n<p><em>Submitted by cmichel, also found by JMukesh and hickuphh3</em></p>\n<p>The <code>claim</code> function performs an ERC20 transfer <code>rewardsToken.transfer(to, claiming);</code> but does not check the return value, nor does it work with all legacy tokens.</p>\n<p>Some tokens (like USDT) don’t correctly implement the EIP20 standard and their <code>transfer</code>/<code>transferFrom</code> function return <code>void</code> instead of a success boolean. Calling these functions with the correct EIP20 function signatures will always revert.</p>\n<p>The <code>ERC20.transfer()</code> and <code>ERC20.transferFrom()</code> functions return a boolean value indicating success. This parameter needs to be checked for success.\nSome tokens do <strong>not</strong> revert if the transfer failed but return <code>false</code> instead.</p>\n<p>Tokens that don’t actually perform the transfer and return <code>false</code> are still counted as a correct transfer and tokens that don’t correctly implement the latest EIP20 spec, like USDT, will be unusable in the protocol as they revert the transaction because of the missing return value.</p>\n<p>Recommend using OpenZeppelin’s <code>SafeERC20</code> versions with the <code>safeTransfer</code> and <code>safeTransferFrom</code> functions that handle the return value check as well as non-standard-compliant tokens.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/31#issuecomment-898826857\">alcueca (Yield) confirmed</a>:</strong></p>\n<blockquote>\n<p>True, thanks for spotting it!</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/31#issuecomment-899365841\">alcueca (Yield) patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/yieldprotocol/yield-utils-v2/commit/3715140ab7d6fbde593257c7542a661bc9191d8c\">Fix</a></p>\n</blockquote>\n<h2 id=\"m-02-timelock-cannot-schedule-the-same-calls-multiple-times\" style=\"position:relative;\"><a href=\"#m-02-timelock-cannot-schedule-the-same-calls-multiple-times\" aria-label=\"m 02 timelock cannot schedule the same calls multiple times permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/27\">[M-02] <code>TimeLock</code> cannot schedule the same calls multiple times</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The <code>TimeLock.schedule</code> function reverts if the same <code>targets</code> and <code>data</code> fields are used as the <code>txHash</code> will be the same.\nThis means one cannot schedule the same transactions multiple times.</p>\n<p>Imagine the delay is set to 30 days, but a contractor needs to be paid every 2 weeks. One needs to wait 30 days before scheduling the second payment to them.</p>\n<p>Recommend also including <code>eta</code> in the hash. (Compound’s <code>Timelock</code> does it as well.) This way the same transaction data can be used by specifying a different <code>eta</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/27#issuecomment-898830142\">alcueca (Yield) confirmed</a>:</strong></p>\n<blockquote>\n<p>Funny, <a href=\"https://twitter.com/Boring_Crypto/status/1425401221091762189\">BoringCrypto was quite negative about including the eta in the txHash</a>. At the time I couldn’t think of a reason to repeat the same call with the same data, but you are right that sometimes it might make sense, and storing off-chain the expected eta of each timelocked transaction is something you should do anyway.</p>\n<p>I’ll confirm this issue, and will bring it for public discussion once the contest is over.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/27#issuecomment-921487023\">alcueca (Yield) patched</a>:</strong></p>\n<blockquote>\n<p>I ended up <a href=\"https://github.com/yieldprotocol/yield-utils-v2/blob/main/contracts/utils/Timelock.sol\">refactoring the Timelock</a> so that the eta is not included in the parameters, but repeated proposals are allowed.</p>\n</blockquote>\n<h2 id=\"m-03-rewards-squatting---setting-rewards-in-different-erc20-tokens-opens-various-economic-attacks-\" style=\"position:relative;\"><a href=\"#m-03-rewards-squatting---setting-rewards-in-different-erc20-tokens-opens-various-economic-attacks-\" aria-label=\"m 03 rewards squatting   setting rewards in different erc20 tokens opens various economic attacks  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/64\">[M-03] Rewards squatting - setting rewards in different ERC20 tokens opens various economic attacks. </a></h2>\n<p><em>Submitted by moose-code, also found by hickuphh3</em></p>\n<p>Users essentially have an option to either claim currently earned reward amounts on future rewards tokens, or the current rewards token.</p>\n<p>Although stated on line 84, it does not take into account the implications the lock in this contract will have on the future value of new tokens able to be issued via rewards.</p>\n<p>Smart users will monitor the mempool for <code>setRewards</code> transactions. If the new reward token (token b) is less valuable than the old reward token (token a), they can  front run this transaction by calling claim. Otherwise, they let their accrued ‘token a’ roll into rewards of of the more valuable ‘token b’.</p>\n<p>Given loads of users will likely hold these tokens from day 1, there will potentially be thousands of different addresses squatting on rewards.</p>\n<p>Economically, and given the above, it makes sense that the value of new reward tokens, i.e. ‘token b’ should always be less than that of ‘token a’. This is undesirable in a rewards token contract, as there is no reliable way to start issuing a more valuable token at a later stage, unless exposing yourself to a major risk of reward squatting.</p>\n<p>i.e. You could not issue a more valuable token in future (for example, if we wanted to run a rewards period issuing an asset like WETH rewards for 10 days) after first initially issuing DAI as a reward. This hamstrings flexibility of the contract.</p>\n<p>P.s. This is one of the slickest contracts I’ve read. Love how awesome it is.Just believe this should be fixed, then its good to go.</p>\n<p>It is true you could probably write a script to manually go call <code>claim</code> on thousands of squatting token addresses but this is a poor solution.</p>\n<p>Recommend instead, that a simple mapping pattern could be used with an index mapping to a reward cycle with a reward token and a new accumulative etc. Users would likely need to be given a period a to claim from old reward cycles before their token balance could no longer reliably used to calculate past rewards. The would still be able to claim everything up until their last action (even though this may be before the rewards cycle ended).</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/64#issuecomment-899068756\">alcueca (Yield) confirmed</a>:</strong></p>\n<blockquote>\n<p>Thanks! I agree that allowing to change the rewards token is just too troublesome.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/64#issuecomment-899270061\">alcueca (Yield) patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/yieldprotocol/yield-utils-v2/commit/6df51f81a36e8f9b26b4946ac1aeda90eff6ffda\">Fix</a></p>\n</blockquote>\n<h2 id=\"m-04-use-safetransfer-instead-of-transfer\" style=\"position:relative;\"><a href=\"#m-04-use-safetransfer-instead-of-transfer\" aria-label=\"m 04 use safetransfer instead of transfer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/36\">[M-04] Use <code>safeTransfer</code> instead of <code>transfer</code></a></h2>\n<p><em>Submitted by shw</em></p>\n<p>Tokens not compliant with the ERC20 specification could return <code>false</code> from the <code>transfer</code> function call to indicate the transfer fails, while the calling contract would not notice the failure if the return value is not checked. Checking the return value is a requirement, as written in the <a href=\"https://eips.ethereum.org/EIPS/eip-20\">EIP-20</a> specification:</p>\n<blockquote>\n<p>Callers MUST handle <code>false</code> from <code>returns (bool success)</code>. Callers MUST NOT assume that <code>false</code> is never returned!</p>\n</blockquote>\n<p>See <a href=\"https://github.com/code-423n4/2021-08-yield/blob/main/contracts/utils/token/ERC20Rewards.sol#L175\">ERC20Rewards.sol L175</a>.</p>\n<p>Recommend using the <code>SafeERC20</code> library <a href=\"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol\">implementation</a> from OpenZeppelin and calling <code>safeTransfer</code> or <code>safeTransferFrom</code> when transferring ERC20 tokens.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/36#issuecomment-899365631\">alcueca (Yield) confirmed and patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/yieldprotocol/yield-utils-v2/commit/3715140ab7d6fbde593257c7542a661bc9191d8c\">Fix</a></p>\n</blockquote>\n<h1 id=\"low-risk-findings-12\" style=\"position:relative;\"><a href=\"#low-risk-findings-12\" aria-label=\"low risk findings 12 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Low Risk Findings (12)</h1>\n<h2 id=\"l-01-updatetime-of-get-is-0\" style=\"position:relative;\"><a href=\"#l-01-updatetime-of-get-is-0\" aria-label=\"l 01 updatetime of get is 0 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/7\">[L-01] <code>updateTime</code> of get is 0</a></h2>\n<p><em>Submitted by gpersoon, also found by shw</em></p>\n<p>In function <code>_get</code> of <code>CompositeMultiOracle</code> the <code>updateTime</code> is not initialized, so it will be 0.</p>\n<p>Function <code>_get</code> has the following statement:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"5\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">   </span><span class=\"mtk12\">updateTimeOut</span><span class=\"mtk1\"> = (</span><span class=\"mtk12\">updateTimeOut</span><span class=\"mtk1\"> &lt; </span><span class=\"mtk12\">updateTimeIn</span><span class=\"mtk1\">) ? </span><span class=\"mtk12\">updateTimeOut</span><span class=\"mtk1\"> : </span><span class=\"mtk12\">updateTimeIn</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">updateTimeIn</span><span class=\"mtk1\"> ==</span><span class=\"mtk7\">0</span><span class=\"mtk1\"> ==&gt;  (</span><span class=\"mtk12\">updateTimeOut</span><span class=\"mtk1\"> &lt; </span><span class=\"mtk12\">updateTimeIn</span><span class=\"mtk1\">)== </span><span class=\"mtk4\">false</span><span class=\"mtk1\"> ==&gt; </span><span class=\"mtk12\">result</span><span class=\"mtk1\"> </span><span class=\"mtk4\">of</span><span class=\"mtk1\"> </span><span class=\"mtk12\">the</span><span class=\"mtk1\"> </span><span class=\"mtk12\">expression</span><span class=\"mtk1\"> </span><span class=\"mtk12\">is</span><span class=\"mtk1\"> </span><span class=\"mtk12\">updateTimeIn</span><span class=\"mtk1\"> == </span><span class=\"mtk7\">0</span><span class=\"mtk1\"> ==&gt; </span><span class=\"mtk12\">updateTimeOut</span><span class=\"mtk1\"> =</span><span class=\"mtk7\">0</span></span></span></code></pre>\n<p>So this means the function get will always return <code>updateTime==0</code></p>\n<p>The <code>updateTime</code> result of the function <code>get</code> doesn’t seem to be used in the code so the risk is low. If would only be relevant for future code updates.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"6\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"94\"></span><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"95\"></span><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">get</span><span class=\"mtk1\">(</span><span class=\"mtk12\">bytes32</span><span class=\"mtk1\"> </span><span class=\"mtk12\">base</span><span class=\"mtk1\">, </span><span class=\"mtk12\">bytes32</span><span class=\"mtk1\"> </span><span class=\"mtk12\">quote</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">amount</span><span class=\"mtk1\">)  </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">virtual</span><span class=\"mtk1\"> </span><span class=\"mtk11\">override</span><span class=\"mtk1\">  </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">value</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">updateTime</span><span class=\"mtk1\">)  {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"96\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"97\"></span><span class=\"grvsc-source\"><span class=\"mtk15\">for</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">p</span><span class=\"mtk1\"> = </span><span class=\"mtk7\">0</span><span class=\"mtk1\">; </span><span class=\"mtk12\">p</span><span class=\"mtk1\"> &lt; </span><span class=\"mtk12\">path</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span><span class=\"mtk1\">; </span><span class=\"mtk12\">p</span><span class=\"mtk1\">++) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"98\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">  (</span><span class=\"mtk12\">price</span><span class=\"mtk1\">, </span><span class=\"mtk12\">updateTime</span><span class=\"mtk1\">) = </span><span class=\"mtk11\">_get</span><span class=\"mtk1\">(</span><span class=\"mtk12\">base_</span><span class=\"mtk1\">, </span><span class=\"mtk12\">path</span><span class=\"mtk1\">[</span><span class=\"mtk12\">p</span><span class=\"mtk1\">], </span><span class=\"mtk12\">price</span><span class=\"mtk1\">, </span><span class=\"mtk12\">updateTime</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"99\"></span><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"100\"></span><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">_get</span><span class=\"mtk1\">(</span><span class=\"mtk12\">bytes6</span><span class=\"mtk1\"> </span><span class=\"mtk12\">base</span><span class=\"mtk1\">, </span><span class=\"mtk12\">bytes6</span><span class=\"mtk1\"> </span><span class=\"mtk12\">quote</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">priceIn</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">updateTimeIn</span><span class=\"mtk1\">)  </span><span class=\"mtk11\">private</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">priceOut</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">updateTimeOut</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"101\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"102\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">  (</span><span class=\"mtk12\">priceOut</span><span class=\"mtk1\">, </span><span class=\"mtk12\">updateTimeOut</span><span class=\"mtk1\">) = </span><span class=\"mtk11\">IOracle</span><span class=\"mtk1\">(</span><span class=\"mtk12\">source</span><span class=\"mtk1\">.</span><span class=\"mtk12\">source</span><span class=\"mtk1\">).</span><span class=\"mtk11\">get</span><span class=\"mtk1\">(</span><span class=\"mtk12\">base</span><span class=\"mtk1\">, </span><span class=\"mtk12\">quote</span><span class=\"mtk1\">, </span><span class=\"mtk7\">10</span><span class=\"mtk1\"> ** </span><span class=\"mtk12\">source</span><span class=\"mtk1\">.</span><span class=\"mtk12\">decimals</span><span class=\"mtk1\">);    </span><span class=\"mtk3\">// Get price for one unit</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"103\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">  ...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"104\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">updateTimeOut</span><span class=\"mtk1\"> = (</span><span class=\"mtk12\">updateTimeOut</span><span class=\"mtk1\"> &lt; </span><span class=\"mtk12\">updateTimeIn</span><span class=\"mtk1\">) ? </span><span class=\"mtk12\">updateTimeOut</span><span class=\"mtk1\"> : </span><span class=\"mtk12\">updateTimeIn</span><span class=\"mtk1\">;                 </span><span class=\"mtk3\">// Take the oldest update time</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"105\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p>Recommend adding the following in the beginning of the <code>_get</code> function:\n<code>updateTime = block.timestamp;</code></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/7#issuecomment-900516054\">alcueca (Yield) confirmed and patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/yieldprotocol/vault-v2/commit/a24ea994ba169469f7db661e1436dad43af40653\">Fix</a></p>\n</blockquote>\n<h2 id=\"l-02-different-definition-of-beforematurity-and-aftermaturity-modifier-in-different-file\" style=\"position:relative;\"><a href=\"#l-02-different-definition-of-beforematurity-and-aftermaturity-modifier-in-different-file\" aria-label=\"l 02 different definition of beforematurity and aftermaturity modifier in different file permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/18\">[L-02] Different definition of <code>beforeMaturity()</code> and <code>afterMaturity()</code> modifier in different file</a></h2>\n<p><em>Submitted by JMukesh</em></p>\n<p>Different definition of <code>beforeMaturity()</code> and <code>afterMaturity()</code> modifier in <a href=\"https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L82\"><code>Strategy.sol</code> L82</a> and <a href=\"https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/FYToken.sol#L65\"><code>FYToken.sol</code> L65</a> which used <code>FYTokenFacory()</code>. See issue page for further elaboration.</p>\n<p>See issue page for more.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/18#issuecomment-898830802\">alcueca (Yield) disagreed with severity</a>:</strong></p>\n<blockquote>\n<p>It is right that there is a different definition of before and after maturity, and that Strategy.sol should match FYToken.sol, same as Pool.sol does.</p>\n<p>However, there is no impact from this issue. The only thing that could happen is that an user <code>mint</code> strategy tokens on an already matured pool, which is harmless.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/18#issuecomment-899435473\">alcueca (Yield) patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/yieldprotocol/strategy-v2/commit/2b10fc35d51b5e1edd233e5969ce0296994cd863\">Fix</a></p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/18#issuecomment-913864941\">ghoul-sol (judge) commented</a>:</strong></p>\n<blockquote>\n<p>per sponsor comment, making this low risk</p>\n</blockquote>\n<h2 id=\"l-03-missing-input-validation-to-check-that-end--start\" style=\"position:relative;\"><a href=\"#l-03-missing-input-validation-to-check-that-end--start\" aria-label=\"l 03 missing input validation to check that end  start permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/49\">[L-03] Missing input validation to check that <code>end</code> > <code>start</code></a></h2>\n<p><em>Submitted by 0xRajeev</em></p>\n<p><code>setRewards()</code> is missing input validation on parameters <code>start</code> and <code>end</code> to check if <code>end</code> > <code>start</code>. If accidentally set incorrectly, this will allow resetting new rewards while there is an ongoing one (<a href=\"https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L74-L88\"><code>ERC20Rewards.sol#L74</code> L88</a>).</p>\n<p>Recommend adding a <code>require()</code> to check that <code>end</code> > <code>start</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/49#issuecomment-899066375\">alcueca (Yield) confirmed</a>:</strong></p>\n<blockquote>\n<blockquote>\n<p>If accidentally set incorrectly, this will allow resetting new rewards while there is an ongoing one.</p>\n</blockquote>\n<p>I would say that if we set it incorrectly, we would like to reset it as soon as possible :)</p>\n<p>Still, a good check to add, since otherwise it leads to strange behaviour.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/49#issuecomment-899275404\">alcueca (Yield) patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/yieldprotocol/yield-utils-v2/commit/71f1e761f1a492954971bb5a9b1209ea1cc9d294\">Fix</a></p>\n</blockquote>\n<h2 id=\"l-04-upgrading-solc-compiler-version-may-help-with-bug-fixes\" style=\"position:relative;\"><a href=\"#l-04-upgrading-solc-compiler-version-may-help-with-bug-fixes\" aria-label=\"l 04 upgrading solc compiler version may help with bug fixes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/50\">[L-04] Upgrading solc compiler version may help with bug fixes</a></h2>\n<p><em>Submitted by 0xRajeev</em></p>\n<p>solc version 0.8.3 and 0.8.4 fixed important bugs in the compiler. Using version 0.8.1 misses these fixes and may cause a vulnerability.</p>\n<p>See <a href=\"https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L2\"><code>ERC20Rewards.sol</code> L2</a>.\n<a href=\"https://github.com/ethereum/solidity/releases/tag/v0.8.4\">Solidity 0.8.4</a> fixes a bug in the ABI decoder. The release contains an important bugfix. See decoding from memory bug blog post for more details.</p>\n<p><a href=\"https://github.com/ethereum/solidity/releases/tag/v0.8.3\">Solidity 0.8.3</a> is a bugfix release that fixes an important bug about how the optimizer handles the Keccak256 opcode. For details on the bug, please see the bug blog post.</p>\n<p>Recommend considering upgrading to 0.8.3 or 0.8.4.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/50#issuecomment-901222844\">alcueca (Yield) confirmed and patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/yieldprotocol/vault-v2/commit/deb13c92511585cda8afe52150bdde637ffa2526\">Fix</a>, <a href=\"https://github.com/yieldprotocol/yieldspace-v2/pull/129/commits/7d4f60a7726e60b782ad414cc6d6deeebfea1cae\">fix</a>, and <a href=\"https://github.com/yieldprotocol/strategy-v2/commit/5c0c0e4d9e73c8665ec61c1cc08a55e6db640a8e\">fix</a>.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/50#issuecomment-901236905\">alcueca (Yield) commented</a>:</strong></p>\n<blockquote>\n<p>I might actually revert the fixes, unless we are affected by the bug fixes. Using solc 0.8.6 forces us to drop the optimizer from 20000 to 5000.</p>\n</blockquote>\n<h2 id=\"l-05-missing-emits-for-events\" style=\"position:relative;\"><a href=\"#l-05-missing-emits-for-events\" aria-label=\"l 05 missing emits for events permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/51\">[L-05] Missing emits for events</a></h2>\n<p><em>Submitted by 0xRajeev, also found by cmichel</em></p>\n<p>Few events are missing emits which prevents the intended data from being observed easily by off-chain interfaces (<a href=\"https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L48-L49\"><code>Strategy.sol#L48</code> L49</a>).</p>\n<p>Recommend adding emits or remove event declarations.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/51#issuecomment-899436418\">alcueca (Yield) confirmed and patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/yieldprotocol/strategy-v2/commit/e22386827fd01ee01396ef366131080d1834b37b\">Fix</a></p>\n</blockquote>\n<h2 id=\"l-06-unused-cauldron_-parameter\" style=\"position:relative;\"><a href=\"#l-06-unused-cauldron_-parameter\" aria-label=\"l 06 unused cauldron_ parameter permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/54\">[L-06] Unused <code>cauldron_</code> parameter</a></h2>\n<p><em>Submitted by 0xRajeev</em></p>\n<p>That <code>cauldron_</code> parameter is not used here and <code>ladle_.cauldron()</code> is used instead. The <code>Ladle</code> constructor initializes its cauldron value and so the only way this could differ from the parameter is if the argument to this function is specified incorrectly. See issue page for referenced code.</p>\n<p>Recommend either using parameter, or remove it in favor of the value from <code>ladle_.cauldron()</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/54#issuecomment-899436210\">alcueca (Yield) confirmed and patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/yieldprotocol/strategy-v2/commit/aca5465c714226b07a05ad1dc65e0110b93d6a23\">Fix</a></p>\n</blockquote>\n<h2 id=\"l-07-missing-check-for-contract-existence\" style=\"position:relative;\"><a href=\"#l-07-missing-check-for-contract-existence\" aria-label=\"l 07 missing check for contract existence permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/55\">[L-07] Missing check for contract existence</a></h2>\n<p>Low-level call returns success even if the contract is non-existent. This requires a contract existence check before making the low-level call (<a href=\"https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/TimeLock.sol#L93\"><code>TimeLock.sol</code> L93</a>).</p>\n<p>See: “The low-level functions call, <code>delegatecall</code> and <code>staticcall</code> return true as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed.” from <a href=\"https://docs.soliditylang.org/en/v0.8.7/control-structures.html#error-handling-assert-require-revert-and-exceptions\">https://docs.soliditylang.org/en/v0.8.7/control-structures.html#error-handling-assert-require-revert-and-exceptions</a></p>\n<p>Recommend checking for target contract existence before call.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/55#issuecomment-899067175\">alcueca (Yield) confirmed</a>:</strong></p>\n<blockquote>\n<p>Mmm, we do this in several other places in the codebase, as well as others do in earlier implementations. Will fix.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/55#issuecomment-899380013\">alcueca (Yield) patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/yieldprotocol/yield-utils-v2/commit/15be6d4a9c681780d0af3b72b2498f3967b5cd26\">Fix</a></p>\n</blockquote>\n<h2 id=\"l-08-_peek-does-not-work-for-tokens-with--18-decimals\" style=\"position:relative;\"><a href=\"#l-08-_peek-does-not-work-for-tokens-with--18-decimals\" aria-label=\"l 08 _peek does not work for tokens with  18 decimals permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/23\">[L-08] <code>_peek</code> does not work for tokens with > 18 decimals</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The <code>CTokenMultiOracle._peek/_get</code> function does the following computation on unsigned integers which reverts when <code>source.decimals > 18</code>:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"7\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">price</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">uint</span><span class=\"mtk1\">(</span><span class=\"mtk12\">rawPrice</span><span class=\"mtk1\">) * </span><span class=\"mtk7\">10</span><span class=\"mtk1\"> ** (</span><span class=\"mtk7\">18</span><span class=\"mtk1\"> - </span><span class=\"mtk12\">source</span><span class=\"mtk1\">.</span><span class=\"mtk12\">decimals</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p>Recommend instead performing this <code>price = uint(rawPrice) * 10 ** 18 / 10 ** source.decimals;</code>.\nNote that this leads to a loss of precision and the price could end up being <code>0</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/23#issuecomment-901202463\">alcueca (Yield) acknowledged and patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/yieldprotocol/vault-v2/commit/e9c1ee5532c946e9ab2fc8912039829e190fbb64\">Fix</a></p>\n</blockquote>\n<h2 id=\"l-09-erc20rewards-claiming-can-fail-if-no-reward-tokens\" style=\"position:relative;\"><a href=\"#l-09-erc20rewards-claiming-can-fail-if-no-reward-tokens\" aria-label=\"l 09 erc20rewards claiming can fail if no reward tokens permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/30\">[L-09] <code>ERC20Rewards</code> claiming can fail if no reward tokens</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The <code>ERC20Rewards</code> contract assumes that enough <code>rewardsToken</code> are in the contract to pay out when <code>claim</code> is called but this value is never checked and claiming rewards can fail.</p>\n<p>Recommend that, when setting new rewards periods, to make sure that enough <code>rewardsToken</code>s are in the contract to cover the entire period.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/30#issuecomment-898828516\">alcueca (Yield) acknowledged</a>:</strong></p>\n<blockquote>\n<p>This is a known issue, which we prefer to leave as it is.</p>\n<p>Users can check if there are rewards tokens in the contract to cover the whole period, if they wish. ERC20Rewards.sol is intended to be inherited, so it depends on the implementation of the child contract whether that user check (or the proposed mitigation) could be trusted.</p>\n<p>In our intended use of ERC20Rewards, it is a governance action to make sure that there are funds to cover rewards at all times, which is easy to do since they are evenly distributed over time.</p>\n</blockquote>\n<h2 id=\"l-10-improve-safety-of-role-constants-\" style=\"position:relative;\"><a href=\"#l-10-improve-safety-of-role-constants-\" aria-label=\"l 10 improve safety of role constants  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/9\">[L-10] improve safety of role constants </a></h2>\n<p><em>Submitted by gpersoon</em></p>\n<p>The contract <code>Wand</code> defines a few role constants with <code>bytes4(keccak256(\"...function...\"))</code>\nHowever if the function template would change slightly, for example when <code>uint128</code> is replaced by <code>uint256</code>, then this construction isn’t valid anymore.</p>\n<p>It is safer to use the function selector, as is done in <a href=\"https://github.com/code-423n4/2021-08-yield/blob/main/contracts/Wand.sol#L27\"><code>EmergencyBrake.sol</code></a></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"8\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">bytes4</span><span class=\"mtk1\"> </span><span class=\"mtk12\">public</span><span class=\"mtk1\"> </span><span class=\"mtk12\">constant</span><span class=\"mtk1\"> </span><span class=\"mtk12\">JOIN</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">bytes4</span><span class=\"mtk1\">(</span><span class=\"mtk11\">keccak256</span><span class=\"mtk1\">(</span><span class=\"mtk8\">&quot;join(address,uint128)&quot;</span><span class=\"mtk1\">));</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">bytes4</span><span class=\"mtk1\"> </span><span class=\"mtk12\">public</span><span class=\"mtk1\"> </span><span class=\"mtk12\">constant</span><span class=\"mtk1\"> </span><span class=\"mtk12\">EXIT</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">bytes4</span><span class=\"mtk1\">(</span><span class=\"mtk11\">keccak256</span><span class=\"mtk1\">(</span><span class=\"mtk8\">&quot;exit(address,uint128)&quot;</span><span class=\"mtk1\">));</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">bytes4</span><span class=\"mtk1\"> </span><span class=\"mtk12\">public</span><span class=\"mtk1\"> </span><span class=\"mtk12\">constant</span><span class=\"mtk1\"> </span><span class=\"mtk12\">MINT</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">bytes4</span><span class=\"mtk1\">(</span><span class=\"mtk11\">keccak256</span><span class=\"mtk1\">(</span><span class=\"mtk8\">&quot;mint(address,uint256)&quot;</span><span class=\"mtk1\">));</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">bytes4</span><span class=\"mtk1\"> </span><span class=\"mtk12\">public</span><span class=\"mtk1\"> </span><span class=\"mtk12\">constant</span><span class=\"mtk1\"> </span><span class=\"mtk12\">BURN</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">bytes4</span><span class=\"mtk1\">(</span><span class=\"mtk11\">keccak256</span><span class=\"mtk1\">(</span><span class=\"mtk8\">&quot;burn(address,uint256)&quot;</span><span class=\"mtk1\">));</span></span></span></code></pre>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"9\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"35\"></span><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-gutter-pad\"></span><span class=\"grvsc-gutter grvsc-line-number\" aria-hidden=\"true\" data-content=\"36\"></span><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk11\">_grantRole</span><span class=\"mtk1\">(</span><span class=\"mtk12\">IEmergencyBrake</span><span class=\"mtk1\">.</span><span class=\"mtk12\">plan</span><span class=\"mtk1\">.</span><span class=\"mtk12\">selector</span><span class=\"mtk1\">, </span><span class=\"mtk12\">planner</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p>Recommend using function selectors in <code>Wand.sol</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/9#issuecomment-899463822\">alcueca (Yield) confirmed and patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/yieldprotocol/vault-v2/commit/012b621ba0ff56dab795bd62833124220a7b070c\">Fix</a></p>\n</blockquote>\n<h2 id=\"l-11-emergencybrakesol-permissions-cannot-be-re-planned-after-termination\" style=\"position:relative;\"><a href=\"#l-11-emergencybrakesol-permissions-cannot-be-re-planned-after-termination\" aria-label=\"l 11 emergencybrakesol permissions cannot be re planned after termination permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/21\">[L-11] <code>EmergencyBrake.sol</code>: Permissions cannot be re-planned after termination</a></h2>\n<p><em>Submitted by hickuphh3</em></p>\n<p>Given a configuration of target, contacts, and permissions, calling <code>terminate()</code>, will permanently prevent this configuration from being used again because the state becomes <code>State.TERMINATED</code>. All other functions require the configuration to be in the other states (UNKNOWN, PLANNED, or EXECUTED).</p>\n<p>In other words, the removal of the restoring option for the configuration through <code>EmergencyBrake</code> is permanent.</p>\n<p>Recommend that, since <code>EmergencyBrake</code> cannot reinstate permissions after termination, it would be better to have terminate change its state to UNKNOWN. The TERMINATED state can therefore be removed.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/21#issuecomment-898846397\">alcueca (Yield) confirmed</a>:</strong></p>\n<blockquote>\n<p>That’s right.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/21#issuecomment-899399553\">alcueca (Yield) patched</a>:</strong></p>\n<blockquote>\n<p><a href=\"https://github.com/yieldprotocol/yield-utils-v2/commit/d7e814d63467600c9ca379abf57e194561c7078d\">Fix</a></p>\n</blockquote>\n<h2 id=\"l-12-erc20rewardssol-have-a-method-to-calculate-the-latest-rewardspertoken-accumulated-value\" style=\"position:relative;\"><a href=\"#l-12-erc20rewardssol-have-a-method-to-calculate-the-latest-rewardspertoken-accumulated-value\" aria-label=\"l 12 erc20rewardssol have a method to calculate the latest rewardspertoken accumulated value permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/57\">[L-12] <code>ERC20Rewards.sol</code>: Have a method to calculate the latest <code>rewardsPerToken</code> accumulated value</a></h2>\n<p><em>Submitted by hickuphh3</em></p>\n<p>This would be equivalent to <a href=\"https://github.com/k06a/Unipool/blob/master/contracts/Unipool.sol#L69\">Unipool’s <code>rewardPerToken()</code> function</a>. Note that <code>rewardsPerToken.accumulated</code> only reflects the latest stored accumulated value, but does not account for pending accumulation like Unipool, and is therefore not the same. It possibly might be mistaken to be so, hence the low risk classification.</p>\n<p>A possible implementation is given below.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"jsx\" data-index=\"10\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">latestRewardPerToken</span><span class=\"mtk1\">() </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">view</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">\t</span><span class=\"mtk12\">RewardsPerToken</span><span class=\"mtk1\"> </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">rewardsPerToken_</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">rewardsPerToken</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">\t</span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">_totalSupply</span><span class=\"mtk1\"> == </span><span class=\"mtk7\">0</span><span class=\"mtk1\">) </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk12\">rewardsPerToken_</span><span class=\"mtk1\">.</span><span class=\"mtk12\">accumulated</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">\t</span><span class=\"mtk12\">uint32</span><span class=\"mtk1\"> </span><span class=\"mtk12\">end</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">earliest</span><span class=\"mtk1\">(</span><span class=\"mtk12\">block</span><span class=\"mtk1\">.</span><span class=\"mtk12\">timestamp</span><span class=\"mtk1\">.</span><span class=\"mtk11\">u32</span><span class=\"mtk1\">(), </span><span class=\"mtk12\">rewardsPeriod</span><span class=\"mtk1\">.</span><span class=\"mtk12\">end</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">\t</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">timeSinceLastUpdated</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">end</span><span class=\"mtk1\"> - </span><span class=\"mtk12\">rewardsPerToken_</span><span class=\"mtk1\">.</span><span class=\"mtk12\">lastUpdated</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">\t</span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk12\">rewardsPerToken_</span><span class=\"mtk1\">.</span><span class=\"mtk12\">accumulated</span><span class=\"mtk1\"> + </span><span class=\"mtk7\">1e18</span><span class=\"mtk1\"> * </span><span class=\"mtk12\">timeSinceLastUpdated</span><span class=\"mtk1\"> * </span><span class=\"mtk12\">rewardsPerToken_</span><span class=\"mtk1\">.</span><span class=\"mtk12\">rate</span><span class=\"mtk1\"> / </span><span class=\"mtk12\">_totalSupply</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/57#issuecomment-899067608\">alcueca (Yield) confirmed</a>:</strong></p>\n<blockquote>\n<p>Thanks for the suggestion. Even if there is no risk, it will be nice to have this on frontends.</p>\n</blockquote>\n<h1 id=\"non-critical-findings-9\" style=\"position:relative;\"><a href=\"#non-critical-findings-9\" aria-label=\"non critical findings 9 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Non-Critical findings (9)</h1>\n<ul>\n<li><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/19\">[N-01] Incorrect type of uint parameter is used in event </a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/52\">[N-02] Missing zero-address checks</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/22\">[N-03] Missing parameter validation</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/53\">[N-04] Multiple solc versions may be allowed</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/11\">[N-05] <code>CTokenMultiOracle.sol</code> - Add natspec documentation</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/12\">[N-06] <code>CTokenMultiOracle.sol</code> - require in <code>_setSource()</code> seems useless</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/15\">[N-07] <code>CompositeMultiOracle.sol</code> - Add natspec documentation</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/1\">[N-08] double negative in comment</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/63\">[N-09] <code>Timelock.sol</code>: Indexing targets array might not be useful</a></li>\n</ul>\n<h1 id=\"gas-optimizations-18\" style=\"position:relative;\"><a href=\"#gas-optimizations-18\" aria-label=\"gas optimizations 18 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Gas Optimizations (18)</h1>\n<ul>\n<li><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/41\">[G-01] Storage slot packing impacts gas efficiency</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/42\">[G-02] Changing function visibility from public to external saves gas</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/43\">[G-03] Caching state variable in local variables for repeated reads saves gas by converting expensive SLOADs into much cheaper MLOADs</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/44\">[G-04] Using parameters or local variables instead of state variables in event emits can save gas</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/45\">[G-05] Not using memory data location specifier for external function parameters will save gas</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/46\">[G-06] Two functions with same code can be replaced by a single one</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/47\">[G-07] Redundant check</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/48\">[G-08] Check made redundant by following check</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/10\">[G-09] <code>FYTokenFactory.sol</code> - <code>fyToken.ROOT()</code> can be stored in a variable</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/13\">[G-10] <code>CTokenMultiOracle.sol</code> - <code>cTokenIds.length</code> in <code>setSources()</code> can be stored in a variable</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/16\">[G-11] <code>CompositeMultiOracle.sol</code> - bases.length in <code>setSources()</code> and <code>setPaths()</code> can be stored in a variable</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/33\">[G-12] Gas: <code>TimeLock.setDelay</code> reads storage variable for event</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/34\">[G-13] Gas: <code>ERC20Rewards._updateRewardsPerToken</code> return value is not needed</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/3\">[G-14] gas improvement in schedule and cancel of <code>TimeLock.sol</code></a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/5\">[G-15] gas improvement with <code>source.decimals</code></a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/6\">[G-16] Combine get and peek</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/58\">[G-17] <code>ERC20Rewards.sol</code>: <code>latest()</code> is unused</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-yield-findings/issues/39\">[G-18] Gas optimization on <code>_updateRewardsPerToken</code> of <code>ERC20Rewards</code></a></li>\n</ul>\n<h1 id=\"disclosures\" style=\"position:relative;\"><a href=\"#disclosures\" aria-label=\"disclosures permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Disclosures</h1>\n<p>C4 is an open organization governed by participants in the community.</p>\n<p>C4 Contests incentivize the discovery of exploits, vulnerabilities, and bugs in smart contracts. Security researchers are rewarded at an increasing rate for finding higher-risk issues. Contest submissions are judged by a knowledgeable security researcher and solidity developer and disclosed to sponsoring developers. C4 does not conduct formal verification regarding the provided code but instead provides final verification.</p>\n<p>C4 does not provide any guarantee or warranty regarding the security of this project. All smart contract software should be used at the sole risk and responsibility of users.</p>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n  .dark-default-dark {\n    background-color: #1E1E1E;\n    color: #D4D4D4;\n  }\n  .dark-default-dark .mtk1 { color: #D4D4D4; }\n  .dark-default-dark .mtk12 { color: #9CDCFE; }\n  .dark-default-dark .mtk11 { color: #DCDCAA; }\n  .dark-default-dark .mtk7 { color: #B5CEA8; }\n  .dark-default-dark .mtk3 { color: #6A9955; }\n  .dark-default-dark .mtk4 { color: #569CD6; }\n  .dark-default-dark .mtk15 { color: #C586C0; }\n  .dark-default-dark .mtk8 { color: #CE9178; }\n  .dark-default-dark .grvsc-line-highlighted::before {\n    background-color: var(--grvsc-line-highlighted-background-color, rgba(255, 255, 255, 0.1));\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(255, 255, 255, 0.5));\n  }\n</style>",
  "toc": "<ul>\n<li>\n<p><a href=\"#overview\">Overview</a></p>\n<ul>\n<li><a href=\"#about-c4\">About C4</a></li>\n<li><a href=\"#wardens\">Wardens</a></li>\n</ul>\n</li>\n<li><a href=\"#summary\">Summary</a></li>\n<li><a href=\"#scope\">Scope</a></li>\n<li><a href=\"#severity-criteria\">Severity Criteria</a></li>\n<li>\n<p><a href=\"#high-risk-findings-5\">High Risk Findings (5)</a></p>\n<ul>\n<li><a href=\"#h-01-compositemultioracle-returns-wrong-decimals-for-prices\">[H-01] <code>CompositeMultiOracle</code> returns wrong decimals for prices?</a></li>\n<li><a href=\"#h-02-erc20rewards-returns-wrong-rewards-if-no-tokens-initially-exist\">[H-02] <code>ERC20Rewards</code> returns wrong rewards if no tokens initially exist</a></li>\n<li><a href=\"#h-03-erc20rewards-breaks-when-setting-a-different-token\">[H-03] <code>ERC20Rewards</code> breaks when setting a different token</a></li>\n<li><a href=\"#h-04-rewards-accumulated-can-stay-constant-and-often-not-increment\">[H-04] Rewards accumulated can stay constant and often not increment</a></li>\n<li><a href=\"#h-05-exchange-rates-from-compound-are-assumed-with-18-decimals\">[H-05] Exchange rates from Compound are assumed with 18 decimals</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#medium-risk-findings-4\">Medium Risk Findings (4)</a></p>\n<ul>\n<li><a href=\"#m-01-no-erc20-safe-versions-called\">[M-01] No ERC20 safe* versions called</a></li>\n<li><a href=\"#m-02-timelock-cannot-schedule-the-same-calls-multiple-times\">[M-02] <code>TimeLock</code> cannot schedule the same calls multiple times</a></li>\n<li><a href=\"#m-03-rewards-squatting---setting-rewards-in-different-erc20-tokens-opens-various-economic-attacks-\">[M-03] Rewards squatting - setting rewards in different ERC20 tokens opens various economic attacks. </a></li>\n<li><a href=\"#m-04-use-safetransfer-instead-of-transfer\">[M-04] Use <code>safeTransfer</code> instead of <code>transfer</code></a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#low-risk-findings-12\">Low Risk Findings (12)</a></p>\n<ul>\n<li><a href=\"#l-01-updatetime-of-get-is-0\">[L-01] <code>updateTime</code> of get is 0</a></li>\n<li><a href=\"#l-02-different-definition-of-beforematurity-and-aftermaturity-modifier-in-different-file\">[L-02] Different definition of <code>beforeMaturity()</code> and <code>afterMaturity()</code> modifier in different file</a></li>\n<li><a href=\"#l-03-missing-input-validation-to-check-that-end--start\">[L-03] Missing input validation to check that <code>end</code> > <code>start</code></a></li>\n<li><a href=\"#l-04-upgrading-solc-compiler-version-may-help-with-bug-fixes\">[L-04] Upgrading solc compiler version may help with bug fixes</a></li>\n<li><a href=\"#l-05-missing-emits-for-events\">[L-05] Missing emits for events</a></li>\n<li><a href=\"#l-06-unused-cauldron_-parameter\">[L-06] Unused <code>cauldron_</code> parameter</a></li>\n<li><a href=\"#l-07-missing-check-for-contract-existence\">[L-07] Missing check for contract existence</a></li>\n<li><a href=\"#l-08-_peek-does-not-work-for-tokens-with--18-decimals\">[L-08] <code>_peek</code> does not work for tokens with > 18 decimals</a></li>\n<li><a href=\"#l-09-erc20rewards-claiming-can-fail-if-no-reward-tokens\">[L-09] <code>ERC20Rewards</code> claiming can fail if no reward tokens</a></li>\n<li><a href=\"#l-10-improve-safety-of-role-constants-\">[L-10] improve safety of role constants </a></li>\n<li><a href=\"#l-11-emergencybrakesol-permissions-cannot-be-re-planned-after-termination\">[L-11] <code>EmergencyBrake.sol</code>: Permissions cannot be re-planned after termination</a></li>\n<li><a href=\"#l-12-erc20rewardssol-have-a-method-to-calculate-the-latest-rewardspertoken-accumulated-value\">[L-12] <code>ERC20Rewards.sol</code>: Have a method to calculate the latest <code>rewardsPerToken</code> accumulated value</a></li>\n</ul>\n</li>\n<li><a href=\"#non-critical-findings-9\">Non-Critical findings (9)</a></li>\n<li><a href=\"#gas-optimizations-18\">Gas Optimizations (18)</a></li>\n<li><a href=\"#disclosures\">Disclosures</a></li>\n</ul>",
  "md": "\n# Overview\n\n## About C4\n\nCode 432n4 (C4) is an open organization consisting of security researchers, auditors, developers, and individuals with domain expertise in smart contracts.\n\nA C4 code contest is an event in which community participants, referred to as Wardens, review, audit, or analyze smart contract logic in exchange for a bounty provided by sponsoring projects.\n\nDuring the code contest outlined in this document, C4 conducted an analysis of the Yield smart contract system written in Solidity. The code contest took place between August 11—August 14 2021.\n\n## Wardens\n\n8 Wardens contributed reports to the Yield micro code contest:\n\n1. [cmichel](https://twitter.com/cmichelio)\n2. [shw](https://github.com/x9453)\n3. [moose-code](https://twitter.com/jonjonclark)\n4. [0xRajeev](https://twitter.com/0xRajeev)\n5. [hickuphh3](https://twitter.com/HickupH)\n6. [gpersoon](https://twitter.com/gpersoon)\n7. [Jmukesh](https://twitter.com/MukeshJ_eth)\n8. [PierrickGT](https://twitter.com/PierrickGT)\n\nThis contest was judged by [ghoul.sol](https://twitter.com/ghoulsol).\n\nFinal report assembled by [moneylegobatman](https://twitter.com/money_lego) and [ninek](https://twitter.com/_ninek_).\n\n# Summary\n\nThe C4 analysis yielded an aggregated total of 21 unique vulnerabilities and 48 total findings.   All of the issues presented here are linked back to their original finding\n\nOf these vulnerabilities, 5 received a risk rating in the category of HIGH severity, 4 received a risk rating in the category of MEDIUM severity, and 12 received a risk rating in the category of LOW severity.\n\nC4 analysis also identified 9 non-critical recommendations and 18 gas optimizations.\n\n# Scope\n\nThe code under review can be found within the [C4 Yield micro code contest repository](https://github.com/code-423n4/2021-08-yield) is comprised of 61 smart contracts written in the Solidity programming language and includes 4,115 lines of Solidity code.\n\n# Severity Criteria\n\nC4 assesses the severity of disclosed vulnerabilities according to a methodology based on [OWASP standards](https://owasp.org/www-community/OWASP_Risk_Rating_Methodology).\n\nVulnerabilities are divided into three primary risk categories: high, medium, and low.\n\nHigh-level considerations for vulnerabilities span the following key areas when conducting assessments:\n\n- Malicious Input Handling\n- Escalation of privileges\n- Arithmetic\n- Gas use\n\nFurther information regarding the severity criteria referenced throughout the submission review process, please refer to the documentation provided on [the C4 website](https://code423n4.com).\n\n# High Risk Findings (5)\n\n## [[H-01] `CompositeMultiOracle` returns wrong decimals for prices?](https://github.com/code-423n4/2021-08-yield-findings/issues/26)\n_Submitted by cmichel_\n\nThe `CompositeMultiOracle.peek/get` functions seem to return wrong prices.\nIt's unclear what decimals `source.decimals` refers to in this case. Does it refer to `source.source` token decimals?\n\nIt chains the price arguments through `_peek` function calls and a single price is computed as:\n\n```solidity\n(priceOut, updateTimeOut) = IOracle(source.source).peek(base, quote, 10 ** source.decimals);   // Get price for one unit\n// @audit shouldn't this divide by 10 ** IOracle(source.source).decimals() instead?\npriceOut = priceIn * priceOut / (10 ** source.decimals);\n```\n\nAssume all oracles use 18 decimals (`oracle.decimals()` returns 18) and `source.decimals` refers to the _token decimals_ of `source.source`.\n\nThen going from `USDC -> DAI -> USDT` (`path = [DAI]`) starts with a price of `1e18` in `peek`:\n- `_peek(USDC, DAI, 1e18)`: Gets the price of `1e6 USDC` (as USDC has 6 decimals) in DAI with 18 decimals precision (because all oracle precision is set to 18): `priceOut = priceIn * 1e18 / 1e6 = 1e18 * 1e18 / 1e6 = 1e30`\n- `_peek(DAI, USDT, 1e30)`: Gets the price of `1e18 DAI` (DAI has 18 decimals) with 18 decimals precision: `priceOut = priceIn * 1e18 / 1e18 = priceIn = 1e30`\n\nIt then uses `1e30` as the price to go from `USDC` to `USDT`: `value = price * amount / 1e18 = 1e30 * (1.0 USDC) / 1e18 = 1e30 * 1e6 / 1e18 = 1e18 = 1e12 * 1e6 = 1_000_000_000_000.0 USDT`. Inflating the actual `USDT` amount.\n\nThe issue is that `peek` assumes that the final price is in 18 decimals in the `value = price * amount / 1e18` division by `1e18`.\nBut `_peek` (and `_get`) don't enforce this.\n\nRecommend that `_peek` should scale the prices to `1e18` by doing:\n\n```solidity\n(priceOut, updateTimeOut) = IOracle(source.source).get(base, quote, 10 ** source.decimals);\n// priceOut will have same decimals as priceIn if we divide by oracle decimals\npriceOut = priceIn * priceOut / (10 ** IOracle(source.source).decimals());\n```\n\nIt does not need to divide by the `source.source` _token precision_ (`source.decimals`), but by the oracle precision (`IOracle(source.source).decimals()`).\n\n**[alcueca (Yield) acknowledged](https://github.com/code-423n4/2021-08-yield-findings/issues/26#issuecomment-898819530):**\n > It's confusing to deal with all these decimals, I should at least comment the code better, and try to make it easier to understand.\n>\n> > It's unclear what decimals source.decimals refers to in this case. Does it refer to source.source token decimals?\n>\n> CompositeMultiOracle takes IOracle contracts as sources, so `source.decimals` refers to the token decimals of the oracle, not of the data source one level below.\n>\n> > It does not need to divide by the source.source token precision (source.decimals), but by the oracle precision (IOracle(source.source).decimals()).\n>\n> The source.source token precision would be `IChainlinkAggregatorV3(source.source()).decimals()`, the source oracle precision is `source.decimals()`. CompositeMultiOracle cannot make an assumption on any fields present on `source.source`, and must  work only with the underlying `source` IOracles.\n>\n> I'm still not disputing this finding. I need to dig further to make sure the decimals are right when different IOracle sources have different decimals, and I've hardcoded a few `1e18` in there. Those are code smells.\n\n**[alcueca (Yield) patched](https://github.com/code-423n4/2021-08-yield-findings/issues/26#issuecomment-900850053):**\n > Sent me into a wild goose chase to support IOracle of multiple decimals as sources to CompositeMultiOracle, only to realize that we create all IOracles and we always create them with 18 decimals, converting from the underlying data source if needed.\n>\n> Ended up making CompositeMultiOracle require that underlying oracles have 18 decimals. [Done](https://github.com/yieldprotocol/vault-v2/commit/621b680f893436f88f7668164b2942dbb94d1ca2).\n\n**[alcueca (Yield) further patched](https://github.com/code-423n4/2021-08-yield-findings/issues/26#issuecomment-900850053):**\n > Further [refactored all oracles so that decimals are handled properly](https://github.com/yieldprotocol/vault-v2/pull/276), and work on taking an amount of base as input, and returning an amount of quote as output. Our oracles don't have decimals themselves anymore as a state variable, since the return values are in the decimals of quote. This means that CompositeMultiOracle is agnostic with regards to decimals, and doesn't even need to know about them.\n\n\n## [[H-02] `ERC20Rewards` returns wrong rewards if no tokens initially exist](https://github.com/code-423n4/2021-08-yield-findings/issues/28)\n_Submitted by cmichel_\n\nThe `ERC20Rewards._updateRewardsPerToken` function exits without updating `rewardsPerToken_.lastUpdated` if `totalSupply` is zero, i.e., if there are no tokens initially.\n\nThis leads to an error if there is an active rewards period but no tokens have been minted yet.\n\n**Example:** `rewardsPeriod.start: 1 month ago`, `rewardsPeriod.end: in 1 month`, `totalSupply == 0`.\n\nThe first mint leads to the user (mintee) receiving all rewards for the past period (50% of the total rewards in this case).\n- `_mint` is called, calls `_updateRewardsPerToken` which short-circuits. `rewardsPerToken.lastUpdated` is still set to `rewardsPeriod.start` from the constructor. Then `_updateUserRewards` is called and does not currently yield any rewards. (because both balance and the index diff are zero). User has now minted the tokens, `totalSupply` increases and user balance is set.\n- User performs a `claim`: `_updateRewardsPerToken` is called and `timeSinceLastUpdated = end - rewardsPerToken_.lastUpdated = block.timestamp - rewardsPeriod.start = 1 month`. Contract \"issues\" rewards for the past month. The first mintee receives all of it.\n\nThe first mintee receives all pending rewards when they should not receive any past rewards.\nThis can easily happen if the token is new, the reward period has already been initialized and is running, but the protocol has not officially launched yet.\nNote that `setRewards` also allows setting a date in the past which would also be fatal in this case.\n\nRecommend that the `rewardsPerToken_.lastUpdated` field must always be updated in `_updateRewardsPerToken` to the current time (or `end`) even if `_totalSupply == 0`. Don't return early.\n\n**[alcueca (Yield) confirmed](https://github.com/code-423n4/2021-08-yield-findings/issues/28#issuecomment-898824250):**\n > You are right, that's a great finding. For the record, I think that this is what [this line in Unipool.sol](https://github.com/k06a/Unipool/blob/bb1843b454bbb10b3b1ccf48edf5e72a80b2acfe/contracts/Unipool.sol#L70) does:\n```solidity\nfunction rewardPerToken() public view returns (uint256) {\n  if (totalSupply() == 0) {\n    return rewardPerTokenStored;\n  }\n```\n>\n> I'll apply the mitigation step suggested, with a conditional to not do the `rewardsPerToken_.accumulated` math that would revert.\n>\n> Now I know the feeling of the devs that fork a known project and leave a pesky conditional out, thanks again :D\n>\n\n**[alcueca (Yield) patched](https://github.com/code-423n4/2021-08-yield-findings/issues/28#issuecomment-899370816):**\n > [Fix](https://github.com/yieldprotocol/yield-utils-v2/commit/d2ad343f40d375baf492131d9b1c7e288b5825d6)\n\n## [[H-03] `ERC20Rewards` breaks when setting a different token](https://github.com/code-423n4/2021-08-yield-findings/issues/29)\n_Submitted by cmichel_\n\nThe `setRewards` function allows setting a different token.\nHolders of a previous reward period cannot all be paid out and will receive **their old reward amount** in the new token.\n\nThis leads to issues when the new token is more (less) valuable, or uses different decimals.\n\n**Example:** Assume the first reward period paid out in `DAI` which has 18 decimals. Someone would have received `1.0 DAI = 1e18 DAI` if they called `claim` now. Instead, they wait until the new period starts with `USDC` (using only 6 decimals) and can `claim` their `1e18` reward amount in USDC which would equal `1e12 USDC`, one trillion USD.\n\nChanging the reward token only works if old and new tokens use the same decimals and have the exact same value. Otherwise, users that claim too late/early will lose out.\n\nRecommend disallowing changing the reward token, or clearing user's pending rewards of the old token. The second approach requires more code changes and keeping track of what token a user last claimed.\n\n**[alcueca (Yield) confirmed](https://github.com/code-423n4/2021-08-yield-findings/issues/29#issuecomment-898821371):**\n > Maybe I should have used stronger language:\n> `// If changed in a new rewards program, any unclaimed rewards from the last one will be served in the new token`\n>\n> The issue is known, but you are right in pointing it out. There are few situations in which changing the rewards token would make sense (such as replacing a faulty rewards token by a fixed one). I think it would be best to just disallow changing the token.\n\n**[alcueca (Yield) patched](https://github.com/code-423n4/2021-08-yield-findings/issues/29#issuecomment-899366677):**\n > [Fix](https://github.com/yieldprotocol/yield-utils-v2/commit/6df51f81a36e8f9b26b4946ac1aeda90eff6ffda)\n\n## [[H-04] Rewards accumulated can stay constant and often not increment](https://github.com/code-423n4/2021-08-yield-findings/issues/65)\n_Submitted by moose-code_\n\n`rewardsPerToken_.accumulated` can stay constant while `rewardsPerToken_.lastUpdated` is continually updated, leading to no actual rewards being distributed. I.e. No rewards accumulate.\n\nLine 115, `rewardsPerToken_.accumulated` could stay constant if there are very quick update intervals, a relatively low `rewardsPerToken_.rate` and a decent supply of the ERC20 token.\n\nI.e. imagine the token supply is 1 billion tokens (quite a common amount, note even if a supply of only say 1 million tokens this is still relevant). i.e. 1e27 wei.\n\nLine 115 has\n```solidity\n1e18 * timeSinceLastUpdated * rewardsPerToken_.rate / _totalSupply\n```\n\n`timeSinceLastUpdated` can be crafted to be arbitrarily small by simply transferring or burning tokens, so lets exclude this term (it could be 10 seconds etc). Imagine total supply is 1e27 as mentioned.\n\nTherefore, `1e18 * rewardsPerToken_.rate / 1e27`, which shows that if the `rewardsPerToken_.rate` is < 1e9, something which is very likely, then the accumulated amount won't increment, as there are no decimals in solidity and this line of code will evaluate to adding zero. While this is rounded down to zero, critically, ` rewardsPerToken_.lastUpdated = end;` is updated.\n\nThe reason I have labelled this as a high risk is the express purpose of this contract is to reward users with tokens, yet a user could potentially quite easily exploit this line to ensure no one ever gets rewards and the accumulated amount never increases.\n\nGiven a fairly large token supply, and a relatively low emissions rate is set, that satisfies the above equation, for the entire duration of the rewards period, the user simply sends tokens back and forth every couple seconds (gas limitations, but layer 2), to keep the delta `timeSinceLastUpdated` close to 1.\n\nThis way the accumulated amount will never tick up, but time keeps being counted.\n\nFurthermore, I would say this is high risk as this wouldn't even need an attacker. Given the transfer function is likely often being called by users, `timeSinceLastUpdated` will naturally be very low anyways.\n\nEven if not so extreme as the above case, Alberto points out that \"rounding can eat into the rewards\" which is likely to be prevalent in the current scenario and make a big impact over time on the targeted vs actual distribution.\n\nAgain, this problem is more likely to occur in naturally liquid tokens where lots of transfer, mint or burn events occur.\n\nAs suggested by Alberto, the simplest it to probably not update the `rewardsPerToken_.lastUpdated` field if `rewardsPerToken_.accumulated` does not change. Although this change should be closely scrutinized to see it doesn't introduce bugs elsewhere.\n\n**[alcueca (Yield) acknowledged and disagreed with severity](https://github.com/code-423n4/2021-08-yield-findings/issues/65#issuecomment-900485268):**\n > While the issue exists, it's not as severe as portrayed, and doesn't need fixing.\n>\n> There is an error in the assessment, and it is that the `rate` refers to the rewards amount distributed per second among all token holders. It is not the rewards amount distributed per token per second (that's dynamically calculated).\n>\n> Also, it needs to be taken into account that `rewardsPerToken.accumulated` is stored scaled up by 1e18, to avoid losing much ground to rounding.\n>\n```solidity\nstruct RewardsPerToken {\n  uint128 accumulated;                            // Accumulated rewards per token for the period, scaled up by 1e18\n  uint32 lastUpdated;                             // Last time the rewards per token accumulator was updated\n  uint96 rate;                                    // Wei rewarded per second among all token holders\n}\n```\n>\n> One of the largest cap tokens is Dai, with a distribution close to 1e28.\n> If ERC20Rewards were to distribute 1 cent/second among all token holders (which wouldn't be very exciting), and block times were of 1 second, the accumulator would still accumulate.\n>\n> `accumulator += 1e18 (scaling) * 1 (seconds per block) * 1e16 (Dai wei / second) / 1e28 (Dai total supply)`\n> The increase to the `accumulator` is of 1e6, which gives plenty of precision. I would expect a rewards program on Dai holders would be at least 1e6 larger per second.\n>\n> On the other hand, `accumulator` is an `uint128`, which holds amounts of up to 1e38. To overflow it we would need a low cap token (let's say USDC, with 1e15), and a high distribution (1e12 per second, which is unreal), and we run the program for 3 years, or 1e9, to make it easy.\n>\n> The accumulator at the end of the ten years would be:\n> `accumulator = 1e18 (scaling) * 1e9 (seconds) * 1e12 (distribution) / 1e15 (supply) = 1e24`\n> Which doesn't overflow.\n\n**[ghoul-sol (judge) commented](https://github.com/code-423n4/2021-08-yield-findings/issues/65#issuecomment-913864410):**\n > I'll keep high risk as there should be no scenario where the math breaks.\n\n## [[H-05] Exchange rates from Compound are assumed with 18 decimals](https://github.com/code-423n4/2021-08-yield-findings/issues/38)\n_Submitted by shw_\n\nThe `CTokenMultiOracle` contract assumes the exchange rates (borrowing rate) of Compound always have 18 decimals, while, however, which is not true. According to the [Compound documentation](https://compound.finance/docs/ctokens#exchange-rate), the exchange rate returned from the `exchangeRateCurrent` function is scaled by `1 * 10^(18 - 8 + Underlying Token Decimals)` (and so does `exchangeRateStored`). Using a wrong decimal number on the exchange rate could cause incorrect pricing on tokens. See [`CTokenMultiOracle.sol` #L110](https://github.com/code-423n4/2021-08-yield/blob/main/contracts/oracles/compound/CTokenMultiOracle.sol#L110).\n\nRecommend following the documentation and getting the decimals of the underlying tokens to set the correct decimal of a `Source`.\n\n**[alcueca (Yield) confirmed](https://github.com/code-423n4/2021-08-yield-findings/issues/38#issuecomment-899063337):**\n > Thanks a lot for coming up with this. I had looked into how Compound defined the decimals and couldn't find it.\n\n**[alcueca (Yield) patched](https://github.com/code-423n4/2021-08-yield-findings/issues/38#issuecomment-901201555):**\n > [Fix](https://github.com/yieldprotocol/vault-v2/commit/e9c1ee5532c946e9ab2fc8912039829e190fbb64)\n\n# Medium Risk Findings (4)\n\n## [[M-01] No ERC20 safe* versions called](https://github.com/code-423n4/2021-08-yield-findings/issues/31)\n_Submitted by cmichel, also found by JMukesh and hickuphh3_\n\nThe `claim` function performs an ERC20 transfer `rewardsToken.transfer(to, claiming);` but does not check the return value, nor does it work with all legacy tokens.\n\nSome tokens (like USDT) don't correctly implement the EIP20 standard and their `transfer`/`transferFrom` function return `void` instead of a success boolean. Calling these functions with the correct EIP20 function signatures will always revert.\n\nThe `ERC20.transfer()` and `ERC20.transferFrom()` functions return a boolean value indicating success. This parameter needs to be checked for success.\nSome tokens do **not** revert if the transfer failed but return `false` instead.\n\nTokens that don't actually perform the transfer and return `false` are still counted as a correct transfer and tokens that don't correctly implement the latest EIP20 spec, like USDT, will be unusable in the protocol as they revert the transaction because of the missing return value.\n\nRecommend using OpenZeppelin’s `SafeERC20` versions with the `safeTransfer` and `safeTransferFrom` functions that handle the return value check as well as non-standard-compliant tokens.\n\n**[alcueca (Yield) confirmed](https://github.com/code-423n4/2021-08-yield-findings/issues/31#issuecomment-898826857):**\n > True, thanks for spotting it!\n\n**[alcueca (Yield) patched](https://github.com/code-423n4/2021-08-yield-findings/issues/31#issuecomment-899365841):**\n > [Fix](https://github.com/yieldprotocol/yield-utils-v2/commit/3715140ab7d6fbde593257c7542a661bc9191d8c)\n\n## [[M-02] `TimeLock` cannot schedule the same calls multiple times](https://github.com/code-423n4/2021-08-yield-findings/issues/27)\n_Submitted by cmichel_\n\nThe `TimeLock.schedule` function reverts if the same `targets` and `data` fields are used as the `txHash` will be the same.\nThis means one cannot schedule the same transactions multiple times.\n\nImagine the delay is set to 30 days, but a contractor needs to be paid every 2 weeks. One needs to wait 30 days before scheduling the second payment to them.\n\nRecommend also including `eta` in the hash. (Compound's `Timelock` does it as well.) This way the same transaction data can be used by specifying a different `eta`.\n\n**[alcueca (Yield) confirmed](https://github.com/code-423n4/2021-08-yield-findings/issues/27#issuecomment-898830142):**\n > Funny, [BoringCrypto was quite negative about including the eta in the txHash](https://twitter.com/Boring_Crypto/status/1425401221091762189). At the time I couldn't think of a reason to repeat the same call with the same data, but you are right that sometimes it might make sense, and storing off-chain the expected eta of each timelocked transaction is something you should do anyway.\n>\n> I'll confirm this issue, and will bring it for public discussion once the contest is over.\n\n**[alcueca (Yield) patched](https://github.com/code-423n4/2021-08-yield-findings/issues/27#issuecomment-921487023):**\n> I ended up [refactoring the Timelock](https://github.com/yieldprotocol/yield-utils-v2/blob/main/contracts/utils/Timelock.sol) so that the eta is not included in the parameters, but repeated proposals are allowed.\n\n## [[M-03] Rewards squatting - setting rewards in different ERC20 tokens opens various economic attacks. ](https://github.com/code-423n4/2021-08-yield-findings/issues/64)\n_Submitted by moose-code, also found by hickuphh3_\n\nUsers essentially have an option to either claim currently earned reward amounts on future rewards tokens, or the current rewards token.\n\nAlthough stated on line 84, it does not take into account the implications the lock in this contract will have on the future value of new tokens able to be issued via rewards.\n\nSmart users will monitor the mempool for `setRewards` transactions. If the new reward token (token b) is less valuable than the old reward token (token a), they can  front run this transaction by calling claim. Otherwise, they let their accrued 'token a' roll into rewards of of the more valuable 'token b'.\n\nGiven loads of users will likely hold these tokens from day 1, there will potentially be thousands of different addresses squatting on rewards.\n\nEconomically, and given the above, it makes sense that the value of new reward tokens, i.e. 'token b' should always be less than that of 'token a'. This is undesirable in a rewards token contract, as there is no reliable way to start issuing a more valuable token at a later stage, unless exposing yourself to a major risk of reward squatting.\n\ni.e. You could not issue a more valuable token in future (for example, if we wanted to run a rewards period issuing an asset like WETH rewards for 10 days) after first initially issuing DAI as a reward. This hamstrings flexibility of the contract.\n\nP.s. This is one of the slickest contracts I've read. Love how awesome it is.Just believe this should be fixed, then its good to go.\n\nIt is true you could probably write a script to manually go call `claim` on thousands of squatting token addresses but this is a poor solution.\n\nRecommend instead, that a simple mapping pattern could be used with an index mapping to a reward cycle with a reward token and a new accumulative etc. Users would likely need to be given a period a to claim from old reward cycles before their token balance could no longer reliably used to calculate past rewards. The would still be able to claim everything up until their last action (even though this may be before the rewards cycle ended).\n\n**[alcueca (Yield) confirmed](https://github.com/code-423n4/2021-08-yield-findings/issues/64#issuecomment-899068756):**\n > Thanks! I agree that allowing to change the rewards token is just too troublesome.\n\n**[alcueca (Yield) patched](https://github.com/code-423n4/2021-08-yield-findings/issues/64#issuecomment-899270061):**\n > [Fix](https://github.com/yieldprotocol/yield-utils-v2/commit/6df51f81a36e8f9b26b4946ac1aeda90eff6ffda)\n\n## [[M-04] Use `safeTransfer` instead of `transfer`](https://github.com/code-423n4/2021-08-yield-findings/issues/36)\n_Submitted by shw_\n\nTokens not compliant with the ERC20 specification could return `false` from the `transfer` function call to indicate the transfer fails, while the calling contract would not notice the failure if the return value is not checked. Checking the return value is a requirement, as written in the [EIP-20](https://eips.ethereum.org/EIPS/eip-20) specification:\n> Callers MUST handle `false` from `returns (bool success)`. Callers MUST NOT assume that `false` is never returned!\n\nSee [ERC20Rewards.sol L175](https://github.com/code-423n4/2021-08-yield/blob/main/contracts/utils/token/ERC20Rewards.sol#L175).\n\nRecommend using the `SafeERC20` library [implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol) from OpenZeppelin and calling `safeTransfer` or `safeTransferFrom` when transferring ERC20 tokens.\n\n**[alcueca (Yield) confirmed and patched](https://github.com/code-423n4/2021-08-yield-findings/issues/36#issuecomment-899365631):**\n > [Fix](https://github.com/yieldprotocol/yield-utils-v2/commit/3715140ab7d6fbde593257c7542a661bc9191d8c)\n\n# Low Risk Findings (12)\n\n## [[L-01] `updateTime` of get is 0](https://github.com/code-423n4/2021-08-yield-findings/issues/7)\n_Submitted by gpersoon, also found by shw_\n\nIn function `_get` of `CompositeMultiOracle` the `updateTime` is not initialized, so it will be 0.\n\nFunction `_get` has the following statement:\n```solidity\n   updateTimeOut = (updateTimeOut < updateTimeIn) ? updateTimeOut : updateTimeIn;\n\nupdateTimeIn ==0 ==>  (updateTimeOut < updateTimeIn)== false ==> result of the expression is updateTimeIn == 0 ==> updateTimeOut =0\n```\n\nSo this means the function get will always return `updateTime==0`\n\nThe `updateTime` result of the function `get` doesn't seem to be used in the code so the risk is low. If would only be relevant for future code updates.\n\n```solidity\n// https://github.com/code-423n4/2021-08-yield/blob/main/contracts/oracles/composite/CompositeMultiOracle.sol#L94\nfunction get(bytes32 base, bytes32 quote, uint256 amount)  external virtual override  returns (uint256 value, uint256 updateTime)  {\n...\nfor (uint256 p = 0; p < path.length; p++) {\n  (price, updateTime) = _get(base_, path[p], price, updateTime);\n\nfunction _get(bytes6 base, bytes6 quote, uint256 priceIn, uint256 updateTimeIn)  private returns (uint priceOut, uint updateTimeOut) {\n...\n  (priceOut, updateTimeOut) = IOracle(source.source).get(base, quote, 10 ** source.decimals);    // Get price for one unit\n  ...\n  updateTimeOut = (updateTimeOut < updateTimeIn) ? updateTimeOut : updateTimeIn;                 // Take the oldest update time\n}\n```\n\nRecommend adding the following in the beginning of the `_get` function:\n`updateTime = block.timestamp;`\n\n**[alcueca (Yield) confirmed and patched](https://github.com/code-423n4/2021-08-yield-findings/issues/7#issuecomment-900516054):**\n > [Fix](https://github.com/yieldprotocol/vault-v2/commit/a24ea994ba169469f7db661e1436dad43af40653)\n\n## [[L-02] Different definition of `beforeMaturity()` and `afterMaturity()` modifier in different file](https://github.com/code-423n4/2021-08-yield-findings/issues/18)\n_Submitted by JMukesh_\n\nDifferent definition of `beforeMaturity()` and `afterMaturity()` modifier in [`Strategy.sol` L82](https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L82) and [`FYToken.sol` L65](https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/FYToken.sol#L65) which used `FYTokenFacory()`. See issue page for further elaboration.\n\nSee issue page for more.\n\n**[alcueca (Yield) disagreed with severity](https://github.com/code-423n4/2021-08-yield-findings/issues/18#issuecomment-898830802):**\n > It is right that there is a different definition of before and after maturity, and that Strategy.sol should match FYToken.sol, same as Pool.sol does.\n>\n> However, there is no impact from this issue. The only thing that could happen is that an user `mint` strategy tokens on an already matured pool, which is harmless.\n\n**[alcueca (Yield) patched](https://github.com/code-423n4/2021-08-yield-findings/issues/18#issuecomment-899435473):**\n > [Fix](https://github.com/yieldprotocol/strategy-v2/commit/2b10fc35d51b5e1edd233e5969ce0296994cd863)\n\n**[ghoul-sol (judge) commented](https://github.com/code-423n4/2021-08-yield-findings/issues/18#issuecomment-913864941):**\n > per sponsor comment, making this low risk\n\n## [[L-03] Missing input validation to check that `end` > `start`](https://github.com/code-423n4/2021-08-yield-findings/issues/49)\n_Submitted by 0xRajeev_\n\n`setRewards()` is missing input validation on parameters `start` and `end` to check if `end` > `start`. If accidentally set incorrectly, this will allow resetting new rewards while there is an ongoing one ([`ERC20Rewards.sol#L74` L88](https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L74-L88)).\n\nRecommend adding a `require()` to check that `end` > `start`.\n\n**[alcueca (Yield) confirmed](https://github.com/code-423n4/2021-08-yield-findings/issues/49#issuecomment-899066375):**\n > > If accidentally set incorrectly, this will allow resetting new rewards while there is an ongoing one.\n>\n> I would say that if we set it incorrectly, we would like to reset it as soon as possible :)\n>\n> Still, a good check to add, since otherwise it leads to strange behaviour.\n\n**[alcueca (Yield) patched](https://github.com/code-423n4/2021-08-yield-findings/issues/49#issuecomment-899275404):**\n > [Fix](https://github.com/yieldprotocol/yield-utils-v2/commit/71f1e761f1a492954971bb5a9b1209ea1cc9d294)\n\n## [[L-04] Upgrading solc compiler version may help with bug fixes](https://github.com/code-423n4/2021-08-yield-findings/issues/50)\n_Submitted by 0xRajeev_\n\nsolc version 0.8.3 and 0.8.4 fixed important bugs in the compiler. Using version 0.8.1 misses these fixes and may cause a vulnerability.\n\nSee [`ERC20Rewards.sol` L2](https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L2).\n[Solidity 0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4) fixes a bug in the ABI decoder. The release contains an important bugfix. See decoding from memory bug blog post for more details.\n\n[Solidity 0.8.3](https://github.com/ethereum/solidity/releases/tag/v0.8.3) is a bugfix release that fixes an important bug about how the optimizer handles the Keccak256 opcode. For details on the bug, please see the bug blog post.\n\nRecommend considering upgrading to 0.8.3 or 0.8.4.\n\n**[alcueca (Yield) confirmed and patched](https://github.com/code-423n4/2021-08-yield-findings/issues/50#issuecomment-901222844):**\n > [Fix](https://github.com/yieldprotocol/vault-v2/commit/deb13c92511585cda8afe52150bdde637ffa2526), [fix](https://github.com/yieldprotocol/yieldspace-v2/pull/129/commits/7d4f60a7726e60b782ad414cc6d6deeebfea1cae), and [fix](https://github.com/yieldprotocol/strategy-v2/commit/5c0c0e4d9e73c8665ec61c1cc08a55e6db640a8e).\n\n**[alcueca (Yield) commented](https://github.com/code-423n4/2021-08-yield-findings/issues/50#issuecomment-901236905):**\n > I might actually revert the fixes, unless we are affected by the bug fixes. Using solc 0.8.6 forces us to drop the optimizer from 20000 to 5000.\n\n## [[L-05] Missing emits for events](https://github.com/code-423n4/2021-08-yield-findings/issues/51)\n_Submitted by 0xRajeev, also found by cmichel_\n\nFew events are missing emits which prevents the intended data from being observed easily by off-chain interfaces ([`Strategy.sol#L48` L49](https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L48-L49)).\n\nRecommend adding emits or remove event declarations.\n\n**[alcueca (Yield) confirmed and patched](https://github.com/code-423n4/2021-08-yield-findings/issues/51#issuecomment-899436418):**\n > [Fix](https://github.com/yieldprotocol/strategy-v2/commit/e22386827fd01ee01396ef366131080d1834b37b)\n\n## [[L-06] Unused `cauldron_` parameter](https://github.com/code-423n4/2021-08-yield-findings/issues/54)\n_Submitted by 0xRajeev_\n\nThat `cauldron_` parameter is not used here and `ladle_.cauldron()` is used instead. The `Ladle` constructor initializes its cauldron value and so the only way this could differ from the parameter is if the argument to this function is specified incorrectly. See issue page for referenced code.\n\nRecommend either using parameter, or remove it in favor of the value from `ladle_.cauldron()`.\n\n**[alcueca (Yield) confirmed and patched](https://github.com/code-423n4/2021-08-yield-findings/issues/54#issuecomment-899436210):**\n > [Fix](https://github.com/yieldprotocol/strategy-v2/commit/aca5465c714226b07a05ad1dc65e0110b93d6a23)\n\n## [[L-07] Missing check for contract existence](https://github.com/code-423n4/2021-08-yield-findings/issues/55)\n\nLow-level call returns success even if the contract is non-existent. This requires a contract existence check before making the low-level call ([`TimeLock.sol` L93](https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/TimeLock.sol#L93)).\n\n\nSee: “The low-level functions call, `delegatecall` and `staticcall` return true as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed.” from https://docs.soliditylang.org/en/v0.8.7/control-structures.html#error-handling-assert-require-revert-and-exceptions\n\nRecommend checking for target contract existence before call.\n\n**[alcueca (Yield) confirmed](https://github.com/code-423n4/2021-08-yield-findings/issues/55#issuecomment-899067175):**\n > Mmm, we do this in several other places in the codebase, as well as others do in earlier implementations. Will fix.\n\n**[alcueca (Yield) patched](https://github.com/code-423n4/2021-08-yield-findings/issues/55#issuecomment-899380013):**\n > [Fix](https://github.com/yieldprotocol/yield-utils-v2/commit/15be6d4a9c681780d0af3b72b2498f3967b5cd26)\n\n## [[L-08] `_peek` does not work for tokens with > 18 decimals](https://github.com/code-423n4/2021-08-yield-findings/issues/23)\n_Submitted by cmichel_\n\nThe `CTokenMultiOracle._peek/_get` function does the following computation on unsigned integers which reverts when `source.decimals > 18`:\n\n```solidity\nprice = uint(rawPrice) * 10 ** (18 - source.decimals);\n```\n\nRecommend instead performing this `price = uint(rawPrice) * 10 ** 18 / 10 ** source.decimals;`.\nNote that this leads to a loss of precision and the price could end up being `0`.\n\n**[alcueca (Yield) acknowledged and patched](https://github.com/code-423n4/2021-08-yield-findings/issues/23#issuecomment-901202463):**\n > [Fix](https://github.com/yieldprotocol/vault-v2/commit/e9c1ee5532c946e9ab2fc8912039829e190fbb64)\n\n## [[L-09] `ERC20Rewards` claiming can fail if no reward tokens](https://github.com/code-423n4/2021-08-yield-findings/issues/30)\n_Submitted by cmichel_\n\nThe `ERC20Rewards` contract assumes that enough `rewardsToken` are in the contract to pay out when `claim` is called but this value is never checked and claiming rewards can fail.\n\nRecommend that, when setting new rewards periods, to make sure that enough `rewardsToken`s are in the contract to cover the entire period.\n\n**[alcueca (Yield) acknowledged](https://github.com/code-423n4/2021-08-yield-findings/issues/30#issuecomment-898828516):**\n > This is a known issue, which we prefer to leave as it is.\n>\n> Users can check if there are rewards tokens in the contract to cover the whole period, if they wish. ERC20Rewards.sol is intended to be inherited, so it depends on the implementation of the child contract whether that user check (or the proposed mitigation) could be trusted.\n>\n> In our intended use of ERC20Rewards, it is a governance action to make sure that there are funds to cover rewards at all times, which is easy to do since they are evenly distributed over time.\n\n## [[L-10] improve safety of role constants ](https://github.com/code-423n4/2021-08-yield-findings/issues/9)\n_Submitted by gpersoon_\n\nThe contract `Wand` defines a few role constants with `bytes4(keccak256(\"...function...\"))`\nHowever if the function template would change slightly, for example when `uint128` is replaced by `uint256`, then this construction isn't valid anymore.\n\nIt is safer to use the function selector, as is done in [`EmergencyBrake.sol`](https://github.com/code-423n4/2021-08-yield/blob/main/contracts/Wand.sol#L27)\n```solidity\n  bytes4 public constant JOIN = bytes4(keccak256(\"join(address,uint128)\"));\n  bytes4 public constant EXIT = bytes4(keccak256(\"exit(address,uint128)\"));\n  bytes4 public constant MINT = bytes4(keccak256(\"mint(address,uint256)\"));\n  bytes4 public constant BURN = bytes4(keccak256(\"burn(address,uint256)\"));\n```\n\n```solidity\n// https://github.com/code-423n4/2021-08-yield/blob/main/contracts/utils/EmergencyBrake.sol#L35\n  _grantRole(IEmergencyBrake.plan.selector, planner);\n```\n\nRecommend using function selectors in `Wand.sol`.\n\n**[alcueca (Yield) confirmed and patched](https://github.com/code-423n4/2021-08-yield-findings/issues/9#issuecomment-899463822):**\n > [Fix](https://github.com/yieldprotocol/vault-v2/commit/012b621ba0ff56dab795bd62833124220a7b070c)\n\n## [[L-11] `EmergencyBrake.sol`: Permissions cannot be re-planned after termination](https://github.com/code-423n4/2021-08-yield-findings/issues/21)\n_Submitted by hickuphh3_\n\nGiven a configuration of target, contacts, and permissions, calling `terminate()`, will permanently prevent this configuration from being used again because the state becomes `State.TERMINATED`. All other functions require the configuration to be in the other states (UNKNOWN, PLANNED, or EXECUTED).\n\nIn other words, the removal of the restoring option for the configuration through `EmergencyBrake` is permanent.\n\nRecommend that, since `EmergencyBrake` cannot reinstate permissions after termination, it would be better to have terminate change its state to UNKNOWN. The TERMINATED state can therefore be removed.\n\n**[alcueca (Yield) confirmed](https://github.com/code-423n4/2021-08-yield-findings/issues/21#issuecomment-898846397):**\n > That's right.\n\n**[alcueca (Yield) patched](https://github.com/code-423n4/2021-08-yield-findings/issues/21#issuecomment-899399553):**\n > [Fix](https://github.com/yieldprotocol/yield-utils-v2/commit/d7e814d63467600c9ca379abf57e194561c7078d)\n\n## [[L-12] `ERC20Rewards.sol`: Have a method to calculate the latest `rewardsPerToken` accumulated value](https://github.com/code-423n4/2021-08-yield-findings/issues/57)\n_Submitted by hickuphh3_\n\nThis would be equivalent to [Unipool's `rewardPerToken()` function](https://github.com/k06a/Unipool/blob/master/contracts/Unipool.sol#L69). Note that `rewardsPerToken.accumulated` only reflects the latest stored accumulated value, but does not account for pending accumulation like Unipool, and is therefore not the same. It possibly might be mistaken to be so, hence the low risk classification.\n\nA possible implementation is given below.\n```jsx\nfunction latestRewardPerToken() external view returns (uint256) {\n\tRewardsPerToken memory rewardsPerToken_ = rewardsPerToken;\n\tif (_totalSupply == 0) return rewardsPerToken_.accumulated;\n\tuint32 end = earliest(block.timestamp.u32(), rewardsPeriod.end);\n\tuint256 timeSinceLastUpdated = end - rewardsPerToken_.lastUpdated;\n\treturn rewardsPerToken_.accumulated + 1e18 * timeSinceLastUpdated * rewardsPerToken_.rate / _totalSupply;\n}\n```\n\n**[alcueca (Yield) confirmed](https://github.com/code-423n4/2021-08-yield-findings/issues/57#issuecomment-899067608):**\n > Thanks for the suggestion. Even if there is no risk, it will be nice to have this on frontends.\n\n# Non-Critical findings (9)\n\n- [[N-01] Incorrect type of uint parameter is used in event ](https://github.com/code-423n4/2021-08-yield-findings/issues/19)\n- [[N-02] Missing zero-address checks](https://github.com/code-423n4/2021-08-yield-findings/issues/52)\n- [[N-03] Missing parameter validation](https://github.com/code-423n4/2021-08-yield-findings/issues/22)\n- [[N-04] Multiple solc versions may be allowed](https://github.com/code-423n4/2021-08-yield-findings/issues/53)\n- [[N-05] `CTokenMultiOracle.sol` - Add natspec documentation](https://github.com/code-423n4/2021-08-yield-findings/issues/11)\n- [[N-06] `CTokenMultiOracle.sol` - require in `_setSource()` seems useless](https://github.com/code-423n4/2021-08-yield-findings/issues/12)\n- [[N-07] `CompositeMultiOracle.sol` - Add natspec documentation](https://github.com/code-423n4/2021-08-yield-findings/issues/15)\n- [[N-08] double negative in comment](https://github.com/code-423n4/2021-08-yield-findings/issues/1)\n- [[N-09] `Timelock.sol`: Indexing targets array might not be useful](https://github.com/code-423n4/2021-08-yield-findings/issues/63)\n\n# Gas Optimizations (18)\n\n- [[G-01] Storage slot packing impacts gas efficiency](https://github.com/code-423n4/2021-08-yield-findings/issues/41)\n- [[G-02] Changing function visibility from public to external saves gas](https://github.com/code-423n4/2021-08-yield-findings/issues/42)\n- [[G-03] Caching state variable in local variables for repeated reads saves gas by converting expensive SLOADs into much cheaper MLOADs](https://github.com/code-423n4/2021-08-yield-findings/issues/43)\n- [[G-04] Using parameters or local variables instead of state variables in event emits can save gas](https://github.com/code-423n4/2021-08-yield-findings/issues/44)\n- [[G-05] Not using memory data location specifier for external function parameters will save gas](https://github.com/code-423n4/2021-08-yield-findings/issues/45)\n- [[G-06] Two functions with same code can be replaced by a single one](https://github.com/code-423n4/2021-08-yield-findings/issues/46)\n- [[G-07] Redundant check](https://github.com/code-423n4/2021-08-yield-findings/issues/47)\n- [[G-08] Check made redundant by following check](https://github.com/code-423n4/2021-08-yield-findings/issues/48)\n- [[G-09] `FYTokenFactory.sol` - `fyToken.ROOT()` can be stored in a variable](https://github.com/code-423n4/2021-08-yield-findings/issues/10)\n- [[G-10] `CTokenMultiOracle.sol` - `cTokenIds.length` in `setSources()` can be stored in a variable](https://github.com/code-423n4/2021-08-yield-findings/issues/13)\n- [[G-11] `CompositeMultiOracle.sol` - bases.length in `setSources()` and `setPaths()` can be stored in a variable](https://github.com/code-423n4/2021-08-yield-findings/issues/16)\n- [[G-12] Gas: `TimeLock.setDelay` reads storage variable for event](https://github.com/code-423n4/2021-08-yield-findings/issues/33)\n- [[G-13] Gas: `ERC20Rewards._updateRewardsPerToken` return value is not needed](https://github.com/code-423n4/2021-08-yield-findings/issues/34)\n- [[G-14] gas improvement in schedule and cancel of `TimeLock.sol`](https://github.com/code-423n4/2021-08-yield-findings/issues/3)\n- [[G-15] gas improvement with `source.decimals`](https://github.com/code-423n4/2021-08-yield-findings/issues/5)\n- [[G-16] Combine get and peek](https://github.com/code-423n4/2021-08-yield-findings/issues/6)\n- [[G-17] `ERC20Rewards.sol`: `latest()` is unused](https://github.com/code-423n4/2021-08-yield-findings/issues/58)\n- [[G-18] Gas optimization on `_updateRewardsPerToken` of `ERC20Rewards`](https://github.com/code-423n4/2021-08-yield-findings/issues/39)\n\n# Disclosures\n\nC4 is an open organization governed by participants in the community.\n\nC4 Contests incentivize the discovery of exploits, vulnerabilities, and bugs in smart contracts. Security researchers are rewarded at an increasing rate for finding higher-risk issues. Contest submissions are judged by a knowledgeable security researcher and solidity developer and disclosed to sponsoring developers. C4 does not conduct formal verification regarding the provided code but instead provides final verification.\n\nC4 does not provide any guarantee or warranty regarding the security of this project. All smart contract software should be used at the sole risk and responsibility of users.\n"
}