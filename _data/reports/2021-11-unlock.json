{
  "circa": {
    "title": "Unlock Protocol contest",
    "sponsor": "Unlock Protocol",
    "slug": "2021-11-unlock",
    "date": "2022-04-20",
    "findings": "https://github.com/code-423n4/2021-11-unlock-findings/issues",
    "contest": 54
  },
  "html": "<h1 id=\"overview\" style=\"position:relative;\"><a href=\"#overview\" aria-label=\"overview permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Overview</h1>\n<h2 id=\"about-c4\" style=\"position:relative;\"><a href=\"#about-c4\" aria-label=\"about c4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>About C4</h2>\n<p>Code4rena (C4) is an open organization consisting of security researchers, auditors, developers, and individuals with domain expertise in smart contracts.</p>\n<p>A C4 audit contest is an event in which community participants, referred to as Wardens, review, audit, or analyze smart contract logic in exchange for a bounty provided by sponsoring projects.</p>\n<p>During the audit contest outlined in this document, C4 conducted an analysis of the Unlock Protocol smart contract system written in Solidity. The audit contest took place between November 18—November 24, 2021.</p>\n<h2 id=\"wardens\" style=\"position:relative;\"><a href=\"#wardens\" aria-label=\"wardens permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Wardens</h2>\n<p>27 Wardens contributed reports to the Unlock Protocol contest:</p>\n<ol>\n<li>WatchPug (<a href=\"https://github.com/jack-the-pug\">jtp</a> and <a href=\"https://github.com/mingwatch\">ming</a>)</li>\n<li><a href=\"https://twitter.com/cmichelio\">cmichel</a></li>\n<li>elprofesor</li>\n<li><a href=\"https://twitter.com/KenzoAgada\">kenzo</a></li>\n<li><a href=\"https://twitter.com/SolidityDev\">pauliax</a></li>\n<li><a href=\"https://twitter.com/GiveMeTestEther\">GiveMeTestEther</a></li>\n<li>0x0x0x</li>\n<li><a href=\"https://twitter.com/itsmeSTYJ\">itsmeSTYJ</a></li>\n<li><a href=\"https://twitter.com/loop_225\">loop</a></li>\n<li><a href=\"https://twitter.com/0xruhum\">Ruhum</a></li>\n<li><a href=\"https://twitter.com/defsec_\">defsec</a></li>\n<li><a href=\"https://twitter.com/Meta0xNull\">Meta0xNull</a></li>\n<li>harleythedog</li>\n<li>Jujic</li>\n<li>hagrid</li>\n<li>jayjonah8</li>\n<li>Reigada</li>\n<li><a href=\"https://twitter.com/HardlyDifficult\">HardlyDifficult</a></li>\n<li><a href=\"https://twitter.com/_ye0lde\">ye0lde</a></li>\n<li><a href=\"https://github.com/TomAFrench\">TomFrenchBlockchain</a></li>\n<li><a href=\"https://twitter.com/n4th4n131?t=ZXGbALC3q6JMMoolZddgHg&#x26;s=09\">nathaniel</a></li>\n<li><a href=\"https://twitter.com/gzeon\">gzeon</a></li>\n<li><a href=\"bousalman.com\">BouSalman</a></li>\n<li>mics</li>\n<li><a href=\"https://twitter.com/sabtikw\">sabtikw</a></li>\n<li>aga7hokakological</li>\n</ol>\n<p>This contest was judged by <a href=\"https://twitter.com/liam_eastwood13\">0xleastwood</a>.</p>\n<p>Final report assembled by <a href=\"https://twitter.com/itsmetechjay\">itsmetechjay</a>, <a href=\"https://twitter.com/CloudEllie1\">CloudEllie</a>, and <a href=\"https://twitter.com/liveactionllama\">liveactionllama</a>.</p>\n<h1 id=\"summary\" style=\"position:relative;\"><a href=\"#summary\" aria-label=\"summary permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Summary</h1>\n<p>The C4 analysis yielded an aggregated total of 49 unique vulnerabilities and 151 total findings. All of the issues presented here are linked back to their original finding.</p>\n<p>Of these vulnerabilities, 4 received a risk rating in the category of HIGH severity, 13 received a risk rating in the category of MEDIUM severity, and 32 received a risk rating in the category of LOW severity.</p>\n<p>C4 analysis also identified 54 non-critical recommendations and 48 gas optimizations.</p>\n<h1 id=\"scope\" style=\"position:relative;\"><a href=\"#scope\" aria-label=\"scope permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Scope</h1>\n<p>The code under review can be found within the <a href=\"https://github.com/code-423n4/2021-11-unlock\">C4 Unlock Protocol contest repository</a>, and is composed of 3 smart contracts written in the Solidity programming language and includes 604 source lines of Solidity code.</p>\n<h1 id=\"severity-criteria\" style=\"position:relative;\"><a href=\"#severity-criteria\" aria-label=\"severity criteria permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Severity Criteria</h1>\n<p>C4 assesses the severity of disclosed vulnerabilities according to a methodology based on <a href=\"https://owasp.org/www-community/OWASP_Risk_Rating_Methodology\">OWASP standards</a>.</p>\n<p>Vulnerabilities are divided into three primary risk categories: high, medium, and low.</p>\n<p>High-level considerations for vulnerabilities span the following key areas when conducting assessments:</p>\n<ul>\n<li>Malicious Input Handling</li>\n<li>Escalation of privileges</li>\n<li>Arithmetic</li>\n<li>Gas use</li>\n</ul>\n<p>Further information regarding the severity criteria referenced throughout the submission review process, please refer to the documentation provided on <a href=\"https://code423n4.com\">the C4 website</a>.</p>\n<h1 id=\"high-risk-findings-4\" style=\"position:relative;\"><a href=\"#high-risk-findings-4\" aria-label=\"high risk findings 4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>High Risk Findings (4)</h1>\n<h2 id=\"h-01-mev-miner-can-mint-larger-than-expected-udt-total-supply\" style=\"position:relative;\"><a href=\"#h-01-mev-miner-can-mint-larger-than-expected-udt-total-supply\" aria-label=\"h 01 mev miner can mint larger than expected udt total supply permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/135\">[H-01] MEV miner can mint larger than expected UDT total supply</a></h2>\n<p><em>Submitted by elprofesor</em></p>\n<p><code>UnlockProtocol</code> attempts to calculate gas reimbursement using <code>tx.gasprice</code>, typically users who falsify <code>tx.gasprice</code>would lose gas to miners and therefore not obtain any advantage over the protocol itself. This does present capabilities for miners to extract value, as they can submit their own transactions, or cooperate with a malicious user, reimbursing a portion (or all) or the <code>tx.gasprice</code> used. As the following calculation is made;</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"\" data-index=\"0\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">    uint tokensToDistribute = (estimatedGasForPurchase * tx.gasprice) * (125 * 10 ** 18) / 100 / udtPrice;</span></span></code></pre>\n<p>we can see that arbitrary <code>tx.gasprices</code> can rapidly inflate the <code>tokensToDistribute</code>. Though capped at maxTokens, this value can be up to half the total supply of UDT, which could dramatically affect the value of UDT potentially leading to lucrative value extractions outside of the pool.</p>\n<h4 id=\"recommended-mitigation-steps\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps\" aria-label=\"recommended mitigation steps permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h4>\n<p>Using an oracle service to determine the average gas price and ensuring it is within some normal bounds that has not been subjected to arbitrary value manipulation.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/135#issuecomment-991699670\">julien51 (Unlock Protocol) disputed and commented</a>:</strong></p>\n<blockquote>\n<blockquote>\n<p>we can see that arbitrary tx.gasprices can rapidly inflate the tokensToDistribute. Though capped at maxTokens, this value can be up to half the total supply of UDT, which could dramatically affect the value of UDT potentially leading to lucrative value extractions outside of the pool.</p>\n</blockquote>\n<p>As you noted it would be capped by the actual increase of the GDP transaction.</p>\n<p>However we could indeed use an oracle to determine the average gas price over a certain number of blocks to limit the risk even further. </p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/135#issuecomment-1009512489\">0xleastwood (judge) commented</a>:</strong></p>\n<blockquote>\n<p>I think the warden has raised a valid issue of value extractions. Whether the value extracted is capped at a certain number of tokens, I don’t think the issue is nullified as a result. Miners can realistically fill up blockspace by abusing this behaviour and then selling netted tokens on the open market. I’ll consider marking this as <code>medium</code>, what do you think @julien51 ?</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/135#issuecomment-1009577434\">0xleastwood (judge) commented</a>:</strong></p>\n<blockquote>\n<p>I think <code>maxTokens</code> will be set to <code>IMintableERC20(udt).totalSupply() / 2</code> upon the first call to <code>recordKeyPurchase()</code>. If I’m not mistaken, this could allow a malicious miner could effectively distribute half of the token supply in one tx.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/135#issuecomment-1013810733\">0xleastwood (judge) commented</a>:</strong></p>\n<blockquote>\n<p>After further offline discussions with @julien51. We agree that this is an issue that needs to be addressed.</p>\n<p>If we consider real-world values for <code>IMintableERC20(udt).totalSupply()</code> and <code>IMintableERC20(udt).totalSupply()</code> as <code>1_000_000e18</code> and <code>400e18</code> respectively. Then a miner could mint up to ~1247 <code>UDT</code> tokens valued at $USD 124,688 if they provide a single Ether as their purchase amount. Obviously this can be abused to generate a huge amount of profit for miners, so as this is a viable way to extract value from the protocol, I will be keeping this as <code>high</code> severity.</p>\n</blockquote>\n<h2 id=\"h-02-wrong-designimplementation-of-freetrial-allows-attacker-to-steal-funds-from-the-protocol\" style=\"position:relative;\"><a href=\"#h-02-wrong-designimplementation-of-freetrial-allows-attacker-to-steal-funds-from-the-protocol\" aria-label=\"h 02 wrong designimplementation of freetrial allows attacker to steal funds from the protocol permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/188\">[H-02] Wrong design/implementation of freeTrial allows attacker to steal funds from the protocol</a></h2>\n<p><em>Submitted by WatchPug</em></p>\n<p>The current design/implementation of <code>freeTrial</code> allows users to get full refund before the <code>freeTrial</code> ends. Plus, a user can transfer partial of their time to another user using <code>shareKey</code>.</p>\n<p>This makes it possible for the attacker to steal from the protocol by transferring <code>freeTrial</code> time from multiple addresses to one address and adding up to <code>expirationDuration</code> and call refund to steal from the protocol.</p>\n<h4 id=\"proof-of-concept\" style=\"position:relative;\"><a href=\"#proof-of-concept\" aria-label=\"proof of concept permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h4>\n<p>Given:</p>\n<ul>\n<li><code>keyPrice</code> is 1 ETH;</li>\n<li><code>expirationDuration</code> is 360 days;</li>\n<li><code>freeTrialLength</code> is 31 days.</li>\n</ul>\n<p>The attacker can create two wallet addresses: Alice and Bob.</p>\n<ol>\n<li>Alice calls <code>purchase()</code>, transfer 30 days via <code>shareKey()</code> to Bob, then calls <code>cancelAndRefund()</code> to get full refund; Repeat 12 times;</li>\n<li>Bob calls <code>cancelAndRefund()</code> and get 1 ETH.</li>\n</ol>\n<h4 id=\"recommendation\" style=\"position:relative;\"><a href=\"#recommendation\" aria-label=\"recommendation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommendation</h4>\n<p>Consider disabling <code>cancelAndRefund()</code> for users who transferred time to another user.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/188#issuecomment-979656014\">julien51 (Unlock Protocol) confirmed and commented</a>:</strong></p>\n<blockquote>\n<p>I think this is valid! The free trial approach is indeed a risk on that front and we need to “warn” lock managers about this more.</p>\n<p>For lock manager who still want to offer free trials, the best approach would probably be to set a high transfer fee to make sure that free trials cannot be transfered.</p>\n<p>As a consequence of this, I am not sure this is as critical as indicated by the submitter.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/188#issuecomment-1013831268\">0xleastwood (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Nice find!</p>\n<p>From what I can tell at least, this does seem like a viable attack vector. Can I ask why this should not be treated as <code>high</code> risk? @julien51 </p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/188#issuecomment-1068786053\">julien51 (Unlock Protocol) commented</a>:</strong></p>\n<blockquote>\n<p>Sorry for the long delay here.\nIn short: this is valid, but only an issue for locks which are enabling free trials (no one has done it) and we would make sure our UI shows this as a potential issue.\nIn other words: a lock manager would need to <em>explicitly</em> enable free trials, despite our warning to put their own funds at risk. For that reason I don’t think this is “High”.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/188#issuecomment-1075667239\">0xleastwood (judge) commented</a>:</strong></p>\n<blockquote>\n<p>While this is a valid issue pertaining only to lock managers who <em>explicitly</em> enable free trials, this may still lead to a loss of funds if <code>cancelAndRefund</code> is called by a user who has transferred their time to another account. I still believe this deserves a <code>high</code> severity rating.</p>\n<p>In my honest opinion, a warning isn’t sufficient to prevent such abuse. I think on-chain enforcement ideal in this situation.</p>\n</blockquote>\n<h2 id=\"h-03-mixintransfersoltransferfrom-wrong-implementation-can-potentially-allows-attackers-to-reverse-transfer-and-cause-fund-loss-to-the-users\" style=\"position:relative;\"><a href=\"#h-03-mixintransfersoltransferfrom-wrong-implementation-can-potentially-allows-attackers-to-reverse-transfer-and-cause-fund-loss-to-the-users\" aria-label=\"h 03 mixintransfersoltransferfrom wrong implementation can potentially allows attackers to reverse transfer and cause fund loss to the users permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/182\">[H-03] <code>MixinTransfer.sol#transferFrom</code> Wrong implementation can potentially allows attackers to reverse transfer and cause fund loss to the users</a></h2>\n<p><em>Submitted by WatchPug</em></p>\n<p><a href=\"https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinTransfer.sol#L131-L152\">https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinTransfer.sol#L131-L152</a></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"1\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">toKey</span><span class=\"mtk1\">.</span><span class=\"mtk12\">tokenId</span><span class=\"mtk1\"> == </span><span class=\"mtk7\">0</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">toKey</span><span class=\"mtk1\">.</span><span class=\"mtk12\">tokenId</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_tokenId</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk11\">_recordOwner</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_recipient</span><span class=\"mtk1\">, </span><span class=\"mtk12\">_tokenId</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk3\">// Clear any previous approvals</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk11\">_clearApproval</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_tokenId</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">previousExpiration</span><span class=\"mtk1\"> &lt;= </span><span class=\"mtk12\">block</span><span class=\"mtk1\">.</span><span class=\"mtk12\">timestamp</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk3\">// The recipient did not have a key, or had a key but it expired. The new expiration is the sender&#39;s key expiration</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk3\">// An expired key is no longer a valid key, so the new tokenID is the sender&#39;s tokenID</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">toKey</span><span class=\"mtk1\">.</span><span class=\"mtk12\">expirationTimestamp</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">fromKey</span><span class=\"mtk1\">.</span><span class=\"mtk12\">expirationTimestamp</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">toKey</span><span class=\"mtk1\">.</span><span class=\"mtk12\">tokenId</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_tokenId</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk3\">// Reset the key Manager to the key owner</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk11\">_setKeyManagerOf</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_tokenId</span><span class=\"mtk1\">, </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">));</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk11\">_recordOwner</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_recipient</span><span class=\"mtk1\">, </span><span class=\"mtk12\">_tokenId</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">} </span><span class=\"mtk15\">else</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk3\">// The recipient has a non expired key. We just add them the corresponding remaining time</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk3\">// SafeSub is not required since the if confirms `previousExpiration - block.timestamp` cannot underflow</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">toKey</span><span class=\"mtk1\">.</span><span class=\"mtk12\">expirationTimestamp</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">fromKey</span><span class=\"mtk1\">.</span><span class=\"mtk12\">expirationTimestamp</span><span class=\"mtk1\"> + </span><span class=\"mtk12\">previousExpiration</span><span class=\"mtk1\"> - </span><span class=\"mtk12\">block</span><span class=\"mtk1\">.</span><span class=\"mtk12\">timestamp</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p>Based on the context, L131-136 seems to be the logic of handling the case of the recipient with no key, and L138-148 is handing the case of the recipient’s key expired.</p>\n<p>However, in L131-136, the key manager is not being reset.</p>\n<p>This allows attackers to keep the role of key manager after the transfer, and transfer the key back or to another recipient.</p>\n<h4 id=\"proof-of-concept-1\" style=\"position:relative;\"><a href=\"#proof-of-concept-1\" aria-label=\"proof of concept 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h4>\n<p>Given:</p>\n<ul>\n<li>Alice owns a key that is valid until 1 year later.</li>\n<li>Alice calls <code>setKeyManagerOf()</code>, making herself the keyManager;</li>\n<li>Alice calls <code>transferFrom()</code>, transferring the key to Bob; Bob might have paid a certain amount of money to Alice upon receive of the key;</li>\n<li>Alice calls <code>transferFrom()</code> again, transferring the key back from Bob.</li>\n</ul>\n<h4 id=\"recommendation-1\" style=\"position:relative;\"><a href=\"#recommendation-1\" aria-label=\"recommendation 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommendation</h4>\n<p>Consider resetting the key manager regardless of the status of the recipient’s key.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/182#issuecomment-991678597\">julien51 (Unlock Protocol) confirmed</a>:</strong></p>\n<blockquote>\n<p>I <em>think</em> you are onto something here. We will need to investigate further and reproduce to fix!</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/182#issuecomment-1013830991\">0xleastwood (judge) commented</a>:</strong></p>\n<blockquote>\n<p>@julien51 Just following up if you were able to double-check this?</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/182#issuecomment-1068786599\">julien51 (Unlock Protocol) confirmed</a>:</strong></p>\n<blockquote>\n<p>This is indeed valid and I think we will need to “patch” this. We’re still unsure how but we’re exploring multiple ways.</p>\n</blockquote>\n<h2 id=\"h-04-approvals-not-cleared-after-key-transfer\" style=\"position:relative;\"><a href=\"#h-04-approvals-not-cleared-after-key-transfer\" aria-label=\"h 04 approvals not cleared after key transfer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/160\">[H-04] Approvals not cleared after key transfer</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The locks implement three different approval types, see <code>onlyKeyManagerOrApproved</code> for an overview:</p>\n<ul>\n<li>key manager (map <code>keyManagerOf</code>)</li>\n<li>single-person approvals (map <code>approved</code>). Cleared by <code>_clearApproval</code> or <code>_setKeyManagerOf</code></li>\n<li>operator approvals (map <code>managerToOperatorApproved</code>)</li>\n</ul>\n<p>The <code>MixinTransfer.transferFrom</code> requires any of the three approval types in the <code>onlyKeyManagerOrApproved</code> modifier on the tokenId to authenticate transfers from <code>from</code>.</p>\n<p>Notice that if the <code>to</code> address previously had a key but it expired only the <code>_setKeyManagerOf</code> call is performed, which does not clear <code>approved</code> if the key manager was already set to 0:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"2\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">transferFrom</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_from</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_recipient</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_tokenId</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk11\">public</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk11\">onlyIfAlive</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk11\">hasValidKey</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_from</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk11\">onlyKeyManagerOrApproved</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_tokenId</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">{</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk3\">// @audit this is skipped if user had a key that expired</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">toKey</span><span class=\"mtk1\">.</span><span class=\"mtk12\">tokenId</span><span class=\"mtk1\"> == </span><span class=\"mtk7\">0</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">toKey</span><span class=\"mtk1\">.</span><span class=\"mtk12\">tokenId</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_tokenId</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">_recordOwner</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_recipient</span><span class=\"mtk1\">, </span><span class=\"mtk12\">_tokenId</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// Clear any previous approvals</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">_clearApproval</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_tokenId</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">previousExpiration</span><span class=\"mtk1\"> &lt;= </span><span class=\"mtk12\">block</span><span class=\"mtk1\">.</span><span class=\"mtk12\">timestamp</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// The recipient did not have a key, or had a key but it expired. The new expiration is the sender&#39;s key expiration</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// An expired key is no longer a valid key, so the new tokenID is the sender&#39;s tokenID</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">toKey</span><span class=\"mtk1\">.</span><span class=\"mtk12\">expirationTimestamp</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">fromKey</span><span class=\"mtk1\">.</span><span class=\"mtk12\">expirationTimestamp</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">toKey</span><span class=\"mtk1\">.</span><span class=\"mtk12\">tokenId</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_tokenId</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// Reset the key Manager to the key owner</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// @audit  doesn&#39;t clear approval if key manager already was 0</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">_setKeyManagerOf</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_tokenId</span><span class=\"mtk1\">, </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">));</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">_recordOwner</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_recipient</span><span class=\"mtk1\">, </span><span class=\"mtk12\">_tokenId</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk3\">// ...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// </span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">_setKeyManagerOf</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_tokenId</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_keyManager</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">) </span><span class=\"mtk11\">internal</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">{</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk3\">// @audit-ok only clears approved if key manager updated</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk15\">if</span><span class=\"mtk1\">(</span><span class=\"mtk12\">keyManagerOf</span><span class=\"mtk1\">[</span><span class=\"mtk12\">_tokenId</span><span class=\"mtk1\">] != </span><span class=\"mtk12\">_keyManager</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">keyManagerOf</span><span class=\"mtk1\">[</span><span class=\"mtk12\">_tokenId</span><span class=\"mtk1\">] = </span><span class=\"mtk12\">_keyManager</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">_clearApproval</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_tokenId</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">emit</span><span class=\"mtk1\"> </span><span class=\"mtk11\">KeyManagerChanged</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_tokenId</span><span class=\"mtk1\">, </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">));</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<h4 id=\"impact\" style=\"position:relative;\"><a href=\"#impact\" aria-label=\"impact permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h4>\n<p>It’s possible to sell someone a key and then claim it back as the approvals are not always cleared.</p>\n<h4 id=\"proof-of-concept-2\" style=\"position:relative;\"><a href=\"#proof-of-concept-2\" aria-label=\"proof of concept 2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof Of Concept</h4>\n<ul>\n<li>Attacker A has a valuable key (<code>tokenId = 42</code>) with an expiry date far in the future.</li>\n<li>A sets approvals for their second attacker controlled account A’ by calling <code>MixinKeys.setApprovalForAll(A', true)</code>, which sets <code>managerToOperatorApproved[A][A'] = true</code>.</li>\n<li>A clears the key manager by setting it to zero, for example, by transferring it to a second account that does not have a key yet, this calls the above <code>_setKeyManagerOf(42, address(0));</code> in <code>transferFrom</code></li>\n<li>A sets single-token approval to A’ by calling <code>MixinKeys.approve(A', 42)</code>, setting <code>approved[42] = A'</code>.</li>\n<li>A sells the token to a victim V for a discount (compared to purchasing it from the Lock). The victim needs to have owned a key before which already expired. The <code>transferFrom(A, V, 42)</code> call sets the owner of token 42 to <code>V</code>, but does not clear the <code>approved[42] == A'</code> field as described above. (<code>_setKeyManagerOf(_tokenId, address(0));</code> is called but the key manager was already zero, which then does not clear approvals.)</li>\n<li>A’ can claim back the token by calling <code>transferFrom(V, A', 42)</code> and the <code>onlyKeyManagerOrApproved(42)</code> modifier will pass as <code>approved[42] == A'</code> is still set.</li>\n</ul>\n<h4 id=\"recommended-mitigation-steps-1\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-1\" aria-label=\"recommended mitigation steps 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h4>\n<p>The <code>_setKeyManagerOf</code> function should not handle clearing approvals of single-token approvals (<code>approved</code>) as these are two separate approval types.\nThe <code>transferFrom</code> function should always call <code>_clearApproval</code> in the <code>(previousExpiration &#x3C;= block.timestamp)</code> case.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/160#issuecomment-991687080\">julien51 (Unlock Protocol) confirmed and commented</a>:</strong></p>\n<blockquote>\n<p>Thanks for reporting this.\nThis is valid and we will fix it.</p>\n</blockquote>\n<h1 id=\"medium-risk-findings-13\" style=\"position:relative;\"><a href=\"#medium-risk-findings-13\" aria-label=\"medium risk findings 13 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Medium Risk Findings (13)</h1>\n<h2 id=\"m-01-unlock-free-udt-arbitrage-opportunity\" style=\"position:relative;\"><a href=\"#m-01-unlock-free-udt-arbitrage-opportunity\" aria-label=\"m 01 unlock free udt arbitrage opportunity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/70\">[M-01] Unlock: free UDT arbitrage opportunity</a></h2>\n<p><em>Submitted by itsmeSTYJ</em></p>\n<p>Uniswap v2 made oracle attacks much more expensive to execute (since it needs to be manipulated over X number of blocks) however its biggest drawback is that it reacts slow to price volatility (depends on how far back you look). Depending on a single oracle is still very risky and can be exploited given the correct conditions.</p>\n<p>Assuming the ideal conditions, it is possible to purchase many keys across many locks for the UDT token that is distributed to the referrer and sell them on some other exchanges where the price of UDT is higher; high enough such that the malicious user can still profit even after requesting for a refund (w/ or w/o a free trial).</p>\n<h4 id=\"proof-of-concept-3\" style=\"position:relative;\"><a href=\"#proof-of-concept-3\" aria-label=\"proof of concept 3 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h4>\n<p>This exploit is made possible because of:</p>\n<ul>\n<li>the over dependency on a single price oracle</li>\n<li>UDT token distribution logic is flawed</li>\n</ul>\n<p>The following assumptions has to be true for this attack to work:</p>\n<ol>\n<li>price of UDT on an exchange is much higher than that from the price retrieved from the <code>uniswapOracle</code>.</li>\n<li>Since the price retrieved by <code>udtOracle.updateAndConsult()</code> only updates once per day, it is slow to react to the volatility of UDT price movements.</li>\n<li>Malicious user creates a lock and buys many keys across multiple addresses.</li>\n<li>Malicious user sells these UDT tokens on the exchanges w/ the higher price.</li>\n<li>Malicious user requests for a refund on the keys owned.</li>\n<li>Repeat until it is no longer profitable i.e. price on other exchanges become close to parity with the price retrieved by the <code>uniswapOracle</code>.</li>\n</ol>\n<h4 id=\"recommended-mitigation-steps-2\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-2\" aria-label=\"recommended mitigation steps 2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h4>\n<ul>\n<li>Use the average of multiple oracle sources so that the price of UDT tokens (from <code>Unlock.sol</code>’s PoV) reacts faster.</li>\n<li>UDT tokens distributed based on the duration of key ownership.</li>\n</ul>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/70#issuecomment-1004137608\">julien51 (Unlock Protocol) disagreed with severity and commented</a>:</strong></p>\n<blockquote>\n<p>As you noted this is pretty theoretical and given that the amount of UDT minted is capped to the gas spent, the user will need to 1) purchase a LOT of keys and 2) cancel them all and 3) find an exchange where the price is significantly different. </p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/70#issuecomment-1010535323\">0xleastwood (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Nice find!</p>\n<p>While, I do agree this is a difficult attack to perform, it is still a valid way of extracting value from the protocol. Hence, I believe this should be kept as <code>medium</code>.</p>\n<p><code>2 — Med (M): vulns have a risk of 2 and are considered “Medium” severity when assets are not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.</code></p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/70#issuecomment-1068788560\">julien51 (Unlock Protocol) commented</a>:</strong></p>\n<blockquote>\n<p>We will mitigate this in an upcoming upgrade by moving to Uniswap v3 for our oracles. </p>\n</blockquote>\n<h2 id=\"m-02-potential-economic-attack-on-udt-grants-to-the-referrer\" style=\"position:relative;\"><a href=\"#m-02-potential-economic-attack-on-udt-grants-to-the-referrer\" aria-label=\"m 02 potential economic attack on udt grants to the referrer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/186\">[M-02] Potential economic attack on UDT grants to the referrer</a></h2>\n<p><em>Submitted by WatchPug</em></p>\n<p>In the current implementation, <code>Unlock.sol#recordKeyPurchase()</code> will send <code>estimatedGasForPurchase * tx.gasprice</code> worth of UDT to the referrer.</p>\n<p><a href=\"https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/Unlock.sol#L325-L325\">https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/Unlock.sol#L325-L325</a></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"3\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">tokensToDistribute</span><span class=\"mtk1\"> = (</span><span class=\"mtk12\">estimatedGasForPurchase</span><span class=\"mtk1\"> * </span><span class=\"mtk12\">tx</span><span class=\"mtk1\">.</span><span class=\"mtk12\">gasprice</span><span class=\"mtk1\">) * (</span><span class=\"mtk7\">125</span><span class=\"mtk1\"> * </span><span class=\"mtk7\">10</span><span class=\"mtk1\"> ** </span><span class=\"mtk7\">18</span><span class=\"mtk1\">) / </span><span class=\"mtk7\">100</span><span class=\"mtk1\"> / </span><span class=\"mtk12\">udtPrice</span><span class=\"mtk1\">;</span></span></span></code></pre>\n<p>We believe there are multiple potential economic attack vectors to exploit this.</p>\n<p>If <code>estimatedGasForPurchase</code> is misconfigured to a higher amount than the actual avg gas cost for a purchase call, or future network upgrades make the actual gas cost become lower than the configured <code>estimatedGasForPurchase</code>, it can be exploited simply by creating a lock and call <code>purchase()</code> many times to mint UDT.</p>\n<p>Even if <code>estimatedGasForPurchase</code> is configured to an amount similar to the actual gas cost, a more sophisticated attack is still possible:</p>\n<h4 id=\"proof-of-concept-4\" style=\"position:relative;\"><a href=\"#proof-of-concept-4\" aria-label=\"proof of concept 4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h4>\n<p>Given:</p>\n<ul>\n<li><code>estimatedGasForPurchase</code> is configured as <code>200,000</code>;</li>\n<li>The gas cost of a regular purchase call is about <code>200,000</code>.</li>\n</ul>\n<p>The attacker can create a lock contract and set the token address to a special gas saving token, which will SELFDESTRUCT to get a gas refund on <code>transfer</code>.</p>\n<p>The attacker can:</p>\n<ol>\n<li>Mint gas saving token with gas price: <code>1 gwei</code>;</li>\n<li>Call <code>purchase()</code> and use 48 contract slots with gas price: <code>1000 gwei</code>;</li>\n</ol>\n<p>Total gas saved will be ~0.8 ETH (or other native tokens, eg. BNB, MATIC). Therefore, the attacker will profit ~0.8 ETH worth of UDT.</p>\n<p>See: <a href=\"https://gastoken.io/\">https://gastoken.io/</a></p>\n<h4 id=\"recommendation-2\" style=\"position:relative;\"><a href=\"#recommendation-2\" aria-label=\"recommendation 2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommendation</h4>\n<p>Consider setting a global daily upper limit of total UDT grants to referrers, plus, an upper limit for UDT minted per purchase.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/186#issuecomment-991673917\">julien51 (Unlock Protocol) acknowledged, but disagreed with severity and commented</a>:</strong></p>\n<blockquote>\n<blockquote>\n<p>If <code>estimatedGasForPurchase</code> is misconfigured to a higher amount than the actual avg gas cost for a purchase call, or future network upgrades make the actual gas cost become lower than the configured <code>estimatedGasForPurchase</code>, it can be exploited simply by creating a lock and call <code>purchase()</code> many times to mint UDT.</p>\n</blockquote>\n<p>Absolutely but considering the security model, the admin indeed have full control over the protocol. We are thinking about finding a mechanism to not hardcode gas spent but use the actual number eventually. When we do that we should consider the impact of things like gas-token (even though EIP1559 has probably made them mostly impractical?).</p>\n<p>At this point given that the gas spent is hardcoded, there is a de-facto cap on how much UDT they could earn (based on the token price).</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/186#issuecomment-1013811232\">0xleastwood (judge) commented</a>:</strong></p>\n<blockquote>\n<p>While I agree with the warden, there is potential for value extraction, however, it does require the admin to be unaware about upcoming network upgrades. </p>\n<p>As the sponsor has noted, they will be moving towards a dynamic <code>estimatedGasForPurchase</code> value, however, from the perspective of the c4 contest, this doesn’t change the outcome of my decision.</p>\n<p>As the protocol may leak value based on certain network assumptions, I’ll mark this as <code>medium</code> severity.</p>\n<p><code>2 — Med (M): vulns have a risk of 2 and are considered “Medium” severity when assets are not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.</code></p>\n</blockquote>\n<p><strong>Please note: the following additional discussions and re-assessment took place approximately 2 months after judging and awarding were finalized. As such, this report will leave this finding in its originally assessed risk category as it simply reflects a snapshot in time.</strong></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/186#issuecomment-1068789965\">julien51 (Unlock Protocol) commented</a>:</strong></p>\n<blockquote>\n<p>I don’t think the protocl can “leak” value based on that.\nThe tokens that are used to compute GDP and distribute tokens have to be approved by the DAO (right now only USDC, DAI and BAT have been approved on mainnet, and only USDC on Polygon). I don’t think the DAO would approve gas tokens givem that indeed they could result in leakage of UDT, so I think it is <code>minor</code>.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/186#issuecomment-1075674165\">0xleastwood (judge) decreased severity to Low and commented</a>:</strong></p>\n<blockquote>\n<p>Considering the sponsor’s comments, I actually agree that this is less likely than initially stated. Similar to the <code>SafeERC20</code> issue, it isn’t expected that gas saving tokens will be approved to compute and distribute <code>UDT</code> tokens. I’ll downgrade this to <code>low</code>.</p>\n</blockquote>\n<h2 id=\"m-03-support-of-different-erc20-tokens\" style=\"position:relative;\"><a href=\"#m-03-support-of-different-erc20-tokens\" aria-label=\"m 03 support of different erc20 tokens permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/221\">[M-03] Support of different ERC20 tokens</a></h2>\n<p><em>Submitted by pauliax, also found by cmichel, Reigada, kenzo, Ruhum, 0x0x0x, GiveMeTestEther, and WatchPug</em></p>\n<p>The current version of the codebase does not handle special cases of tokens, e.g. deflationary, rebasing, or those that return true/false on success (see: <a href=\"https://github.com/d-xo/weird-erc20\">https://github.com/d-xo/weird-erc20</a>). Function purchase transfers tokens from msg.sender but it does not check the return value, nor how many tokens were actually transferred:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"4\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">token</span><span class=\"mtk1\">.</span><span class=\"mtk11\">transferFrom</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">, </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">), </span><span class=\"mtk12\">pricePaid</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<h4 id=\"recommended-mitigation-steps-3\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-3\" aria-label=\"recommended mitigation steps 3 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h4>\n<p>I have 2 suggestions here:</p>\n<ol>\n<li>Use SafeERC20 library to handle token transfers: <a href=\"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol\">https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol</a></li>\n<li>Consider checking the actual balances transferred (balance after-before) or clearly documenting that you do not support deflationary / rebasing / etc tokens.</li>\n</ol>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/221#issuecomment-991662738\">julien51 (Unlock Protocol) disputed and commented</a>:</strong></p>\n<blockquote>\n<p>The only party that would be penalized in the examples you describe is the lock manager (and beneficiary) who has explicitly deployed the lock using the (noncompliant) ERC20.\nIf we consider the threat model here then I think this is not really an issue, as additional checks would incur a gas cost for everyone.</p>\n</blockquote>\n<p><strong>Please note: the following additional discussions and re-assessment took place approximately 2 months after judging and awarding were finalized. As such, this report will leave this finding in its originally assessed risk category as it simply reflects a snapshot in time.</strong></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/221#issuecomment-1068790582\">julien51 (Unlock Protocol) commented</a>:</strong></p>\n<blockquote>\n<p>The fact that this requires an explicit action by the lock manager (ie using a buggy/malicious ERC20 token) and that it puts only <em>their</em> tokens at risk, I think this is <code>minor</code>.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/221#issuecomment-1075664726\">0xleastwood (judge) decreased severity to Low and commented</a>:</strong></p>\n<blockquote>\n<p>Giving this a bit more thought, I think its always safe to enforce these checks rather than leave it up to the lock manage to potentially make the mistake and then be liable for this mistake later on. However, considering the threat model, I do think this is better suited as a <code>low</code> severity issue.</p>\n</blockquote>\n<h2 id=\"m-04-key-buyers-will-not-be-able-to-get-refund-if-lock-manager-withdraws-profits\" style=\"position:relative;\"><a href=\"#m-04-key-buyers-will-not-be-able-to-get-refund-if-lock-manager-withdraws-profits\" aria-label=\"m 04 key buyers will not be able to get refund if lock manager withdraws profits permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/50\">[M-04] Key buyers will not be able to get refund if lock manager withdraws profits</a></h2>\n<p><em>Submitted by kenzo</em></p>\n<p>Unlock contains a feature in which a key buyer can ask for a refund.\nThe refund is sent from the lock - where the purchase funds were sent.\nThe lock manager can withdraw all funds from the lock.\nTherefore, if the lock manager withdraws enough profits from the lock, the user would not be able to cancel his key and request refund.\nEven if a lock manager is not malicious, if he would want to enable users to cancel their key, he would have to keep track of how much tokens need to be kept in the contract in order to enable this - not a trivial calculation. A naive lock manager might accidentally disable refunds for his clients.</p>\n<h4 id=\"impact-1\" style=\"position:relative;\"><a href=\"#impact-1\" aria-label=\"impact 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h4>\n<p>Refunds are not guaranteed.\nA user might buy a key expecting to cancel it within some time, only to discover he can not cancel it. (This loss of user funds is why I consider this a high risk finding.)\nAn unaware lock manager who just wants to withdraw all his profits might accidentally discover that he removed his users’ ability to cancel their key.</p>\n<h4 id=\"notes\" style=\"position:relative;\"><a href=\"#notes\" aria-label=\"notes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Notes</h4>\n<p>It seems the Unlock team is aware to some extent that withdrawing breaks refunds, as they state in the <code>withdraw</code> function:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"\" data-index=\"5\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">   * TODO: consider allowing anybody to trigger this as long as it goes to owner anyway?</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">   *  -- however be wary of draining funds as it breaks the `cancelAndRefund` and `expireAndRefundFor`</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">   * use cases.</span></span></code></pre>\n<p>However, even if just the owner is allowed to call it, he may break the refund functionality - on purpose or accidentally.\nLooking on Unlock documentation I don’t see a warning to creators about withdrawing their funds.</p>\n<h4 id=\"proof-of-concept-5\" style=\"position:relative;\"><a href=\"#proof-of-concept-5\" aria-label=\"proof of concept 5 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h4>\n<p><code>withdraw</code> function has no limit on the amount withdrawn, therefore the owner can withdraw all funds:\n<a href=\"https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinLockCore.sol#L133:#L162\">https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinLockCore.sol#L133:#L162</a></p>\n<p><code>cancelAndRefund</code> transfers the funds from the same lock contract:\n<a href=\"https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinRefunds.sol#L118\">https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinRefunds.sol#L118</a>\nTherefore if there are not enough funds, the transfer will fail.</p>\n<h4 id=\"recommended-mitigation-steps-4\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-4\" aria-label=\"recommended mitigation steps 4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h4>\n<p>Perhaps a sort of MasterChef-like shares system can be implemented in order to make sure the owner leaves enough funds in the lock to process refunds.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/50#issuecomment-976135073\">julien51 (Unlock Protocol) disagreed with severity and commented</a>:</strong></p>\n<blockquote>\n<p>As noted, this is actually documented. You are right though that we should make this more obvious on the UI.\nI would not classify this as High Risk.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/50#issuecomment-1013832438\">0xleastwood (judge) decreased severity to Medium and commented</a>:</strong></p>\n<blockquote>\n<p>Nice find! I think this can be downgraded to <code>medium</code> as the availability of the protocol is impacted by this issue.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/50#issuecomment-1068791454\">julien51 (Unlock Protocol) commented</a>:</strong></p>\n<blockquote>\n<p>This would not affect the whole protocol but only the “malicious” lock and it is impractice not only documented but also how these things work in the real world. If Netflix went out of business tomorrow, I could not get a refund on this month’s membership fee…</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/50#issuecomment-1075662850\">0xleastwood (judge) commented</a>:</strong></p>\n<blockquote>\n<p>While I mostly agree with the sponsor, this may be intended behaviour as user’s should not be entitled to a refund in this case. However, based on what was known at the time, it seemed like this broke the functionality of <code>cancelAndRefund</code> and <code>expireAndRefundFor</code> functions, hence why it was marked as <code>medium</code> severity.</p>\n</blockquote>\n<h2 id=\"m-05-refund-mechanism-doesnt-take-into-account-that-key-price-can-change\" style=\"position:relative;\"><a href=\"#m-05-refund-mechanism-doesnt-take-into-account-that-key-price-can-change\" aria-label=\"m 05 refund mechanism doesnt take into account that key price can change permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/53\">[M-05] Refund mechanism doesn’t take into account that key price can change</a></h2>\n<p><em>Submitted by kenzo, also found by WatchPug and 0x0x0x</em></p>\n<p>Lock manager can change key pricing.\nThe refund mechanism calculates refund according to current key price, not price actually paid.</p>\n<h4 id=\"impact-2\" style=\"position:relative;\"><a href=\"#impact-2\" aria-label=\"impact 2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h4>\n<p>A user refunding can get less (or more) funds than deserved.</p>\n<h4 id=\"proof-of-concept-6\" style=\"position:relative;\"><a href=\"#proof-of-concept-6\" aria-label=\"proof of concept 6 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h4>\n<p>Refund only takes the current price into account:\n<a href=\"https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinRefunds.sol#L144:#L152\">https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinRefunds.sol#L144:#L152</a></p>\n<p>Lock manager can update key price at any point, and the old price is not saved anywhere:\n<a href=\"https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinLockCore.sol#L183\">https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinLockCore.sol#L183</a></p>\n<p>So if for example a key price has gone down, a user who tried to refund will get less funds than deserved.</p>\n<h4 id=\"recommended-mitigation-steps-5\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-5\" aria-label=\"recommended mitigation steps 5 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h4>\n<p>Consider saving the amount the user paid, and refund according to that.\nOr having a kind of a price snapshot/version mechanism.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/53#issuecomment-976137635\">julien51 (Unlock Protocol) acknowledged, but disagreed with severity and commented</a>:</strong></p>\n<blockquote>\n<p>This is a known issue… but indeed we should show things in the UI to indicate things to users.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/53#issuecomment-1013832674\">0xleastwood (judge) decreased severity to Medium and commented</a>:</strong></p>\n<blockquote>\n<p>Agree this sounds like an issue! However, I don’t think this can be justified as a <code>high</code> risk issue. But it does seem that the protocol could leak value and impact users, so marking this as <code>medium</code>.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/53#issuecomment-1068791889\">julien51 (Unlock Protocol) commented</a>:</strong></p>\n<blockquote>\n<p>We actually are adding a new mechanism to keep track of the last price paid by any user which means we could use it in the next version to solve this issue!</p>\n</blockquote>\n<h2 id=\"m-06-key-transfer-will-destroy-key-if-fromto\" style=\"position:relative;\"><a href=\"#m-06-key-transfer-will-destroy-key-if-fromto\" aria-label=\"m 06 key transfer will destroy key if fromto permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/87\">[M-06] Key transfer will destroy key if from==to</a></h2>\n<p><em>Submitted by kenzo, also found by GiveMeTestEther and cmichel</em></p>\n<p>If calling <code>transferFrom</code> with <code>_from == _recipient</code>, the key will get destroyed (meaning the key will be set as expired and set the owner’s key to be 0).</p>\n<h4 id=\"impact-3\" style=\"position:relative;\"><a href=\"#impact-3\" aria-label=\"impact 3 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h4>\n<p>A key manager or approved might accidentally destroy user’s token.</p>\n<p>Note: this requires user error and so I’m not sure if this is a valid finding.\nHowever, few things make me think that it is valid:</p>\n<ul>\n<li>Unlock protocol checks for transfer to 0-address, so some input validation is there</li>\n<li>Since other entities other than the owner can be allowed to transfer owner’s token, it might be best to make sure such accidental mistake could not happen.</li>\n<li>This scenario manifests a unique and probably unintended behavior</li>\n</ul>\n<h4 id=\"proof-of-concept-7\" style=\"position:relative;\"><a href=\"#proof-of-concept-7\" aria-label=\"proof of concept 7 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h4>\n<p>By following <code>transferFrom</code>’s execution:\n<a href=\"https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L109:#L166\">https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L109:#L166</a>\nOne can see that in the case where <code>_from == _recipient</code> with a valid key:</p>\n<ul>\n<li>The function will deduct transfer fee from the key</li>\n<li>The function will incorrectly add more time to the key’s expiration (<a href=\"https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L151\">L151</a>)</li>\n<li>The function will expire and reset the key (<a href=\"https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L155:#L158\">L155</a>)</li>\n</ul>\n<p>Therefore, the user will lose his key without getting a refund.</p>\n<h4 id=\"recommended-mitigation-steps-6\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-6\" aria-label=\"recommended mitigation steps 6 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h4>\n<p>Add a require statement in the beginning of <code>transferFrom</code>:\n<code>require(_from != _recipient, 'TRANSFER_TO_SELF');</code></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/87\">julien51 (Unlock Protocol) confirmed</a></strong></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/87#issuecomment-1068792003\">julien51 (Unlock Protocol) commented</a>:</strong></p>\n<blockquote>\n<p>Fixed since then :)</p>\n</blockquote>\n<h2 id=\"m-07-mixinpurchasesharekey-allows-to-generate-keys-without-purchasing\" style=\"position:relative;\"><a href=\"#m-07-mixinpurchasesharekey-allows-to-generate-keys-without-purchasing\" aria-label=\"m 07 mixinpurchasesharekey allows to generate keys without purchasing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/242\">[M-07] MixinPurchase:shareKey allows to generate keys without purchasing</a></h2>\n<p><em>Submitted by GiveMeTestEther, also found by kenzo</em></p>\n<p>The <code>shareKey</code> function allows a user to share some time with another user that doesn’t already has/had a key and this generates a new key. This even allows the user to generate more keys than <code>\\_maxNumberOfKeys</code>.</p>\n<p>Attacker generates a lot of EOA addresses, buys a key, share the minimum necessary time with each address and in each “sharing” a new key gets generated. This allows cheaply to allocate alot of “keys” with out really purchasing them and a lot of user can’t get a “key” because purchase has a modifier notSoldOut, that limits the max purchasable to “keys” to <code>maxNumberOfKeys</code></p>\n<h4 id=\"proof-of-concept-8\" style=\"position:relative;\"><a href=\"#proof-of-concept-8\" aria-label=\"proof of concept 8 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h4>\n<p>Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.</p>\n<h4 id=\"tools-used\" style=\"position:relative;\"><a href=\"#tools-used\" aria-label=\"tools used permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tools Used</h4>\n<p>Manual Analysis</p>\n<h4 id=\"recommended-mitigation-steps-7\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-7\" aria-label=\"recommended mitigation steps 7 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h4>\n<ul>\n<li>rethink the whole <code>shareKey</code> thingy,</li>\n</ul>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/242#issuecomment-979648865\">julien51 (Unlock Protocol) acknowledged and commented</a>:</strong></p>\n<blockquote>\n<p>I am not sure this is a bug or even a risk.\nSomeone could actually achieve the same thing by purchasing keys at the full price and cancelling them immediately getting an almost full refund (or even full refund when there is a free trial) and could quickly get the lock to “sell out”.\nIt is actually the case with any NFT project where there is a cap/limit to number of tokens and someone can easily “Capture” them all.</p>\n<p>One way to limit the impact for the lock manager would be to set a cancellation penalty AND a transfer fee.  </p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/242#issuecomment-1013834438\">0xleastwood (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Nice find! While I understand what the sponsor is saying, this does seem like a valid way to deny a lock from selling membership to honest users.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/242#issuecomment-1068792488\">julien51 (Unlock Protocol) commented</a>:</strong></p>\n<blockquote>\n<p>Note that a lock manager can easily increase supply to mitigate that (and even could <em>delete</em> existing keys/NFT to reduce the outstanding supply)</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/242#issuecomment-1075656944\">0xleastwood (judge) commented</a>:</strong></p>\n<blockquote>\n<p>While the lock manager can restore the contract to some valid state, this will still impact protocol availability, even in the short-term.</p>\n</blockquote>\n<h2 id=\"m-08-frontrunning-publiclockinitialize-can-prevent-upgrades-due-to-insufficient-access-control\" style=\"position:relative;\"><a href=\"#m-08-frontrunning-publiclockinitialize-can-prevent-upgrades-due-to-insufficient-access-control\" aria-label=\"m 08 frontrunning publiclockinitialize can prevent upgrades due to insufficient access control permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/132\">[M-08] Frontrunning <code>PublicLock.initialize()</code> can prevent upgrades due to insufficient access control</a></h2>\n<p><em>Submitted by elprofesor, also found by kenzo</em></p>\n<p>The unlock protocols base contract <code>Unlock.sol</code> uses <code>setLocktemplate()</code> to initialize the implementation contract for the <code>PublicLock</code> proxy. This function will initialize the relevant <code>PublicLock</code> contract which has been deployed separately. <code>PublicLock.initialize()</code> does not have any relevant access control and does not prevent arbitrary users from initialising. This means that a malicious user could front run the <code>setLocktemplate()</code> forcing the deployer of <code>PublicLock</code>’s implementation to redeploy. The process can be repeated, which costs the malicious user less than it would the owner of the Unlock Protocol, potentially unnecessarily draining funds from the development team.</p>\n<h4 id=\"proof-of-concept-9\" style=\"position:relative;\"><a href=\"#proof-of-concept-9\" aria-label=\"proof of concept 9 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h4>\n<p><a href=\"https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/PublicLock.sol#L42-L51\">Lack of access control on initialize</a></p>\n<h4 id=\"recommended-mitigation-steps-8\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-8\" aria-label=\"recommended mitigation steps 8 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h4>\n<p>Implement valid access control on the <code>PublicLock</code> contract to ensure only the relevant deployer can <code>initialize()</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/132\">julien51 (Unlock Protocol) disagreed with severity</a></strong></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/132#issuecomment-1075675604\">0xleastwood (judge) commented</a>:</strong></p>\n<blockquote>\n<p>I agree with the warden, <code>_publicLockAddress</code> is deployed separately and hence <code>initialize</code> can be called before <code>setLockTemplate</code> is called.</p>\n</blockquote>\n<h2 id=\"m-09-referrer-discount-token-amount-can-be-manipulated\" style=\"position:relative;\"><a href=\"#m-09-referrer-discount-token-amount-can-be-manipulated\" aria-label=\"m 09 referrer discount token amount can be manipulated permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/155\">[M-09] Referrer discount token amount can be manipulated</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The <code>Unlock.recordKeyPurchase</code> function is called on each key purchase (<code>MixinPurchase.purchase</code>) and mints UDT tokens to the referrer.\nThe amount to mint is based on the transaction’s gas price which is controlled by the caller (purchaser):</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"6\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">tokensToDistribute</span><span class=\"mtk1\"> = (</span><span class=\"mtk12\">estimatedGasForPurchase</span><span class=\"mtk1\"> * </span><span class=\"mtk12\">tx</span><span class=\"mtk1\">.</span><span class=\"mtk12\">gasprice</span><span class=\"mtk1\">) * (</span><span class=\"mtk7\">125</span><span class=\"mtk1\"> * </span><span class=\"mtk7\">10</span><span class=\"mtk1\"> ** </span><span class=\"mtk7\">18</span><span class=\"mtk1\">) / </span><span class=\"mtk7\">100</span><span class=\"mtk1\"> / </span><span class=\"mtk12\">udtPrice</span><span class=\"mtk1\">;</span></span></span></code></pre>\n<h4 id=\"impact-4\" style=\"position:relative;\"><a href=\"#impact-4\" aria-label=\"impact 4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h4>\n<p>Tokens can be minted by purchasing a key with themself as the referrer at a high transaction gas price.\nDepending on the UDT price on external markets, it could be profitable to buy a key at a high gas price, receive UDT and then sell them on a market for a profit.</p>\n<h4 id=\"recommended-mitigation-steps-9\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-9\" aria-label=\"recommended mitigation steps 9 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h4>\n<p>The amount minted should be more predictable and not depend on the user’s gas price input.\nConsider declaring an <em>average gas price</em> storage variable that is set by a trusted party and use this one instead.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/155#issuecomment-991691106\">julien51 (Unlock Protocol) disagreed with severity and commented</a>:</strong></p>\n<blockquote>\n<blockquote>\n<p>Depending on the UDT price on external markets, it could be profitable to buy a key at a high gas price, receive UDT and then sell them on a market for a profit.</p>\n</blockquote>\n<p>Since we get the token price from the Uniswap oracle, the amount of tokens received is always at most equal to what they would have spent to acquire them on Uniswap.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/155#issuecomment-1013842955\">0xleastwood (judge) commented</a>:</strong></p>\n<blockquote>\n<p>As the uniswap oracle provides averaged price data, if there is any discrepancy between the spot price and the TWAP price, this can definitely be abused to extract value from the protocol. Keeping this as <code>medium</code>.</p>\n</blockquote>\n<h2 id=\"m-10-inaccurate-fees-computation\" style=\"position:relative;\"><a href=\"#m-10-inaccurate-fees-computation\" aria-label=\"m 10 inaccurate fees computation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/165\">[M-10] Inaccurate fees computation</a></h2>\n<p><em>Submitted by cmichel, also found by 0x0x0x</em></p>\n<p>The <code>MixinTransfer.shareKey</code> function wants to compute a fee such that <code>time + fee * time == timeRemaining (timePlusFee)</code>:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"7\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">fee</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">getTransferFee</span><span class=\"mtk1\">(</span><span class=\"mtk12\">keyOwner</span><span class=\"mtk1\">, </span><span class=\"mtk12\">_timeShared</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">timePlusFee</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_timeShared</span><span class=\"mtk1\"> + </span><span class=\"mtk12\">fee</span><span class=\"mtk1\">;</span></span></span></code></pre>\n<p>However, if the time remaining is less than the computed fee time, <strong>the computation changes and a different formula is applied</strong>.\nThe fee is now simply taken on the remaining time.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"8\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">if</span><span class=\"mtk1\">(</span><span class=\"mtk12\">timePlusFee</span><span class=\"mtk1\"> &lt; </span><span class=\"mtk12\">timeRemaining</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk3\">// now we can safely set the time</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">time</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_timeShared</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk3\">// deduct time from parent key, including transfer fee</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk11\">_timeMachine</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_tokenId</span><span class=\"mtk1\">, </span><span class=\"mtk12\">timePlusFee</span><span class=\"mtk1\">, </span><span class=\"mtk4\">false</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">} </span><span class=\"mtk15\">else</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk3\">// we have to recalculate the fee here</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">fee</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">getTransferFee</span><span class=\"mtk1\">(</span><span class=\"mtk12\">keyOwner</span><span class=\"mtk1\">, </span><span class=\"mtk12\">timeRemaining</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk3\">// @audit want it such that time + fee * time == timeRemaining, but fee is taken on timeRemaining instead of time</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">time</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">timeRemaining</span><span class=\"mtk1\"> - </span><span class=\"mtk12\">fee</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p>It should compute the <code>time</code> without fee as <code>time = timeRemaining / (1.0 + fee_as_decimal)</code> instead, i.e., <code>time = BASIS_POINTS_DEN * timeRemaining / (transferFeeBasisPoints + BASIS_POINTS_DEN)</code>.</p>\n<h4 id=\"proof-of-concept-10\" style=\"position:relative;\"><a href=\"#proof-of-concept-10\" aria-label=\"proof of concept 10 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof Of Concept</h4>\n<p>To demonstrate the difference with a 10% fee and a <code>_timeShared = 10,000s</code> which should be credited to the <code>to</code> account.</p>\n<p>The correct time plus fee which is reduced from <code>from</code> (as in the <code>timePlusFee &#x3C; timeRemaining</code> branch) would be <code>10,000 + 10% * 10,000 = 11,000</code>.</p>\n<p>However, if <code>from</code> has not enough time remaining and <code>timePlusFee >= timeRemaining</code>, the entire time remaining is reduced from <code>from</code> but the credited <code>time</code> is computed wrongly as:\n(Let’s assume <code>timeRemaining == timePlusFee</code>): <code>time = 11,000 - 10% * 11,000 = 11,000 - 1,100 = 9900</code>.</p>\n<p>They would receive 100 seconds less than what they are owed.</p>\n<h4 id=\"impact-5\" style=\"position:relative;\"><a href=\"#impact-5\" aria-label=\"impact 5 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h4>\n<p>When transferring more time than the <code>from</code> account has, the credited time is scaled down wrongly and the receiver receives less time (a larger fee is applied).</p>\n<h4 id=\"recommended-mitigation-steps-10\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-10\" aria-label=\"recommended mitigation steps 10 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h4>\n<p>It should change the first <code>if</code> branch condition to <code>timePlusFee &#x3C;= timeRemaining</code> (less than or equal).\nIn the <code>else</code> branch, it should compute the time without fee as <code>time = BASIS_POINTS_DEN * timeRemaining / (transferFeeBasisPoints + BASIS_POINTS_DEN)</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/165#issuecomment-991683180\">julien51 (Unlock Protocol) confirmed and commented</a>:</strong></p>\n<blockquote>\n<p>Great find!</p>\n</blockquote>\n<h2 id=\"m-11-missing-scaling-factor-in-recordkeypurchase\" style=\"position:relative;\"><a href=\"#m-11-missing-scaling-factor-in-recordkeypurchase\" aria-label=\"m 11 missing scaling factor in recordkeypurchase permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/156\">[M-11] Missing scaling factor in <code>recordKeyPurchase</code>?</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The <code>Unlock.recordKeyPurchase</code> function computes the <code>maxTokens</code> as:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"9\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">maxTokens</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">IMintableERC20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">udt</span><span class=\"mtk1\">).</span><span class=\"mtk11\">balanceOf</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">)) * </span><span class=\"mtk12\">valueInETH</span><span class=\"mtk1\"> / (</span><span class=\"mtk7\">2</span><span class=\"mtk1\"> + </span><span class=\"mtk7\">2</span><span class=\"mtk1\"> * </span><span class=\"mtk12\">valueInETH</span><span class=\"mtk1\"> / </span><span class=\"mtk12\">grossNetworkProduct</span><span class=\"mtk1\">) / </span><span class=\"mtk12\">grossNetworkProduct</span><span class=\"mtk1\">;</span></span></span></code></pre>\n<p>Note that <code>grossNetworkProduct</code> was already increased by <code>valueInETH</code> in the code before.\nMeaning, the <code>(2 + 2 * valueInETH / grossNetworkProduct)</code> part of the computation will almost always be <code>2</code> as usually <code>grossNetworkProduct > 2 * valueInETH</code>, and thus the <code>2 * valueInETH / grossNetworkProduct</code> is zero by integer division.</p>\n<h4 id=\"impact-6\" style=\"position:relative;\"><a href=\"#impact-6\" aria-label=\"impact 6 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h4>\n<p>The <code>maxTokens</code> curve might not be computed as intended and lead to being able to receive more token rewards than intended.</p>\n<h4 id=\"recommended-mitigation-steps-11\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-11\" aria-label=\"recommended mitigation steps 11 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h4>\n<p>The comment “we distribute tokens using asymptotic curve between 0 and 0.5” should be more clear to indicate how exactly the curve looks like.\nIt could be that a floating-point number was desired instead of the integer division in <code>2 * valueInETH / grossNetworkProduct</code>. In that case, consider adding a scaling factor to this term and divide by it at the end of the computation again.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/156#issuecomment-991690466\">julien51 (Unlock Protocol) commented</a>:</strong></p>\n<blockquote>\n<p>I am not fully sure I understand what the problem is here?</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/156#issuecomment-1013844481\">0xleastwood (judge) commented</a>:</strong></p>\n<blockquote>\n<p>I think the warden is raising an issue where <code>2 * valueInEth / grossNetworkProduct</code> will more than likely truncate and return <code>0</code>. I think this is a valid finding.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/156#issuecomment-1068793080\">julien51 (Unlock Protocol) commented</a>:</strong></p>\n<blockquote>\n<p>Hum, we did some tests and could not reproduce here.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/156#issuecomment-1075696998\">0xleastwood (judge) commented</a>:</strong></p>\n<blockquote>\n<p>I’m not sure how <code>2 * valueInETH / grossNetworkProduct</code> does not always lead to some truncation. <code>grossNetworkProduct</code> is equal to <code>valueInETH</code> in the first call but always greater than <code>valueInETH</code> in any subsequent calls.</p>\n</blockquote>\n<h2 id=\"m-12-missing-maxnumberofkeys-checks-in-sharekey-and-grantkey\" style=\"position:relative;\"><a href=\"#m-12-missing-maxnumberofkeys-checks-in-sharekey-and-grantkey\" aria-label=\"m 12 missing maxnumberofkeys checks in sharekey and grantkey permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/55\">[M-12] Missing maxNumberOfKeys checks in shareKey and grantKey</a></h2>\n<p><em>Submitted by kenzo</em></p>\n<p>More keys can be minted than maxNumberOfKeys since <code>shareKey</code> and <code>grantKey</code> do not check if the lock is sold out.</p>\n<h4 id=\"impact-7\" style=\"position:relative;\"><a href=\"#impact-7\" aria-label=\"impact 7 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h4>\n<p>More keys can be minted than intended.</p>\n<h4 id=\"proof-of-concept-11\" style=\"position:relative;\"><a href=\"#proof-of-concept-11\" aria-label=\"proof of concept 11 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h4>\n<p>In both <code>shareKey</code> and <code>grantKey</code>, if minting a new token, a new token is simply minted (and <code>_totalSupply</code> increased) without checking it against <code>maxNumberOfKeys</code>.\nThis is unlike <code>purchase</code>, which has the <code>notSoldOut</code> modifier.</p>\n<p><code>grantKey</code>:\n<a href=\"https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinGrantKeys.sol#L41:#L42\">https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinGrantKeys.sol#L41:#L42</a></p>\n<p><code>shareKey</code>:\n<a href=\"https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L83:#L84\">https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L83:#L84</a>\nBoth functions call <code>_assignNewTokenId</code> which does not check maxNumberOfKeys.</p>\n<p><a href=\"https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinKeys.sol#L311:#L322\">https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinKeys.sol#L311:#L322</a>\nSo you can say that <code>_assignNewTokenId</code> is actually the root of the error, and this is why I am submitting this as 1 finding and not 2 (for grantKey/shareKey).</p>\n<h4 id=\"recommended-mitigation-steps-12\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-12\" aria-label=\"recommended mitigation steps 12 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h4>\n<p>Add a check to <code>_assignNewTokenId</code> that will revert if we need to record a new key and <code>maxNumberOfKeys</code> has been reached.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/55#issuecomment-1004066282\">julien51 (Unlock Protocol) confirmed and commented</a>:</strong></p>\n<blockquote>\n<p>This is actually intentional. We want the lock manager to be able to grant keys even if the lock is sold out. Note that the lock manager could also increase the supply if they needed anyway.\nHowever, we should take that into account in the <code>shareKey</code> flow so I’ll mark as confirmed for that flow.</p>\n</blockquote>\n<h2 id=\"m-13-malicious-user-can-get-infinite-free-trial-by-repeatedly-refund-and-repurchase-right-before-the-freetrial-ends\" style=\"position:relative;\"><a href=\"#m-13-malicious-user-can-get-infinite-free-trial-by-repeatedly-refund-and-repurchase-right-before-the-freetrial-ends\" aria-label=\"m 13 malicious user can get infinite free trial by repeatedly refund and repurchase right before the freetrial ends permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/189\">[M-13] Malicious user can get infinite free trial by repeatedly refund and repurchase right before the freeTrial ends</a></h2>\n<p><em>Submitted by WatchPug</em></p>\n<p>The current design/implementation allows users who are refunded before to get another <code>freeTrial</code>. This can be exploited by malicious users to get an infinite free trial.</p>\n<h4 id=\"proof-of-concept-12\" style=\"position:relative;\"><a href=\"#proof-of-concept-12\" aria-label=\"proof of concept 12 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h4>\n<p>Given:</p>\n<ul>\n<li><code>keyPrice</code> is 1 ETH;</li>\n<li><code>freeTrialLength</code> is 31 days.</li>\n</ul>\n<p>A malicious user can:</p>\n<ol>\n<li>Call <code>purchase()</code>, pay 1 ETH and get 31 days of <code>freeTrial</code> on day 1;</li>\n<li>Call <code>cancelAndRefund()</code> on day 30 and get 1 ETH of refund; then call <code>purchase()</code> again, pay 1 ETH and get 31 days of <code>freeTrial</code> again.</li>\n</ol>\n<p>Repeat the steps above and the user can get infinite <code>freeTrial</code>.</p>\n<h4 id=\"impact-8\" style=\"position:relative;\"><a href=\"#impact-8\" aria-label=\"impact 8 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h4>\n<p>A malicious third party may provide a service named <code>freeUnlock</code>, which will call <code>cancelAndRefund()</code> and <code>purchase()</code> automatically right before the end of the <code>freeTrial</code>. This can cause fund loss to all the owners that provide a <code>freeTrial</code>.</p>\n<h4 id=\"recommendation-3\" style=\"position:relative;\"><a href=\"#recommendation-3\" aria-label=\"recommendation 3 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommendation</h4>\n<p>Consider adding a <code>mapping(address => uint256) freeTrialEnds</code> and make sure each address can only get 1 <code>freeTrial</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/189#issuecomment-979654912\">julien51 (Unlock Protocol) disputed and commented</a>:</strong></p>\n<blockquote>\n<p>Isn’t that the case with every free trial system?\nIf they use the same address the lock manager could easily use the hook system to keep track of who already had received a  full refund and not grant it on the 2nd cancellation.\nThe user could still use new addresses all the time, and in that case that would be valid, but that is actually the case with a lot of systems like that :)\nOne of my roommates in college was just subscribing to newspaper and getting the full risk-free refund by using a different name every time (but used the same address)</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/189#issuecomment-1013831584\">0xleastwood (judge) commented</a>:</strong></p>\n<blockquote>\n<p>While I agree with the warden, there is potential for unlimited free trials. Limiting a free trial to a single address does not resolve the issue as an attacker can generate any number of addresses from a single seed. However, I do understand this is a tricky issue to workaround. </p>\n<p>So I’m not sure how this should be treated as it does affect how the protocol is intended to operate. Is there any reason for users to not abuse this @julien51 ? Typically with newspapers, you have to provide credit card details, so an individual is really limited by the number of cards they hold.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/189#issuecomment-1014073979\">julien51 (Unlock Protocol) commented</a>:</strong></p>\n<blockquote>\n<p>As you noted, there is <em>no way</em> to prevent free trials from being abused which is why by default, locks do <em>not</em> have a free trial: they have to be manually explicitly configured. From there, since it’s trivial to just create an infinite number of accounts, anyone could just claim free trials over and over from new accounts.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/189#issuecomment-1014093336\">0xleastwood (judge) decreased severity to Medium and commented</a>:</strong></p>\n<blockquote>\n<p>As per sponsor, trials are not enabled by default. But seeing as this impacts protocol availability through abuse if enabled. I’ll mark this as <code>medium</code>.</p>\n</blockquote>\n<h2 id=\"m-14-mixinrefunds-frontrun-updatekeypricing-for-free-profit\" style=\"position:relative;\"><a href=\"#m-14-mixinrefunds-frontrun-updatekeypricing-for-free-profit\" aria-label=\"m 14 mixinrefunds frontrun updatekeypricing for free profit permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/72\">[M-14] MixinRefunds: frontrun updateKeyPricing() for free profit</a></h2>\n<p><em>Submitted by itsmeSTYJ</em></p>\n<p>A malicious user is able to withdraw all payments that were paid to a lock owner if the owner increases the keyPrice.</p>\n<h4 id=\"proof-of-concept-13\" style=\"position:relative;\"><a href=\"#proof-of-concept-13\" aria-label=\"proof of concept 13 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h4>\n<p>When <code>updateKeyPricing()</code> is called to increase the price of a key, it is possible to frontrun this call and buy many keys at the cheaper price then request for a refund at the higher price.</p>\n<h4 id=\"recommendation-4\" style=\"position:relative;\"><a href=\"#recommendation-4\" aria-label=\"recommendation 4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommendation</h4>\n<p>Keep track of the price at which keys are purchased so that when you issue a refund, you use the original keyPrice to refund instead of the updated keyPrice</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/72#issuecomment-1004133079\">julien51 (Unlock Protocol) acknowledged, but disagreed with High severity and commented</a>:</strong></p>\n<blockquote>\n<p>This is only true for locks where there is no penalty. We should make it clear on the front-end that when changing the price it is recommended to set up a penalty (at least temporarily) for the price difference so that no key can be refunded for the full price.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/72#issuecomment-1075679839\">0xleastwood (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Circling back on this, I’m not sure how a penalty would be correctly applied to all locks. Wouldn’t users who wanted to get a refund for their key get penalised if they purchase after the change in key price? I think it would also be safer to update the key price and apply the penalty in the one transaction.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/72#issuecomment-1004133079\">julien51 (Unlock Protocol) commented</a>:</strong></p>\n<blockquote>\n<p>I think that is a good finding, but there again (like often) I think this is pretty edgy.\nThe cancellation penalty is pretty easy to apply just to a single lock from the <a href=\"https://github.com/unlock-protocol/unlock/blob/b7c5a555efc3c2be619cbb942eb67d4008baa049/smart-contracts/contracts/mixins/MixinRefunds.sol#L70\">lock manager’s perspective</a>. Before changing the lock price, a lock manager can easily apply a penalty for the difference in price. IE if I change the price from 10 to 12, I apply a penalty for 2 and anyone who tries to abuse this will only get a refund of 12-2 = 10.</p>\n<p>On top of that we’re actually storing the amount paid for the latest key as part of our next upgrade to support automatically recurring memberships, which should make things even more robust as anyone will only get re-imbursed based on what they paid…</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/72#issuecomment-1075679839\">0xleastwood (judge) decreased severity to Medium and commented</a>:</strong></p>\n<blockquote>\n<p>Considering the sponsor’s comments and after some further discussion on Discord. I think it is more correct to downgrade this to <code>medium</code> severity. While it isn’t clear, the lock manager is expected to apply a penalty before updating the cost of a membership such that users cannot game the price difference. However, this isn’t enforced on-chain or documented anywhere so based on the judge’s and warden’s context at the time, this seemed like a valid <code>high</code> severity issue. It is important to note that users who refund their membership after purchasing a membership post price change will be refunded less than users who purchased their memberships before the price change. The sponsor is looking to integrate these fixes in their next upgrade.</p>\n</blockquote>\n<h1 id=\"low-risk-findings-32\" style=\"position:relative;\"><a href=\"#low-risk-findings-32\" aria-label=\"low risk findings 32 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Low Risk Findings (32)</h1>\n<ul>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/133\">[L-01] <code>Unlock.addLockTemplate</code> does not adequately increment version, leading to gaps in version</a> <em>Submitted by elprofesor, also found by loop, pauliax, 0x0x0x, and harleythedog</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/134\">[L-02] Insufficient version validation causes denial of service for <code>PublicLock</code> during lock upgrades</a> <em>Submitted by elprofesor</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/62\">[L-03] MixinGrantKeys:grantKeys possible DoS with (Unexpected) revert</a> <em>Submitted by GiveMeTestEther</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/161\">[L-04] No ERC20 safeApprove called &#x26; not success check</a> <em>Submitted by cmichel, also found by Reigada and 0x0x0x</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/151\">[L-05] MixinLockCore: use safeApprove from SafeERC20, and do approve(0) before approve(amount)</a> <em>Submitted by GiveMeTestEther</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/140\">[L-06] getTransferFee() Fee Could Be 0</a> <em>Submitted by Meta0xNull</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/29\">[L-07] The function MixinLockCore.approveBeneficiary is susceptible to a race condition</a> <em>Submitted by Ruhum</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/136\">[L-08] Unlock has incomplete fallback function which may cause loss of funds</a> <em>Submitted by elprofesor</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/153\">[L-09] <code>initialize</code> functions can be frontrun</a> <em>Submitted by cmichel, also found by WatchPug</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/223\">[L-10] _cancelAndRefund is not protected from re-entrancy</a> <em>Submitted by pauliax</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/52\">[L-11] setKeyManagerOf has no address-0 check</a> <em>Submitted by kenzo</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/230\">[L-12] Distribution of tokens in recordKeyPurchase</a> <em>Submitted by pauliax</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/120\">[L-13] a single user can become owner of multiple token ids</a> <em>Submitted by GiveMeTestEther</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/117\">[L-14] Setting the admin in initialize initializeProxyAdmin can be frontrun by an attacker</a> <em>Submitted by Jujic</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/27\">[L-15] Scenario where variable in Unlock.recordKeyPurchase() is not initialized</a> <em>Submitted by Ruhum</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/174\">[L-16] Consider adding storage gaps to <code>Mixin***</code> contracts</a> <em>Submitted by WatchPug</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/154\">[L-17] Lock template versions can be overwritten</a> <em>Submitted by cmichel</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/158\">[L-18] Can set arbitrary lock templates</a> <em>Submitted by cmichel</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/163\">[L-19] DoS when <code>onKeyPurchaseHook</code> reverts</a> <em>Submitted by cmichel</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/170\">[L-20]  PREVENT DIV BY 0</a> <em>Submitted by defsec</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/85\">[L-21] Confliction on double <code>initialize</code> functions front-run <code>minter</code> </a> <em>Submitted by hagrid</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/74\">[L-22] Unimplemented function computeAvailableDiscountFor </a> <em>Submitted by harleythedog</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/3\">[L-23] Unused function parameters </a> <em>Submitted by jayjonah8</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/84\">[L-24] Wrong event parameter emitted at _setKeyManagerOf</a> <em>Submitted by kenzo</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/43\">[L-25] Potential division by 0 in <code>recordKeyPurchase</code></a> <em>Submitted by loop</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/45\">[L-26] Function spec and implementation difference / strict comparison</a> <em>Submitted by loop</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/220\">[L-27] msg.value should be 0 when token is not native</a> <em>Submitted by pauliax</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/222\">[L-28] tokenByIndex returns wrong token id</a> <em>Submitted by pauliax</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/224\">[L-29] Interface and implementation differ</a> <em>Submitted by pauliax</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/225\">[L-30] onKeyPurchase hook expects amount + discount</a> <em>Submitted by pauliax</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/228\">[L-31] Validations</a> <em>Submitted by pauliax</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/187\">[L-32] <code>MixinRefunds.sol#cancelAndRefund()</code> Potential fund loss on <code>cancelAndRefund()</code> for users who purchased multiple times</a> <em>Submitted by WatchPug, also found by GiveMeTestEther</em></li>\n</ul>\n<h1 id=\"non-critical-findings-54\" style=\"position:relative;\"><a href=\"#non-critical-findings-54\" aria-label=\"non critical findings 54 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Non-Critical Findings (54)</h1>\n<ul>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/109\">[N-01] Use safeTransfer consistently instead of transfer</a> <em>Submitted by Jujic</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/96\">[N-02] <code>freeTrialLength</code> is used as full refund period</a> <em>Submitted by 0x0x0x</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/22\">[N-03] Open TODOs</a> <em>Submitted by mics, also found by Meta0xNull, loop, pauliax, ye0lde, hagrid, and defsec</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/147\">[N-04] Function grantKeys() - Bulk Send Free Keys Are Not Practical &#x26; Gas May Over Block Size Limit</a> <em>Submitted by Meta0xNull</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/157\">[N-05] ERC20 return values not checked</a> <em>Submitted by cmichel</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/215\">[N-06] Unable to change token approval when tokenAddress changed</a> <em>Submitted by gzeon</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/77\">[N-07] input validation</a> <em>Submitted by sabtikw</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/83\">[N-08] Input validation of Zero address on addLockTemplate</a> <em>Submitted by BouSalman</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/86\">[N-09] Input validation of Zero address on function initialize()</a> <em>Submitted by BouSalman</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/81\">[N-10] Input validation Zero address</a> <em>Submitted by BouSalman</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/171\">[N-11] Insufficient input validation</a> <em>Submitted by WatchPug</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/105\">[N-12] Missing input validation on array lengths (MixinGrantKeys.sol)</a> <em>Submitted by ye0lde</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/169\">[N-13] transferOwnership should be two step process</a> <em>Submitted by defsec, also found by Meta0xNull</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/14\">[N-14] USE OF DEPRECATED _SETUPROLE FUNCTION</a> <em>Submitted by Reigada</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/15\">[N-15] USE OF FLOATING PRAGMA</a> <em>Submitted by Reigada, also found by jayjonah8</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/32\">[N-16] MixinERC721Enumerable.tokenOfOwnerByIndex - parameter _index can be removed</a> <em>Submitted by Reigada</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/204\">[N-17] Missing events for critical operations</a> <em>Submitted by WatchPug</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/1\">[N-18] Initializer modifiers should be called in the same way everywhere </a> <em>Submitted by jayjonah8</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/82\">[N-19] Wrong comment in recordKeyPurchase</a> <em>Submitted by kenzo</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/212\">[N-20] Inconsistent code and comment</a> <em>Submitted by gzeon</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/122\">[N-21] MixinLockCore.sol has wrong comments</a> <em>Submitted by GiveMeTestEther</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/208\">[N-22] Incorrect or confusing comments or missing code in tokenOfOwnerByIndex</a> <em>Submitted by ye0lde</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/20\">[N-23] named return issue</a> <em>Submitted by mics</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/21\">[N-24] safeApprove is deprecated. </a> <em>Submitted by mics</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/37\">[N-25] Use explicit variables type</a> <em>Submitted by BouSalman</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/5\">[N-26] Function type from public to external</a> <em>Submitted by BouSalman</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/75\">[N-27] Missing event for critical updateBeneficiary function</a> <em>Submitted by BouSalman</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/76\">[N-28] Function type from public to external tokenByIndex()</a> <em>Submitted by BouSalman</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/128\">[N-29] Fix event params for <code>KeyManagerChanged</code></a> <em>Submitted by HardlyDifficult</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/131\">[N-30] Reduce rounding error when minting UDT in Unlock</a> <em>Submitted by HardlyDifficult</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/91\">[N-31] shareKey onERC721Received tokenId</a> <em>Submitted by HardlyDifficult</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/94\">[N-32] Remove fallback function</a> <em>Submitted by HardlyDifficult</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/25\">[N-33] Unnecessary function parameter in Unlock.upgradeLock() function</a> <em>Submitted by Ruhum</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/28\">[N-34] Changes that affect access control should be accompanied by an event</a> <em>Submitted by Ruhum</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/173\">[N-35] Constants are not explicitly declared</a> <em>Submitted by WatchPug</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/184\">[N-36] Code Style: Unnecessary public function visibility</a> <em>Submitted by WatchPug</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/193\">[N-37] Consider adding <code>initializer</code> modifier to _initialize** functions</a> <em>Submitted by WatchPug</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/197\">[N-38] Incomplete implementation</a> <em>Submitted by WatchPug</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/198\">[N-39] <code>MixinPurchase#purchase()</code> Consider checking if _referrer equals _recipient</a> <em>Submitted by WatchPug</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/202\">[N-40] Race condition on ERC20 approval</a> <em>Submitted by WatchPug</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/205\">[N-41] Typos</a> <em>Submitted by WatchPug</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/207\">[N-42] Critical changes should use two-step procedure</a> <em>Submitted by WatchPug</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/11\">[N-43] Order of layout is wrong in ERC20Patched.sol</a> <em>Submitted by aga7hokakological</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/9\">[N-44] Order of function is wrong in contracts ERC20PermitUpgradeable, ERC20VotesCompUpgradeable, EIP712Upgradeable</a> <em>Submitted by aga7hokakological</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/78\">[N-45] Missing <code>_beforeTokenTransfer</code> Token Transfer Handle</a> <em>Submitted by hagrid</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/137\">[N-46] Initialization parameters of new lock template are hardcoded</a> <em>Submitted by kenzo</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/90\">[N-47] Unconventional log emittance confuses Etherscan</a> <em>Submitted by kenzo</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/46\">[N-48] Commented lines of code</a> <em>Submitted by loop</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/48\">[N-49] Use of access control require statement when modifier exists</a> <em>Submitted by loop</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/56\">[N-50] grantKeys no check on parameter array lengths and values</a> <em>Submitted by nathaniel</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/231\">[N-51] Store owners in EnumerableSet</a> <em>Submitted by pauliax</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/115\">[N-52] <code>== true</code> doesn’t bring anything</a> <em>Submitted by 0x0x0x</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/146\">[N-53] Avoiding Initialization of Loop Index If It Is 0</a> <em>Submitted by Meta0xNull</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/12\">[N-54] Upgrade pragma to at least 0.8.4</a> <em>Submitted by defsec</em></li>\n</ul>\n<h1 id=\"gas-optimizations-48\" style=\"position:relative;\"><a href=\"#gas-optimizations-48\" aria-label=\"gas optimizations 48 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Gas Optimizations (48)</h1>\n<ul>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/123\">[G-01] MixinTransfer:getTransferFee gas optimization with unchecked</a> <em>Submitted by GiveMeTestEther</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/101\">[G-02] Setters of <code>UnlockProtocolGovernor.sol</code> can be implemented more efficiently</a> <em>Submitted by 0x0x0x</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/103\">[G-03] Cache length at for loop to save gas</a> <em>Submitted by 0x0x0x</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/110\">[G-04] <code>MixinGrantKeys.sol</code> apply requiere statements earlier</a> <em>Submitted by 0x0x0x</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/111\">[G-05] Use unchecked operation to save gas</a> <em>Submitted by 0x0x0x</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/116\">[G-06] 4 variables are cached and used only once at <code>Unlock.sol#upgradeLock</code></a> <em>Submitted by 0x0x0x</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/98\">[G-07] <code>UnlockUtils.sol#address2Str</code> can be implemented much cheaper</a> <em>Submitted by 0x0x0x</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/4\">[G-08] Unnecessary fallback function</a> <em>Submitted by BouSalman</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/203\">[G-09] Adding unchecked directive can save gas</a> <em>Submitted by WatchPug, also found by GiveMeTestEther, mics, and pauliax</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/149\">[G-10] MixinGrantKeys:grantKeys gas optimizations</a> <em>Submitted by GiveMeTestEther, also found by Reigada and defsec</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/226\">[G-11] Unlock:createLock no need to define the newLock as payable</a> <em>Submitted by GiveMeTestEther, also found by WatchPug</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/232\">[G-12] Unlock:_deployProxyAdmin return value is not used</a> <em>Submitted by GiveMeTestEther</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/60\">[G-13] MixinFunds:_initializeMixinFunds move the require statement to the beginning of the function so save gas in the case of a revert</a> <em>Submitted by GiveMeTestEther, also found by loop</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/127\">[G-14] Gas: Assume 0 when creating struct</a> <em>Submitted by HardlyDifficult</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/129\">[G-15] Gas: Cast instead of creating new variables</a> <em>Submitted by HardlyDifficult, also found by TomFrench and cmichel</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/145\">[G-16] Avoid On Chain Computation That Have Known Answer to Save Gas</a> <em>Submitted by Meta0xNull</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/36\">[G-17] Long Revert Strings</a> <em>Submitted by Reigada, also found by WatchPug</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/24\">[G-18] Using uint16 for lock versions increases gas costs for no reason.</a> <em>Submitted by TomFrench</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/177\">[G-19] Unused named returns</a> <em>Submitted by WatchPug</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/178\">[G-20] <code>UnlockUtils.sol#uint2Str()</code> Implementation can be simpler and save some gas</a> <em>Submitted by WatchPug</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/179\">[G-21] <code>MixinLockCore.sol#updateKeyPricing()</code> Check of <code>_tokenAddress</code> can be done earlier to save gas</a> <em>Submitted by WatchPug</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/185\">[G-22] Remove unnecessary variables can make the code simpler and save some gas</a> <em>Submitted by WatchPug</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/194\">[G-23] Redundant check of <code>owner() != address(0)</code></a> <em>Submitted by WatchPug</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/196\">[G-24] Changing function visibility from public to external can save gas</a> <em>Submitted by WatchPug, also found by loop, mics, nathaniel, and Jujic</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/199\">[G-25] Avoid unnecessary storage reads can save gas</a> <em>Submitted by WatchPug</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/200\">[G-26] Remove unnecessary function can make the code simpler and save some gas</a> <em>Submitted by WatchPug</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/206\">[G-27] <code>MixinRefunds.sol#_getCancelAndRefundValue</code> Cache and read storage variables from the stack can save gas</a> <em>Submitted by WatchPug</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/167\">[G-28] Gas: <code>_recordOwner</code> pushes duplicates</a> <em>Submitted by cmichel</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/209\">[G-29] Inconsistent use of _msgSender()</a> <em>Submitted by defsec</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/210\">[G-30] Gas improvement on the nonce increment</a> <em>Submitted by defsec</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/89\">[G-31] Less than 256 uints are not gas efficient</a> <em>Submitted by defsec</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/213\">[G-32] Gas optimization: Unused variable <code>yieldedDiscountTokens</code></a> <em>Submitted by gzeon</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/68\">[G-33] MixinRefunds: use variable to save gas</a> <em>Submitted by itsmeSTYJ</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/69\">[G-34] MixinPurchase: gas optimisation by relying on 0.8.0 auto revert on underflow.</a> <em>Submitted by itsmeSTYJ</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/54\">[G-35] Redundant check of freeTrialLength == 0</a> <em>Submitted by nathaniel</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/233\">[G-36] Precalculate expressions</a> <em>Submitted by pauliax</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/234\">[G-37] Unnecessary checks</a> <em>Submitted by pauliax</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/236\">[G-38] Refund amount and penalty calculation</a> <em>Submitted by pauliax</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/237\">[G-39] timePlusFee = timeRemaining</a> <em>Submitted by pauliax</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/238\">[G-40] assigned operations to constant variables</a> <em>Submitted by pauliax, also found by Reigada</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/239\">[G-41] 0 valueInETH</a> <em>Submitted by pauliax</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/240\">[G-42] ++/— are cheapest</a> <em>Submitted by pauliax</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/241\">[G-43] address(this).address2Str()</a> <em>Submitted by pauliax</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/121\">[G-44] Use existing memory version of state variables</a> <em>Submitted by ye0lde</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/66\">[G-45] Unused Named Returns</a> <em>Submitted by ye0lde</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/130\">[G-46] Gas: remove owners array</a> <em>Submitted by HardlyDifficult</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/114\">[G-47] <code>Unlock.sol#RecordKeyPurchases</code> can be implemented cheaper</a> <em>Submitted by 0x0x0x</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-11-unlock-findings/issues/126\">[G-48] Gas: Merge callbacks to Unlock on purchase</a> <em>Submitted by HardlyDifficult</em></li>\n</ul>\n<h1 id=\"disclosures\" style=\"position:relative;\"><a href=\"#disclosures\" aria-label=\"disclosures permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Disclosures</h1>\n<p>C4 is an open organization governed by participants in the community.</p>\n<p>C4 Contests incentivize the discovery of exploits, vulnerabilities, and bugs in smart contracts. Security researchers are rewarded at an increasing rate for finding higher-risk issues. Contest submissions are judged by a knowledgeable security researcher and solidity developer and disclosed to sponsoring developers. C4 does not conduct formal verification regarding the provided code but instead provides final verification.</p>\n<p>C4 does not provide any guarantee or warranty regarding the security of this project. All smart contract software should be used at the sole risk and responsibility of users.</p>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n  .dark-default-dark {\n    background-color: #1E1E1E;\n    color: #D4D4D4;\n  }\n  .dark-default-dark .mtk15 { color: #C586C0; }\n  .dark-default-dark .mtk1 { color: #D4D4D4; }\n  .dark-default-dark .mtk12 { color: #9CDCFE; }\n  .dark-default-dark .mtk7 { color: #B5CEA8; }\n  .dark-default-dark .mtk11 { color: #DCDCAA; }\n  .dark-default-dark .mtk3 { color: #6A9955; }\n  .dark-default-dark .mtk4 { color: #569CD6; }\n  .dark-default-dark .grvsc-line-highlighted::before {\n    background-color: var(--grvsc-line-highlighted-background-color, rgba(255, 255, 255, 0.1));\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(255, 255, 255, 0.5));\n  }\n</style>",
  "toc": "<ul>\n<li>\n<p><a href=\"#overview\">Overview</a></p>\n<ul>\n<li><a href=\"#about-c4\">About C4</a></li>\n<li><a href=\"#wardens\">Wardens</a></li>\n</ul>\n</li>\n<li><a href=\"#summary\">Summary</a></li>\n<li><a href=\"#scope\">Scope</a></li>\n<li><a href=\"#severity-criteria\">Severity Criteria</a></li>\n<li>\n<p><a href=\"#high-risk-findings-4\">High Risk Findings (4)</a></p>\n<ul>\n<li><a href=\"#h-01-mev-miner-can-mint-larger-than-expected-udt-total-supply\">[H-01] MEV miner can mint larger than expected UDT total supply</a></li>\n<li><a href=\"#h-02-wrong-designimplementation-of-freetrial-allows-attacker-to-steal-funds-from-the-protocol\">[H-02] Wrong design/implementation of freeTrial allows attacker to steal funds from the protocol</a></li>\n<li><a href=\"#h-03-mixintransfersoltransferfrom-wrong-implementation-can-potentially-allows-attackers-to-reverse-transfer-and-cause-fund-loss-to-the-users\">[H-03] <code>MixinTransfer.sol#transferFrom</code> Wrong implementation can potentially allows attackers to reverse transfer and cause fund loss to the users</a></li>\n<li><a href=\"#h-04-approvals-not-cleared-after-key-transfer\">[H-04] Approvals not cleared after key transfer</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#medium-risk-findings-13\">Medium Risk Findings (13)</a></p>\n<ul>\n<li><a href=\"#m-01-unlock-free-udt-arbitrage-opportunity\">[M-01] Unlock: free UDT arbitrage opportunity</a></li>\n<li><a href=\"#m-02-potential-economic-attack-on-udt-grants-to-the-referrer\">[M-02] Potential economic attack on UDT grants to the referrer</a></li>\n<li><a href=\"#m-03-support-of-different-erc20-tokens\">[M-03] Support of different ERC20 tokens</a></li>\n<li><a href=\"#m-04-key-buyers-will-not-be-able-to-get-refund-if-lock-manager-withdraws-profits\">[M-04] Key buyers will not be able to get refund if lock manager withdraws profits</a></li>\n<li><a href=\"#m-05-refund-mechanism-doesnt-take-into-account-that-key-price-can-change\">[M-05] Refund mechanism doesn’t take into account that key price can change</a></li>\n<li><a href=\"#m-06-key-transfer-will-destroy-key-if-fromto\">[M-06] Key transfer will destroy key if from==to</a></li>\n<li><a href=\"#m-07-mixinpurchasesharekey-allows-to-generate-keys-without-purchasing\">[M-07] MixinPurchase:shareKey allows to generate keys without purchasing</a></li>\n<li><a href=\"#m-08-frontrunning-publiclockinitialize-can-prevent-upgrades-due-to-insufficient-access-control\">[M-08] Frontrunning <code>PublicLock.initialize()</code> can prevent upgrades due to insufficient access control</a></li>\n<li><a href=\"#m-09-referrer-discount-token-amount-can-be-manipulated\">[M-09] Referrer discount token amount can be manipulated</a></li>\n<li><a href=\"#m-10-inaccurate-fees-computation\">[M-10] Inaccurate fees computation</a></li>\n<li><a href=\"#m-11-missing-scaling-factor-in-recordkeypurchase\">[M-11] Missing scaling factor in <code>recordKeyPurchase</code>?</a></li>\n<li><a href=\"#m-12-missing-maxnumberofkeys-checks-in-sharekey-and-grantkey\">[M-12] Missing maxNumberOfKeys checks in shareKey and grantKey</a></li>\n<li><a href=\"#m-13-malicious-user-can-get-infinite-free-trial-by-repeatedly-refund-and-repurchase-right-before-the-freetrial-ends\">[M-13] Malicious user can get infinite free trial by repeatedly refund and repurchase right before the freeTrial ends</a></li>\n<li><a href=\"#m-14-mixinrefunds-frontrun-updatekeypricing-for-free-profit\">[M-14] MixinRefunds: frontrun updateKeyPricing() for free profit</a></li>\n</ul>\n</li>\n<li><a href=\"#low-risk-findings-32\">Low Risk Findings (32)</a></li>\n<li><a href=\"#non-critical-findings-54\">Non-Critical Findings (54)</a></li>\n<li><a href=\"#gas-optimizations-48\">Gas Optimizations (48)</a></li>\n<li><a href=\"#disclosures\">Disclosures</a></li>\n</ul>",
  "md": "\n# Overview\n\n## About C4\n\nCode4rena (C4) is an open organization consisting of security researchers, auditors, developers, and individuals with domain expertise in smart contracts.\n\nA C4 audit contest is an event in which community participants, referred to as Wardens, review, audit, or analyze smart contract logic in exchange for a bounty provided by sponsoring projects.\n\nDuring the audit contest outlined in this document, C4 conducted an analysis of the Unlock Protocol smart contract system written in Solidity. The audit contest took place between November 18—November 24, 2021.\n\n## Wardens\n\n27 Wardens contributed reports to the Unlock Protocol contest:\n\n1. WatchPug ([jtp](https://github.com/jack-the-pug) and [ming](https://github.com/mingwatch))\n1. [cmichel](https://twitter.com/cmichelio)\n1. elprofesor\n1. [kenzo](https://twitter.com/KenzoAgada)\n1. [pauliax](https://twitter.com/SolidityDev)\n1. [GiveMeTestEther](https://twitter.com/GiveMeTestEther)\n1. 0x0x0x\n1. [itsmeSTYJ](https://twitter.com/itsmeSTYJ)\n1. [loop](https://twitter.com/loop_225)\n1. [Ruhum](https://twitter.com/0xruhum)\n1. [defsec](https://twitter.com/defsec_)\n1. [Meta0xNull](https://twitter.com/Meta0xNull)\n1. harleythedog\n1. Jujic\n1. hagrid\n1. jayjonah8\n1. Reigada\n1. [HardlyDifficult](https://twitter.com/HardlyDifficult)\n1. [ye0lde](https://twitter.com/_ye0lde)\n1. [TomFrenchBlockchain](https://github.com/TomAFrench)\n1. [nathaniel](https://twitter.com/n4th4n131?t&#x3D;ZXGbALC3q6JMMoolZddgHg&amp;s&#x3D;09)\n1. [gzeon](https://twitter.com/gzeon)\n1. [BouSalman](bousalman.com)\n1. mics\n1. [sabtikw](https://twitter.com/sabtikw)\n1. aga7hokakological\n\nThis contest was judged by [0xleastwood](https://twitter.com/liam_eastwood13).\n\nFinal report assembled by [itsmetechjay](https://twitter.com/itsmetechjay), [CloudEllie](https://twitter.com/CloudEllie1), and [liveactionllama](https://twitter.com/liveactionllama).\n\n# Summary\n\nThe C4 analysis yielded an aggregated total of 49 unique vulnerabilities and 151 total findings. All of the issues presented here are linked back to their original finding.\n\nOf these vulnerabilities, 4 received a risk rating in the category of HIGH severity, 13 received a risk rating in the category of MEDIUM severity, and 32 received a risk rating in the category of LOW severity.\n\nC4 analysis also identified 54 non-critical recommendations and 48 gas optimizations.\n\n# Scope\n\nThe code under review can be found within the [C4 Unlock Protocol contest repository](https://github.com/code-423n4/2021-11-unlock), and is composed of 3 smart contracts written in the Solidity programming language and includes 604 source lines of Solidity code.\n\n# Severity Criteria\n\nC4 assesses the severity of disclosed vulnerabilities according to a methodology based on [OWASP standards](https://owasp.org/www-community/OWASP_Risk_Rating_Methodology).\n\nVulnerabilities are divided into three primary risk categories: high, medium, and low.\n\nHigh-level considerations for vulnerabilities span the following key areas when conducting assessments:\n\n- Malicious Input Handling\n- Escalation of privileges\n- Arithmetic\n- Gas use\n\nFurther information regarding the severity criteria referenced throughout the submission review process, please refer to the documentation provided on [the C4 website](https://code423n4.com).\n\n# High Risk Findings (4)\n## [[H-01] MEV miner can mint larger than expected UDT total supply](https://github.com/code-423n4/2021-11-unlock-findings/issues/135)\n_Submitted by elprofesor_\n\n`UnlockProtocol` attempts to calculate gas reimbursement using `tx.gasprice`, typically users who falsify `tx.gasprice `would lose gas to miners and therefore not obtain any advantage over the protocol itself. This does present capabilities for miners to extract value, as they can submit their own transactions, or cooperate with a malicious user, reimbursing a portion (or all) or the `tx.gasprice` used. As the following calculation is made;\n\n        uint tokensToDistribute = (estimatedGasForPurchase * tx.gasprice) * (125 * 10 ** 18) / 100 / udtPrice;\n\nwe can see that arbitrary `tx.gasprices` can rapidly inflate the `tokensToDistribute`. Though capped at maxTokens, this value can be up to half the total supply of UDT, which could dramatically affect the value of UDT potentially leading to lucrative value extractions outside of the pool.\n\n#### Recommended Mitigation Steps\n\nUsing an oracle service to determine the average gas price and ensuring it is within some normal bounds that has not been subjected to arbitrary value manipulation.\n\n**[julien51 (Unlock Protocol) disputed and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/135#issuecomment-991699670):**\n > > we can see that arbitrary tx.gasprices can rapidly inflate the tokensToDistribute. Though capped at maxTokens, this value can be up to half the total supply of UDT, which could dramatically affect the value of UDT potentially leading to lucrative value extractions outside of the pool.\n> \n> As you noted it would be capped by the actual increase of the GDP transaction.\n> \n> However we could indeed use an oracle to determine the average gas price over a certain number of blocks to limit the risk even further. \n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/135#issuecomment-1009512489):**\n > I think the warden has raised a valid issue of value extractions. Whether the value extracted is capped at a certain number of tokens, I don't think the issue is nullified as a result. Miners can realistically fill up blockspace by abusing this behaviour and then selling netted tokens on the open market. I'll consider marking this as `medium`, what do you think @julien51 ?\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/135#issuecomment-1009577434):**\n > I think `maxTokens` will be set to `IMintableERC20(udt).totalSupply() / 2` upon the first call to `recordKeyPurchase()`. If I'm not mistaken, this could allow a malicious miner could effectively distribute half of the token supply in one tx.\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/135#issuecomment-1013810733):**\n > After further offline discussions with @julien51. We agree that this is an issue that needs to be addressed.\n> \n> If we consider real-world values for `IMintableERC20(udt).totalSupply()` and `IMintableERC20(udt).totalSupply()` as `1_000_000e18` and `400e18` respectively. Then a miner could mint up to ~1247 `UDT` tokens valued at \\$USD 124,688 if they provide a single Ether as their purchase amount. Obviously this can be abused to generate a huge amount of profit for miners, so as this is a viable way to extract value from the protocol, I will be keeping this as `high` severity.\n\n\n\n## [[H-02] Wrong design/implementation of freeTrial allows attacker to steal funds from the protocol](https://github.com/code-423n4/2021-11-unlock-findings/issues/188)\n_Submitted by WatchPug_\n\nThe current design/implementation of `freeTrial` allows users to get full refund before the `freeTrial` ends. Plus, a user can transfer partial of their time to another user using `shareKey`.\n\nThis makes it possible for the attacker to steal from the protocol by transferring `freeTrial` time from multiple addresses to one address and adding up to `expirationDuration` and call refund to steal from the protocol.\n\n#### Proof of Concept\n\nGiven:\n\n*   `keyPrice` is 1 ETH;\n*   `expirationDuration` is 360 days;\n*   `freeTrialLength` is 31 days.\n\nThe attacker can create two wallet addresses: Alice and Bob.\n\n1.  Alice calls `purchase()`, transfer 30 days via `shareKey()` to Bob, then calls `cancelAndRefund()` to get full refund; Repeat 12 times;\n2.  Bob calls `cancelAndRefund()` and get 1 ETH.\n\n#### Recommendation\n\nConsider disabling `cancelAndRefund()` for users who transferred time to another user.\n\n**[julien51 (Unlock Protocol) confirmed and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/188#issuecomment-979656014):**\n > I think this is valid! The free trial approach is indeed a risk on that front and we need to \"warn\" lock managers about this more.\n >\n > For lock manager who still want to offer free trials, the best approach would probably be to set a high transfer fee to make sure that free trials cannot be transfered.\n >\n > As a consequence of this, I am not sure this is as critical as indicated by the submitter.\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/188#issuecomment-1013831268):**\n > Nice find!\n> \n> From what I can tell at least, this does seem like a viable attack vector. Can I ask why this should not be treated as `high` risk? @julien51 \n\n**[julien51 (Unlock Protocol) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/188#issuecomment-1068786053):**\n > Sorry for the long delay here.\n > In short: this is valid, but only an issue for locks which are enabling free trials (no one has done it) and we would make sure our UI shows this as a potential issue.\n > In other words: a lock manager would need to _explicitly_ enable free trials, despite our warning to put their own funds at risk. For that reason I don't think this is \"High\".\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/188#issuecomment-1075667239):**\n > While this is a valid issue pertaining only to lock managers who _explicitly_ enable free trials, this may still lead to a loss of funds if `cancelAndRefund` is called by a user who has transferred their time to another account. I still believe this deserves a `high` severity rating.\n >\n > In my honest opinion, a warning isn't sufficient to prevent such abuse. I think on-chain enforcement ideal in this situation.\n\n\n\n## [[H-03] `MixinTransfer.sol#transferFrom` Wrong implementation can potentially allows attackers to reverse transfer and cause fund loss to the users](https://github.com/code-423n4/2021-11-unlock-findings/issues/182)\n_Submitted by WatchPug_\n\n<https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinTransfer.sol#L131-L152>\n\n```solidity\nif (toKey.tokenId == 0) {\n  toKey.tokenId = _tokenId;\n  _recordOwner(_recipient, _tokenId);\n  // Clear any previous approvals\n  _clearApproval(_tokenId);\n}\n\nif (previousExpiration <= block.timestamp) {\n  // The recipient did not have a key, or had a key but it expired. The new expiration is the sender's key expiration\n  // An expired key is no longer a valid key, so the new tokenID is the sender's tokenID\n  toKey.expirationTimestamp = fromKey.expirationTimestamp;\n  toKey.tokenId = _tokenId;\n\n  // Reset the key Manager to the key owner\n  _setKeyManagerOf(_tokenId, address(0));\n\n  _recordOwner(_recipient, _tokenId);\n} else {\n  // The recipient has a non expired key. We just add them the corresponding remaining time\n  // SafeSub is not required since the if confirms `previousExpiration - block.timestamp` cannot underflow\n  toKey.expirationTimestamp = fromKey.expirationTimestamp + previousExpiration - block.timestamp;\n}\n```\n\nBased on the context, L131-136 seems to be the logic of handling the case of the recipient with no key, and L138-148 is handing the case of the recipient's key expired.\n\nHowever, in L131-136, the key manager is not being reset.\n\nThis allows attackers to keep the role of key manager after the transfer, and transfer the key back or to another recipient.\n\n#### Proof of Concept\n\nGiven:\n\n*   Alice owns a key that is valid until 1 year later.\n\n1.  Alice calls `setKeyManagerOf()`, making herself the keyManager;\n2.  Alice calls `transferFrom()`, transferring the key to Bob; Bob might have paid a certain amount of money to Alice upon receive of the key;\n3.  Alice calls `transferFrom()` again, transferring the key back from Bob.\n\n#### Recommendation\n\nConsider resetting the key manager regardless of the status of the recipient's key.\n\n**[julien51 (Unlock Protocol) confirmed](https://github.com/code-423n4/2021-11-unlock-findings/issues/182#issuecomment-991678597):**\n > I _think_ you are onto something here. We will need to investigate further and reproduce to fix!\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/182#issuecomment-1013830991):**\n > @julien51 Just following up if you were able to double-check this?\n\n**[julien51 (Unlock Protocol) confirmed](https://github.com/code-423n4/2021-11-unlock-findings/issues/182#issuecomment-1068786599):**\n > This is indeed valid and I think we will need to \"patch\" this. We're still unsure how but we're exploring multiple ways.\n\n\n\n## [[H-04] Approvals not cleared after key transfer](https://github.com/code-423n4/2021-11-unlock-findings/issues/160)\n_Submitted by cmichel_\n\nThe locks implement three different approval types, see `onlyKeyManagerOrApproved` for an overview:\n\n*   key manager (map `keyManagerOf`)\n*   single-person approvals (map `approved`). Cleared by `_clearApproval` or `_setKeyManagerOf`\n*   operator approvals (map `managerToOperatorApproved`)\n\nThe `MixinTransfer.transferFrom` requires any of the three approval types in the `onlyKeyManagerOrApproved` modifier on the tokenId to authenticate transfers from `from`.\n\nNotice that if the `to` address previously had a key but it expired only the `_setKeyManagerOf` call is performed, which does not clear `approved` if the key manager was already set to 0:\n\n```solidity\nfunction transferFrom(\n  address _from,\n  address _recipient,\n  uint _tokenId\n)\n  public\n  onlyIfAlive\n  hasValidKey(_from)\n  onlyKeyManagerOrApproved(_tokenId)\n{\n  // @audit this is skipped if user had a key that expired\n  if (toKey.tokenId == 0) {\n    toKey.tokenId = _tokenId;\n    _recordOwner(_recipient, _tokenId);\n    // Clear any previous approvals\n    _clearApproval(_tokenId);\n  }\n\n  if (previousExpiration <= block.timestamp) {\n    // The recipient did not have a key, or had a key but it expired. The new expiration is the sender's key expiration\n    // An expired key is no longer a valid key, so the new tokenID is the sender's tokenID\n    toKey.expirationTimestamp = fromKey.expirationTimestamp;\n    toKey.tokenId = _tokenId;\n\n    // Reset the key Manager to the key owner\n    // @audit  doesn't clear approval if key manager already was 0\n    _setKeyManagerOf(_tokenId, address(0));\n\n    _recordOwner(_recipient, _tokenId);\n  }\n  // ...\n}\n\n// \nfunction _setKeyManagerOf(\n  uint _tokenId,\n  address _keyManager\n) internal\n{\n  // @audit-ok only clears approved if key manager updated\n  if(keyManagerOf[_tokenId] != _keyManager) {\n    keyManagerOf[_tokenId] = _keyManager;\n    _clearApproval(_tokenId);\n    emit KeyManagerChanged(_tokenId, address(0));\n  }\n}\n```\n\n#### Impact\n\nIt's possible to sell someone a key and then claim it back as the approvals are not always cleared.\n\n#### Proof Of Concept\n\n*   Attacker A has a valuable key (`tokenId = 42`) with an expiry date far in the future.\n*   A sets approvals for their second attacker controlled account A' by calling `MixinKeys.setApprovalForAll(A', true)`, which sets `managerToOperatorApproved[A][A'] = true`.\n*   A clears the key manager by setting it to zero, for example, by transferring it to a second account that does not have a key yet, this calls the above `_setKeyManagerOf(42, address(0));` in `transferFrom`\n*   A sets single-token approval to A' by calling `MixinKeys.approve(A', 42)`, setting `approved[42] = A'`.\n*   A sells the token to a victim V for a discount (compared to purchasing it from the Lock). The victim needs to have owned a key before which already expired. The `transferFrom(A, V, 42)` call sets the owner of token 42 to `V`, but does not clear the `approved[42] == A'` field as described above. (`_setKeyManagerOf(_tokenId, address(0));` is called but the key manager was already zero, which then does not clear approvals.)\n*   A' can claim back the token by calling `transferFrom(V, A', 42)` and the `onlyKeyManagerOrApproved(42)` modifier will pass as `approved[42] == A'` is still set.\n\n#### Recommended Mitigation Steps\n\nThe `_setKeyManagerOf` function should not handle clearing approvals of single-token approvals (`approved`) as these are two separate approval types.\nThe `transferFrom` function should always call `_clearApproval` in the `(previousExpiration <= block.timestamp)` case.\n\n**[julien51 (Unlock Protocol) confirmed and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/160#issuecomment-991687080):**\n > Thanks for reporting this.\n > This is valid and we will fix it.\n\n\n\n# Medium Risk Findings (13)\n## [[M-01] Unlock: free UDT arbitrage opportunity](https://github.com/code-423n4/2021-11-unlock-findings/issues/70)\n_Submitted by itsmeSTYJ_\n\nUniswap v2 made oracle attacks much more expensive to execute (since it needs to be manipulated over X number of blocks) however its biggest drawback is that it reacts slow to price volatility (depends on how far back you look). Depending on a single oracle is still very risky and can be exploited given the correct conditions.\n\nAssuming the ideal conditions, it is possible to purchase many keys across many locks for the UDT token that is distributed to the referrer and sell them on some other exchanges where the price of UDT is higher; high enough such that the malicious user can still profit even after requesting for a refund (w/ or w/o a free trial).\n\n#### Proof of Concept\n\nThis exploit is made possible because of:\n\n*   the over dependency on a single price oracle\n*   UDT token distribution logic is flawed\n\nThe following assumptions has to be true for this attack to work:\n\n1.  price of UDT on an exchange is much higher than that from the price retrieved from the `uniswapOracle`.\n2.  Since the price retrieved by `udtOracle.updateAndConsult()` only updates once per day, it is slow to react to the volatility of UDT price movements.\n3.  Malicious user creates a lock and buys many keys across multiple addresses.\n4.  Malicious user sells these UDT tokens on the exchanges w/ the higher price.\n5.  Malicious user requests for a refund on the keys owned.\n6.  Repeat until it is no longer profitable i.e. price on other exchanges become close to parity with the price retrieved by the `uniswapOracle`.\n\n#### Recommended Mitigation Steps\n\n*   Use the average of multiple oracle sources so that the price of UDT tokens (from `Unlock.sol`'s PoV) reacts faster.\n*   UDT tokens distributed based on the duration of key ownership.\n\n**[julien51 (Unlock Protocol) disagreed with severity and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/70#issuecomment-1004137608):**\n > As you noted this is pretty theoretical and given that the amount of UDT minted is capped to the gas spent, the user will need to 1) purchase a LOT of keys and 2) cancel them all and 3) find an exchange where the price is significantly different. \n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/70#issuecomment-1010535323):**\n > Nice find!\n> \n> While, I do agree this is a difficult attack to perform, it is still a valid way of extracting value from the protocol. Hence, I believe this should be kept as `medium`.\n> \n> `\n> 2 — Med (M): vulns have a risk of 2 and are considered “Medium” severity when assets are not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n> `\n\n**[julien51 (Unlock Protocol) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/70#issuecomment-1068788560):**\n > We will mitigate this in an upcoming upgrade by moving to Uniswap v3 for our oracles. \n\n\n\n## [[M-02] Potential economic attack on UDT grants to the referrer](https://github.com/code-423n4/2021-11-unlock-findings/issues/186)\n_Submitted by WatchPug_\n\nIn the current implementation, `Unlock.sol#recordKeyPurchase()` will send `estimatedGasForPurchase * tx.gasprice` worth of UDT to the referrer.\n\n<https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/Unlock.sol#L325-L325>\n\n```solidity\nuint tokensToDistribute = (estimatedGasForPurchase * tx.gasprice) * (125 * 10 ** 18) / 100 / udtPrice;\n```\n\nWe believe there are multiple potential economic attack vectors to exploit this.\n\nIf `estimatedGasForPurchase` is misconfigured to a higher amount than the actual avg gas cost for a purchase call, or future network upgrades make the actual gas cost become lower than the configured `estimatedGasForPurchase`, it can be exploited simply by creating a lock and call `purchase()` many times to mint UDT.\n\nEven if `estimatedGasForPurchase` is configured to an amount similar to the actual gas cost, a more sophisticated attack is still possible:\n\n#### Proof of Concept\n\nGiven:\n\n*   `estimatedGasForPurchase` is configured as `200,000`;\n*   The gas cost of a regular purchase call is about `200,000`.\n\nThe attacker can create a lock contract and set the token address to a special gas saving token, which will SELFDESTRUCT to get a gas refund on `transfer`.\n\nThe attacker can:\n\n1.  Mint gas saving token with gas price: `1 gwei`;\n2.  Call `purchase()` and use 48 contract slots with gas price: `1000 gwei`;\n\nTotal gas saved will be \\~0.8 ETH (or other native tokens, eg. BNB, MATIC). Therefore, the attacker will profit \\~0.8 ETH worth of UDT.\n\nSee: <https://gastoken.io/>\n\n#### Recommendation\n\nConsider setting a global daily upper limit of total UDT grants to referrers, plus, an upper limit for UDT minted per purchase.\n\n**[julien51 (Unlock Protocol) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/186#issuecomment-991673917):**\n > > If `estimatedGasForPurchase` is misconfigured to a higher amount than the actual avg gas cost for a purchase call, or future network upgrades make the actual gas cost become lower than the configured `estimatedGasForPurchase`, it can be exploited simply by creating a lock and call `purchase()` many times to mint UDT.\n> \n> Absolutely but considering the security model, the admin indeed have full control over the protocol. We are thinking about finding a mechanism to not hardcode gas spent but use the actual number eventually. When we do that we should consider the impact of things like gas-token (even though EIP1559 has probably made them mostly impractical?).\n> \n> At this point given that the gas spent is hardcoded, there is a de-facto cap on how much UDT they could earn (based on the token price).\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/186#issuecomment-1013811232):**\n > While I agree with the warden, there is potential for value extraction, however, it does require the admin to be unaware about upcoming network upgrades. \n> \n> As the sponsor has noted, they will be moving towards a dynamic `estimatedGasForPurchase` value, however, from the perspective of the c4 contest, this doesn't change the outcome of my decision.\n> \n > As the protocol may leak value based on certain network assumptions, I'll mark this as `medium` severity.\n > \n> `\n> 2 — Med (M): vulns have a risk of 2 and are considered “Medium” severity when assets are not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n> `\n\n**Please note: the following additional discussions and re-assessment took place approximately 2 months after judging and awarding were finalized. As such, this report will leave this finding in its originally assessed risk category as it simply reflects a snapshot in time.**\n\n**[julien51 (Unlock Protocol) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/186#issuecomment-1068789965):**\n > I don't think the protocl can \"leak\" value based on that.\n > The tokens that are used to compute GDP and distribute tokens have to be approved by the DAO (right now only USDC, DAI and BAT have been approved on mainnet, and only USDC on Polygon). I don't think the DAO would approve gas tokens givem that indeed they could result in leakage of UDT, so I think it is `minor`.\n\n**[0xleastwood (judge) decreased severity to Low and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/186#issuecomment-1075674165):**\n > Considering the sponsor's comments, I actually agree that this is less likely than initially stated. Similar to the `SafeERC20` issue, it isn't expected that gas saving tokens will be approved to compute and distribute `UDT` tokens. I'll downgrade this to `low`.\n\n\n\n## [[M-03] Support of different ERC20 tokens](https://github.com/code-423n4/2021-11-unlock-findings/issues/221)\n_Submitted by pauliax, also found by cmichel, Reigada, kenzo, Ruhum, 0x0x0x, GiveMeTestEther, and WatchPug_\n\nThe current version of the codebase does not handle special cases of tokens, e.g. deflationary, rebasing, or those that return true/false on success (see: <https://github.com/d-xo/weird-erc20>). Function purchase transfers tokens from msg.sender but it does not check the return value, nor how many tokens were actually transferred:\n\n```solidity\n  token.transferFrom(msg.sender, address(this), pricePaid);\n```\n\n#### Recommended Mitigation Steps\n\nI have 2 suggestions here:\n\n1.  Use SafeERC20 library to handle token transfers: <https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol>\n2.  Consider checking the actual balances transferred (balance after-before) or clearly documenting that you do not support deflationary / rebasing / etc tokens.\n\n**[julien51 (Unlock Protocol) disputed and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/221#issuecomment-991662738):**\n > The only party that would be penalized in the examples you describe is the lock manager (and beneficiary) who has explicitly deployed the lock using the (noncompliant) ERC20.\n> If we consider the threat model here then I think this is not really an issue, as additional checks would incur a gas cost for everyone.\n\n**Please note: the following additional discussions and re-assessment took place approximately 2 months after judging and awarding were finalized. As such, this report will leave this finding in its originally assessed risk category as it simply reflects a snapshot in time.**\n\n**[julien51 (Unlock Protocol) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/221#issuecomment-1068790582):**\n > The fact that this requires an explicit action by the lock manager (ie using a buggy/malicious ERC20 token) and that it puts only _their_ tokens at risk, I think this is `minor`.\n\n**[0xleastwood (judge) decreased severity to Low and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/221#issuecomment-1075664726):**\n > Giving this a bit more thought, I think its always safe to enforce these checks rather than leave it up to the lock manage to potentially make the mistake and then be liable for this mistake later on. However, considering the threat model, I do think this is better suited as a `low` severity issue.\n\n\n\n## [[M-04] Key buyers will not be able to get refund if lock manager withdraws profits](https://github.com/code-423n4/2021-11-unlock-findings/issues/50)\n_Submitted by kenzo_\n\nUnlock contains a feature in which a key buyer can ask for a refund.\nThe refund is sent from the lock - where the purchase funds were sent.\nThe lock manager can withdraw all funds from the lock.\nTherefore, if the lock manager withdraws enough profits from the lock, the user would not be able to cancel his key and request refund.\nEven if a lock manager is not malicious, if he would want to enable users to cancel their key, he would have to keep track of how much tokens need to be kept in the contract in order to enable this - not a trivial calculation. A naive lock manager might accidentally disable refunds for his clients.\n\n#### Impact\n\nRefunds are not guaranteed.\nA user might buy a key expecting to cancel it within some time, only to discover he can not cancel it. (This loss of user funds is why I consider this a high risk finding.)\nAn unaware lock manager who just wants to withdraw all his profits might accidentally discover that he removed his users' ability to cancel their key.\n\n#### Notes\n\nIt seems the Unlock team is aware to some extent that withdrawing breaks refunds, as they state in the `withdraw` function:\n\n       * TODO: consider allowing anybody to trigger this as long as it goes to owner anyway?\n       *  -- however be wary of draining funds as it breaks the `cancelAndRefund` and `expireAndRefundFor`\n       * use cases.\n\nHowever, even if just the owner is allowed to call it, he may break the refund functionality - on purpose or accidentally.\nLooking on Unlock documentation I don't see a warning to creators about withdrawing their funds.\n\n#### Proof of Concept\n\n`withdraw` function has no limit on the amount withdrawn, therefore the owner can withdraw all funds:\n<https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinLockCore.sol#L133:#L162>\n\n`cancelAndRefund` transfers the funds from the same lock contract:\n<https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinRefunds.sol#L118>\nTherefore if there are not enough funds, the transfer will fail.\n\n#### Recommended Mitigation Steps\n\nPerhaps a sort of MasterChef-like shares system can be implemented in order to make sure the owner leaves enough funds in the lock to process refunds.\n\n**[julien51 (Unlock Protocol) disagreed with severity and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/50#issuecomment-976135073):**\n > As noted, this is actually documented. You are right though that we should make this more obvious on the UI.\n> I would not classify this as High Risk.\n\n**[0xleastwood (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/50#issuecomment-1013832438):**\n > Nice find! I think this can be downgraded to `medium` as the availability of the protocol is impacted by this issue.\n\n**[julien51 (Unlock Protocol) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/50#issuecomment-1068791454):**\n > This would not affect the whole protocol but only the \"malicious\" lock and it is impractice not only documented but also how these things work in the real world. If Netflix went out of business tomorrow, I could not get a refund on this month's membership fee...\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/50#issuecomment-1075662850):**\n > While I mostly agree with the sponsor, this may be intended behaviour as user's should not be entitled to a refund in this case. However, based on what was known at the time, it seemed like this broke the functionality of `cancelAndRefund` and `expireAndRefundFor` functions, hence why it was marked as `medium` severity.\n\n\n\n## [[M-05] Refund mechanism doesn't take into account that key price can change](https://github.com/code-423n4/2021-11-unlock-findings/issues/53)\n_Submitted by kenzo, also found by WatchPug and 0x0x0x_\n\nLock manager can change key pricing.\nThe refund mechanism calculates refund according to current key price, not price actually paid.\n\n#### Impact\n\nA user refunding can get less (or more) funds than deserved.\n\n#### Proof of Concept\n\nRefund only takes the current price into account:\n<https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinRefunds.sol#L144:#L152>\n\nLock manager can update key price at any point, and the old price is not saved anywhere:\n<https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinLockCore.sol#L183>\n\nSo if for example a key price has gone down, a user who tried to refund will get less funds than deserved.\n\n#### Recommended Mitigation Steps\n\nConsider saving the amount the user paid, and refund according to that.\nOr having a kind of a price snapshot/version mechanism.\n\n**[julien51 (Unlock Protocol) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/53#issuecomment-976137635):**\n > This is a known issue... but indeed we should show things in the UI to indicate things to users.\n\n**[0xleastwood (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/53#issuecomment-1013832674):**\n > Agree this sounds like an issue! However, I don't think this can be justified as a `high` risk issue. But it does seem that the protocol could leak value and impact users, so marking this as `medium`.\n\n**[julien51 (Unlock Protocol) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/53#issuecomment-1068791889):**\n > We actually are adding a new mechanism to keep track of the last price paid by any user which means we could use it in the next version to solve this issue!\n\n\n\n## [[M-06] Key transfer will destroy key if from==to](https://github.com/code-423n4/2021-11-unlock-findings/issues/87)\n_Submitted by kenzo, also found by GiveMeTestEther and cmichel_\n\nIf calling `transferFrom` with `_from == _recipient`, the key will get destroyed (meaning the key will be set as expired and set the owner's key to be 0).\n\n#### Impact\n\nA key manager or approved might accidentally destroy user's token.\n\nNote: this requires user error and so I'm not sure if this is a valid finding.\nHowever, few things make me think that it is valid:\n\n*   Unlock protocol checks for transfer to 0-address, so some input validation is there\n*   Since other entities other than the owner can be allowed to transfer owner's token, it might be best to make sure such accidental mistake could not happen.\n*   This scenario manifests a unique and probably unintended behavior\n\n#### Proof of Concept\n\nBy following `transferFrom`'s execution:\n<https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L109:#L166>\nOne can see that in the case where `_from == _recipient` with a valid key:\n\n*   The function will deduct transfer fee from the key\n*   The function will incorrectly add more time to the key's expiration ([L151](https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L151))\n*   The function will expire and reset the key ([L155](https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L155:#L158))\n\nTherefore, the user will lose his key without getting a refund.\n\n#### Recommended Mitigation Steps\n\nAdd a require statement in the beginning of `transferFrom`:\n`require(_from != _recipient, 'TRANSFER_TO_SELF');`\n\n**[julien51 (Unlock Protocol) confirmed](https://github.com/code-423n4/2021-11-unlock-findings/issues/87)**\n\n**[julien51 (Unlock Protocol) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/87#issuecomment-1068792003):**\n > Fixed since then :)\n\n\n\n## [[M-07] MixinPurchase:shareKey allows to generate keys without purchasing](https://github.com/code-423n4/2021-11-unlock-findings/issues/242)\n_Submitted by GiveMeTestEther, also found by kenzo_\n\nThe `shareKey` function allows a user to share some time with another user that doesn't already has/had a key and this generates a new key. This even allows the user to generate more keys than `\\_maxNumberOfKeys`.\n\nAttacker generates a lot of EOA addresses, buys a key, share the minimum necessary time with each address and in each \"sharing\" a new key gets generated. This allows cheaply to allocate alot of \"keys\" with out really purchasing them and a lot of user can't get a \"key\" because purchase has a modifier notSoldOut, that limits the max purchasable to \"keys\" to `maxNumberOfKeys`\n\n#### Proof of Concept\n\nProvide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.\n\n#### Tools Used\n\nManual Analysis\n\n#### Recommended Mitigation Steps\n\n*   rethink the whole `shareKey` thingy,\n\n**[julien51 (Unlock Protocol) acknowledged and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/242#issuecomment-979648865):**\n > I am not sure this is a bug or even a risk. \n> Someone could actually achieve the same thing by purchasing keys at the full price and cancelling them immediately getting an almost full refund (or even full refund when there is a free trial) and could quickly get the lock to \"sell out\". \n> It is actually the case with any NFT project where there is a cap/limit to number of tokens and someone can easily \"Capture\" them all.\n> \n> One way to limit the impact for the lock manager would be to set a cancellation penalty AND a transfer fee.  \n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/242#issuecomment-1013834438):**\n > Nice find! While I understand what the sponsor is saying, this does seem like a valid way to deny a lock from selling membership to honest users.\n\n**[julien51 (Unlock Protocol) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/242#issuecomment-1068792488):**\n > Note that a lock manager can easily increase supply to mitigate that (and even could _delete_ existing keys/NFT to reduce the outstanding supply)\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/242#issuecomment-1075656944):**\n > While the lock manager can restore the contract to some valid state, this will still impact protocol availability, even in the short-term.\n\n\n\n## [[M-08] Frontrunning `PublicLock.initialize()` can prevent upgrades due to insufficient access control](https://github.com/code-423n4/2021-11-unlock-findings/issues/132)\n_Submitted by elprofesor, also found by kenzo_\n\nThe unlock protocols base contract `Unlock.sol` uses `setLocktemplate()` to initialize the implementation contract for the `PublicLock` proxy. This function will initialize the relevant `PublicLock` contract which has been deployed separately. `PublicLock.initialize()` does not have any relevant access control and does not prevent arbitrary users from initialising. This means that a malicious user could front run the `setLocktemplate()` forcing the deployer of `PublicLock`'s implementation to redeploy. The process can be repeated, which costs the malicious user less than it would the owner of the Unlock Protocol, potentially unnecessarily draining funds from the development team.\n\n#### Proof of Concept\n\n[Lack of access control on initialize](https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/PublicLock.sol#L42-L51)\n\n#### Recommended Mitigation Steps\n\nImplement valid access control on the `PublicLock` contract to ensure only the relevant deployer can `initialize()`.\n\n**[julien51 (Unlock Protocol) disagreed with severity](https://github.com/code-423n4/2021-11-unlock-findings/issues/132)**\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/132#issuecomment-1075675604):**\n > I agree with the warden, `_publicLockAddress` is deployed separately and hence `initialize` can be called before `setLockTemplate` is called.\n\n\n\n## [[M-09] Referrer discount token amount can be manipulated](https://github.com/code-423n4/2021-11-unlock-findings/issues/155)\n_Submitted by cmichel_\n\nThe `Unlock.recordKeyPurchase` function is called on each key purchase (`MixinPurchase.purchase`) and mints UDT tokens to the referrer.\nThe amount to mint is based on the transaction's gas price which is controlled by the caller (purchaser):\n\n```solidity\nuint tokensToDistribute = (estimatedGasForPurchase * tx.gasprice) * (125 * 10 ** 18) / 100 / udtPrice;\n```\n\n#### Impact\n\nTokens can be minted by purchasing a key with themself as the referrer at a high transaction gas price.\nDepending on the UDT price on external markets, it could be profitable to buy a key at a high gas price, receive UDT and then sell them on a market for a profit.\n\n#### Recommended Mitigation Steps\n\nThe amount minted should be more predictable and not depend on the user's gas price input.\nConsider declaring an *average gas price* storage variable that is set by a trusted party and use this one instead.\n\n**[julien51 (Unlock Protocol) disagreed with severity and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/155#issuecomment-991691106):**\n > > Depending on the UDT price on external markets, it could be profitable to buy a key at a high gas price, receive UDT and then sell them on a market for a profit.\n> \n> Since we get the token price from the Uniswap oracle, the amount of tokens received is always at most equal to what they would have spent to acquire them on Uniswap.\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/155#issuecomment-1013842955):**\n > As the uniswap oracle provides averaged price data, if there is any discrepancy between the spot price and the TWAP price, this can definitely be abused to extract value from the protocol. Keeping this as `medium`.\n\n\n\n## [[M-10] Inaccurate fees computation](https://github.com/code-423n4/2021-11-unlock-findings/issues/165)\n_Submitted by cmichel, also found by 0x0x0x_\n\nThe `MixinTransfer.shareKey` function wants to compute a fee such that `time + fee * time == timeRemaining (timePlusFee)`:\n\n```solidity\nuint fee = getTransferFee(keyOwner, _timeShared);\nuint timePlusFee = _timeShared + fee;\n```\n\nHowever, if the time remaining is less than the computed fee time, **the computation changes and a different formula is applied**.\nThe fee is now simply taken on the remaining time.\n\n```solidity\nif(timePlusFee < timeRemaining) {\n  // now we can safely set the time\n  time = _timeShared;\n  // deduct time from parent key, including transfer fee\n  _timeMachine(_tokenId, timePlusFee, false);\n} else {\n  // we have to recalculate the fee here\n  fee = getTransferFee(keyOwner, timeRemaining);\n  // @audit want it such that time + fee * time == timeRemaining, but fee is taken on timeRemaining instead of time\n  time = timeRemaining - fee;\n}\n```\n\nIt should compute the `time` without fee as `time = timeRemaining / (1.0 + fee_as_decimal)` instead, i.e., `time = BASIS_POINTS_DEN * timeRemaining / (transferFeeBasisPoints + BASIS_POINTS_DEN)`.\n\n#### Proof Of Concept\n\nTo demonstrate the difference with a 10% fee and a `_timeShared = 10,000s` which should be credited to the `to` account.\n\nThe correct time plus fee which is reduced from `from` (as in the `timePlusFee < timeRemaining` branch) would be `10,000 + 10% * 10,000 = 11,000`.\n\nHowever, if `from` has not enough time remaining and `timePlusFee >= timeRemaining`, the entire time remaining is reduced from `from` but the credited `time` is computed wrongly as:\n(Let's assume `timeRemaining == timePlusFee`): `time = 11,000 - 10% * 11,000 = 11,000 - 1,100 = 9900`.\n\nThey would receive 100 seconds less than what they are owed.\n\n#### Impact\n\nWhen transferring more time than the `from` account has, the credited time is scaled down wrongly and the receiver receives less time (a larger fee is applied).\n\n#### Recommended Mitigation Steps\n\nIt should change the first `if` branch condition to `timePlusFee <= timeRemaining` (less than or equal).\nIn the `else` branch, it should compute the time without fee as `time = BASIS_POINTS_DEN * timeRemaining / (transferFeeBasisPoints + BASIS_POINTS_DEN)`.\n\n**[julien51 (Unlock Protocol) confirmed and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/165#issuecomment-991683180):**\n > Great find!\n\n\n\n## [[M-11] Missing scaling factor in `recordKeyPurchase`?](https://github.com/code-423n4/2021-11-unlock-findings/issues/156)\n_Submitted by cmichel_\n\nThe `Unlock.recordKeyPurchase` function computes the `maxTokens` as:\n\n```solidity\nmaxTokens = IMintableERC20(udt).balanceOf(address(this)) * valueInETH / (2 + 2 * valueInETH / grossNetworkProduct) / grossNetworkProduct;\n```\n\nNote that `grossNetworkProduct` was already increased by `valueInETH` in the code before.\nMeaning, the `(2 + 2 * valueInETH / grossNetworkProduct)` part of the computation will almost always be `2` as usually `grossNetworkProduct > 2 * valueInETH`, and thus the `2 * valueInETH / grossNetworkProduct` is zero by integer division.\n\n#### Impact\n\nThe `maxTokens` curve might not be computed as intended and lead to being able to receive more token rewards than intended.\n\n#### Recommended Mitigation Steps\n\nThe comment \"we distribute tokens using asymptotic curve between 0 and 0.5\" should be more clear to indicate how exactly the curve looks like.\nIt could be that a floating-point number was desired instead of the integer division in `2 * valueInETH / grossNetworkProduct`. In that case, consider adding a scaling factor to this term and divide by it at the end of the computation again.\n\n**[julien51 (Unlock Protocol) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/156#issuecomment-991690466):**\n > I am not fully sure I understand what the problem is here?\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/156#issuecomment-1013844481):**\n > I think the warden is raising an issue where `2 * valueInEth / grossNetworkProduct` will more than likely truncate and return `0`. I think this is a valid finding.\n\n**[julien51 (Unlock Protocol) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/156#issuecomment-1068793080):**\n > Hum, we did some tests and could not reproduce here.\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/156#issuecomment-1075696998):**\n > I'm not sure how `2 * valueInETH / grossNetworkProduct` does not always lead to some truncation. `grossNetworkProduct` is equal to `valueInETH` in the first call but always greater than `valueInETH` in any subsequent calls.\n\n\n\n## [[M-12] Missing maxNumberOfKeys checks in shareKey and grantKey](https://github.com/code-423n4/2021-11-unlock-findings/issues/55)\n_Submitted by kenzo_\n\nMore keys can be minted than maxNumberOfKeys since `shareKey` and `grantKey` do not check if the lock is sold out.\n\n#### Impact\n\nMore keys can be minted than intended.\n\n#### Proof of Concept\n\nIn both `shareKey` and `grantKey`, if minting a new token, a new token is simply minted (and `_totalSupply` increased) without checking it against `maxNumberOfKeys`.\nThis is unlike `purchase`, which has the `notSoldOut` modifier.\n\n`grantKey`:\n<https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinGrantKeys.sol#L41:#L42>\n\n`shareKey`:\n<https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L83:#L84>\nBoth functions call `_assignNewTokenId` which does not check maxNumberOfKeys.\n\n<https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinKeys.sol#L311:#L322>\nSo you can say that `_assignNewTokenId` is actually the root of the error, and this is why I am submitting this as 1 finding and not 2 (for grantKey/shareKey).\n\n#### Recommended Mitigation Steps\n\nAdd a check to `_assignNewTokenId` that will revert if we need to record a new key and `maxNumberOfKeys` has been reached.\n\n**[julien51 (Unlock Protocol) confirmed and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/55#issuecomment-1004066282):**\n > This is actually intentional. We want the lock manager to be able to grant keys even if the lock is sold out. Note that the lock manager could also increase the supply if they needed anyway.\n > However, we should take that into account in the `shareKey` flow so I'll mark as confirmed for that flow.\n\n\n\n## [[M-13] Malicious user can get infinite free trial by repeatedly refund and repurchase right before the freeTrial ends](https://github.com/code-423n4/2021-11-unlock-findings/issues/189)\n_Submitted by WatchPug_\n\nThe current design/implementation allows users who are refunded before to get another `freeTrial`. This can be exploited by malicious users to get an infinite free trial.\n\n#### Proof of Concept\n\nGiven:\n\n*   `keyPrice` is 1 ETH;\n*   `freeTrialLength` is 31 days.\n\nA malicious user can:\n\n1.  Call `purchase()`, pay 1 ETH and get 31 days of `freeTrial` on day 1;\n2.  Call `cancelAndRefund()` on day 30 and get 1 ETH of refund; then call `purchase()` again, pay 1 ETH and get 31 days of `freeTrial` again.\n\nRepeat the steps above and the user can get infinite `freeTrial`.\n\n#### Impact\n\nA malicious third party may provide a service named `freeUnlock`, which will call `cancelAndRefund()` and `purchase()` automatically right before the end of the `freeTrial`. This can cause fund loss to all the owners that provide a `freeTrial`.\n\n#### Recommendation\n\nConsider adding a `mapping(address => uint256) freeTrialEnds` and make sure each address can only get 1 `freeTrial`.\n\n**[julien51 (Unlock Protocol) disputed and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/189#issuecomment-979654912):**\n > Isn't that the case with every free trial system? \n> If they use the same address the lock manager could easily use the hook system to keep track of who already had received a  full refund and not grant it on the 2nd cancellation.\n> The user could still use new addresses all the time, and in that case that would be valid, but that is actually the case with a lot of systems like that :)\n> One of my roommates in college was just subscribing to newspaper and getting the full risk-free refund by using a different name every time (but used the same address)\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/189#issuecomment-1013831584):**\n > While I agree with the warden, there is potential for unlimited free trials. Limiting a free trial to a single address does not resolve the issue as an attacker can generate any number of addresses from a single seed. However, I do understand this is a tricky issue to workaround. \n > \n > So I'm not sure how this should be treated as it does affect how the protocol is intended to operate. Is there any reason for users to not abuse this @julien51 ? Typically with newspapers, you have to provide credit card details, so an individual is really limited by the number of cards they hold.\n\n**[julien51 (Unlock Protocol) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/189#issuecomment-1014073979):**\n > As you noted, there is _no way_ to prevent free trials from being abused which is why by default, locks do *not* have a free trial: they have to be manually explicitly configured. From there, since it's trivial to just create an infinite number of accounts, anyone could just claim free trials over and over from new accounts.\n\n**[0xleastwood (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/189#issuecomment-1014093336):**\n > As per sponsor, trials are not enabled by default. But seeing as this impacts protocol availability through abuse if enabled. I'll mark this as `medium`.\n\n\n\n## [[M-14] MixinRefunds: frontrun updateKeyPricing() for free profit](https://github.com/code-423n4/2021-11-unlock-findings/issues/72)\n_Submitted by itsmeSTYJ_\n\nA malicious user is able to withdraw all payments that were paid to a lock owner if the owner increases the keyPrice.\n\n#### Proof of Concept\n\nWhen `updateKeyPricing()` is called to increase the price of a key, it is possible to frontrun this call and buy many keys at the cheaper price then request for a refund at the higher price.\n\n#### Recommendation\n\nKeep track of the price at which keys are purchased so that when you issue a refund, you use the original keyPrice to refund instead of the updated keyPrice\n\n**[julien51 (Unlock Protocol) acknowledged, but disagreed with High severity and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/72#issuecomment-1004133079):**\n > This is only true for locks where there is no penalty. We should make it clear on the front-end that when changing the price it is recommended to set up a penalty (at least temporarily) for the price difference so that no key can be refunded for the full price.\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/72#issuecomment-1075679839):**\n > Circling back on this, I'm not sure how a penalty would be correctly applied to all locks. Wouldn't users who wanted to get a refund for their key get penalised if they purchase after the change in key price? I think it would also be safer to update the key price and apply the penalty in the one transaction.\n\n**[julien51 (Unlock Protocol) commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/72#issuecomment-1004133079):**\n > I think that is a good finding, but there again (like often) I think this is pretty edgy.\n > The cancellation penalty is pretty easy to apply just to a single lock from the [lock manager's perspective](https://github.com/unlock-protocol/unlock/blob/b7c5a555efc3c2be619cbb942eb67d4008baa049/smart-contracts/contracts/mixins/MixinRefunds.sol#L70). Before changing the lock price, a lock manager can easily apply a penalty for the difference in price. IE if I change the price from 10 to 12, I apply a penalty for 2 and anyone who tries to abuse this will only get a refund of 12-2 = 10.\n >\n > On top of that we're actually storing the amount paid for the latest key as part of our next upgrade to support automatically recurring memberships, which should make things even more robust as anyone will only get re-imbursed based on what they paid...\n\n**[0xleastwood (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2021-11-unlock-findings/issues/72#issuecomment-1075679839):**\n > Considering the sponsor's comments and after some further discussion on Discord. I think it is more correct to downgrade this to `medium` severity. While it isn't clear, the lock manager is expected to apply a penalty before updating the cost of a membership such that users cannot game the price difference. However, this isn't enforced on-chain or documented anywhere so based on the judge's and warden's context at the time, this seemed like a valid `high` severity issue. It is important to note that users who refund their membership after purchasing a membership post price change will be refunded less than users who purchased their memberships before the price change. The sponsor is looking to integrate these fixes in their next upgrade.\n\n \n\n# Low Risk Findings (32)\n- [[L-01] `Unlock.addLockTemplate` does not adequately increment version, leading to gaps in version](https://github.com/code-423n4/2021-11-unlock-findings/issues/133) _Submitted by elprofesor, also found by loop, pauliax, 0x0x0x, and harleythedog_\n- [[L-02] Insufficient version validation causes denial of service for `PublicLock` during lock upgrades](https://github.com/code-423n4/2021-11-unlock-findings/issues/134) _Submitted by elprofesor_\n- [[L-03] MixinGrantKeys:grantKeys possible DoS with (Unexpected) revert](https://github.com/code-423n4/2021-11-unlock-findings/issues/62) _Submitted by GiveMeTestEther_\n- [[L-04] No ERC20 safeApprove called & not success check](https://github.com/code-423n4/2021-11-unlock-findings/issues/161) _Submitted by cmichel, also found by Reigada and 0x0x0x_\n- [[L-05] MixinLockCore: use safeApprove from SafeERC20, and do approve(0) before approve(amount)](https://github.com/code-423n4/2021-11-unlock-findings/issues/151) _Submitted by GiveMeTestEther_\n- [[L-06] getTransferFee() Fee Could Be 0](https://github.com/code-423n4/2021-11-unlock-findings/issues/140) _Submitted by Meta0xNull_\n- [[L-07] The function MixinLockCore.approveBeneficiary is susceptible to a race condition](https://github.com/code-423n4/2021-11-unlock-findings/issues/29) _Submitted by Ruhum_\n- [[L-08] Unlock has incomplete fallback function which may cause loss of funds](https://github.com/code-423n4/2021-11-unlock-findings/issues/136) _Submitted by elprofesor_\n- [[L-09] `initialize` functions can be frontrun](https://github.com/code-423n4/2021-11-unlock-findings/issues/153) _Submitted by cmichel, also found by WatchPug_\n- [[L-10] _cancelAndRefund is not protected from re-entrancy](https://github.com/code-423n4/2021-11-unlock-findings/issues/223) _Submitted by pauliax_\n- [[L-11] setKeyManagerOf has no address-0 check](https://github.com/code-423n4/2021-11-unlock-findings/issues/52) _Submitted by kenzo_\n- [[L-12] Distribution of tokens in recordKeyPurchase](https://github.com/code-423n4/2021-11-unlock-findings/issues/230) _Submitted by pauliax_\n- [[L-13] a single user can become owner of multiple token ids](https://github.com/code-423n4/2021-11-unlock-findings/issues/120) _Submitted by GiveMeTestEther_\n- [[L-14] Setting the admin in initialize initializeProxyAdmin can be frontrun by an attacker](https://github.com/code-423n4/2021-11-unlock-findings/issues/117) _Submitted by Jujic_\n- [[L-15] Scenario where variable in Unlock.recordKeyPurchase() is not initialized](https://github.com/code-423n4/2021-11-unlock-findings/issues/27) _Submitted by Ruhum_\n- [[L-16] Consider adding storage gaps to `Mixin***` contracts](https://github.com/code-423n4/2021-11-unlock-findings/issues/174) _Submitted by WatchPug_\n- [[L-17] Lock template versions can be overwritten](https://github.com/code-423n4/2021-11-unlock-findings/issues/154) _Submitted by cmichel_\n- [[L-18] Can set arbitrary lock templates](https://github.com/code-423n4/2021-11-unlock-findings/issues/158) _Submitted by cmichel_\n- [[L-19] DoS when `onKeyPurchaseHook` reverts](https://github.com/code-423n4/2021-11-unlock-findings/issues/163) _Submitted by cmichel_\n- [[L-20]  PREVENT DIV BY 0](https://github.com/code-423n4/2021-11-unlock-findings/issues/170) _Submitted by defsec_\n- [[L-21] Confliction on double `initialize` functions front-run `minter` ](https://github.com/code-423n4/2021-11-unlock-findings/issues/85) _Submitted by hagrid_\n- [[L-22] Unimplemented function computeAvailableDiscountFor ](https://github.com/code-423n4/2021-11-unlock-findings/issues/74) _Submitted by harleythedog_\n- [[L-23] Unused function parameters ](https://github.com/code-423n4/2021-11-unlock-findings/issues/3) _Submitted by jayjonah8_\n- [[L-24] Wrong event parameter emitted at _setKeyManagerOf](https://github.com/code-423n4/2021-11-unlock-findings/issues/84) _Submitted by kenzo_\n- [[L-25] Potential division by 0 in `recordKeyPurchase`](https://github.com/code-423n4/2021-11-unlock-findings/issues/43) _Submitted by loop_\n- [[L-26] Function spec and implementation difference / strict comparison](https://github.com/code-423n4/2021-11-unlock-findings/issues/45) _Submitted by loop_\n- [[L-27] msg.value should be 0 when token is not native](https://github.com/code-423n4/2021-11-unlock-findings/issues/220) _Submitted by pauliax_\n- [[L-28] tokenByIndex returns wrong token id](https://github.com/code-423n4/2021-11-unlock-findings/issues/222) _Submitted by pauliax_\n- [[L-29] Interface and implementation differ](https://github.com/code-423n4/2021-11-unlock-findings/issues/224) _Submitted by pauliax_\n- [[L-30] onKeyPurchase hook expects amount + discount](https://github.com/code-423n4/2021-11-unlock-findings/issues/225) _Submitted by pauliax_\n- [[L-31] Validations](https://github.com/code-423n4/2021-11-unlock-findings/issues/228) _Submitted by pauliax_\n- [[L-32] `MixinRefunds.sol#cancelAndRefund()` Potential fund loss on `cancelAndRefund()` for users who purchased multiple times](https://github.com/code-423n4/2021-11-unlock-findings/issues/187) _Submitted by WatchPug, also found by GiveMeTestEther_\n\n# Non-Critical Findings (54)\n- [[N-01] Use safeTransfer consistently instead of transfer](https://github.com/code-423n4/2021-11-unlock-findings/issues/109) _Submitted by Jujic_\n- [[N-02] `freeTrialLength` is used as full refund period](https://github.com/code-423n4/2021-11-unlock-findings/issues/96) _Submitted by 0x0x0x_\n- [[N-03] Open TODOs](https://github.com/code-423n4/2021-11-unlock-findings/issues/22) _Submitted by mics, also found by Meta0xNull, loop, pauliax, ye0lde, hagrid, and defsec_\n- [[N-04] Function grantKeys() - Bulk Send Free Keys Are Not Practical & Gas May Over Block Size Limit](https://github.com/code-423n4/2021-11-unlock-findings/issues/147) _Submitted by Meta0xNull_\n- [[N-05] ERC20 return values not checked](https://github.com/code-423n4/2021-11-unlock-findings/issues/157) _Submitted by cmichel_\n- [[N-06] Unable to change token approval when tokenAddress changed](https://github.com/code-423n4/2021-11-unlock-findings/issues/215) _Submitted by gzeon_\n- [[N-07] input validation](https://github.com/code-423n4/2021-11-unlock-findings/issues/77) _Submitted by sabtikw_\n- [[N-08] Input validation of Zero address on addLockTemplate](https://github.com/code-423n4/2021-11-unlock-findings/issues/83) _Submitted by BouSalman_\n- [[N-09] Input validation of Zero address on function initialize()](https://github.com/code-423n4/2021-11-unlock-findings/issues/86) _Submitted by BouSalman_\n- [[N-10] Input validation Zero address](https://github.com/code-423n4/2021-11-unlock-findings/issues/81) _Submitted by BouSalman_\n- [[N-11] Insufficient input validation](https://github.com/code-423n4/2021-11-unlock-findings/issues/171) _Submitted by WatchPug_\n- [[N-12] Missing input validation on array lengths (MixinGrantKeys.sol)](https://github.com/code-423n4/2021-11-unlock-findings/issues/105) _Submitted by ye0lde_\n- [[N-13] transferOwnership should be two step process](https://github.com/code-423n4/2021-11-unlock-findings/issues/169) _Submitted by defsec, also found by Meta0xNull_\n- [[N-14] USE OF DEPRECATED _SETUPROLE FUNCTION](https://github.com/code-423n4/2021-11-unlock-findings/issues/14) _Submitted by Reigada_\n- [[N-15] USE OF FLOATING PRAGMA](https://github.com/code-423n4/2021-11-unlock-findings/issues/15) _Submitted by Reigada, also found by jayjonah8_\n- [[N-16] MixinERC721Enumerable.tokenOfOwnerByIndex - parameter _index can be removed](https://github.com/code-423n4/2021-11-unlock-findings/issues/32) _Submitted by Reigada_\n- [[N-17] Missing events for critical operations](https://github.com/code-423n4/2021-11-unlock-findings/issues/204) _Submitted by WatchPug_\n- [[N-18] Initializer modifiers should be called in the same way everywhere ](https://github.com/code-423n4/2021-11-unlock-findings/issues/1) _Submitted by jayjonah8_\n- [[N-19] Wrong comment in recordKeyPurchase](https://github.com/code-423n4/2021-11-unlock-findings/issues/82) _Submitted by kenzo_\n- [[N-20] Inconsistent code and comment](https://github.com/code-423n4/2021-11-unlock-findings/issues/212) _Submitted by gzeon_\n- [[N-21] MixinLockCore.sol has wrong comments](https://github.com/code-423n4/2021-11-unlock-findings/issues/122) _Submitted by GiveMeTestEther_\n- [[N-22] Incorrect or confusing comments or missing code in tokenOfOwnerByIndex](https://github.com/code-423n4/2021-11-unlock-findings/issues/208) _Submitted by ye0lde_\n- [[N-23] named return issue](https://github.com/code-423n4/2021-11-unlock-findings/issues/20) _Submitted by mics_\n- [[N-24] safeApprove is deprecated. ](https://github.com/code-423n4/2021-11-unlock-findings/issues/21) _Submitted by mics_\n- [[N-25] Use explicit variables type](https://github.com/code-423n4/2021-11-unlock-findings/issues/37) _Submitted by BouSalman_\n- [[N-26] Function type from public to external](https://github.com/code-423n4/2021-11-unlock-findings/issues/5) _Submitted by BouSalman_\n- [[N-27] Missing event for critical updateBeneficiary function](https://github.com/code-423n4/2021-11-unlock-findings/issues/75) _Submitted by BouSalman_\n- [[N-28] Function type from public to external tokenByIndex()](https://github.com/code-423n4/2021-11-unlock-findings/issues/76) _Submitted by BouSalman_\n- [[N-29] Fix event params for `KeyManagerChanged`](https://github.com/code-423n4/2021-11-unlock-findings/issues/128) _Submitted by HardlyDifficult_\n- [[N-30] Reduce rounding error when minting UDT in Unlock](https://github.com/code-423n4/2021-11-unlock-findings/issues/131) _Submitted by HardlyDifficult_\n- [[N-31] shareKey onERC721Received tokenId](https://github.com/code-423n4/2021-11-unlock-findings/issues/91) _Submitted by HardlyDifficult_\n- [[N-32] Remove fallback function](https://github.com/code-423n4/2021-11-unlock-findings/issues/94) _Submitted by HardlyDifficult_\n- [[N-33] Unnecessary function parameter in Unlock.upgradeLock() function](https://github.com/code-423n4/2021-11-unlock-findings/issues/25) _Submitted by Ruhum_\n- [[N-34] Changes that affect access control should be accompanied by an event](https://github.com/code-423n4/2021-11-unlock-findings/issues/28) _Submitted by Ruhum_\n- [[N-35] Constants are not explicitly declared](https://github.com/code-423n4/2021-11-unlock-findings/issues/173) _Submitted by WatchPug_\n- [[N-36] Code Style: Unnecessary public function visibility](https://github.com/code-423n4/2021-11-unlock-findings/issues/184) _Submitted by WatchPug_\n- [[N-37] Consider adding `initializer` modifier to _initialize** functions](https://github.com/code-423n4/2021-11-unlock-findings/issues/193) _Submitted by WatchPug_\n- [[N-38] Incomplete implementation](https://github.com/code-423n4/2021-11-unlock-findings/issues/197) _Submitted by WatchPug_\n- [[N-39] `MixinPurchase#purchase()` Consider checking if _referrer equals _recipient](https://github.com/code-423n4/2021-11-unlock-findings/issues/198) _Submitted by WatchPug_\n- [[N-40] Race condition on ERC20 approval](https://github.com/code-423n4/2021-11-unlock-findings/issues/202) _Submitted by WatchPug_\n- [[N-41] Typos](https://github.com/code-423n4/2021-11-unlock-findings/issues/205) _Submitted by WatchPug_\n- [[N-42] Critical changes should use two-step procedure](https://github.com/code-423n4/2021-11-unlock-findings/issues/207) _Submitted by WatchPug_\n- [[N-43] Order of layout is wrong in ERC20Patched.sol](https://github.com/code-423n4/2021-11-unlock-findings/issues/11) _Submitted by aga7hokakological_\n- [[N-44] Order of function is wrong in contracts ERC20PermitUpgradeable, ERC20VotesCompUpgradeable, EIP712Upgradeable](https://github.com/code-423n4/2021-11-unlock-findings/issues/9) _Submitted by aga7hokakological_\n- [[N-45] Missing `_beforeTokenTransfer` Token Transfer Handle](https://github.com/code-423n4/2021-11-unlock-findings/issues/78) _Submitted by hagrid_\n- [[N-46] Initialization parameters of new lock template are hardcoded](https://github.com/code-423n4/2021-11-unlock-findings/issues/137) _Submitted by kenzo_\n- [[N-47] Unconventional log emittance confuses Etherscan](https://github.com/code-423n4/2021-11-unlock-findings/issues/90) _Submitted by kenzo_\n- [[N-48] Commented lines of code](https://github.com/code-423n4/2021-11-unlock-findings/issues/46) _Submitted by loop_\n- [[N-49] Use of access control require statement when modifier exists](https://github.com/code-423n4/2021-11-unlock-findings/issues/48) _Submitted by loop_\n- [[N-50] grantKeys no check on parameter array lengths and values](https://github.com/code-423n4/2021-11-unlock-findings/issues/56) _Submitted by nathaniel_\n- [[N-51] Store owners in EnumerableSet](https://github.com/code-423n4/2021-11-unlock-findings/issues/231) _Submitted by pauliax_\n- [[N-52] `== true` doesn't bring anything](https://github.com/code-423n4/2021-11-unlock-findings/issues/115) _Submitted by 0x0x0x_\n- [[N-53] Avoiding Initialization of Loop Index If It Is 0](https://github.com/code-423n4/2021-11-unlock-findings/issues/146) _Submitted by Meta0xNull_\n- [[N-54] Upgrade pragma to at least 0.8.4](https://github.com/code-423n4/2021-11-unlock-findings/issues/12) _Submitted by defsec_\n\n# Gas Optimizations (48)\n- [[G-01] MixinTransfer:getTransferFee gas optimization with unchecked](https://github.com/code-423n4/2021-11-unlock-findings/issues/123) _Submitted by GiveMeTestEther_\n- [[G-02] Setters of `UnlockProtocolGovernor.sol` can be implemented more efficiently](https://github.com/code-423n4/2021-11-unlock-findings/issues/101) _Submitted by 0x0x0x_\n- [[G-03] Cache length at for loop to save gas](https://github.com/code-423n4/2021-11-unlock-findings/issues/103) _Submitted by 0x0x0x_\n- [[G-04] `MixinGrantKeys.sol` apply requiere statements earlier](https://github.com/code-423n4/2021-11-unlock-findings/issues/110) _Submitted by 0x0x0x_\n- [[G-05] Use unchecked operation to save gas](https://github.com/code-423n4/2021-11-unlock-findings/issues/111) _Submitted by 0x0x0x_\n- [[G-06] 4 variables are cached and used only once at `Unlock.sol#upgradeLock`](https://github.com/code-423n4/2021-11-unlock-findings/issues/116) _Submitted by 0x0x0x_\n- [[G-07] `UnlockUtils.sol#address2Str` can be implemented much cheaper](https://github.com/code-423n4/2021-11-unlock-findings/issues/98) _Submitted by 0x0x0x_\n- [[G-08] Unnecessary fallback function](https://github.com/code-423n4/2021-11-unlock-findings/issues/4) _Submitted by BouSalman_\n- [[G-09] Adding unchecked directive can save gas](https://github.com/code-423n4/2021-11-unlock-findings/issues/203) _Submitted by WatchPug, also found by GiveMeTestEther, mics, and pauliax_\n- [[G-10] MixinGrantKeys:grantKeys gas optimizations](https://github.com/code-423n4/2021-11-unlock-findings/issues/149) _Submitted by GiveMeTestEther, also found by Reigada and defsec_\n- [[G-11] Unlock:createLock no need to define the newLock as payable](https://github.com/code-423n4/2021-11-unlock-findings/issues/226) _Submitted by GiveMeTestEther, also found by WatchPug_\n- [[G-12] Unlock:_deployProxyAdmin return value is not used](https://github.com/code-423n4/2021-11-unlock-findings/issues/232) _Submitted by GiveMeTestEther_\n- [[G-13] MixinFunds:_initializeMixinFunds move the require statement to the beginning of the function so save gas in the case of a revert](https://github.com/code-423n4/2021-11-unlock-findings/issues/60) _Submitted by GiveMeTestEther, also found by loop_\n- [[G-14] Gas: Assume 0 when creating struct](https://github.com/code-423n4/2021-11-unlock-findings/issues/127) _Submitted by HardlyDifficult_\n- [[G-15] Gas: Cast instead of creating new variables](https://github.com/code-423n4/2021-11-unlock-findings/issues/129) _Submitted by HardlyDifficult, also found by TomFrench and cmichel_\n- [[G-16] Avoid On Chain Computation That Have Known Answer to Save Gas](https://github.com/code-423n4/2021-11-unlock-findings/issues/145) _Submitted by Meta0xNull_\n- [[G-17] Long Revert Strings](https://github.com/code-423n4/2021-11-unlock-findings/issues/36) _Submitted by Reigada, also found by WatchPug_\n- [[G-18] Using uint16 for lock versions increases gas costs for no reason.](https://github.com/code-423n4/2021-11-unlock-findings/issues/24) _Submitted by TomFrench_\n- [[G-19] Unused named returns](https://github.com/code-423n4/2021-11-unlock-findings/issues/177) _Submitted by WatchPug_\n- [[G-20] `UnlockUtils.sol#uint2Str()` Implementation can be simpler and save some gas](https://github.com/code-423n4/2021-11-unlock-findings/issues/178) _Submitted by WatchPug_\n- [[G-21] `MixinLockCore.sol#updateKeyPricing()` Check of `_tokenAddress` can be done earlier to save gas](https://github.com/code-423n4/2021-11-unlock-findings/issues/179) _Submitted by WatchPug_\n- [[G-22] Remove unnecessary variables can make the code simpler and save some gas](https://github.com/code-423n4/2021-11-unlock-findings/issues/185) _Submitted by WatchPug_\n- [[G-23] Redundant check of `owner() != address(0)`](https://github.com/code-423n4/2021-11-unlock-findings/issues/194) _Submitted by WatchPug_\n- [[G-24] Changing function visibility from public to external can save gas](https://github.com/code-423n4/2021-11-unlock-findings/issues/196) _Submitted by WatchPug, also found by loop, mics, nathaniel, and Jujic_\n- [[G-25] Avoid unnecessary storage reads can save gas](https://github.com/code-423n4/2021-11-unlock-findings/issues/199) _Submitted by WatchPug_\n- [[G-26] Remove unnecessary function can make the code simpler and save some gas](https://github.com/code-423n4/2021-11-unlock-findings/issues/200) _Submitted by WatchPug_\n- [[G-27] `MixinRefunds.sol#_getCancelAndRefundValue` Cache and read storage variables from the stack can save gas](https://github.com/code-423n4/2021-11-unlock-findings/issues/206) _Submitted by WatchPug_\n- [[G-28] Gas: `_recordOwner` pushes duplicates](https://github.com/code-423n4/2021-11-unlock-findings/issues/167) _Submitted by cmichel_\n- [[G-29] Inconsistent use of _msgSender()](https://github.com/code-423n4/2021-11-unlock-findings/issues/209) _Submitted by defsec_\n- [[G-30] Gas improvement on the nonce increment](https://github.com/code-423n4/2021-11-unlock-findings/issues/210) _Submitted by defsec_\n- [[G-31] Less than 256 uints are not gas efficient](https://github.com/code-423n4/2021-11-unlock-findings/issues/89) _Submitted by defsec_\n- [[G-32] Gas optimization: Unused variable `yieldedDiscountTokens`](https://github.com/code-423n4/2021-11-unlock-findings/issues/213) _Submitted by gzeon_\n- [[G-33] MixinRefunds: use variable to save gas](https://github.com/code-423n4/2021-11-unlock-findings/issues/68) _Submitted by itsmeSTYJ_\n- [[G-34] MixinPurchase: gas optimisation by relying on 0.8.0 auto revert on underflow.](https://github.com/code-423n4/2021-11-unlock-findings/issues/69) _Submitted by itsmeSTYJ_\n- [[G-35] Redundant check of freeTrialLength == 0](https://github.com/code-423n4/2021-11-unlock-findings/issues/54) _Submitted by nathaniel_\n- [[G-36] Precalculate expressions](https://github.com/code-423n4/2021-11-unlock-findings/issues/233) _Submitted by pauliax_\n- [[G-37] Unnecessary checks](https://github.com/code-423n4/2021-11-unlock-findings/issues/234) _Submitted by pauliax_\n- [[G-38] Refund amount and penalty calculation](https://github.com/code-423n4/2021-11-unlock-findings/issues/236) _Submitted by pauliax_\n- [[G-39] timePlusFee = timeRemaining](https://github.com/code-423n4/2021-11-unlock-findings/issues/237) _Submitted by pauliax_\n- [[G-40] assigned operations to constant variables](https://github.com/code-423n4/2021-11-unlock-findings/issues/238) _Submitted by pauliax, also found by Reigada_\n- [[G-41] 0 valueInETH](https://github.com/code-423n4/2021-11-unlock-findings/issues/239) _Submitted by pauliax_\n- [[G-42] ++/-- are cheapest](https://github.com/code-423n4/2021-11-unlock-findings/issues/240) _Submitted by pauliax_\n- [[G-43] address(this).address2Str()](https://github.com/code-423n4/2021-11-unlock-findings/issues/241) _Submitted by pauliax_\n- [[G-44] Use existing memory version of state variables](https://github.com/code-423n4/2021-11-unlock-findings/issues/121) _Submitted by ye0lde_\n- [[G-45] Unused Named Returns](https://github.com/code-423n4/2021-11-unlock-findings/issues/66) _Submitted by ye0lde_\n- [[G-46] Gas: remove owners array](https://github.com/code-423n4/2021-11-unlock-findings/issues/130) _Submitted by HardlyDifficult_\n- [[G-47] `Unlock.sol#RecordKeyPurchases` can be implemented cheaper](https://github.com/code-423n4/2021-11-unlock-findings/issues/114) _Submitted by 0x0x0x_\n- [[G-48] Gas: Merge callbacks to Unlock on purchase](https://github.com/code-423n4/2021-11-unlock-findings/issues/126) _Submitted by HardlyDifficult_\n\n# Disclosures\n\nC4 is an open organization governed by participants in the community.\n\nC4 Contests incentivize the discovery of exploits, vulnerabilities, and bugs in smart contracts. Security researchers are rewarded at an increasing rate for finding higher-risk issues. Contest submissions are judged by a knowledgeable security researcher and solidity developer and disclosed to sponsoring developers. C4 does not conduct formal verification regarding the provided code but instead provides final verification.\n\nC4 does not provide any guarantee or warranty regarding the security of this project. All smart contract software should be used at the sole risk and responsibility of users.\n"
}