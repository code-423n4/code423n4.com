{
  "circa": {
    "title": "Notional",
    "sponsor": "Notional",
    "slug": "2021-08-notional",
    "date": "2021-10-01",
    "findings": "https://github.com/code-423n4/2021-08-notional-findings/issues",
    "contest": 23
  },
  "html": "<h1 id=\"overview\" style=\"position:relative;\"><a href=\"#overview\" aria-label=\"overview permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Overview</h1>\n<h2 id=\"about-c4\" style=\"position:relative;\"><a href=\"#about-c4\" aria-label=\"about c4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>About C4</h2>\n<p>Code 432n4 (C4) is an open organization consisting of security researchers, auditors, developers, and individuals with domain expertise in smart contracts.</p>\n<p>A C4 code contest is an event in which community participants, referred to as Wardens, review, audit, or analyze smart contract logic in exchange for a bounty provided by sponsoring projects.</p>\n<p>During the code contest outlined in this document, C4 conducted an analysis of Notional smart contract system written in Solidity. The code contest took place between August 25—September 8, 2021.</p>\n<h2 id=\"wardens\" style=\"position:relative;\"><a href=\"#wardens\" aria-label=\"wardens permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Wardens</h2>\n<p>11 Wardens contributed reports to the Notional code contest:</p>\n<ol>\n<li><a href=\"https://twitter.com/cmichelio\">cmichel</a></li>\n<li><a href=\"https://twitter.com/liam_eastwood13\">leastwood</a></li>\n<li><a href=\"https://twitter.com/SolidityDev\">pauliax</a></li>\n<li><a href=\"https://twitter.com/Tensors8\">tensors</a></li>\n<li><a href=\"https://twitter.com/gpersoon\">gpersoon</a></li>\n<li><a href=\"https://twitter.com/omikomikomik\">Omik</a></li>\n<li><a href=\"https://twitter.com/MukeshJ_eth\">Jmukesh</a></li>\n<li><a href=\"https://twitter.com/_hrkrshnn\">hrkrshnn</a></li>\n<li><a href=\"https://twitter.com/a_delamo\">a_delamo</a></li>\n<li><a href=\"https://twitter.com/lsdan_defi\">LSDan</a></li>\n<li><a href=\"https://twitter.com/adeshkolte_\">ad3sh_</a></li>\n</ol>\n<p>This contest was judged by <a href=\"https://twitter.com/ghoulsol\">ghoul.sol</a>.</p>\n<p>Final report assembled by <a href=\"https://twitter.com/money_lego\">moneylegobatman</a> and <a href=\"https://twitter.com/_ninek_\">ninek</a>.</p>\n<h1 id=\"summary\" style=\"position:relative;\"><a href=\"#summary\" aria-label=\"summary permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Summary</h1>\n<p>The C4 analysis yielded an aggregated total of 38 unique vulnerabilities. All of the issues presented here are linked back to their original findings.</p>\n<p>Of these vulnerabilities, 10 received a risk rating in the category of HIGH severity, 7 received a risk rating in the category of MEDIUM severity, and 21 received a risk rating in the category of LOW severity.</p>\n<p>C4 analysis also identified 13 non-critical recommendations and 8 gas optimizations.</p>\n<h1 id=\"scope\" style=\"position:relative;\"><a href=\"#scope\" aria-label=\"scope permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Scope</h1>\n<p>The code under review can be found within the <a href=\"https://github.com/code-423n4/2021-08-notional\">C4 Notional code contest repository</a> is comprised of 98 smart contracts written in the Solidity programming language and includes 13,208 lines of Solidity code.</p>\n<h1 id=\"severity-criteria\" style=\"position:relative;\"><a href=\"#severity-criteria\" aria-label=\"severity criteria permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Severity Criteria</h1>\n<p>C4 assesses the severity of disclosed vulnerabilities according to a methodology based on <a href=\"https://owasp.org/www-community/OWASP_Risk_Rating_Methodology\">OWASP standards</a>.</p>\n<p>Vulnerabilities are divided into three primary risk categories: high, medium, and low.</p>\n<p>High-level considerations for vulnerabilities span the following key areas when conducting assessments:</p>\n<ul>\n<li>Malicious Input Handling</li>\n<li>Escalation of privileges</li>\n<li>Arithmetic</li>\n<li>Gas use</li>\n</ul>\n<p>Further information regarding the severity criteria referenced throughout the submission review process, please refer to the documentation provided on <a href=\"https://code423n4.com\">the C4 website</a>.</p>\n<h1 id=\"high-risk-findings-10\" style=\"position:relative;\"><a href=\"#high-risk-findings-10\" aria-label=\"high risk findings 10 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>High Risk Findings (10)</h1>\n<h2 id=\"h-01-self-transfer-can-lead-to-unlimited-mint\" style=\"position:relative;\"><a href=\"#h-01-self-transfer-can-lead-to-unlimited-mint\" aria-label=\"h 01 self transfer can lead to unlimited mint permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/1\">[H-01] Self transfer can lead to unlimited mint</a></h2>\n<p><em>Submitted by Omik, also found by gpersoon</em></p>\n<p>The implementation of the transfer function in <a href=\"https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol\"><code>nTokenAction.sol</code></a> is different from the usual erc20 token transfer function.</p>\n<p> This happens because it counts the incentive that the user gets, but with a self-transfer,  it can lead to unlimited mint. In <a href=\"https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol#_L278\">L278</a>, it makes the amount negative, but in <a href=\"https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol#L279\">L279</a>, it returns the value to an amount that is not negative. So, in the <a href=\"https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol#L281-282\">L281-282</a>, it finalizes a positive value, only because the negative value is changed to the positive value.</p>\n<p> You can interact with this transfer function through <a href=\"https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/adapters/nTokenERC20Proxy.sol\">nTokenERC20Proxy.sol</a>.</p>\n<p>Recommend adding <code>(sender != recipient)</code>.</p>\n<h2 id=\"h-02-dao-proposals-can-be-executed-by-anyone-due-to-vulnerable-timelockcontroller\" style=\"position:relative;\"><a href=\"#h-02-dao-proposals-can-be-executed-by-anyone-due-to-vulnerable-timelockcontroller\" aria-label=\"h 02 dao proposals can be executed by anyone due to vulnerable timelockcontroller permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/58\">[H-02] DAO proposals can be executed by anyone due to vulnerable <code>TimelockController</code></a></h2>\n<p><em>Submitted by cmichel, also found by leastwood</em></p>\n<p>The <code>GovernorAlpha</code> inherits from a vulnerable <code>TimelockController</code>.\nThis <code>TimelockController</code> allows an <code>EXECUTOR</code> role to escalate privileges and also gain the proposer role. See details on <a href=\"https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-fg47-3c2x-m2wr\">OZ</a> and the <a href=\"https://github.com/OpenZeppelin/openzeppelin-contracts/compare/v4.3.0...v4.3.1\">fix here</a>.</p>\n<p>The bug is that <code>_executeBatch</code> checks if the proposal was scheduled only <strong>after</strong> the transactions have been executed. This allows inserting a call into the batch that schedules the batch itself, and the entire batch will succeed.\nAs the custom <code>GovernorAlpha.executeProposal</code> function removed the original “queued state check” (<code>require(state(proposalId) == ProposalState.Queued</code>), the attack can be executed by anyone, even without the <code>EXEUCTOR_ROLE</code>.</p>\n<p><strong>Proof of concept</strong>:</p>\n<ol>\n<li>Create a proposal using <code>propose</code>. The <code>calldata</code> will be explained in the next step. (This can be done by anyone passing the min <code>proposalThreshold</code>)</li>\n<li>Call <code>executeProposal(proposalId, ...)</code> such that the following calls are made:</li>\n</ol>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"0\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">call</span><span class=\"mtk1\">-</span><span class=\"mtk7\">0</span><span class=\"mtk1\">: </span><span class=\"mtk11\">grantRole</span><span class=\"mtk1\">(</span><span class=\"mtk12\">TIME_LOCK_ADMIN</span><span class=\"mtk1\">, </span><span class=\"mtk12\">attackerContract</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">call</span><span class=\"mtk1\">-</span><span class=\"mtk7\">1</span><span class=\"mtk1\">: </span><span class=\"mtk11\">grantRole</span><span class=\"mtk1\">(</span><span class=\"mtk12\">EXECUTOR</span><span class=\"mtk1\">, </span><span class=\"mtk12\">attackerContract</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">call</span><span class=\"mtk1\">-</span><span class=\"mtk7\">2</span><span class=\"mtk1\">: </span><span class=\"mtk11\">grantRole</span><span class=\"mtk1\">(</span><span class=\"mtk12\">PROPOSER</span><span class=\"mtk1\">, </span><span class=\"mtk12\">attackerContract</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">call</span><span class=\"mtk1\">-</span><span class=\"mtk7\">3</span><span class=\"mtk1\">: </span><span class=\"mtk11\">updateDelay</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">) </span><span class=\"mtk3\">// such that _afterCall &quot;isOperationReady(id): timestamp[id] = block.timestamp + minDelay (0) &lt;= block.timestamp&quot; passes</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">call</span><span class=\"mtk1\">-</span><span class=\"mtk7\">4</span><span class=\"mtk1\">: </span><span class=\"mtk12\">attackerContract</span><span class=\"mtk1\">.</span><span class=\"mtk11\">hello</span><span class=\"mtk1\">() </span><span class=\"mtk3\">// this calls timelock.schedule(args=[targets, values, datas, ...]) where args were previously already stored in contract. (this is necessary because id depends on this function&#39;s args and we may not be self-referential)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// attackerContract is proposer &amp; executor now and can directly call scheduleBatch &amp; executeBatch without having to create a proposal</span></span></span></code></pre>\n<blockquote>\n<p>ℹ️  I already talked to Jeff Wu about this and he created a test case for it confirming this finding</p>\n</blockquote>\n<p>The impact is that, anyone who can create a proposal can become <code>Timelock</code> admin (proposer &#x26; executor) and execute arbitrary transactions as the DAO-controlled <code>GovernorAlpha</code>.\nNote that this contract has severe privileges and an attacker can now do anything that previously required approval of the DAO. For example, they could update the <code>globalTransferOperator</code> and steal all tokens.</p>\n<p>Recommend updating the vulnerable contract to <code>TimelockController v3.4.2</code> as it currently uses <code>OpenZeppelin/openzeppelin-contracts@3.4.0-solc-0.7</code></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/58\">jeffywu (Notional) confirmed</a></strong></p>\n<h2 id=\"h-03-compoundtonotionalv2notionalcallback-erc20-return-values-not-checked\" style=\"position:relative;\"><a href=\"#h-03-compoundtonotionalv2notionalcallback-erc20-return-values-not-checked\" aria-label=\"h 03 compoundtonotionalv2notionalcallback erc20 return values not checked permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/68\">[H-03] <code>CompoundToNotionalV2.notionalCallback</code> ERC20 return values not checked</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>Some tokens (like USDT) don’t correctly implement the EIP20 standard and their <code>transfer</code>/<code>transferFrom</code> functions return <code>void</code>, instead of a success boolean. Calling these functions with the correct EIP20 function signatures will always revert. See <code>CompoundToNotionalV2.notionalCallback</code>’s <code>IERC20(underlyingToken).transferFrom</code> call.</p>\n<p>Tokens that don’t correctly implement the latest EIP20 spec, like USDT, will be unusable in the protocol as they revert the transaction because of the missing return value.\nThe fact that there is a <code>cToken</code> with <code>USDT</code> as the underlying this issue directly applies to the protocol.</p>\n<p>We recommend using OpenZeppelin’s <code>SafeERC20</code> versions with the <code>safeTransfer</code> and <code>safeTransferFrom</code> functions that handle the return value check as well as non-standard-compliant tokens.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/68\">jeffywu (Notional) confirmed</a></strong></p>\n<h2 id=\"h-04-access-restrictions-on-compoundtonotionalv2notionalcallback-can-be-bypassed\" style=\"position:relative;\"><a href=\"#h-04-access-restrictions-on-compoundtonotionalv2notionalcallback-can-be-bypassed\" aria-label=\"h 04 access restrictions on compoundtonotionalv2notionalcallback can be bypassed permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/69\">[H-04] Access restrictions on <code>CompoundToNotionalV2.notionalCallback</code> can be bypassed</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The <code>CompoundToNotionalV2.notionalCallback</code> is supposed to only be called from the verified contract that calls this callback. But, the access restrictions can be circumvented by simply providing <code>sender = this</code>, as <code>sender</code> is a parameter of the function that can be chosen by the attacker.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"1\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">notionalCallback</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">sender</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">account</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">bytes</span><span class=\"mtk1\"> </span><span class=\"mtk12\">calldata</span><span class=\"mtk1\"> </span><span class=\"mtk12\">callbackData</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// @audit sender can be passed in by the attacker</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">sender</span><span class=\"mtk1\"> == </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">), </span><span class=\"mtk8\">&quot;Unauthorized callback&quot;</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p>An attacker can call the function passing in an arbitrary <code>account</code> whose tokens are then transferred to the contract.\nThe <code>account</code> first has to approve this contract but this can happen with accounts that legitimately want to call the outer function and have to send a first transaction to approve the contract, but then an attacker front-runs the actual transaction.</p>\n<p>It’s at least a griefing attack:\nI can pass in a malicious <code>cTokenBorrow</code> that returns any token of my choice (through the <code>.underlying()</code> call) but whose <code>repayBorrowBehalf</code> is a no-op.</p>\n<p>This will lead to any of the victim’s approved tokens becoming stuck in the contract, essentially burning them:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"2\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// @audit using a malicious contract, this can be any token</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">underlyingToken</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">CTokenInterface</span><span class=\"mtk1\">(</span><span class=\"mtk12\">cTokenBorrow</span><span class=\"mtk1\">).</span><span class=\"mtk11\">underlying</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">bool</span><span class=\"mtk1\"> </span><span class=\"mtk12\">success</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">IERC20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">underlyingToken</span><span class=\"mtk1\">).</span><span class=\"mtk11\">transferFrom</span><span class=\"mtk1\">(</span><span class=\"mtk12\">account</span><span class=\"mtk1\">, </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">), </span><span class=\"mtk12\">cTokenRepayAmount</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">success</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;Transfer of repayment failed&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// Use the amount transferred to repay the borrow</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// @audit using a malicious contract, this can be a no-op</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">code</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">CErc20Interface</span><span class=\"mtk1\">(</span><span class=\"mtk12\">cTokenBorrow</span><span class=\"mtk1\">).</span><span class=\"mtk11\">repayBorrowBehalf</span><span class=\"mtk1\">(</span><span class=\"mtk12\">account</span><span class=\"mtk1\">, </span><span class=\"mtk12\">cTokenRepayAmount</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p>Note that the assumption at the end of the function ”// When this exits a free collateral check will be triggered” is not correct anymore but I couldn’t find a way to make use of it to lead to an invalid account state.</p>\n<p>Recommend fixing the authorization check.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/69\">jeffywu (Notional) confirmed</a></strong></p>\n<h2 id=\"h-05-access-restrictions-on-notionalv1tonotionalv2notionalcallback-can-be-bypassed\" style=\"position:relative;\"><a href=\"#h-05-access-restrictions-on-notionalv1tonotionalv2notionalcallback-can-be-bypassed\" aria-label=\"h 05 access restrictions on notionalv1tonotionalv2notionalcallback can be bypassed permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/71\">[H-05] Access restrictions on <code>NotionalV1ToNotionalV2.notionalCallback</code> can be bypassed</a></h2>\n<p><em>Submitted by cmichel, also found by pauliax</em></p>\n<p>The <code>NotionalV1ToNotionalV2.notionalCallback</code> is supposed to only be called from the verified contract that calls this callback but the access restrictions can be circumvented by simply providing <code>sender = this</code> as <code>sender</code> is a parameter of the function that can be chosen by the attacker.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"3\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">notionalCallback</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">sender</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">account</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">bytes</span><span class=\"mtk1\"> </span><span class=\"mtk12\">calldata</span><span class=\"mtk1\"> </span><span class=\"mtk12\">callbackData</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">sender</span><span class=\"mtk1\"> == </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">), </span><span class=\"mtk8\">&quot;Unauthorized callback&quot;</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p>An attacker can call the function passing in an arbitrary <code>account</code> whose tokens can then be stolen.\nThe <code>account</code> first has to approve this contract but this can happen with accounts that legitimately want to migrate their tokens and therefore have to send a first transaction to approve the contract, but then an attacker frontruns the actual migration transaction.</p>\n<p>The attacker can steal the tokens by performing an attack similar to the following:</p>\n<ul>\n<li>first transaction is used to withdraw the victim’s funds to the contract. This can be done by choosing <code>account=victim</code>, <code>v1RepayAmount=0</code>, <code>v1CollateralId=WBTC</code>, <code>v2CollateralId=DAI</code>. The <a href=\"https://github.com/notional-finance/contracts/blob/4bf7a85e6cf81cde4283e0efab0b03f21249ba00/contracts/ERC1155Trade.sol#L108\"><code>NotionalV1Erc1155.batchOperationWithdraw</code></a> (not part of this contest) will withdraw the victim’s funds to this contract. Note that the attacker has to deposit the same <code>v2CollateralBalance = uint256(collateralBalance)</code> for the victim into the V2 version, but they can choose different cheaper collateral (for example, withdraw WBTC, deposit same amount of DAI).</li>\n<li>second transaction is now used to deposit the victim funds in the contract into the user’s account. They use <code>account=attacker</code>, <code>v1DebtCurrencyId=WBTC</code>, <code>v1RepayAmount=amount</code> to deposit it into Notional V1. (They need to have a small <code>collateralBalance</code>, etc. to pass all checks).</li>\n</ul>\n<p>Recommend fixing the authorization check.</p>\n<h2 id=\"h-06-tokenhandlersafetransferout-does-not-work-on-non-standard-compliant-tokens-like-usdt\" style=\"position:relative;\"><a href=\"#h-06-tokenhandlersafetransferout-does-not-work-on-non-standard-compliant-tokens-like-usdt\" aria-label=\"h 06 tokenhandlersafetransferout does not work on non standard compliant tokens like usdt permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/79\">[H-06] <code>TokenHandler.safeTransferOut</code> does not work on non-standard compliant tokens like USDT</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The <code>TokenHandler.safeTransferOut</code> function uses the standard <code>IERC20</code> function for the transfer call and proceeds with a <code>checkReturnCode</code> function to handle non-standard compliant tokens that don’t return a return value.\nHowever, this does not work, as calling <code>token.transfer(account, amount)</code> already reverts if the token does not return a return value, as <code>token</code>’s <code>IERC20.transfer</code> is defined to always return a <code>boolean</code>.</p>\n<p>The impact is that, when using any non-standard compliant token like USDT, the function will revert.\nDeposits for these tokens are broken, which is bad as <code>USDT</code> is a valid underlying for the <code>cUSDT</code> cToken.</p>\n<p>We recommend using <a href=\"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74\">OpenZeppelin’s <code>SafeERC20</code></a> versions with the <code>safeApprove</code> function that handles the return value check as well as non-standard-compliant tokens.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/79\">jeffywu (Notional) confirmed</a></strong></p>\n<h2 id=\"h-07-tokenhandlersafetransferin-does-not-work-on-non-standard-compliant-tokens-like-usdt\" style=\"position:relative;\"><a href=\"#h-07-tokenhandlersafetransferin-does-not-work-on-non-standard-compliant-tokens-like-usdt\" aria-label=\"h 07 tokenhandlersafetransferin does not work on non standard compliant tokens like usdt permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/80\">[H-07] <code>TokenHandler.safeTransferIn</code> does not work on non-standard compliant tokens like USDT</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The <code>TokenHandler.safeTransferIn</code> function uses the standard <code>IERC20</code> function for the transfer call and proceeds with a <code>checkReturnCode</code> function to handle non-standard compliant tokens that don’t return a return value.\nHowever, this does not work, as calling <code>token.transferFrom(account, amount)</code> already reverts if the token does not return a return value, as <code>token</code>’s <code>IERC20.transferFrom</code> is defined to always return a <code>boolean</code>.</p>\n<p>When using any non-standard compliant token like USDT, the function will revert.\nWithdrawals for these tokens are broken, which is bad as <code>USDT</code> is a valid underlying for the <code>cUSDT</code> cToken.</p>\n<p>We recommend using <a href=\"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74\">OpenZeppelin’s <code>SafeERC20</code></a> versions with the <code>safeApprove</code> function that handles the return value check as well as non-standard-compliant tokens.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/80\">jeffywu (Notional) confirmed</a></strong></p>\n<h2 id=\"h-08-dos-by-frontrunning-noteerc20-initialize-function\" style=\"position:relative;\"><a href=\"#h-08-dos-by-frontrunning-noteerc20-initialize-function\" aria-label=\"h 08 dos by frontrunning noteerc20 initialize function permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/7\">[H-08] DOS by Frontrunning NoteERC20 <code>initialize()</code> Function</a></h2>\n<p><em>Submitted by leastwood</em></p>\n<p>The <code>scripts/</code> folder outlines a number of deployment scripts used by the Notional team. Some of the contracts deployed utilize the ERC1967 upgradeable proxy standard. This standard involves first deploying an implementation contract and later a proxy contract which uses the implementation contract as its logic.</p>\n<p>When users make calls to the proxy contract, the proxy contract will delegate call to the underlying implementation contract. <code>NoteERC20.sol</code> and <code>Router.sol</code> both implement an <code>initialize()</code> function which aims to replace the role of the <code>constructor()</code> when deploying proxy contracts. It is important that these proxy contracts are deployed and initialized in the same transaction to avoid any malicious front-running.</p>\n<p>However, <code>scripts/deployment.py</code> does not follow this pattern when deploying <code>NoteERC20.sol</code>’s proxy contract. As a result, a malicious attacker could monitor the Ethereum blockchain for bytecode that matches the <code>NoteERC20</code> contract and front-run the <code>initialize()</code> transaction to gain ownership of the contract. This can be repeated as a Denial Of Service (DOS) type of attack, effectively preventing Notional’s contract deployment, leading to unrecoverable gas expenses. See <a href=\"https://github.com/code-423n4/2021-08-notional/blob/main/scripts/deployment.py#L44-L60\"><code>deployment.py</code> L44-L60</a>, and <a href=\"https://github.com/code-423n4/2021-08-notional/blob/main/scripts/mainnet/deploy_governance.py#L71-L105\"><code>deploy_governance.py</code> L71-L105</a>.</p>\n<p>As the <code>GovernanceAlpha.sol</code> and <code>NoteERC20.sol</code> are co-dependent contracts in terms of deployment, it won’t be possible to deploy the governance contract before deploying and initializing the token contract. Therefore, it would be worthwhile to ensure the <code>NoteERC20.sol</code> proxy contract is deployed and initialized in the same transaction, or ensure the <code>initialize()</code> function is callable only by the deployer of the <code>NoteERC20.sol</code> contract. This could be set in the proxy contracts <code>constructor()</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/7\">jeffywu (Notional) confirmed</a></strong></p>\n<h2 id=\"h-09-potential-dos-in-contracts-inheriting-uupsupgradeablesol\" style=\"position:relative;\"><a href=\"#h-09-potential-dos-in-contracts-inheriting-uupsupgradeablesol\" aria-label=\"h 09 potential dos in contracts inheriting uupsupgradeablesol permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/98\">[H-09] Potential DOS in Contracts Inheriting <code>UUPSUpgradeable.sol</code></a></h2>\n<p><em>Submitted by leastwood</em></p>\n<p>There are a number of contracts which inherit <code>UUPSUpgradeable.sol</code>, namely; <code>GovernanceAction.sol</code>, <code>PauseRouter.sol</code> and <code>NoteERC20.sol</code>.</p>\n<p>All these contracts are deployed using a proxy pattern whereby the implementation contract is used by the proxy contract for all its logic. The proxy contract will make delegate calls to the implementation contract. This helps to facilitate future upgrades by pointing the proxy contract to a new and upgraded implementation contract.</p>\n<p>However, if the implementation contract is left uninitialized, it is possible for any user to gain ownership of the <code>onlyOwner</code> role in the implementation contract for <code>NoteERC20.sol</code>. Once the user has ownership they are able to perform an upgrade of the implementation contract’s logic contract and delegate call into any arbitrary contract, allowing them to self-destruct the proxy’s implementation contract. Consequently, this will prevent all <code>NoteERC20.sol</code> interactions until a new implementation contract is deployed.</p>\n<p>Initial information about this issue was found <a href=\"https://forum.openzeppelin.com/t/security-advisory-initialize-uups-implementation-contracts/15301\">here</a>.</p>\n<p>Consider the following scenario:</p>\n<ul>\n<li>Notional finance deploys their contracts using their deployment scripts. These deployment scripts leave the implementation contracts uninitialized. Specifically the contract in question is <code>NoteERC20.sol</code>.</li>\n<li>This allows any arbitrary user to call <code>initialize()</code> on the <code>NoteERC20.sol</code> implementation contract.</li>\n<li>Once a user has gained control over <code>NoteERC20.sol</code>’s implementation contract, they can bypass the <code>_authorizeUpgrade</code> check used to restrict upgrades to the <code>onlyOwner</code> role.</li>\n<li>The malicious user then calls <code>UUPSUpgradeable.upgradeToAndCall()</code> shown <a href=\"https://github.com/code-423n4/2021-08-notional/blob/main/contracts/proxy/utils/UUPSUpgradeable.sol#L40-L43\">here</a> which in turn calls <a href=\"https://github.com/code-423n4/2021-08-notional/blob/main/contracts/proxy/ERC1967/ERC1967Upgrade.sol#L77-L107\">this</a> function. The new implementation contract then points to their own contract containing a self-destruct call in its fallback function.</li>\n<li>As a result, the implementation contract will be self-destructed due to the user-controlled delegate call shown <a href=\"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0-solc-0.7/contracts/utils/Address.sol#L163-L169\">here</a>, preventing all future calls to the <code>NoteERC20.sol</code> proxy contract until a new implementation contract has been deployed.</li>\n</ul>\n<p>Recommend considering initializing the implementation contract for <code>NoteERC20.sol</code> and checking the correct permissions before deploying the proxy contract or performing any contract upgrades. This will help to ensure the implementation contract cannot be self-destructed.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/98#issuecomment-917410089\">jeffywu (Notional) acknowledged and disagreed with severity</a>:</strong></p>\n<blockquote>\n<p>Acknowledged, I don’t think this should be categorized high risk because the worst case is a denial of service and a redeployment of the ERC20 contract. As it stands, we’ve already successfully deployed our ERC20 contract so this is a non-issue.</p>\n<p>I would categorize as <code>0 (Non-critical)</code></p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/98#issuecomment-917415717\">adamavenir (organizer) commented</a>:</strong></p>\n<blockquote>\n<p>Warden leastwood added this proof of concept to illustrate the vulnerability <a href=\"https://gist.github.com/leastwood/b23d9e975883c817780116c2ceb785b8\">https://gist.github.com/leastwood/b23d9e975883c817780116c2ceb785b8</a></p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/98#issuecomment-917416175\">jeffywu (Notional) commented</a>:</strong></p>\n<blockquote>\n<p>Ok I retract my previous statement, I misread the issue description. Up to you guys but do you want to pay out a full amount to someone who is reporting issues discovered elsewhere? OZ has already called initialize on our deployed contract for us.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/98#issuecomment-917706252\">adamavenir (organizer) commented</a>:</strong></p>\n<blockquote>\n<p>@jeffywu (Notional) I think the question is whether the issue is valid based on the original code base. Given your initial response and change after his proof of concept, my read was there was value here in what he reported. Is that a correct understanding?</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/98#issuecomment-917706960\">jeffywu (Notional) commented</a>:</strong></p>\n<blockquote>\n<p>There was value added here but perhaps not at the same level as the other high risk issues.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/98#issuecomment-917744246\">adamavenir (organizer) commented</a>:</strong></p>\n<blockquote>\n<p>@jeffywu (Notional) Thanks for the input. As per our rules, awards are determined strictly based on the judge’s assessment of the validity and severity, so we’ll see how our judge chooses to score this.</p>\n</blockquote>\n<h2 id=\"h-10-liquidity-token-value-can-be-manipulated\" style=\"position:relative;\"><a href=\"#h-10-liquidity-token-value-can-be-manipulated\" aria-label=\"h 10 liquidity token value can be manipulated permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/85\">[H-10] Liquidity token value can be manipulated</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The liquidity token value (<code>AssetHandler.getLiquidityTokenValue</code>) is the sum of the value of the individual claims on cash (underlying or rather cTokens) and fCash.\nThe amount to redeem on each of these is computed as the LP token to redeem relative to the total LP tokens, see <code>AssetHandler.getCashClaims</code> / <code>AssetHandler.getHaircutCashClaims</code>:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"4\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// @audit token.notional are the LP tokens to redeem</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">assetCash</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">market</span><span class=\"mtk1\">.</span><span class=\"mtk12\">totalAssetCash</span><span class=\"mtk1\">.</span><span class=\"mtk11\">mul</span><span class=\"mtk1\">(</span><span class=\"mtk12\">token</span><span class=\"mtk1\">.</span><span class=\"mtk12\">notional</span><span class=\"mtk1\">).</span><span class=\"mtk11\">div</span><span class=\"mtk1\">(</span><span class=\"mtk12\">market</span><span class=\"mtk1\">.</span><span class=\"mtk12\">totalLiquidity</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">fCash</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">market</span><span class=\"mtk1\">.</span><span class=\"mtk12\">totalfCash</span><span class=\"mtk1\">.</span><span class=\"mtk11\">mul</span><span class=\"mtk1\">(</span><span class=\"mtk12\">token</span><span class=\"mtk1\">.</span><span class=\"mtk12\">notional</span><span class=\"mtk1\">).</span><span class=\"mtk11\">div</span><span class=\"mtk1\">(</span><span class=\"mtk12\">market</span><span class=\"mtk1\">.</span><span class=\"mtk12\">totalLiquidity</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p>This means the value depends on the <strong>current market reserves</strong> which can be manipulated.\nYou’re essentially computing a spot price (even though the individual values use a TWAP price) because you use the current market reserves which can be manipulated.</p>\n<p>See the “How do I tell if I’m using spot price?” section <a href=\"https://shouldiusespotpriceasmyoracle.com/\">here</a>.</p>\n<blockquote>\n<p>However, by doing this you’re actually incorporating the spot price because you’re still dependent on the reserve balances of the pool. This is an extremely subtle detail, and more than one project has been caught by it. You can read more about this <a href=\"https://cmichel.io/pricing-lp-tokens/\">footgun</a> in this writeup by @cmichelio.</p>\n</blockquote>\n<p>The value of an LP token is computed as <code>assetCashClaim + assetRate.convertFromUnderlying( presentValue(fCashClaim) )</code>, where <code>(assetCashClaim, fCashClaim)</code> depends on the current market reserves which can be manipulated by an attacker via flashloans.\nTherefore, an attacker trading large amounts in the market can either increase or decrease the value of an LP token.</p>\n<p>If the value decreases, they can try to liquidate users borrowing against their LP tokens / nTokens.\nIf the value increases, they can borrow against it and potentially receive an under-collateralized borrow this way, making a profit.</p>\n<p>The exact profitability of such an attack depends on the AMM as the initial reserve manipulation and restoring the reserves later incurs fees and slippage.\nIn constant-product AMMs like Uniswap it’s profitable and several projects have already been exploited by this, like <a href=\"https://cmichel.io/pricing-lp-tokens/\">warp.finance</a>.\nHowever, Notional Finance uses a more complicated AMM and the contest was too short for me to do a more thorough analysis. It seems like a similar attack could be possible here as described by the developers when talking about a different context of using TWAP oracles:</p>\n<blockquote>\n<p>“Oracle rate protects against short term price manipulation. Time window will be set to a value on the order of minutes to hours. This is to protect fCash valuations from market manipulation. For example, a trader could use a flash loan to dump a large amount of cash into the market and depress interest rates. Since we value fCash in portfolios based on these rates, portfolio values will decrease and they may then be liquidated.” - Market.sol L424</p>\n</blockquote>\n<p>Recommend not using the current market reserves to determine the value of LP tokens. Also, think about how to implement a TWAP oracle for the LP tokens themselves, instead of combining it from the two TWAPs of the claimables.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/85#issuecomment-917422519\">T-Woodward (Notional) confirmed and disagreed with severity </a>:</strong></p>\n<blockquote>\n<p>It is true that a flash loan could be used to manipulate the value of a liquidity token’s cash and fCash claims. This issue can potentially cause accounts to be liquidated which shouldn’t be, but not for the reasons stated in this issue. I’ll explain what actually can go wrong, and why the fix is simple and non-invasive.</p>\n<p>First, to restate the issue: The manipulator could borrow or lend a large amount to a liquidity pool, which would change the amount of cash and fCash sitting in that pool and the corresponding cash and fCash claims of a liquidity token associated with that pool. This could change the liquidity token’s net value within the space of a transaction despite the fact that the oracleRate used to value fCash is lagged and manipulation resistant.</p>\n<p>But it is not true that this manipulation could decrease the value of a liquidity token - in fact it could only increase a liquidity token’s value. By borrowing or lending a large amount using a flash loan, the interest rate that the attacker would receive would deviate from the oracleRate in favor of the liquidity provider. If the attacker executed a large lend order, the interest rate on the loan would be significantly below the oracleRate. This would mean that the liquidity providers had borrowed at a below-market rate and that the net value of that trade would be positive for them. Conversely if the attacker executed a large borrow order, the interest rate on the loan would be significantly above the oracleRate. Again, this would mean that the net value of that trade would be positive for the liquidity providers because they would effectively be lending at an above-market rate. In either case, the value of the liquidity token would increase, not decrease.</p>\n<p>However, even though the value of a liquidity token could only increase during such an attack, the collateral value of the liquidity token could decrease once the haircuts were applied in the free collateral calculation. The reason for this is that fCash claims are effectively double-haircut (once by the liquidity token haircut and once by the fCash haircut), whereas cash claims are only haircut once (by the liquidity token haircut). This means that even though the attack would increase the value of the liquidity token without haircuts, once you consider the haircuts applied in the free collateral calculation, the collateral value of the liquidity token can be decreased and accounts could become undercollateralized and eligible for liquidation.</p>\n<p><strong>Remediation:</strong>\nThe immediate remediation for this issue is to restrict providing liquidity to the nToken account exclusively. In the longer term, we will plan to add TWAPs to determine the collateral value of liquidity token cash and fCash claims. This immediate remediation will be fine for now though, and will not degrade the system for two reasons:</p>\n<ol>\n<li>The team does not anticipate users providing liquidity directly outside of the nToken (we don’t even offer a way to do it within the UI for example). Only nToken holders receive NOTE incentives, not direct liquidity providers.</li>\n<li>The nToken accounts are safe from this attack because the maximum amount that an attacker could temporarily decrease the collateral value of liquidity tokens could never be enough to cause the nToken accounts to become undercollateralized, and therefore they would never be at risk of liquidation due to this attack. The TLDR here is that this attack can’t actually decrease the collateral value of liquidity tokens all that much, and so for an account to be vulnerable they would have to be running quite close to minimum collateralization. This will never happen for the nToken because it doesn’t borrow, it just provides liquidity and always maintains very healthy collateralization levels.</li>\n</ol>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/85#issuecomment-922395545\">ghoul-sol (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Again, I gave it some thought and I think that this is high risk. Keeping as is.</p>\n</blockquote>\n<h1 id=\"medium-risk-findings-7\" style=\"position:relative;\"><a href=\"#medium-risk-findings-7\" aria-label=\"medium risk findings 7 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Medium Risk Findings (7)</h1>\n<h2 id=\"m-01-tokenhandlersol-l174---transfer-is-bad-practice\" style=\"position:relative;\"><a href=\"#m-01-tokenhandlersol-l174---transfer-is-bad-practice\" aria-label=\"m 01 tokenhandlersol l174   transfer is bad practice permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/15\">[M-01] TokenHandler.sol, L174 - <code>.transfer</code> is bad practice</a></h2>\n<p><em>Submitted by JMukesh, also found by tensors</em></p>\n<p>The use of <code>.transfer</code> in <a href=\"https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/internal/balances/TokenHandler.sol#L174\"><code>TokenHandler.sol</code> L174</a> to send ether is now considered bad practice as gas costs can change which would break the code.</p>\n<p>See <a href=\"https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/\">stop using soliditys transfer now</a>, and <a href=\"https://chainsecurity.com/istanbul-hardfork-eips-increasing-gas-costs-and-more/\">istanbul hardfork eips increasing gas costs and more</a>.</p>\n<p>Recommend using <code>call</code> instead, and make sure to check for reentrancy.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/38#issuecomment-917446532\">jeffywu (Notional) commented</a>:</strong></p>\n<blockquote>\n<p>This should be <code>0 (Non critical)</code>. ETH transfers still work as of today. This is a best practice recommendation. In the case that there is a hard fork that breaks ETH transfers the protocol can be upgraded to support the use of <code>call()</code></p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/38#issuecomment-920428460\">ghoul-sol (judge) commented</a>:</strong></p>\n<blockquote>\n<p>I aline with warden on this one. <code>.transfer</code> will not work if the account is a smart contract. Keeping as is.</p>\n</blockquote>\n<p><em><strong>EDITORS NOTE:</strong> Additional conversation regarding this vulnerability can be found <a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/38\">here</a></em></p>\n<h2 id=\"m-02-latestrounddata-does-not-update-the-oracle---exchangeratesol\" style=\"position:relative;\"><a href=\"#m-02-latestrounddata-does-not-update-the-oracle---exchangeratesol\" aria-label=\"m 02 latestrounddata does not update the oracle   exchangeratesol permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/18\">[M-02] <code>.latestRoundData()</code> does not update the oracle - <code>ExchangeRate.sol</code></a></h2>\n<p><em>Submitted by a</em>delamo, also found by tensors, JMukesh, cmichel and defsec_</p>\n<p>The method <code>.latestRoundData()</code> on an oracle returns the latest updated price from the oracle, but this is not the current price of an asset. To get an accurate current price you need to query it by calling the oracle and waiting for a callback to fulfill the request.</p>\n<p>Inaccurate price data could quickly lead to a large loss of funds. Suppose the price of an asset changes downward 5% but your oracle is not updated. A user could deposit funds (credited with an extra 5% since the oracle isn’t updated), wait until <code>.latestRoundData()</code> updates (or update it himself) and becomes accurate. He then withdraws to the same asset he put in for an extra 5%. <a href=\"https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/internal/valuation/ExchangeRate.sol#L84\"><code>ExchangeRate.sol</code> L84</a></p>\n<p>Recommend not fetching the latest price (having to call the oracle to update the price instead), and then waiting for the callback.</p>\n<h2 id=\"m-03-allowance-checks-not-correctly-implemented\" style=\"position:relative;\"><a href=\"#m-03-allowance-checks-not-correctly-implemented\" aria-label=\"m 03 allowance checks not correctly implemented permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/66\">[M-03] Allowance checks not correctly implemented</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The <code>nTokenAction</code> implements two token approvals, the <code>nTokenWhitelist</code> which is always used first, and the <code>nTokenAllowance</code> which is checked second.\nIf the <code>nTokenWhitelist</code> does <em>not</em> have enough allowance for the transfer, the transaction fails, even in the case where <code>nTokenAllowance</code> still has enough allowance.</p>\n<p>Transfers that have sufficient allowance fail in certain cases.</p>\n<p>Recommend that, instead of reverting if the <code>nTokenWhitelist</code> allowance is not enough, default to the <code>nTokenAllowance</code> case.</p>\n<p>Something like this:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"5\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">requiredAllowance</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">amount</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">allowance</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">nTokenWhitelist</span><span class=\"mtk1\">[</span><span class=\"mtk12\">from</span><span class=\"mtk1\">][</span><span class=\"mtk12\">spender</span><span class=\"mtk1\">];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// use whitelist allowance first</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">allowance</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk7\">0</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">min</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">amount</span><span class=\"mtk1\"> &lt; </span><span class=\"mtk12\">allowance</span><span class=\"mtk1\"> ? </span><span class=\"mtk12\">amount</span><span class=\"mtk1\"> : </span><span class=\"mtk12\">allowance</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">requiredAllowance</span><span class=\"mtk1\"> -= </span><span class=\"mtk12\">min</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">allowance</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">allowance</span><span class=\"mtk1\">.</span><span class=\"mtk11\">sub</span><span class=\"mtk1\">(</span><span class=\"mtk12\">min</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">nTokenWhitelist</span><span class=\"mtk1\">[</span><span class=\"mtk12\">from</span><span class=\"mtk1\">][</span><span class=\"mtk12\">spender</span><span class=\"mtk1\">] = </span><span class=\"mtk12\">allowance</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// use currency-specific allowance now</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">if</span><span class=\"mtk1\">(</span><span class=\"mtk12\">requiredAllowance</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk7\">0</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// This is the specific allowance for the nToken.</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">allowance</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">nTokenAllowance</span><span class=\"mtk1\">[</span><span class=\"mtk12\">from</span><span class=\"mtk1\">][</span><span class=\"mtk12\">spender</span><span class=\"mtk1\">][</span><span class=\"mtk12\">currencyId</span><span class=\"mtk1\">];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">allowance</span><span class=\"mtk1\"> &gt;= </span><span class=\"mtk12\">requiredAllowance</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;Insufficient allowance&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">allowance</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">allowance</span><span class=\"mtk1\">.</span><span class=\"mtk11\">sub</span><span class=\"mtk1\">(</span><span class=\"mtk12\">requiredAllowance</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">nTokenAllowance</span><span class=\"mtk1\">[</span><span class=\"mtk12\">from</span><span class=\"mtk1\">][</span><span class=\"mtk12\">spender</span><span class=\"mtk1\">][</span><span class=\"mtk12\">currencyId</span><span class=\"mtk1\">] = </span><span class=\"mtk12\">allowance</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/66\">jeffywu (Notional) confirmed</a></strong></p>\n<h2 id=\"m-04-compoundtonotionalv2enabletoken-erc20-missing-return-value-check\" style=\"position:relative;\"><a href=\"#m-04-compoundtonotionalv2enabletoken-erc20-missing-return-value-check\" aria-label=\"m 04 compoundtonotionalv2enabletoken erc20 missing return value check permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/67\">[M-04] <code>CompoundToNotionalV2.enableToken</code> ERC20 missing return value check</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The <code>enableToken</code> function performs an <code>ERC20.approve()</code> call but does not check the <code>success</code> return value.\nSome tokens do <strong>not</strong> revert if the approval failed, returning <code>false</code> instead.</p>\n<p>The impact is that, tokens that don’t actually perform the approve and return <code>false</code> are still counted as a correct approve.</p>\n<p>Recommend using <a href=\"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74\">OpenZeppelin’s <code>SafeERC20</code></a> versions with the <code>safeApprove</code> function that handles the return value check as well as non-standard-compliant tokens.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/67\">jeffywu (Notional) confirmed</a></strong></p>\n<h2 id=\"m-05-ntokenerc20proxy-emits-events-even-when-not-success\" style=\"position:relative;\"><a href=\"#m-05-ntokenerc20proxy-emits-events-even-when-not-success\" aria-label=\"m 05 ntokenerc20proxy emits events even when not success permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/72\">[M-05] <code>nTokenERC20Proxy</code> emits events even when not success</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The <code>nTokenERC20Proxy</code> functions emit events all the time, even if the return value from the inner call returns <code>false</code>, indicating an unsuccessful action.</p>\n<p>An off-chain script scanning for <code>Transfer</code> or <code>Approval</code> events can be tricked into believing that an unsuccessful transfer was indeed successful.\nThis happens in the <code>approve</code>, <code>transfer</code> and <code>transferFrom</code> functions.</p>\n<p>Recommend only emitting events on <code>success</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/72\">jeffywu (Notional) confirmed</a></strong></p>\n<h2 id=\"m-06-tokenhandlersettoken-erc20-missing-return-value-check\" style=\"position:relative;\"><a href=\"#m-06-tokenhandlersettoken-erc20-missing-return-value-check\" aria-label=\"m 06 tokenhandlersettoken erc20 missing return value check permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/77\">[M-06] <code>TokenHandler.setToken</code> ERC20 missing return value check</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The <code>setToken</code> function performs an <code>ERC20.approve()</code> call but does not check the <code>success</code> return value.\nSome tokens do <strong>not</strong> revert if the approval failed but return <code>false</code> instead.</p>\n<p>The impact is that tokens that don’t actually perform the approve and return <code>false</code> are still counted as a correct approve.</p>\n<p>We recommend using <a href=\"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74\">OpenZeppelin’s <code>SafeERC20</code></a> versions with the <code>safeApprove</code> function that handles the return value check as well as non-standard-compliant tokens.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/77\">jeffywu (Notional) confirmed</a></strong></p>\n<h2 id=\"m-07-attackers-can-force-liquidations-by-borrowing-large-amounts-of-an-asset\" style=\"position:relative;\"><a href=\"#m-07-attackers-can-force-liquidations-by-borrowing-large-amounts-of-an-asset\" aria-label=\"m 07 attackers can force liquidations by borrowing large amounts of an asset permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/20\">[M-07] Attackers can force liquidations by borrowing large amounts of an asset.</a></h2>\n<p><em>Submitted by tensors</em></p>\n<p>Consider an attacker who borrows enough to greatly increase the oracle rate. It is claimed that arbitrageurs will come in and fix this discrepancy before the attacker has a chance to profit off of his price manipulation:</p>\n<blockquote>\n<p>“Over the next 1 hour, the effect of the new 12% interest rate will be averaged into the previous 6% rate.\nThis forces the borrower to hold their position and gives an opportunity for other traders to lend to the market\nto bring the interest rate back down to its previous 6% level.”</p>\n</blockquote>\n<p>In my opinion, this incentive is not sufficient to prevent an attack. This assumes that:</p>\n<ol>\n<li>There is sufficient volume to notice a manipulation like this</li>\n<li>The arbitrageurs would be willing to deploy capital for a short amount of for a slightly increased rate</li>\n<li>The arbitrageurs would now know that this is a manipulation, and not a natural market movement (For example, lets say an asset lending rate goes up 10% in value, is it being manipulated or is the rate actually worth 10% more for some reason? An arbitrageur needs to make this before he deploys capital). Since notional is the only market to offer something like this, it is difficult to discern what the response should be.</li>\n<li>The arbitrageurs don’t join in on the attack, and try to liquidate accounts with the attacker</li>\n</ol>\n<p>Proof of concept is based off of the formula and text <a href=\"https://github.com/code-423n4/2021-08-notional/blob/main/contracts/internal/valuation/_README.md\">here</a>.</p>\n<p>Uncertain what the recommendation should be.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/20#issuecomment-917423368\">T-Woodward (Notional) acknowledged and disagreed with severity</a>:</strong></p>\n<blockquote>\n<p>This is a fair point. With a timeWindow value that is under an hour, it’s not clear whether capital will flow in to take advantage of artificially inflated yields before the oracleRate catches up to the lastImpliedRate and accounts are potentially eligible for liquidation at this early stage in Notional’s lifespan before there are lots of eyes on the system and its market dynamics are widely understood.</p>\n<p>However, it’s worth noting that there are several mitigating circumstances which make such an attack unlikely:</p>\n<ul>\n<li>The necessary conditions for a profitable attack to exist are quite narrow</li>\n<li>The capital required to execute such an attack is substantial</li>\n<li>The sunk cost of executing this attack prior to any payoff is significant</li>\n<li>The payoff of the attack is not guaranteed</li>\n</ul>\n<p>First let’s examine what this attack would have to look like.</p>\n<ul>\n<li>With the current fCash market parameters, interest rates top out at about 25%, so the most that an attacker could push interest rates from their natural level is ~20% (assuming a starting interest rate of 5%).</li>\n<li>With the current active maturities (longest dated maturity is one year), a 20% change in interest rates could decrease the collateral value of an account’s fCash by a maximum of ~20%.</li>\n<li>Pushing the interest rate to the top of the range requires the attacker to borrow all of the cash sitting in the liquidity pool. If you assume there is $100M sitting in the pool, then the attacker would have to borrow $100M. At worst, if they execute the borrow all in one shot, their realized borrow rate would be 25%. At best, if they execute the borrow in pieces (increasing the time taken and risk of the attack), their realized borrow rate would be ~15%. This implies that the attacker has placed at least $15M at risk (his total interest owed) as there is no guarantee that he can exit his position in profit or at cost.</li>\n<li>In order for this to be a profitable attack, the attacker needs to offset their borrowing by executing an fCash liquidation that would allow them to lend at the artificially inflated interest rate. This means that there must be an account, or set of accounts, which have borrowed against their fCash, are 20% away from under collateralization, and have enough fCash such that the attacker can offset his borrow by liquidating their fCash. In other words, there would need to be $100M+ of fCash held in the system that is being used as collateral and is close to liquidation.</li>\n<li>These conditions are possible, but improbable. It would imply that the amount of outstanding loans that are being borrowed against (and are close to under collateralization) is greater than the total liquidity in the pool. This strikes me as unlikely for two reasons:</li>\n<li>For there to be more fCash outstanding than liquidity in the pool, there would have to be a lot of two-way trading. We expect this to happen eventually, but in the initial stages we would be very surprised by this because lenders do not earn NOTE incentives, only liquidity providers earn NOTE incentives. It would be very surprising to see more lending than liquidity given this fact. We expect more lending than liquidity once Notional is more mature, but by then there will be more eyes on the system which would make this attack less likely as arbitragers and/or automated yield aggregators really would come in to push rates back down to their natural level.</li>\n<li>Only a percentage of fCash will actually be used as collateral, and probably not a large percentage. So if you specifically need fCash used as collateral (and close to liquidation) to be a multiple of liquidity in the pool, this would imply that the amount of total outstanding fCash would be like an order of magnitude greater than the liquidity in the pool. That strikes me as highly unlikely.</li>\n</ul>\n<p>Ultimately we don’t think this is a significant risk because the necessary conditions are unlikely to obtain in the early stages of Notional’s growth, the attack involves substantial sunk costs and capital committed, and the risk of an unsuccessful attack is significant. To further mitigate against this unlikely risk, we will skew the timeWindow to a longer time / larger value.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/20#issuecomment-922395972\">ghoul-sol (judge) commented</a>:</strong></p>\n<blockquote>\n<p>This attack requires a lot of things aligned and for that single reason I’ll give it medium risk.</p>\n</blockquote>\n<h1 id=\"low-risk-findings-21\" style=\"position:relative;\"><a href=\"#low-risk-findings-21\" aria-label=\"low risk findings 21 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Low Risk Findings (21)</h1>\n<h2 id=\"l-01--incorrect-event-parameters-in-transferfrom-function\" style=\"position:relative;\"><a href=\"#l-01--incorrect-event-parameters-in-transferfrom-function\" aria-label=\"l 01  incorrect event parameters in transferfrom function permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/36\">[L-01]  Incorrect event parameters in <code>transferFrom</code> function</a></h2>\n<p><em>Submitted by pauliax, also found by JMukesh</em></p>\n<p>Different parameter are being set in <code>Approval</code> event in <code>transferFrom()</code></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"6\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">transferFrom</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">from</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">to</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">amount</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> </span><span class=\"mtk11\">override</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">bool</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    (</span><span class=\"mtk12\">bool</span><span class=\"mtk1\"> </span><span class=\"mtk12\">success</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">newAllowance</span><span class=\"mtk1\">) =</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">proxy</span><span class=\"mtk1\">.</span><span class=\"mtk11\">nTokenTransferFrom</span><span class=\"mtk1\">(</span><span class=\"mtk12\">currencyId</span><span class=\"mtk1\">, </span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">, </span><span class=\"mtk12\">from</span><span class=\"mtk1\">, </span><span class=\"mtk12\">to</span><span class=\"mtk1\">, </span><span class=\"mtk12\">amount</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// Emit transfer events here so they come from the correct contract</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">emit</span><span class=\"mtk1\"> </span><span class=\"mtk11\">Transfer</span><span class=\"mtk1\">(</span><span class=\"mtk12\">from</span><span class=\"mtk1\">, </span><span class=\"mtk12\">to</span><span class=\"mtk1\">, </span><span class=\"mtk12\">amount</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// here first parameter should be owner and second should be spender</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">//   as mentioned in ntokenErc20.sol that is :</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// event Approval(address indexed owner, // address indexed spender, uint256 amount);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">emit</span><span class=\"mtk1\"> </span><span class=\"mtk11\">Approval</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">, </span><span class=\"mtk12\">from</span><span class=\"mtk1\">, </span><span class=\"mtk12\">newAllowance</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk12\">success</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p>The impact is that, this error may negatively impact off-chain tools that are monitoring critical transfer events of the token. See <a href=\"https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/external/adapters/nTokenERC20Proxy.sol#L100\"><code>nTokenERC20Proxy.sol</code> L100</a>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/36#issuecomment-917446856\">jeffywu (Notional) disagreed with severity</a>:</strong></p>\n<blockquote>\n<p>Duplicate #55, dispute the categorization. This should be Low Risk.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/36#issuecomment-920425665\">ghoul-sol (judge) commented</a>:</strong></p>\n<blockquote>\n<p>External services might be affected but it’s not clear how significant it would be. Most of the time events are not critical. Making this low risk.</p>\n</blockquote>\n<h2 id=\"l-02-addressiscontract-with-no-check-of-returned-value\" style=\"position:relative;\"><a href=\"#l-02-addressiscontract-with-no-check-of-returned-value\" aria-label=\"l 02 addressiscontract with no check of returned value permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/44\">[L-02] <code>Address.isContract</code> with no check of returned value</a></h2>\n<p><em>Submitted by JMukesh, also found by pauliax</em></p>\n<p>The function <code>activateNotional</code> calls <code>Address.isContract(...)</code> but does not check the returned value, thus making this call pretty much useless:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"7\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">Address</span><span class=\"mtk1\">.</span><span class=\"mtk11\">isContract</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk12\">notionalProxy_</span><span class=\"mtk1\">));</span></span></span></code></pre>\n<p>Recommend wrapping this in a require statement.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/44\">jeffywu (Notional) confirmed</a></strong></p>\n<h2 id=\"l-03-lack-of-input-validation-of-arrays\" style=\"position:relative;\"><a href=\"#l-03-lack-of-input-validation-of-arrays\" aria-label=\"l 03 lack of input validation of arrays permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/43\">[L-03] lack of input validation of arrays</a></h2>\n<p><em>Submitted by JMukesh</em></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"8\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">migrateBorrowFromCompound</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">cTokenBorrow</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">cTokenRepayAmount</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">uint16</span><span class=\"mtk1\">[] </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">notionalV2CollateralIds</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\">[] </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">notionalV2CollateralAmounts</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">BalanceActionWithTrades</span><span class=\"mtk1\">[] </span><span class=\"mtk12\">calldata</span><span class=\"mtk1\"> </span><span class=\"mtk12\">borrowAction</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">) ;</span></span></span></code></pre>\n<p>if the array length of <code>notionalV2CollateralId</code> , <code>notionalV2CollateralAmounts</code> and <code>borrowAction</code> is not equal, it can lead to an error. See <a href=\"https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/external/adapters/CompoundToNotionalV2.sol#L24\"><code>CompoundToNotionalV2.sol</code> L24</a>.</p>\n<p>Recommend checking the input array length.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/43\">jeffywu (Notional) confirmed</a></strong></p>\n<h2 id=\"l-04-no-transfer-ownership-pattern\" style=\"position:relative;\"><a href=\"#l-04-no-transfer-ownership-pattern\" aria-label=\"l 04 no transfer ownership pattern permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/94\">[L-04] No Transfer Ownership Pattern</a></h2>\n<p><em>Submitted by leastwood, also found by JMukesh</em></p>\n<p>The current ownership transfer process involves the current owner calling <code>NoteERC20.transferOwnership()</code>. This function checks that the new owner is not the zero address and proceeds to write the new owner’s address into the owner’s state variable. If the nominated EOA account is not a valid account, it is entirely possible the owner may accidentally transfer ownership to an uncontrolled account, breaking all functions with the <code>onlyOwner()</code> modifier. See <a href=\"https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/governance/NoteERC20.sol#L123-L127\"><code>NoteERC20.sol</code> L123-L127</a>.</p>\n<p>Recommend considering implementing a two step process where the owner nominates an account and the nominated account needs to call an <code>acceptOwnership()</code> function for the transfer of ownership to fully succeed. This ensures the nominated EOA account is a valid and active account.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/94\">jeffywu (Notional) confirmed</a></strong></p>\n<h2 id=\"l-05-initialize-functions-can-be-front-run\" style=\"position:relative;\"><a href=\"#l-05-initialize-functions-can-be-front-run\" aria-label=\"l 05 initialize functions can be front run permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/59\">[L-05] <code>initialize</code> functions can be front-run</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The <code>initialize</code> function that initializes important contract state can be called by anyone.</p>\n<p>Occurences:</p>\n<ul>\n<li><code>NoteERC20.initialize</code></li>\n<li><code>Router.initialize</code></li>\n</ul>\n<p>The attacker can initialize the contract before the legitimate deployer, hoping that the victim continues to use the same contract.\nIn the best case for the victim, they notice it and have to redeploy their contract costing gas.</p>\n<p>Recommend using the constructor to initialize non-proxied contracts. For initializing proxy contracts, recommend deploying contracts using a factory contract that immediately calls <code>initialize</code> after deployment, or make sure to call it immediately after deployment and verify the transaction succeeded.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/59\">jeffywu (Notional) confirmed</a></strong></p>\n<h2 id=\"l-06-erc1155action-returns-false-on-supportsinterface-with-the-real-erc1155-interface\" style=\"position:relative;\"><a href=\"#l-06-erc1155action-returns-false-on-supportsinterface-with-the-real-erc1155-interface\" aria-label=\"l 06 erc1155action returns false on supportsinterface with the real erc1155 interface permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/61\">[L-06] <code>ERC1155Action</code> returns <code>false</code> on <code>supportsInterface</code> with the real ERC1155 interface</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>As the return value of <code>ERC1155.balanceOf</code> was changed to a signed integer, the <code>nERC1155Interface</code> does not implement the <code>ERC1155</code> interface and the <code>supportsInterface</code> call will return false if people call it with the actual <code>ERC1155</code> interface ID.</p>\n<p>Not all users of the contract might care about the <code>balance</code> function and call <code>supportsInterface</code> with the original EIP1155 interface.\nThe contract will still deny the <em>[content missing]</em></p>\n<p>It is indeed debatable if this contract should be considered implementing ERC1155 and what the correct return value of <code>supportsInterface(ERC1155.interface)</code> should be for compatibility.\nUsers need to be aware that this contract is not standard compliant and that the <code>supportsInterface</code> call will fail.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/61\">jeffywu (Notional) confirmed</a></strong></p>\n<h2 id=\"l-07-erc1155-has-reentrancy-possibilities\" style=\"position:relative;\"><a href=\"#l-07-erc1155-has-reentrancy-possibilities\" aria-label=\"l 07 erc1155 has reentrancy possibilities permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/25\">[L-07] ERC1155 has reentrancy possibilities.</a></h2>\n<p><em>Submitted by cmichel, also found by tensors</em></p>\n<p>ERC1155 tokens have a callback on transfer, making reentrancy a possibility.\nI haven’t been able to find any reentrancy, but having extra external function calls isn’t safe.\nIf it’s necessary to use an ERC1155 there is nothing you can do about it, but otherwise consider just using an ERC20.</p>\n<p>See <a href=\"https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/ERC1155Action.sol\"><code>actions/ERC1155Action</code> sol</a>.</p>\n<p>Recommend confirming that using tokens with callbacks is really necessary for the protocol to function.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/25#issuecomment-917448341\">jeffywu (Notional) disputed and disagreed with severity</a>:</strong></p>\n<blockquote>\n<p>Callbacks are required as part of the ERC1155 spec. Duplicate #62. Severity should be Low or Non Critical.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/25#issuecomment-922398689\">ghoul-sol (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Duplicate of #62 ergo low risk</p>\n</blockquote>\n<h2 id=\"l-08-open-todos-in-erc1155action\" style=\"position:relative;\"><a href=\"#l-08-open-todos-in-erc1155action\" aria-label=\"l 08 open todos in erc1155action permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/63\">[L-08] Open TODOs in <code>ERC1155Action</code></a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The <code>ERC1155Action._checkPostTransferEvent</code> has open TODOs:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"9\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// TODO: retrieve revert string</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">status</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;Call failed&quot;</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p>Open TODOs can hint at programming or architectural errors that still need to be fixed.</p>\n<p>Recommend resolving the TODO and bubble up the error.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/63\">jeffywu (Notional) confirmed</a></strong></p>\n<h2 id=\"l-09-router-calls-to-ntokenactionntokentransferapprove-fail\" style=\"position:relative;\"><a href=\"#l-09-router-calls-to-ntokenactionntokentransferapprove-fail\" aria-label=\"l 09 router calls to ntokenactionntokentransferapprove fail permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/64\">[L-09] Router calls to <code>nTokenAction.nTokenTransferApprove</code> fail</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The <code>Router</code> forwards <code>nTokenTransferApprove</code> calls to the <code>nTokenAction</code> implementation. However, these always fail due to the <code>msg.sender == nTokenAddress</code> check.</p>\n<p>This call failing seems to be the intended behavior but it shouldn’t even be forwarded in the Router.</p>\n<p>Recommend removing <code>sig == nTokenAction.nTokenTransferApprove.selector</code> from the <code>getRouterImplementation</code> as it indicates that this is a valid function call.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/64#issuecomment-917700011\">jeffywu (Notional) disputed</a>:</strong></p>\n<blockquote>\n<p>Calling approve on the nToken will forward the call to the Router which will then delegate call to the <code>nTokenTransferApprove</code> method. This is the intended functionality and will pass the require statement because the delegate call does not change the <code>msg.sender</code></p>\n</blockquote>\n<h2 id=\"l-10-unclear-decimals-value-in-ctokenaggregator\" style=\"position:relative;\"><a href=\"#l-10-unclear-decimals-value-in-ctokenaggregator\" aria-label=\"l 10 unclear decimals value in ctokenaggregator permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/70\">[L-10] Unclear decimals value in <code>cTokenAggregator</code></a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The <code>cTokenAggregator.decimals</code> value is set to <code>18</code> but <code>cTokens</code> only have <code>8</code> decimals. It’s unclear what this <code>decimals</code> field refers to.</p>\n<p>If it should refer to the <code>cToken</code> decimals, it’s wrong and should be set to <code>8</code>.\nThis value is not used inside the contract but it’s <code>public</code> and anyone can read it.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/70#issuecomment-917415350\">jeffywu (Notional) confirmed</a>:</strong></p>\n<blockquote>\n<p>Decimals refers to the decimals in the exchange rate, but we should add a comment here. Agree it is confusing.</p>\n</blockquote>\n<h2 id=\"l-11-governor-average-block-time-is-not-up-to-date\" style=\"position:relative;\"><a href=\"#l-11-governor-average-block-time-is-not-up-to-date\" aria-label=\"l 11 governor average block time is not up to date permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/73\">[L-11] Governor average block time is not up-to-date</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The <code>GovernorAlpha.MIN_VOTING_PERIOD_BLOCKS = 6700</code> value indicates an average block time of 12.8956s which was correct a year ago, but at the moment a more accurate block time would be 13.2s, see <a href=\"https://etherscan.io/chart/blocktime\">blocktime</a>.</p>\n<p>Recommend using a <code>MIN_VOTING_PERIOD_BLOCKS</code> of <code>6545</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/73\">jeffywu (Notional) confirmed</a></strong></p>\n<h2 id=\"l-12-noteerc20-missing-initial-ownership-event\" style=\"position:relative;\"><a href=\"#l-12-noteerc20-missing-initial-ownership-event\" aria-label=\"l 12 noteerc20 missing initial ownership event permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/74\">[L-12] NoteERC20 missing initial ownership event</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The <code>NoteERC20.initialize</code> function does not emit an initial <code>OwnershipTransferred</code> event.</p>\n<p>Recommend emitting <code>OwnershipTransferred(address(0), owner_)</code> in <code>initialize</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/74\">jeffywu (Notional) confirmed</a></strong></p>\n<h2 id=\"l-13-tokenhandlertransfer-wrong-branch-order\" style=\"position:relative;\"><a href=\"#l-13-tokenhandlertransfer-wrong-branch-order\" aria-label=\"l 13 tokenhandlertransfer wrong branch order permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/78\">[L-13] <code>TokenHandler.transfer</code> wrong branch order</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The <code>TokenHandler.transfer</code> should handle the <code>if (token.tokenType == TokenType.Ether)</code> case first, as if the token type is <code>Ether</code> but <code>netTransferExternal &#x3C;= 0</code> it treats the token as an <code>ERC20</code> token and tries to call <code>ERC20</code> functions on it.</p>\n<p>Luckily, trying to call ERC20 functions on the invalid token address will revert which is the desired behavior.</p>\n<p>We still recommend reordering the branches and adding a <code>netTransferExternal &#x3C;= 0</code> check. The code becomes cleaner and it’s more obvious that the transaction will fail.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/78\">jeffywu (Notional) confirmed</a></strong></p>\n<h2 id=\"l-14-datetimeisvalidmarketmaturity-bounds-should-be-tighter\" style=\"position:relative;\"><a href=\"#l-14-datetimeisvalidmarketmaturity-bounds-should-be-tighter\" aria-label=\"l 14 datetimeisvalidmarketmaturity bounds should be tighter permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/81\">[L-14] <code>DateTime.isValidMarketMaturity</code> bounds should be tighter</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p><code>DateTime.isValidMarketMaturity</code> can be called with a <code>maxMarketIndex &#x3C; 10</code> but the inner <code>DateTime.getTradedMarket(i)</code> function will revert for any values <code>i > 7</code>.</p>\n<p>The impact is that “Valid” <code>maxMarketIndex</code> values above 7 will break and return with an error.</p>\n<p>Recommend that the upper bound on <code>maxMarketIndex</code> should be set to <code>7</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/81\">jeffywu (Notional) confirmed</a></strong></p>\n<h2 id=\"l-15-datetimegetmarketindex-bounds-should-be-tighter\" style=\"position:relative;\"><a href=\"#l-15-datetimegetmarketindex-bounds-should-be-tighter\" aria-label=\"l 15 datetimegetmarketindex bounds should be tighter permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/82\">[L-15] <code>DateTime.getMarketIndex</code> bounds should be tighter</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p><code>DateTime.getMarketIndex</code> can be called with a <code>maxMarketIndex &#x3C; 10</code> but the inner <code>DateTime.getTradedMarket(i)</code> function will revert for any values <code>i > 7</code>.</p>\n<p>“Valid” <code>maxMarketIndex</code> values above 7 will break and return with an error.</p>\n<p>The upper bound on <code>maxMarketIndex</code> should be set to <code>7</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/82\">jeffywu (Notional) confirmed</a></strong></p>\n<h2 id=\"l-16-double-check-for-birthday-collision\" style=\"position:relative;\"><a href=\"#l-16-double-check-for-birthday-collision\" aria-label=\"l 16 double check for birthday collision permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/4\">[L-16] Double check for “birthday” collision</a></h2>\n<p><em>Submitted by gpersoon</em></p>\n<p>The function <a href=\"https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/Router.sol#L97\"><code>getRouterImplementation</code></a> of <code>Router.sol</code> checks the selectors of functions and calls the appropriate function.\nSelectors are only 4 bytes long, so there is a theoretical probability of a collision (e.g. two functions having the same selector).</p>\n<p>This is comparable to the <a href=\"https://en.wikipedia.org/wiki/Birthday_attack\">“birthday attack”</a>.\nThe probability of a collision when you have 93 different functions is 10^−6.\nDue to the structure of the <code>Router.sol</code>, the solidity compiler does not prevent collisions</p>\n<p>Recommend double checking (perhaps via a continuous integration script / github workflow), that there are no collisions of the selectors.</p>\n<p><strong>- <a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/4\">jeffywu (Notional) confirmed</a></strong></p>\n<h2 id=\"l-17-notionalcallback-returns-no-value\" style=\"position:relative;\"><a href=\"#l-17-notionalcallback-returns-no-value\" aria-label=\"l 17 notionalcallback returns no value permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/46\">[L-17] <code>notionalCallback</code> returns no value</a></h2>\n<p><em>Submitted by pauliax</em></p>\n<p>The function <code>notionalCallback</code> (in <code>NotionalV1ToNotionalV2</code> and <code>CompoundToNotionalV2</code>) declares to return uint, however, no actual value is returned.</p>\n<p>Recommend either removing the return declaration or returning the intended value (I assume it may return a value that it gets from <code>depositUnderlyingToken</code>/<code>depositAssetToken</code>). Otherwise, it may confuse other protocols that later may want to integrate with you.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/46\">jeffywu (Notional) confirmed</a></strong></p>\n<h2 id=\"l-18-notionalv1tonotionalv2-should-reject-eth-transfers-from-others-than-weth\" style=\"position:relative;\"><a href=\"#l-18-notionalv1tonotionalv2-should-reject-eth-transfers-from-others-than-weth\" aria-label=\"l 18 notionalv1tonotionalv2 should reject eth transfers from others than weth permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/48\">[L-18] <code>NotionalV1ToNotionalV2</code> should reject ETH transfers from others than WETH</a></h2>\n<p><em>Submitted by pauliax</em></p>\n<p>The contract <code>NotionalV1ToNotionalV2</code> has an empty receive function which allows it to receive Ether. I suppose this was needed to receive ETH when withdrawing from WETH. As there is no way to send out accidentally sent ETH from this contract, I suggest adding an auth check to this receive function to only accept ETH from WETH contract.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"10\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\"> == </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk12\">WETH</span><span class=\"mtk1\">), </span><span class=\"mtk8\">&quot;Not WETH&quot;</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/48\">jeffywu (Notional) confirmed</a></strong></p>\n<h2 id=\"l-19-no-checks-on-target-variable\" style=\"position:relative;\"><a href=\"#l-19-no-checks-on-target-variable\" aria-label=\"l 19 no checks on target variable permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/29\">[L-19] No checks on target variable</a></h2>\n<p><em>Submitted by tensors</em></p>\n<p>Lack of checks on target could lead to loss of funds in <a href=\"https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/external/governance/Reservoir.sol#L50\"><code>Reservoir.sol</code> L50</a>.</p>\n<p>Recommend requiring that target is non-zero.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/29\">jeffywu (Notional) confirmed</a></strong></p>\n<h2 id=\"l-20-some-tradingactions-do-not-have-front-running-protections\" style=\"position:relative;\"><a href=\"#l-20-some-tradingactions-do-not-have-front-running-protections\" aria-label=\"l 20 some tradingactions do not have front running protections permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/30\">[L-20] Some <code>TradingActions</code> do not have front-running protections</a></h2>\n<p><em>Submitted by tensors</em></p>\n<p>Some of the actions in <code>TradingAction.sol</code> can be front-run. Since there are no slippage protections, its unclear how bad this problem can be.\nSee <a href=\"https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/external/actions/TradingAction.sol#L334\"><code>TradingAction.sol</code> L334</a>.</p>\n<p>An example is <code>_settleCashDebt()</code>. This goes through <code>_getfCashSettleAmount()</code> which uses an <code>impliedRate</code> variable. This can be manipulated by a frontrunner. Add checks that exist on the other trade types.</p>\n<p>Recommend adding <code>minAmountOut</code>/<code>minAmountCredited</code> as function variables to protect against frontrunning. For example. <code>_executeLiquidityTrade</code> has such protections in place.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/30#issuecomment-917422834\">T-Woodward (Notional) acknowledged but disagreed with severity</a>:</strong></p>\n<blockquote>\n<p>I don’t think this is a particularly serious issue in practice, given that _getfCashSettleAmount is calculated off the oraclePrice which is manipulation-resistant, but it is still a valid concern.</p>\n<p><strong>Remediation:</strong>\nAdd slippage guards similar to executing a normal lend/borrow on the AMM</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/30#issuecomment-917447729\">jeffywu (Notional) commented</a>:</strong></p>\n<blockquote>\n<p>Severity should be <code>1 Low Risk</code>. It is true that you can potentially front run settle cash debt but we will not fix this as there is no room in the calldata for an additional parameter. The likelihood of manipulating the oracle rate for a given time window is low.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/30#issuecomment-922397396\">ghoul-sol (judge) commented</a>:</strong></p>\n<blockquote>\n<p>As the sponsor said, there is no immediate risk of losing funds and it’s not clear how this could be manipulated is the oracle price is a base to calculate the settlement amount. Making this low risk.</p>\n</blockquote>\n<h2 id=\"l-21-noteerc20getpriorvotes-includes-current-unclaimed-incentives\" style=\"position:relative;\"><a href=\"#l-21-noteerc20getpriorvotes-includes-current-unclaimed-incentives\" aria-label=\"l 21 noteerc20getpriorvotes includes current unclaimed incentives permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/76\">[L-21] <code>NoteERC20.getPriorVotes</code> includes current unclaimed incentives</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The <code>NoteERC20.getPriorVotes</code> function is supposed to return the voting strength of an account at a specific block in the past.\nThis should be a static value but it directly includes the <em>current</em> unclaimed incentives due to the <code>getUnclaimedVotes(account)</code> call.</p>\n<p>Users that didn’t even have tokens at the time of proposal creation (but are now interested in voting on the proposal), can farm unclaimed incentives and impact the outcome of the proposal.</p>\n<p>Adding checkpoints for all unclaimed incentives would be the correct solution but was probably not done because it’d cost too much gas.\nIt also needs to be ensured that incentives cannot be increased through flash-loaning of assets.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/76#issuecomment-917435282\">T-Woodward (Notional) acknowledged and disagreed with severity</a>:</strong></p>\n<blockquote>\n<p>It is true that getPriorVotes returns an inaccurate value for the reason you have stated.</p>\n<p>In practice, this issue is not very severe though. Any meaningful attack would require an enormous amount of capital, and could only gain access to at most a relatively small number of votes.  The attack would be to provide liquidity at the moment a proposal is introduced, accrue incentives for the duration of the voting period, and then vote for them. So the maximum damage that could be done would assume that you have provided all liquidity on the platform (not gonna happen) for the entire voting period (5 days). Given that the highest annual emission rate for NOTE incentives is 20M, this would imply that the maximum amount of incentives earned in the five day period is 277,778 NOTE. This is .277% of the total NOTE supply. So the worst case is still not really a big deal.</p>\n<p>Claimable incentives can’t be manipulated via flash loans.</p>\n<p><strong>Remediation:</strong>\nWe’ll remove the <code>getUnclaimedVotes</code> function. It is a vestige of an earlier design that we have since moved away from anyway, so there’s no real impact on the system or reason not to remove it.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/76#issuecomment-922398001\">ghoul-sol (judge) commented</a>:</strong></p>\n<blockquote>\n<p>per sponsor comment, the impact is indeed low</p>\n</blockquote>\n<h1 id=\"non-critical-findings-13\" style=\"position:relative;\"><a href=\"#non-critical-findings-13\" aria-label=\"non critical findings 13 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Non-Critical Findings (13)</h1>\n<ul>\n<li><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/35\">[N-01] proposal get defeated even if <code>forVotes == againstVotes</code> in <code>GovernorAlpha.sol</code></a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/37\">[N-02] Erc20 Race condition</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/90\">[N-03] Used a fixed or pragma that spans only a single <code>0.x.*</code></a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/93\">[N-04] Lack of Zero Address Validation</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/5\">[N-05] Use pragma abicoder v2</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/50\">[N-06] lack of require message</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/91\">[N-07] Replacing the assembly <code>extcodesize</code> checks for versions <code>>0.8.1</code></a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/47\">[N-08] Check if address is a contract</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/56\">[N-09] Total supply dependency on decimals</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/8\">[N-10] unsafe cast from int to uint can lead to incentive abuse</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/84\">[N-11] Use of <code>msg.value</code> in batch action</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/27\">[N-12] Recommend adding a <code>nonReentrant</code> modifier to external functions</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/42\">[N-13] <code>initialize()</code> function of <code>router.sol</code> can be reinitialize</a></li>\n</ul>\n<h1 id=\"gas-optimizations-8\" style=\"position:relative;\"><a href=\"#gas-optimizations-8\" aria-label=\"gas optimizations 8 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Gas Optimizations (8)</h1>\n<ul>\n<li><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/9\">[G-01] Gas optimization on <code>_INT256_MIN</code> </a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/87\">[G-02] Upgrade to at least 0.8.4</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/88\">[G-03] Caching length in for loops</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/96\">[G-04] <code>StorageLayoutV1</code> Gas Optimisations</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/52\">[G-05] Unused variables</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/53\">[G-06] uint is always >= 0</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/54\">[G-07] Cache values that are accessed more than once</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-08-notional-findings/issues/13\">[G-08] Gas optimization: Can put require and variable declaration inside the if statement.</a></li>\n</ul>\n<h1 id=\"disclosures\" style=\"position:relative;\"><a href=\"#disclosures\" aria-label=\"disclosures permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Disclosures</h1>\n<p>C4 is an open organization governed by participants in the community.</p>\n<p>C4 Contests incentivize the discovery of exploits, vulnerabilities, and bugs in smart contracts. Security researchers are rewarded at an increasing rate for finding higher-risk issues. Contest submissions are judged by a knowledgeable security researcher and solidity developer and disclosed to sponsoring developers. C4 does not conduct formal verification regarding the provided code but instead provides final verification.</p>\n<p>C4 does not provide any guarantee or warranty regarding the security of this project. All smart contract software should be used at the sole risk and responsibility of users.</p>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n  .dark-default-dark {\n    background-color: #1E1E1E;\n    color: #D4D4D4;\n  }\n  .dark-default-dark .mtk12 { color: #9CDCFE; }\n  .dark-default-dark .mtk1 { color: #D4D4D4; }\n  .dark-default-dark .mtk7 { color: #B5CEA8; }\n  .dark-default-dark .mtk11 { color: #DCDCAA; }\n  .dark-default-dark .mtk3 { color: #6A9955; }\n  .dark-default-dark .mtk4 { color: #569CD6; }\n  .dark-default-dark .mtk8 { color: #CE9178; }\n  .dark-default-dark .mtk15 { color: #C586C0; }\n  .dark-default-dark .grvsc-line-highlighted::before {\n    background-color: var(--grvsc-line-highlighted-background-color, rgba(255, 255, 255, 0.1));\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(255, 255, 255, 0.5));\n  }\n</style>",
  "toc": "<ul>\n<li>\n<p><a href=\"#overview\">Overview</a></p>\n<ul>\n<li><a href=\"#about-c4\">About C4</a></li>\n<li><a href=\"#wardens\">Wardens</a></li>\n</ul>\n</li>\n<li><a href=\"#summary\">Summary</a></li>\n<li><a href=\"#scope\">Scope</a></li>\n<li><a href=\"#severity-criteria\">Severity Criteria</a></li>\n<li>\n<p><a href=\"#high-risk-findings-10\">High Risk Findings (10)</a></p>\n<ul>\n<li><a href=\"#h-01-self-transfer-can-lead-to-unlimited-mint\">[H-01] Self transfer can lead to unlimited mint</a></li>\n<li><a href=\"#h-02-dao-proposals-can-be-executed-by-anyone-due-to-vulnerable-timelockcontroller\">[H-02] DAO proposals can be executed by anyone due to vulnerable <code>TimelockController</code></a></li>\n<li><a href=\"#h-03-compoundtonotionalv2notionalcallback-erc20-return-values-not-checked\">[H-03] <code>CompoundToNotionalV2.notionalCallback</code> ERC20 return values not checked</a></li>\n<li><a href=\"#h-04-access-restrictions-on-compoundtonotionalv2notionalcallback-can-be-bypassed\">[H-04] Access restrictions on <code>CompoundToNotionalV2.notionalCallback</code> can be bypassed</a></li>\n<li><a href=\"#h-05-access-restrictions-on-notionalv1tonotionalv2notionalcallback-can-be-bypassed\">[H-05] Access restrictions on <code>NotionalV1ToNotionalV2.notionalCallback</code> can be bypassed</a></li>\n<li><a href=\"#h-06-tokenhandlersafetransferout-does-not-work-on-non-standard-compliant-tokens-like-usdt\">[H-06] <code>TokenHandler.safeTransferOut</code> does not work on non-standard compliant tokens like USDT</a></li>\n<li><a href=\"#h-07-tokenhandlersafetransferin-does-not-work-on-non-standard-compliant-tokens-like-usdt\">[H-07] <code>TokenHandler.safeTransferIn</code> does not work on non-standard compliant tokens like USDT</a></li>\n<li><a href=\"#h-08-dos-by-frontrunning-noteerc20-initialize-function\">[H-08] DOS by Frontrunning NoteERC20 <code>initialize()</code> Function</a></li>\n<li><a href=\"#h-09-potential-dos-in-contracts-inheriting-uupsupgradeablesol\">[H-09] Potential DOS in Contracts Inheriting <code>UUPSUpgradeable.sol</code></a></li>\n<li><a href=\"#h-10-liquidity-token-value-can-be-manipulated\">[H-10] Liquidity token value can be manipulated</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#medium-risk-findings-7\">Medium Risk Findings (7)</a></p>\n<ul>\n<li><a href=\"#m-01-tokenhandlersol-l174---transfer-is-bad-practice\">[M-01] TokenHandler.sol, L174 - <code>.transfer</code> is bad practice</a></li>\n<li><a href=\"#m-02-latestrounddata-does-not-update-the-oracle---exchangeratesol\">[M-02] <code>.latestRoundData()</code> does not update the oracle - <code>ExchangeRate.sol</code></a></li>\n<li><a href=\"#m-03-allowance-checks-not-correctly-implemented\">[M-03] Allowance checks not correctly implemented</a></li>\n<li><a href=\"#m-04-compoundtonotionalv2enabletoken-erc20-missing-return-value-check\">[M-04] <code>CompoundToNotionalV2.enableToken</code> ERC20 missing return value check</a></li>\n<li><a href=\"#m-05-ntokenerc20proxy-emits-events-even-when-not-success\">[M-05] <code>nTokenERC20Proxy</code> emits events even when not success</a></li>\n<li><a href=\"#m-06-tokenhandlersettoken-erc20-missing-return-value-check\">[M-06] <code>TokenHandler.setToken</code> ERC20 missing return value check</a></li>\n<li><a href=\"#m-07-attackers-can-force-liquidations-by-borrowing-large-amounts-of-an-asset\">[M-07] Attackers can force liquidations by borrowing large amounts of an asset.</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#low-risk-findings-21\">Low Risk Findings (21)</a></p>\n<ul>\n<li><a href=\"#l-01--incorrect-event-parameters-in-transferfrom-function\">[L-01]  Incorrect event parameters in <code>transferFrom</code> function</a></li>\n<li><a href=\"#l-02-addressiscontract-with-no-check-of-returned-value\">[L-02] <code>Address.isContract</code> with no check of returned value</a></li>\n<li><a href=\"#l-03-lack-of-input-validation-of-arrays\">[L-03] lack of input validation of arrays</a></li>\n<li><a href=\"#l-04-no-transfer-ownership-pattern\">[L-04] No Transfer Ownership Pattern</a></li>\n<li><a href=\"#l-05-initialize-functions-can-be-front-run\">[L-05] <code>initialize</code> functions can be front-run</a></li>\n<li><a href=\"#l-06-erc1155action-returns-false-on-supportsinterface-with-the-real-erc1155-interface\">[L-06] <code>ERC1155Action</code> returns <code>false</code> on <code>supportsInterface</code> with the real ERC1155 interface</a></li>\n<li><a href=\"#l-07-erc1155-has-reentrancy-possibilities\">[L-07] ERC1155 has reentrancy possibilities.</a></li>\n<li><a href=\"#l-08-open-todos-in-erc1155action\">[L-08] Open TODOs in <code>ERC1155Action</code></a></li>\n<li><a href=\"#l-09-router-calls-to-ntokenactionntokentransferapprove-fail\">[L-09] Router calls to <code>nTokenAction.nTokenTransferApprove</code> fail</a></li>\n<li><a href=\"#l-10-unclear-decimals-value-in-ctokenaggregator\">[L-10] Unclear decimals value in <code>cTokenAggregator</code></a></li>\n<li><a href=\"#l-11-governor-average-block-time-is-not-up-to-date\">[L-11] Governor average block time is not up-to-date</a></li>\n<li><a href=\"#l-12-noteerc20-missing-initial-ownership-event\">[L-12] NoteERC20 missing initial ownership event</a></li>\n<li><a href=\"#l-13-tokenhandlertransfer-wrong-branch-order\">[L-13] <code>TokenHandler.transfer</code> wrong branch order</a></li>\n<li><a href=\"#l-14-datetimeisvalidmarketmaturity-bounds-should-be-tighter\">[L-14] <code>DateTime.isValidMarketMaturity</code> bounds should be tighter</a></li>\n<li><a href=\"#l-15-datetimegetmarketindex-bounds-should-be-tighter\">[L-15] <code>DateTime.getMarketIndex</code> bounds should be tighter</a></li>\n<li><a href=\"#l-16-double-check-for-birthday-collision\">[L-16] Double check for “birthday” collision</a></li>\n<li><a href=\"#l-17-notionalcallback-returns-no-value\">[L-17] <code>notionalCallback</code> returns no value</a></li>\n<li><a href=\"#l-18-notionalv1tonotionalv2-should-reject-eth-transfers-from-others-than-weth\">[L-18] <code>NotionalV1ToNotionalV2</code> should reject ETH transfers from others than WETH</a></li>\n<li><a href=\"#l-19-no-checks-on-target-variable\">[L-19] No checks on target variable</a></li>\n<li><a href=\"#l-20-some-tradingactions-do-not-have-front-running-protections\">[L-20] Some <code>TradingActions</code> do not have front-running protections</a></li>\n<li><a href=\"#l-21-noteerc20getpriorvotes-includes-current-unclaimed-incentives\">[L-21] <code>NoteERC20.getPriorVotes</code> includes current unclaimed incentives</a></li>\n</ul>\n</li>\n<li><a href=\"#non-critical-findings-13\">Non-Critical Findings (13)</a></li>\n<li><a href=\"#gas-optimizations-8\">Gas Optimizations (8)</a></li>\n<li><a href=\"#disclosures\">Disclosures</a></li>\n</ul>",
  "md": "\n# Overview\n\n## About C4\n\nCode 432n4 (C4) is an open organization consisting of security researchers, auditors, developers, and individuals with domain expertise in smart contracts.\n\nA C4 code contest is an event in which community participants, referred to as Wardens, review, audit, or analyze smart contract logic in exchange for a bounty provided by sponsoring projects.\n\nDuring the code contest outlined in this document, C4 conducted an analysis of Notional smart contract system written in Solidity. The code contest took place between August 25—September 8, 2021.\n\n## Wardens\n\n11 Wardens contributed reports to the Notional code contest:\n\n1. [cmichel](https://twitter.com/cmichelio)\n2. [leastwood](https://twitter.com/liam_eastwood13)\n3. [pauliax](https://twitter.com/SolidityDev)\n4. [tensors](https://twitter.com/Tensors8)\n5. [gpersoon](https://twitter.com/gpersoon)\n6. [Omik](https://twitter.com/omikomikomik)\n7. [Jmukesh](https://twitter.com/MukeshJ_eth)\n8.  [hrkrshnn](https://twitter.com/_hrkrshnn)\n9. [a_delamo](https://twitter.com/a_delamo)\n10. [LSDan](https://twitter.com/lsdan_defi)\n11. [ad3sh_](https://twitter.com/adeshkolte_)\n\nThis contest was judged by [ghoul.sol](https://twitter.com/ghoulsol).\n\nFinal report assembled by [moneylegobatman](https://twitter.com/money_lego) and [ninek](https://twitter.com/_ninek_).\n\n# Summary\n\nThe C4 analysis yielded an aggregated total of 38 unique vulnerabilities. All of the issues presented here are linked back to their original findings.\n\nOf these vulnerabilities, 10 received a risk rating in the category of HIGH severity, 7 received a risk rating in the category of MEDIUM severity, and 21 received a risk rating in the category of LOW severity.\n\nC4 analysis also identified 13 non-critical recommendations and 8 gas optimizations.\n\n# Scope\n\nThe code under review can be found within the [C4 Notional code contest repository](https://github.com/code-423n4/2021-08-notional) is comprised of 98 smart contracts written in the Solidity programming language and includes 13,208 lines of Solidity code.\n\n# Severity Criteria\n\nC4 assesses the severity of disclosed vulnerabilities according to a methodology based on [OWASP standards](https://owasp.org/www-community/OWASP_Risk_Rating_Methodology).\n\nVulnerabilities are divided into three primary risk categories: high, medium, and low.\n\nHigh-level considerations for vulnerabilities span the following key areas when conducting assessments:\n\n- Malicious Input Handling\n- Escalation of privileges\n- Arithmetic\n- Gas use\n\nFurther information regarding the severity criteria referenced throughout the submission review process, please refer to the documentation provided on [the C4 website](https://code423n4.com).\n\n# High Risk Findings (10)\n\n## [[H-01] Self transfer can lead to unlimited mint](https://github.com/code-423n4/2021-08-notional-findings/issues/1)\n_Submitted by Omik, also found by gpersoon_\n\nThe implementation of the transfer function in [`nTokenAction.sol`]( https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol) is different from the usual erc20 token transfer function.\n\n This happens because it counts the incentive that the user gets, but with a self-transfer,  it can lead to unlimited mint. In [L278](https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol#_L278), it makes the amount negative, but in [L279](https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol#L279), it returns the value to an amount that is not negative. So, in the [L281-282](https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/nTokenAction.sol#L281-282), it finalizes a positive value, only because the negative value is changed to the positive value.\n\n You can interact with this transfer function through [nTokenERC20Proxy.sol](https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/adapters/nTokenERC20Proxy.sol).\n\nRecommend adding `(sender != recipient)`.\n\n## [[H-02] DAO proposals can be executed by anyone due to vulnerable `TimelockController`](https://github.com/code-423n4/2021-08-notional-findings/issues/58)\n_Submitted by cmichel, also found by leastwood_\n\nThe `GovernorAlpha` inherits from a vulnerable `TimelockController`.\nThis `TimelockController` allows an `EXECUTOR` role to escalate privileges and also gain the proposer role. See details on [OZ](https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-fg47-3c2x-m2wr) and the [fix here](https://github.com/OpenZeppelin/openzeppelin-contracts/compare/v4.3.0...v4.3.1).\n\nThe bug is that `_executeBatch` checks if the proposal was scheduled only **after** the transactions have been executed. This allows inserting a call into the batch that schedules the batch itself, and the entire batch will succeed.\nAs the custom `GovernorAlpha.executeProposal` function removed the original \"queued state check\" (`require(state(proposalId) == ProposalState.Queued`), the attack can be executed by anyone, even without the `EXEUCTOR_ROLE`.\n\n**Proof of concept**:\n1. Create a proposal using `propose`. The `calldata` will be explained in the next step. (This can be done by anyone passing the min `proposalThreshold`)\n2. Call `executeProposal(proposalId, ...)` such that the following calls are made:\n\n```solidity\ncall-0: grantRole(TIME_LOCK_ADMIN, attackerContract)\ncall-1: grantRole(EXECUTOR, attackerContract)\ncall-2: grantRole(PROPOSER, attackerContract)\ncall-3: updateDelay(0) // such that _afterCall \"isOperationReady(id): timestamp[id] = block.timestamp + minDelay (0) <= block.timestamp\" passes\ncall-4: attackerContract.hello() // this calls timelock.schedule(args=[targets, values, datas, ...]) where args were previously already stored in contract. (this is necessary because id depends on this function's args and we may not be self-referential)\n// attackerContract is proposer & executor now and can directly call scheduleBatch & executeBatch without having to create a proposal\n```\n\n> ℹ️  I already talked to Jeff Wu about this and he created a test case for it confirming this finding\n\nThe impact is that, anyone who can create a proposal can become `Timelock` admin (proposer & executor) and execute arbitrary transactions as the DAO-controlled `GovernorAlpha`.\nNote that this contract has severe privileges and an attacker can now do anything that previously required approval of the DAO. For example, they could update the `globalTransferOperator` and steal all tokens.\n\nRecommend updating the vulnerable contract to `TimelockController v3.4.2` as it currently uses `OpenZeppelin/openzeppelin-contracts@3.4.0-solc-0.7`\n\n**[jeffywu (Notional) confirmed](https://github.com/code-423n4/2021-08-notional-findings/issues/58)**\n\n## [[H-03] `CompoundToNotionalV2.notionalCallback` ERC20 return values not checked](https://github.com/code-423n4/2021-08-notional-findings/issues/68)\n_Submitted by cmichel_\n\nSome tokens (like USDT) don't correctly implement the EIP20 standard and their `transfer`/`transferFrom` functions return `void`, instead of a success boolean. Calling these functions with the correct EIP20 function signatures will always revert. See `CompoundToNotionalV2.notionalCallback`'s `IERC20(underlyingToken).transferFrom` call.\n\nTokens that don't correctly implement the latest EIP20 spec, like USDT, will be unusable in the protocol as they revert the transaction because of the missing return value.\nThe fact that there is a `cToken` with `USDT` as the underlying this issue directly applies to the protocol.\n\nWe recommend using OpenZeppelin’s `SafeERC20` versions with the `safeTransfer` and `safeTransferFrom` functions that handle the return value check as well as non-standard-compliant tokens.\n\n**[jeffywu (Notional) confirmed](https://github.com/code-423n4/2021-08-notional-findings/issues/68)**\n\n## [[H-04] Access restrictions on `CompoundToNotionalV2.notionalCallback` can be bypassed](https://github.com/code-423n4/2021-08-notional-findings/issues/69)\n_Submitted by cmichel_\n\nThe `CompoundToNotionalV2.notionalCallback` is supposed to only be called from the verified contract that calls this callback. But, the access restrictions can be circumvented by simply providing `sender = this`, as `sender` is a parameter of the function that can be chosen by the attacker.\n\n```solidity\nfunction notionalCallback(\n    address sender,\n    address account,\n    bytes calldata callbackData\n) external returns (uint256) {\n// @audit sender can be passed in by the attacker\nrequire(sender == address(this), \"Unauthorized callback\");\n```\n\nAn attacker can call the function passing in an arbitrary `account` whose tokens are then transferred to the contract.\nThe `account` first has to approve this contract but this can happen with accounts that legitimately want to call the outer function and have to send a first transaction to approve the contract, but then an attacker front-runs the actual transaction.\n\nIt's at least a griefing attack:\nI can pass in a malicious `cTokenBorrow` that returns any token of my choice (through the `.underlying()` call) but whose `repayBorrowBehalf` is a no-op.\n\n\nThis will lead to any of the victim's approved tokens becoming stuck in the contract, essentially burning them:\n\n```solidity\n// @audit using a malicious contract, this can be any token\naddress underlyingToken = CTokenInterface(cTokenBorrow).underlying();\nbool success = IERC20(underlyingToken).transferFrom(account, address(this), cTokenRepayAmount);\nrequire(success, \"Transfer of repayment failed\");\n\n// Use the amount transferred to repay the borrow\n// @audit using a malicious contract, this can be a no-op\nuint code = CErc20Interface(cTokenBorrow).repayBorrowBehalf(account, cTokenRepayAmount);\n```\n\nNote that the assumption at the end of the function \"// When this exits a free collateral check will be triggered\" is not correct anymore but I couldn't find a way to make use of it to lead to an invalid account state.\n\nRecommend fixing the authorization check.\n\n**[jeffywu (Notional) confirmed](https://github.com/code-423n4/2021-08-notional-findings/issues/69)**\n\n## [[H-05] Access restrictions on `NotionalV1ToNotionalV2.notionalCallback` can be bypassed](https://github.com/code-423n4/2021-08-notional-findings/issues/71)\n_Submitted by cmichel, also found by pauliax_\n\nThe `NotionalV1ToNotionalV2.notionalCallback` is supposed to only be called from the verified contract that calls this callback but the access restrictions can be circumvented by simply providing `sender = this` as `sender` is a parameter of the function that can be chosen by the attacker.\n\n```solidity\nfunction notionalCallback(\n    address sender,\n    address account,\n    bytes calldata callbackData\n) external returns (uint256) {\n    require(sender == address(this), \"Unauthorized callback\");\n```\n\nAn attacker can call the function passing in an arbitrary `account` whose tokens can then be stolen.\nThe `account` first has to approve this contract but this can happen with accounts that legitimately want to migrate their tokens and therefore have to send a first transaction to approve the contract, but then an attacker frontruns the actual migration transaction.\n\nThe attacker can steal the tokens by performing an attack similar to the following:\n- first transaction is used to withdraw the victim's funds to the contract. This can be done by choosing `account=victim`, `v1RepayAmount=0`, `v1CollateralId=WBTC`, `v2CollateralId=DAI`. The [`NotionalV1Erc1155.batchOperationWithdraw`](https://github.com/notional-finance/contracts/blob/4bf7a85e6cf81cde4283e0efab0b03f21249ba00/contracts/ERC1155Trade.sol#L108) (not part of this contest) will withdraw the victim's funds to this contract. Note that the attacker has to deposit the same `v2CollateralBalance = uint256(collateralBalance)` for the victim into the V2 version, but they can choose different cheaper collateral (for example, withdraw WBTC, deposit same amount of DAI).\n- second transaction is now used to deposit the victim funds in the contract into the user's account. They use `account=attacker`, `v1DebtCurrencyId=WBTC`, `v1RepayAmount=amount` to deposit it into Notional V1. (They need to have a small `collateralBalance`, etc. to pass all checks).\n\nRecommend fixing the authorization check.\n\n## [[H-06] `TokenHandler.safeTransferOut` does not work on non-standard compliant tokens like USDT](https://github.com/code-423n4/2021-08-notional-findings/issues/79)\n_Submitted by cmichel_\n\nThe `TokenHandler.safeTransferOut` function uses the standard `IERC20` function for the transfer call and proceeds with a `checkReturnCode` function to handle non-standard compliant tokens that don't return a return value.\nHowever, this does not work, as calling `token.transfer(account, amount)` already reverts if the token does not return a return value, as `token`'s `IERC20.transfer` is defined to always return a `boolean`.\n\nThe impact is that, when using any non-standard compliant token like USDT, the function will revert.\nDeposits for these tokens are broken, which is bad as `USDT` is a valid underlying for the `cUSDT` cToken.\n\nWe recommend using [OpenZeppelin’s `SafeERC20`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74) versions with the `safeApprove` function that handles the return value check as well as non-standard-compliant tokens.\n\n**[jeffywu (Notional) confirmed](https://github.com/code-423n4/2021-08-notional-findings/issues/79)**\n\n## [[H-07] `TokenHandler.safeTransferIn` does not work on non-standard compliant tokens like USDT](https://github.com/code-423n4/2021-08-notional-findings/issues/80)\n_Submitted by cmichel_\n\nThe `TokenHandler.safeTransferIn` function uses the standard `IERC20` function for the transfer call and proceeds with a `checkReturnCode` function to handle non-standard compliant tokens that don't return a return value.\nHowever, this does not work, as calling `token.transferFrom(account, amount)` already reverts if the token does not return a return value, as `token`'s `IERC20.transferFrom` is defined to always return a `boolean`.\n\nWhen using any non-standard compliant token like USDT, the function will revert.\nWithdrawals for these tokens are broken, which is bad as `USDT` is a valid underlying for the `cUSDT` cToken.\n\nWe recommend using [OpenZeppelin’s `SafeERC20`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74) versions with the `safeApprove` function that handles the return value check as well as non-standard-compliant tokens.\n\n**[jeffywu (Notional) confirmed](https://github.com/code-423n4/2021-08-notional-findings/issues/80)**\n\n## [[H-08] DOS by Frontrunning NoteERC20 `initialize()` Function](https://github.com/code-423n4/2021-08-notional-findings/issues/7)\n_Submitted by leastwood_\n\nThe `scripts/` folder outlines a number of deployment scripts used by the Notional team. Some of the contracts deployed utilize the ERC1967 upgradeable proxy standard. This standard involves first deploying an implementation contract and later a proxy contract which uses the implementation contract as its logic.\n\nWhen users make calls to the proxy contract, the proxy contract will delegate call to the underlying implementation contract. `NoteERC20.sol` and `Router.sol` both implement an `initialize()` function which aims to replace the role of the `constructor()` when deploying proxy contracts. It is important that these proxy contracts are deployed and initialized in the same transaction to avoid any malicious front-running.\n\nHowever, `scripts/deployment.py` does not follow this pattern when deploying `NoteERC20.sol`'s proxy contract. As a result, a malicious attacker could monitor the Ethereum blockchain for bytecode that matches the `NoteERC20` contract and front-run the `initialize()` transaction to gain ownership of the contract. This can be repeated as a Denial Of Service (DOS) type of attack, effectively preventing Notional's contract deployment, leading to unrecoverable gas expenses. See [`deployment.py` L44-L60](https://github.com/code-423n4/2021-08-notional/blob/main/scripts/deployment.py#L44-L60), and [`deploy_governance.py` L71-L105](https://github.com/code-423n4/2021-08-notional/blob/main/scripts/mainnet/deploy_governance.py#L71-L105).\n\nAs the `GovernanceAlpha.sol` and `NoteERC20.sol` are co-dependent contracts in terms of deployment, it won't be possible to deploy the governance contract before deploying and initializing the token contract. Therefore, it would be worthwhile to ensure the `NoteERC20.sol` proxy contract is deployed and initialized in the same transaction, or ensure the `initialize()` function is callable only by the deployer of the `NoteERC20.sol` contract. This could be set in the proxy contracts `constructor()`.\n\n**[jeffywu (Notional) confirmed](https://github.com/code-423n4/2021-08-notional-findings/issues/7)**\n\n## [[H-09] Potential DOS in Contracts Inheriting `UUPSUpgradeable.sol`](https://github.com/code-423n4/2021-08-notional-findings/issues/98)\n_Submitted by leastwood_\n\nThere are a number of contracts which inherit `UUPSUpgradeable.sol`, namely; `GovernanceAction.sol`, `PauseRouter.sol` and `NoteERC20.sol`.\n\nAll these contracts are deployed using a proxy pattern whereby the implementation contract is used by the proxy contract for all its logic. The proxy contract will make delegate calls to the implementation contract. This helps to facilitate future upgrades by pointing the proxy contract to a new and upgraded implementation contract.\n\nHowever, if the implementation contract is left uninitialized, it is possible for any user to gain ownership of the `onlyOwner` role in the implementation contract for `NoteERC20.sol`. Once the user has ownership they are able to perform an upgrade of the implementation contract's logic contract and delegate call into any arbitrary contract, allowing them to self-destruct the proxy's implementation contract. Consequently, this will prevent all `NoteERC20.sol` interactions until a new implementation contract is deployed.\n\nInitial information about this issue was found [here](https://forum.openzeppelin.com/t/security-advisory-initialize-uups-implementation-contracts/15301).\n\nConsider the following scenario:\n- Notional finance deploys their contracts using their deployment scripts. These deployment scripts leave the implementation contracts uninitialized. Specifically the contract in question is `NoteERC20.sol`.\n- This allows any arbitrary user to call `initialize()` on the `NoteERC20.sol` implementation contract.\n- Once a user has gained control over `NoteERC20.sol`'s implementation contract, they can bypass the `_authorizeUpgrade` check used to restrict upgrades to the `onlyOwner` role.\n- The malicious user then calls `UUPSUpgradeable.upgradeToAndCall()` shown [here](https://github.com/code-423n4/2021-08-notional/blob/main/contracts/proxy/utils/UUPSUpgradeable.sol#L40-L43) which in turn calls [this](https://github.com/code-423n4/2021-08-notional/blob/main/contracts/proxy/ERC1967/ERC1967Upgrade.sol#L77-L107) function. The new implementation contract then points to their own contract containing a self-destruct call in its fallback function.\n- As a result, the implementation contract will be self-destructed due to the user-controlled delegate call shown [here](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0-solc-0.7/contracts/utils/Address.sol#L163-L169), preventing all future calls to the `NoteERC20.sol` proxy contract until a new implementation contract has been deployed.\n\nRecommend considering initializing the implementation contract for `NoteERC20.sol` and checking the correct permissions before deploying the proxy contract or performing any contract upgrades. This will help to ensure the implementation contract cannot be self-destructed.\n\n**[jeffywu (Notional) acknowledged and disagreed with severity](https://github.com/code-423n4/2021-08-notional-findings/issues/98#issuecomment-917410089):**\n > Acknowledged, I don't think this should be categorized high risk because the worst case is a denial of service and a redeployment of the ERC20 contract. As it stands, we've already successfully deployed our ERC20 contract so this is a non-issue.\n>\n> I would categorize as `0 (Non-critical)`\n\n**[adamavenir (organizer) commented](https://github.com/code-423n4/2021-08-notional-findings/issues/98#issuecomment-917415717):**\n > Warden leastwood added this proof of concept to illustrate the vulnerability https://gist.github.com/leastwood/b23d9e975883c817780116c2ceb785b8\n\n**[jeffywu (Notional) commented](https://github.com/code-423n4/2021-08-notional-findings/issues/98#issuecomment-917416175):**\n > Ok I retract my previous statement, I misread the issue description. Up to you guys but do you want to pay out a full amount to someone who is reporting issues discovered elsewhere? OZ has already called initialize on our deployed contract for us.\n\n**[adamavenir (organizer) commented](https://github.com/code-423n4/2021-08-notional-findings/issues/98#issuecomment-917706252):**\n > @jeffywu (Notional) I think the question is whether the issue is valid based on the original code base. Given your initial response and change after his proof of concept, my read was there was value here in what he reported. Is that a correct understanding?\n\n**[jeffywu (Notional) commented](https://github.com/code-423n4/2021-08-notional-findings/issues/98#issuecomment-917706960):**\n > There was value added here but perhaps not at the same level as the other high risk issues.\n\n**[adamavenir (organizer) commented](https://github.com/code-423n4/2021-08-notional-findings/issues/98#issuecomment-917744246):**\n > @jeffywu (Notional) Thanks for the input. As per our rules, awards are determined strictly based on the judge's assessment of the validity and severity, so we'll see how our judge chooses to score this.\n\n## [[H-10] Liquidity token value can be manipulated](https://github.com/code-423n4/2021-08-notional-findings/issues/85)\n_Submitted by cmichel_\n\nThe liquidity token value (`AssetHandler.getLiquidityTokenValue`) is the sum of the value of the individual claims on cash (underlying or rather cTokens) and fCash.\nThe amount to redeem on each of these is computed as the LP token to redeem relative to the total LP tokens, see `AssetHandler.getCashClaims` / `AssetHandler.getHaircutCashClaims`:\n\n```solidity\n// @audit token.notional are the LP tokens to redeem\nassetCash = market.totalAssetCash.mul(token.notional).div(market.totalLiquidity);\nfCash = market.totalfCash.mul(token.notional).div(market.totalLiquidity);\n```\n\nThis means the value depends on the **current market reserves** which can be manipulated.\nYou're essentially computing a spot price (even though the individual values use a TWAP price) because you use the current market reserves which can be manipulated.\n\nSee the \"How do I tell if I’m using spot price?\" section [here](https://shouldiusespotpriceasmyoracle.com/).\n> However, by doing this you’re actually incorporating the spot price because you’re still dependent on the reserve balances of the pool. This is an extremely subtle detail, and more than one project has been caught by it. You can read more about this [footgun](https://cmichel.io/pricing-lp-tokens/) in this writeup by @cmichelio.\n\nThe value of an LP token is computed as `assetCashClaim + assetRate.convertFromUnderlying( presentValue(fCashClaim) )`, where `(assetCashClaim, fCashClaim)` depends on the current market reserves which can be manipulated by an attacker via flashloans.\nTherefore, an attacker trading large amounts in the market can either increase or decrease the value of an LP token.\n\nIf the value decreases, they can try to liquidate users borrowing against their LP tokens / nTokens.\nIf the value increases, they can borrow against it and potentially receive an under-collateralized borrow this way, making a profit.\n\nThe exact profitability of such an attack depends on the AMM as the initial reserve manipulation and restoring the reserves later incurs fees and slippage.\nIn constant-product AMMs like Uniswap it's profitable and several projects have already been exploited by this, like [warp.finance](https://cmichel.io/pricing-lp-tokens/).\nHowever, Notional Finance uses a more complicated AMM and the contest was too short for me to do a more thorough analysis. It seems like a similar attack could be possible here as described by the developers when talking about a different context of using TWAP oracles:\n> \"Oracle rate protects against short term price manipulation. Time window will be set to a value on the order of minutes to hours. This is to protect fCash valuations from market manipulation. For example, a trader could use a flash loan to dump a large amount of cash into the market and depress interest rates. Since we value fCash in portfolios based on these rates, portfolio values will decrease and they may then be liquidated.\" - Market.sol L424\n\nRecommend not using the current market reserves to determine the value of LP tokens. Also, think about how to implement a TWAP oracle for the LP tokens themselves, instead of combining it from the two TWAPs of the claimables.\n\n**[T-Woodward (Notional) confirmed and disagreed with severity ](https://github.com/code-423n4/2021-08-notional-findings/issues/85#issuecomment-917422519):**\n > It is true that a flash loan could be used to manipulate the value of a liquidity token’s cash and fCash claims. This issue can potentially cause accounts to be liquidated which shouldn’t be, but not for the reasons stated in this issue. I’ll explain what actually can go wrong, and why the fix is simple and non-invasive.\n>\n> First, to restate the issue: The manipulator could borrow or lend a large amount to a liquidity pool, which would change the amount of cash and fCash sitting in that pool and the corresponding cash and fCash claims of a liquidity token associated with that pool. This could change the liquidity token’s net value within the space of a transaction despite the fact that the oracleRate used to value fCash is lagged and manipulation resistant.\n>\n> But it is not true that this manipulation could decrease the value of a liquidity token - in fact it could only increase a liquidity token’s value. By borrowing or lending a large amount using a flash loan, the interest rate that the attacker would receive would deviate from the oracleRate in favor of the liquidity provider. If the attacker executed a large lend order, the interest rate on the loan would be significantly below the oracleRate. This would mean that the liquidity providers had borrowed at a below-market rate and that the net value of that trade would be positive for them. Conversely if the attacker executed a large borrow order, the interest rate on the loan would be significantly above the oracleRate. Again, this would mean that the net value of that trade would be positive for the liquidity providers because they would effectively be lending at an above-market rate. In either case, the value of the liquidity token would increase, not decrease.\n>\n> However, even though the value of a liquidity token could only increase during such an attack, the collateral value of the liquidity token could decrease once the haircuts were applied in the free collateral calculation. The reason for this is that fCash claims are effectively double-haircut (once by the liquidity token haircut and once by the fCash haircut), whereas cash claims are only haircut once (by the liquidity token haircut). This means that even though the attack would increase the value of the liquidity token without haircuts, once you consider the haircuts applied in the free collateral calculation, the collateral value of the liquidity token can be decreased and accounts could become undercollateralized and eligible for liquidation.\n>\n> **Remediation:**\n> The immediate remediation for this issue is to restrict providing liquidity to the nToken account exclusively. In the longer term, we will plan to add TWAPs to determine the collateral value of liquidity token cash and fCash claims. This immediate remediation will be fine for now though, and will not degrade the system for two reasons:\n>\n> 1. The team does not anticipate users providing liquidity directly outside of the nToken (we don’t even offer a way to do it within the UI for example). Only nToken holders receive NOTE incentives, not direct liquidity providers.\n>\n> 2. The nToken accounts are safe from this attack because the maximum amount that an attacker could temporarily decrease the collateral value of liquidity tokens could never be enough to cause the nToken accounts to become undercollateralized, and therefore they would never be at risk of liquidation due to this attack. The TLDR here is that this attack can’t actually decrease the collateral value of liquidity tokens all that much, and so for an account to be vulnerable they would have to be running quite close to minimum collateralization. This will never happen for the nToken because it doesn’t borrow, it just provides liquidity and always maintains very healthy collateralization levels.\n>\n\n**[ghoul-sol (judge) commented](https://github.com/code-423n4/2021-08-notional-findings/issues/85#issuecomment-922395545):**\n > Again, I gave it some thought and I think that this is high risk. Keeping as is.\n\n# Medium Risk Findings (7)\n\n## [[M-01] TokenHandler.sol, L174 - `.transfer` is bad practice](https://github.com/code-423n4/2021-08-notional-findings/issues/15)\n_Submitted by JMukesh, also found by tensors_\n\nThe use of `.transfer` in [`TokenHandler.sol` L174](https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/internal/balances/TokenHandler.sol#L174) to send ether is now considered bad practice as gas costs can change which would break the code.\n\nSee [stop using soliditys transfer now](https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/), and [istanbul hardfork eips increasing gas costs and more](https://chainsecurity.com/istanbul-hardfork-eips-increasing-gas-costs-and-more/).\n\nRecommend using `call` instead, and make sure to check for reentrancy.\n\n**[jeffywu (Notional) commented](https://github.com/code-423n4/2021-08-notional-findings/issues/38#issuecomment-917446532):**\n > This should be `0 (Non critical)`. ETH transfers still work as of today. This is a best practice recommendation. In the case that there is a hard fork that breaks ETH transfers the protocol can be upgraded to support the use of `call()`\n\n**[ghoul-sol (judge) commented](https://github.com/code-423n4/2021-08-notional-findings/issues/38#issuecomment-920428460):**\n > I aline with warden on this one. `.transfer` will not work if the account is a smart contract. Keeping as is.\n\n_**EDITORS NOTE:** Additional conversation regarding this vulnerability can be found [here](https://github.com/code-423n4/2021-08-notional-findings/issues/38)_\n\n## [[M-02] `.latestRoundData()` does not update the oracle - `ExchangeRate.sol`](https://github.com/code-423n4/2021-08-notional-findings/issues/18)\n_Submitted by a_delamo, also found by tensors, JMukesh, cmichel and defsec_\n\nThe method `.latestRoundData()` on an oracle returns the latest updated price from the oracle, but this is not the current price of an asset. To get an accurate current price you need to query it by calling the oracle and waiting for a callback to fulfill the request.\n\nInaccurate price data could quickly lead to a large loss of funds. Suppose the price of an asset changes downward 5% but your oracle is not updated. A user could deposit funds (credited with an extra 5% since the oracle isn't updated), wait until `.latestRoundData()` updates (or update it himself) and becomes accurate. He then withdraws to the same asset he put in for an extra 5%. [`ExchangeRate.sol` L84](https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/internal/valuation/ExchangeRate.sol#L84)\n\nRecommend not fetching the latest price (having to call the oracle to update the price instead), and then waiting for the callback.\n\n## [[M-03] Allowance checks not correctly implemented](https://github.com/code-423n4/2021-08-notional-findings/issues/66)\n_Submitted by cmichel_\n\nThe `nTokenAction` implements two token approvals, the `nTokenWhitelist` which is always used first, and the `nTokenAllowance` which is checked second.\nIf the `nTokenWhitelist` does _not_ have enough allowance for the transfer, the transaction fails, even in the case where `nTokenAllowance` still has enough allowance.\n\nTransfers that have sufficient allowance fail in certain cases.\n\nRecommend that, instead of reverting if the `nTokenWhitelist` allowance is not enough, default to the `nTokenAllowance` case.\n\nSomething like this:\n\n```solidity\nuint256 requiredAllowance = amount;\n\nuint256 allowance = nTokenWhitelist[from][spender];\n// use whitelist allowance first\nif (allowance > 0) {\n    uint256 min = amount < allowance ? amount : allowance;\n    requiredAllowance -= min;\n    allowance = allowance.sub(min);\n    nTokenWhitelist[from][spender] = allowance;\n}\n\n// use currency-specific allowance now\nif(requiredAllowance > 0)\n    // This is the specific allowance for the nToken.\n    allowance = nTokenAllowance[from][spender][currencyId];\n    require(allowance >= requiredAllowance, \"Insufficient allowance\");\n    allowance = allowance.sub(requiredAllowance);\n    nTokenAllowance[from][spender][currencyId] = allowance;\n}\n```\n\n**[jeffywu (Notional) confirmed](https://github.com/code-423n4/2021-08-notional-findings/issues/66)**\n\n## [[M-04] `CompoundToNotionalV2.enableToken` ERC20 missing return value check](https://github.com/code-423n4/2021-08-notional-findings/issues/67)\n_Submitted by cmichel_\n\nThe `enableToken` function performs an `ERC20.approve()` call but does not check the `success` return value.\nSome tokens do **not** revert if the approval failed, returning `false` instead.\n\nThe impact is that, tokens that don't actually perform the approve and return `false` are still counted as a correct approve.\n\nRecommend using [OpenZeppelin’s `SafeERC20`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74) versions with the `safeApprove` function that handles the return value check as well as non-standard-compliant tokens.\n\n**[jeffywu (Notional) confirmed](https://github.com/code-423n4/2021-08-notional-findings/issues/67)**\n\n## [[M-05] `nTokenERC20Proxy` emits events even when not success](https://github.com/code-423n4/2021-08-notional-findings/issues/72)\n_Submitted by cmichel_\n\nThe `nTokenERC20Proxy` functions emit events all the time, even if the return value from the inner call returns `false`, indicating an unsuccessful action.\n\nAn off-chain script scanning for `Transfer` or `Approval` events can be tricked into believing that an unsuccessful transfer was indeed successful.\nThis happens in the `approve`, `transfer` and `transferFrom` functions.\n\nRecommend only emitting events on `success`.\n\n**[jeffywu (Notional) confirmed](https://github.com/code-423n4/2021-08-notional-findings/issues/72)**\n\n## [[M-06] `TokenHandler.setToken` ERC20 missing return value check](https://github.com/code-423n4/2021-08-notional-findings/issues/77)\n_Submitted by cmichel_\n\nThe `setToken` function performs an `ERC20.approve()` call but does not check the `success` return value.\nSome tokens do **not** revert if the approval failed but return `false` instead.\n\nThe impact is that tokens that don't actually perform the approve and return `false` are still counted as a correct approve.\n\nWe recommend using [OpenZeppelin’s `SafeERC20`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74) versions with the `safeApprove` function that handles the return value check as well as non-standard-compliant tokens.\n\n**[jeffywu (Notional) confirmed](https://github.com/code-423n4/2021-08-notional-findings/issues/77)**\n\n## [[M-07] Attackers can force liquidations by borrowing large amounts of an asset.](https://github.com/code-423n4/2021-08-notional-findings/issues/20)\n_Submitted by tensors_\n\nConsider an attacker who borrows enough to greatly increase the oracle rate. It is claimed that arbitrageurs will come in and fix this discrepancy before the attacker has a chance to profit off of his price manipulation:\n> \"Over the next 1 hour, the effect of the new 12% interest rate will be averaged into the previous 6% rate.\n> This forces the borrower to hold their position and gives an opportunity for other traders to lend to the market\n> to bring the interest rate back down to its previous 6% level.\"\n\nIn my opinion, this incentive is not sufficient to prevent an attack. This assumes that:\n\n1) There is sufficient volume to notice a manipulation like this\n2) The arbitrageurs would be willing to deploy capital for a short amount of for a slightly increased rate\n3) The arbitrageurs would now know that this is a manipulation, and not a natural market movement (For example, lets say an asset lending rate goes up 10% in value, is it being manipulated or is the rate actually worth 10% more for some reason? An arbitrageur needs to make this before he deploys capital). Since notional is the only market to offer something like this, it is difficult to discern what the response should be.\n4) The arbitrageurs don't join in on the attack, and try to liquidate accounts with the attacker\n\nProof of concept is based off of the formula and text [here](https://github.com/code-423n4/2021-08-notional/blob/main/contracts/internal/valuation/_README.md).\n\nUncertain what the recommendation should be.\n\n**[T-Woodward (Notional) acknowledged and disagreed with severity](https://github.com/code-423n4/2021-08-notional-findings/issues/20#issuecomment-917423368):**\n > This is a fair point. With a timeWindow value that is under an hour, it’s not clear whether capital will flow in to take advantage of artificially inflated yields before the oracleRate catches up to the lastImpliedRate and accounts are potentially eligible for liquidation at this early stage in Notional’s lifespan before there are lots of eyes on the system and its market dynamics are widely understood.\n>\n> However, it’s worth noting that there are several mitigating circumstances which make such an attack unlikely:\n>\n> - The necessary conditions for a profitable attack to exist are quite narrow\n> - The capital required to execute such an attack is substantial\n> - The sunk cost of executing this attack prior to any payoff is significant\n> - The payoff of the attack is not guaranteed\n>\n> First let’s examine what this attack would have to look like.\n>\n> - With the current fCash market parameters, interest rates top out at about 25%, so the most that an attacker could push interest rates from their natural level is ~20% (assuming a starting interest rate of 5%).\n>\n> - With the current active maturities (longest dated maturity is one year), a 20% change in interest rates could decrease the collateral value of an account’s fCash by a maximum of ~20%.\n>\n> - Pushing the interest rate to the top of the range requires the attacker to borrow all of the cash sitting in the liquidity pool. If you assume there is \\$100M sitting in the pool, then the attacker would have to borrow \\$100M. At worst, if they execute the borrow all in one shot, their realized borrow rate would be 25%. At best, if they execute the borrow in pieces (increasing the time taken and risk of the attack), their realized borrow rate would be ~15%. This implies that the attacker has placed at least \\$15M at risk (his total interest owed) as there is no guarantee that he can exit his position in profit or at cost.\n>\n> - In order for this to be a profitable attack, the attacker needs to offset their borrowing by executing an fCash liquidation that would allow them to lend at the artificially inflated interest rate. This means that there must be an account, or set of accounts, which have borrowed against their fCash, are 20% away from under collateralization, and have enough fCash such that the attacker can offset his borrow by liquidating their fCash. In other words, there would need to be \\$100M+ of fCash held in the system that is being used as collateral and is close to liquidation.\n>\n> - These conditions are possible, but improbable. It would imply that the amount of outstanding loans that are being borrowed against (and are close to under collateralization) is greater than the total liquidity in the pool. This strikes me as unlikely for two reasons:\n>\n> 1. For there to be more fCash outstanding than liquidity in the pool, there would have to be a lot of two-way trading. We expect this to happen eventually, but in the initial stages we would be very surprised by this because lenders do not earn NOTE incentives, only liquidity providers earn NOTE incentives. It would be very surprising to see more lending than liquidity given this fact. We expect more lending than liquidity once Notional is more mature, but by then there will be more eyes on the system which would make this attack less likely as arbitragers and/or automated yield aggregators really would come in to push rates back down to their natural level.\n>\n> 2. Only a percentage of fCash will actually be used as collateral, and probably not a large percentage. So if you specifically need fCash used as collateral (and close to liquidation) to be a multiple of liquidity in the pool, this would imply that the amount of total outstanding fCash would be like an order of magnitude greater than the liquidity in the pool. That strikes me as highly unlikely.\n>\n> Ultimately we don’t think this is a significant risk because the necessary conditions are unlikely to obtain in the early stages of Notional’s growth, the attack involves substantial sunk costs and capital committed, and the risk of an unsuccessful attack is significant. To further mitigate against this unlikely risk, we will skew the timeWindow to a longer time / larger value.\n\n**[ghoul-sol (judge) commented](https://github.com/code-423n4/2021-08-notional-findings/issues/20#issuecomment-922395972):**\n > This attack requires a lot of things aligned and for that single reason I'll give it medium risk.\n\n# Low Risk Findings (21)\n\n## [[L-01]  Incorrect event parameters in `transferFrom` function](https://github.com/code-423n4/2021-08-notional-findings/issues/36)\n_Submitted by pauliax, also found by JMukesh_\n\nDifferent parameter are being set in `Approval` event in `transferFrom()`\n\n```solidity\nfunction transferFrom(\n    address from,\n    address to,\n    uint256 amount\n) external override returns (bool) {\n    (bool success, uint256 newAllowance) =\n        proxy.nTokenTransferFrom(currencyId, msg.sender, from, to, amount);\n\n    // Emit transfer events here so they come from the correct contract\n    emit Transfer(from, to, amount);\n\n// here first parameter should be owner and second should be spender\n//   as mentioned in ntokenErc20.sol that is :\n// event Approval(address indexed owner, // address indexed spender, uint256 amount);\n\n    emit Approval(msg.sender, from, newAllowance);\n\n    return success;\n}\n```\n\nThe impact is that, this error may negatively impact off-chain tools that are monitoring critical transfer events of the token. See [`nTokenERC20Proxy.sol` L100](https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/external/adapters/nTokenERC20Proxy.sol#L100).\n\n**[jeffywu (Notional) disagreed with severity](https://github.com/code-423n4/2021-08-notional-findings/issues/36#issuecomment-917446856):**\n > Duplicate #55, dispute the categorization. This should be Low Risk.\n\n**[ghoul-sol (judge) commented](https://github.com/code-423n4/2021-08-notional-findings/issues/36#issuecomment-920425665):**\n > External services might be affected but it's not clear how significant it would be. Most of the time events are not critical. Making this low risk.\n\n## [[L-02] `Address.isContract` with no check of returned value](https://github.com/code-423n4/2021-08-notional-findings/issues/44)\n_Submitted by JMukesh, also found by pauliax_\n\nThe function `activateNotional` calls `Address.isContract(...)` but does not check the returned value, thus making this call pretty much useless:\n```solidity\nAddress.isContract(address(notionalProxy_));\n```\n\nRecommend wrapping this in a require statement.\n\n**[jeffywu (Notional) confirmed](https://github.com/code-423n4/2021-08-notional-findings/issues/44)**\n\n## [[L-03] lack of input validation of arrays](https://github.com/code-423n4/2021-08-notional-findings/issues/43)\n_Submitted by JMukesh_\n\n```solidity\nfunction migrateBorrowFromCompound(\n    address cTokenBorrow,\n    uint256 cTokenRepayAmount,\n    uint16[] memory notionalV2CollateralIds,\n    uint256[] memory notionalV2CollateralAmounts,\n    BalanceActionWithTrades[] calldata borrowAction\n) ;\n```\n\nif the array length of `notionalV2CollateralId` , `notionalV2CollateralAmounts` and `borrowAction` is not equal, it can lead to an error. See [`CompoundToNotionalV2.sol` L24](https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/external/adapters/CompoundToNotionalV2.sol#L24).\n\nRecommend checking the input array length.\n\n**[jeffywu (Notional) confirmed](https://github.com/code-423n4/2021-08-notional-findings/issues/43)**\n\n## [[L-04] No Transfer Ownership Pattern](https://github.com/code-423n4/2021-08-notional-findings/issues/94)\n_Submitted by leastwood, also found by JMukesh_\n\nThe current ownership transfer process involves the current owner calling `NoteERC20.transferOwnership()`. This function checks that the new owner is not the zero address and proceeds to write the new owner's address into the owner's state variable. If the nominated EOA account is not a valid account, it is entirely possible the owner may accidentally transfer ownership to an uncontrolled account, breaking all functions with the `onlyOwner()` modifier. See [`NoteERC20.sol` L123-L127](https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/governance/NoteERC20.sol#L123-L127).\n\nRecommend considering implementing a two step process where the owner nominates an account and the nominated account needs to call an `acceptOwnership()` function for the transfer of ownership to fully succeed. This ensures the nominated EOA account is a valid and active account.\n\n**[jeffywu (Notional) confirmed](https://github.com/code-423n4/2021-08-notional-findings/issues/94)**\n\n## [[L-05] `initialize` functions can be front-run](https://github.com/code-423n4/2021-08-notional-findings/issues/59)\n_Submitted by cmichel_\n\nThe `initialize` function that initializes important contract state can be called by anyone.\n\nOccurences:\n- `NoteERC20.initialize`\n- `Router.initialize`\n\nThe attacker can initialize the contract before the legitimate deployer, hoping that the victim continues to use the same contract.\nIn the best case for the victim, they notice it and have to redeploy their contract costing gas.\n\nRecommend using the constructor to initialize non-proxied contracts. For initializing proxy contracts, recommend deploying contracts using a factory contract that immediately calls `initialize` after deployment, or make sure to call it immediately after deployment and verify the transaction succeeded.\n\n**[jeffywu (Notional) confirmed](https://github.com/code-423n4/2021-08-notional-findings/issues/59)**\n\n## [[L-06] `ERC1155Action` returns `false` on `supportsInterface` with the real ERC1155 interface](https://github.com/code-423n4/2021-08-notional-findings/issues/61)\n_Submitted by cmichel_\n\nAs the return value of `ERC1155.balanceOf` was changed to a signed integer, the `nERC1155Interface` does not implement the `ERC1155` interface and the `supportsInterface` call will return false if people call it with the actual `ERC1155` interface ID.\n\nNot all users of the contract might care about the `balance` function and call `supportsInterface` with the original EIP1155 interface.\nThe contract will still deny the *[content missing]*\n\nIt is indeed debatable if this contract should be considered implementing ERC1155 and what the correct return value of `supportsInterface(ERC1155.interface)` should be for compatibility.\nUsers need to be aware that this contract is not standard compliant and that the `supportsInterface` call will fail.\n\n**[jeffywu (Notional) confirmed](https://github.com/code-423n4/2021-08-notional-findings/issues/61)**\n\n## [[L-07] ERC1155 has reentrancy possibilities.](https://github.com/code-423n4/2021-08-notional-findings/issues/25)\n_Submitted by cmichel, also found by tensors_\n\nERC1155 tokens have a callback on transfer, making reentrancy a possibility.\nI haven't been able to find any reentrancy, but having extra external function calls isn't safe.\nIf it's necessary to use an ERC1155 there is nothing you can do about it, but otherwise consider just using an ERC20.\n\nSee [`actions/ERC1155Action` sol](https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/actions/ERC1155Action.sol).\n\nRecommend confirming that using tokens with callbacks is really necessary for the protocol to function.\n\n**[jeffywu (Notional) disputed and disagreed with severity](https://github.com/code-423n4/2021-08-notional-findings/issues/25#issuecomment-917448341):**\n > Callbacks are required as part of the ERC1155 spec. Duplicate #62. Severity should be Low or Non Critical.\n\n**[ghoul-sol (judge) commented](https://github.com/code-423n4/2021-08-notional-findings/issues/25#issuecomment-922398689):**\n > Duplicate of #62 ergo low risk\n\n## [[L-08] Open TODOs in `ERC1155Action`](https://github.com/code-423n4/2021-08-notional-findings/issues/63)\n_Submitted by cmichel_\n\nThe `ERC1155Action._checkPostTransferEvent` has open TODOs:\n\n```solidity\n// TODO: retrieve revert string\nrequire(status, \"Call failed\");\n```\n\nOpen TODOs can hint at programming or architectural errors that still need to be fixed.\n\nRecommend resolving the TODO and bubble up the error.\n\n**[jeffywu (Notional) confirmed](https://github.com/code-423n4/2021-08-notional-findings/issues/63)**\n\n## [[L-09] Router calls to `nTokenAction.nTokenTransferApprove` fail](https://github.com/code-423n4/2021-08-notional-findings/issues/64)\n_Submitted by cmichel_\n\nThe `Router` forwards `nTokenTransferApprove` calls to the `nTokenAction` implementation. However, these always fail due to the `msg.sender == nTokenAddress` check.\n\nThis call failing seems to be the intended behavior but it shouldn't even be forwarded in the Router.\n\nRecommend removing `sig == nTokenAction.nTokenTransferApprove.selector` from the `getRouterImplementation` as it indicates that this is a valid function call.\n\n**[jeffywu (Notional) disputed](https://github.com/code-423n4/2021-08-notional-findings/issues/64#issuecomment-917700011):**\n > Calling approve on the nToken will forward the call to the Router which will then delegate call to the `nTokenTransferApprove` method. This is the intended functionality and will pass the require statement because the delegate call does not change the `msg.sender`\n\n## [[L-10] Unclear decimals value in `cTokenAggregator`](https://github.com/code-423n4/2021-08-notional-findings/issues/70)\n_Submitted by cmichel_\n\nThe `cTokenAggregator.decimals` value is set to `18` but `cTokens` only have `8` decimals. It's unclear what this `decimals` field refers to.\n\nIf it should refer to the `cToken` decimals, it's wrong and should be set to `8`.\nThis value is not used inside the contract but it's `public` and anyone can read it.\n\n**[jeffywu (Notional) confirmed](https://github.com/code-423n4/2021-08-notional-findings/issues/70#issuecomment-917415350):**\n > Decimals refers to the decimals in the exchange rate, but we should add a comment here. Agree it is confusing.\n\n## [[L-11] Governor average block time is not up-to-date](https://github.com/code-423n4/2021-08-notional-findings/issues/73)\n_Submitted by cmichel_\n\nThe `GovernorAlpha.MIN_VOTING_PERIOD_BLOCKS = 6700` value indicates an average block time of 12.8956s which was correct a year ago, but at the moment a more accurate block time would be 13.2s, see [blocktime](https://etherscan.io/chart/blocktime).\n\nRecommend using a `MIN_VOTING_PERIOD_BLOCKS` of `6545`.\n\n**[jeffywu (Notional) confirmed](https://github.com/code-423n4/2021-08-notional-findings/issues/73)**\n\n## [[L-12] NoteERC20 missing initial ownership event](https://github.com/code-423n4/2021-08-notional-findings/issues/74)\n_Submitted by cmichel_\n\nThe `NoteERC20.initialize` function does not emit an initial `OwnershipTransferred` event.\n\nRecommend emitting `OwnershipTransferred(address(0), owner_)` in `initialize`.\n\n**[jeffywu (Notional) confirmed](https://github.com/code-423n4/2021-08-notional-findings/issues/74)**\n\n## [[L-13] `TokenHandler.transfer` wrong branch order](https://github.com/code-423n4/2021-08-notional-findings/issues/78)\n_Submitted by cmichel_\n\nThe `TokenHandler.transfer` should handle the `if (token.tokenType == TokenType.Ether)` case first, as if the token type is `Ether` but `netTransferExternal <= 0` it treats the token as an `ERC20` token and tries to call `ERC20` functions on it.\n\nLuckily, trying to call ERC20 functions on the invalid token address will revert which is the desired behavior.\n\nWe still recommend reordering the branches and adding a `netTransferExternal <= 0` check. The code becomes cleaner and it's more obvious that the transaction will fail.\n\n**[jeffywu (Notional) confirmed](https://github.com/code-423n4/2021-08-notional-findings/issues/78)**\n\n## [[L-14] `DateTime.isValidMarketMaturity` bounds should be tighter](https://github.com/code-423n4/2021-08-notional-findings/issues/81)\n_Submitted by cmichel_\n\n`DateTime.isValidMarketMaturity` can be called with a `maxMarketIndex < 10` but the inner `DateTime.getTradedMarket(i)` function will revert for any values `i > 7`.\n\nThe impact is that \"Valid\" `maxMarketIndex` values above 7 will break and return with an error.\n\nRecommend that the upper bound on `maxMarketIndex` should be set to `7`.\n\n**[jeffywu (Notional) confirmed](https://github.com/code-423n4/2021-08-notional-findings/issues/81)**\n\n## [[L-15] `DateTime.getMarketIndex` bounds should be tighter](https://github.com/code-423n4/2021-08-notional-findings/issues/82)\n_Submitted by cmichel_\n\n`DateTime.getMarketIndex` can be called with a `maxMarketIndex < 10` but the inner `DateTime.getTradedMarket(i)` function will revert for any values `i > 7`.\n\n\"Valid\" `maxMarketIndex` values above 7 will break and return with an error.\n\nThe upper bound on `maxMarketIndex` should be set to `7`.\n\n**[jeffywu (Notional) confirmed](https://github.com/code-423n4/2021-08-notional-findings/issues/82)**\n\n## [[L-16] Double check for \"birthday\" collision](https://github.com/code-423n4/2021-08-notional-findings/issues/4)\n_Submitted by gpersoon_\n\nThe function [`getRouterImplementation`](https://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/Router.sol#L97) of `Router.sol` checks the selectors of functions and calls the appropriate function.\nSelectors are only 4 bytes long, so there is a theoretical probability of a collision (e.g. two functions having the same selector).\n\nThis is comparable to the [\"birthday attack\"](https://en.wikipedia.org/wiki/Birthday_attack).\nThe probability of a collision when you have 93 different functions is 10^−6.\nDue to the structure of the `Router.sol`, the solidity compiler does not prevent collisions\n\nRecommend double checking (perhaps via a continuous integration script / github workflow), that there are no collisions of the selectors.\n\n**- [jeffywu (Notional) confirmed](https://github.com/code-423n4/2021-08-notional-findings/issues/4)**\n\n## [[L-17] `notionalCallback` returns no value](https://github.com/code-423n4/2021-08-notional-findings/issues/46)\n_Submitted by pauliax_\n\nThe function `notionalCallback` (in `NotionalV1ToNotionalV2` and `CompoundToNotionalV2`) declares to return uint, however, no actual value is returned.\n\nRecommend either removing the return declaration or returning the intended value (I assume it may return a value that it gets from `depositUnderlyingToken`/`depositAssetToken`). Otherwise, it may confuse other protocols that later may want to integrate with you.\n\n**[jeffywu (Notional) confirmed](https://github.com/code-423n4/2021-08-notional-findings/issues/46)**\n\n## [[L-18] `NotionalV1ToNotionalV2` should reject ETH transfers from others than WETH](https://github.com/code-423n4/2021-08-notional-findings/issues/48)\n_Submitted by pauliax_\n\nThe contract `NotionalV1ToNotionalV2` has an empty receive function which allows it to receive Ether. I suppose this was needed to receive ETH when withdrawing from WETH. As there is no way to send out accidentally sent ETH from this contract, I suggest adding an auth check to this receive function to only accept ETH from WETH contract.\n\n```solidity\nrequire(msg.sender == address(WETH), \"Not WETH\");\n```\n\n**[jeffywu (Notional) confirmed](https://github.com/code-423n4/2021-08-notional-findings/issues/48)**\n\n## [[L-19] No checks on target variable](https://github.com/code-423n4/2021-08-notional-findings/issues/29)\n_Submitted by tensors_\n\nLack of checks on target could lead to loss of funds in [`Reservoir.sol` L50](https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/external/governance/Reservoir.sol#L50).\n\nRecommend requiring that target is non-zero.\n\n**[jeffywu (Notional) confirmed](https://github.com/code-423n4/2021-08-notional-findings/issues/29)**\n\n## [[L-20] Some `TradingActions` do not have front-running protections](https://github.com/code-423n4/2021-08-notional-findings/issues/30)\n_Submitted by tensors_\n\nSome of the actions in `TradingAction.sol` can be front-run. Since there are no slippage protections, its unclear how bad this problem can be.\nSee [`TradingAction.sol` L334](https://github.com/code-423n4/2021-08-notional/blob/4b51b0de2b448e4d36809781c097c7bc373312e9/contracts/external/actions/TradingAction.sol#L334).\n\nAn example is `_settleCashDebt()`. This goes through `_getfCashSettleAmount()` which uses an `impliedRate` variable. This can be manipulated by a frontrunner. Add checks that exist on the other trade types.\n\nRecommend adding `minAmountOut`/`minAmountCredited` as function variables to protect against frontrunning. For example. `_executeLiquidityTrade` has such protections in place.\n\n**[T-Woodward (Notional) acknowledged but disagreed with severity](https://github.com/code-423n4/2021-08-notional-findings/issues/30#issuecomment-917422834):**\n > I don’t think this is a particularly serious issue in practice, given that _getfCashSettleAmount is calculated off the oraclePrice which is manipulation-resistant, but it is still a valid concern.\n>\n> **Remediation:**\n> Add slippage guards similar to executing a normal lend/borrow on the AMM\n\n**[jeffywu (Notional) commented](https://github.com/code-423n4/2021-08-notional-findings/issues/30#issuecomment-917447729):**\n > Severity should be `1 Low Risk`. It is true that you can potentially front run settle cash debt but we will not fix this as there is no room in the calldata for an additional parameter. The likelihood of manipulating the oracle rate for a given time window is low.\n\n**[ghoul-sol (judge) commented](https://github.com/code-423n4/2021-08-notional-findings/issues/30#issuecomment-922397396):**\n > As the sponsor said, there is no immediate risk of losing funds and it's not clear how this could be manipulated is the oracle price is a base to calculate the settlement amount. Making this low risk.\n\n## [[L-21] `NoteERC20.getPriorVotes` includes current unclaimed incentives](https://github.com/code-423n4/2021-08-notional-findings/issues/76)\n_Submitted by cmichel_\n\nThe `NoteERC20.getPriorVotes` function is supposed to return the voting strength of an account at a specific block in the past.\nThis should be a static value but it directly includes the _current_ unclaimed incentives due to the `getUnclaimedVotes(account)` call.\n\nUsers that didn't even have tokens at the time of proposal creation (but are now interested in voting on the proposal), can farm unclaimed incentives and impact the outcome of the proposal.\n\nAdding checkpoints for all unclaimed incentives would be the correct solution but was probably not done because it'd cost too much gas.\nIt also needs to be ensured that incentives cannot be increased through flash-loaning of assets.\n\n**[T-Woodward (Notional) acknowledged and disagreed with severity](https://github.com/code-423n4/2021-08-notional-findings/issues/76#issuecomment-917435282):**\n > It is true that getPriorVotes returns an inaccurate value for the reason you have stated.\n>\n> In practice, this issue is not very severe though. Any meaningful attack would require an enormous amount of capital, and could only gain access to at most a relatively small number of votes.  The attack would be to provide liquidity at the moment a proposal is introduced, accrue incentives for the duration of the voting period, and then vote for them. So the maximum damage that could be done would assume that you have provided all liquidity on the platform (not gonna happen) for the entire voting period (5 days). Given that the highest annual emission rate for NOTE incentives is 20M, this would imply that the maximum amount of incentives earned in the five day period is 277,778 NOTE. This is .277% of the total NOTE supply. So the worst case is still not really a big deal.\n>\n> Claimable incentives can't be manipulated via flash loans.\n>\n> **Remediation:**\n> We'll remove the `getUnclaimedVotes` function. It is a vestige of an earlier design that we have since moved away from anyway, so there's no real impact on the system or reason not to remove it.\n\n**[ghoul-sol (judge) commented](https://github.com/code-423n4/2021-08-notional-findings/issues/76#issuecomment-922398001):**\n > per sponsor comment, the impact is indeed low\n\n# Non-Critical Findings (13)\n\n- [[N-01] proposal get defeated even if `forVotes == againstVotes` in `GovernorAlpha.sol`](https://github.com/code-423n4/2021-08-notional-findings/issues/35)\n- [[N-02] Erc20 Race condition](https://github.com/code-423n4/2021-08-notional-findings/issues/37)\n- [[N-03] Used a fixed or pragma that spans only a single `0.x.*`](https://github.com/code-423n4/2021-08-notional-findings/issues/90)\n- [[N-04] Lack of Zero Address Validation](https://github.com/code-423n4/2021-08-notional-findings/issues/93)\n- [[N-05] Use pragma abicoder v2](https://github.com/code-423n4/2021-08-notional-findings/issues/5)\n- [[N-06] lack of require message](https://github.com/code-423n4/2021-08-notional-findings/issues/50)\n- [[N-07] Replacing the assembly `extcodesize` checks for versions `>0.8.1`](https://github.com/code-423n4/2021-08-notional-findings/issues/91)\n- [[N-08] Check if address is a contract](https://github.com/code-423n4/2021-08-notional-findings/issues/47)\n- [[N-09] Total supply dependency on decimals](https://github.com/code-423n4/2021-08-notional-findings/issues/56)\n- [[N-10] unsafe cast from int to uint can lead to incentive abuse](https://github.com/code-423n4/2021-08-notional-findings/issues/8)\n- [[N-11] Use of `msg.value` in batch action](https://github.com/code-423n4/2021-08-notional-findings/issues/84)\n- [[N-12] Recommend adding a `nonReentrant` modifier to external functions](https://github.com/code-423n4/2021-08-notional-findings/issues/27)\n- [[N-13] `initialize()` function of `router.sol` can be reinitialize](https://github.com/code-423n4/2021-08-notional-findings/issues/42)\n\n# Gas Optimizations (8)\n\n- [[G-01] Gas optimization on `_INT256_MIN` ](https://github.com/code-423n4/2021-08-notional-findings/issues/9)\n- [[G-02] Upgrade to at least 0.8.4](https://github.com/code-423n4/2021-08-notional-findings/issues/87)\n- [[G-03] Caching length in for loops](https://github.com/code-423n4/2021-08-notional-findings/issues/88)\n- [[G-04] `StorageLayoutV1` Gas Optimisations](https://github.com/code-423n4/2021-08-notional-findings/issues/96)\n- [[G-05] Unused variables](https://github.com/code-423n4/2021-08-notional-findings/issues/52)\n- [[G-06] uint is always >= 0](https://github.com/code-423n4/2021-08-notional-findings/issues/53)\n- [[G-07] Cache values that are accessed more than once](https://github.com/code-423n4/2021-08-notional-findings/issues/54)\n- [[G-08] Gas optimization: Can put require and variable declaration inside the if statement.](https://github.com/code-423n4/2021-08-notional-findings/issues/13)\n\n# Disclosures\n\nC4 is an open organization governed by participants in the community.\n\nC4 Contests incentivize the discovery of exploits, vulnerabilities, and bugs in smart contracts. Security researchers are rewarded at an increasing rate for finding higher-risk issues. Contest submissions are judged by a knowledgeable security researcher and solidity developer and disclosed to sponsoring developers. C4 does not conduct formal verification regarding the provided code but instead provides final verification.\n\nC4 does not provide any guarantee or warranty regarding the security of this project. All smart contract software should be used at the sole risk and responsibility of users.\n"
}