{
  "circa": {
    "title": "Ambire Contest",
    "sponsor": "Ambire",
    "slug": "2021-10-ambire",
    "date": "2021-11-11",
    "findings": "https://github.com/code-423n4/2021-10-ambire-findings",
    "contest": 38
  },
  "html": "<h1 id=\"overview\" style=\"position:relative;\"><a href=\"#overview\" aria-label=\"overview permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Overview</h1>\n<h2 id=\"about-c4\" style=\"position:relative;\"><a href=\"#about-c4\" aria-label=\"about c4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>About C4</h2>\n<p>Code 423n4 (C4) is an open organization consisting of security researchers, auditors, developers, and individuals with domain expertise in smart contracts.</p>\n<p>A C4 code contest is an event in which community participants, referred to as Wardens, review, audit, or analyze smart contract logic in exchange for a bounty provided by sponsoring projects.</p>\n<p>During the code contest outlined in this document, C4 conducted an analysis of the Ambire smart contract system written in Solidity. The code contest took place between October 15—October 18 2021.</p>\n<h2 id=\"wardens\" style=\"position:relative;\"><a href=\"#wardens\" aria-label=\"wardens permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Wardens</h2>\n<p>11 Wardens contributed reports to the Ambire code contest:</p>\n<ol>\n<li><a href=\"https://twitter.com/cmichelio\">cmichel</a></li>\n<li><a href=\"https://twitter.com/gpersoon\">gpersoon</a></li>\n<li>\n<p>WatchPug</p>\n<ul>\n<li><a href=\"https://github.com/jack-the-pug\">jtp</a></li>\n<li><a href=\"https://github.com/mingwatch\">ming</a></li>\n</ul>\n</li>\n<li><a href=\"https://twitter.com/SolidityDev\">pauliax</a></li>\n<li><a href=\"https://twitter.com/PMerkleplant\">pmerkleplant</a></li>\n<li><a href=\"https://twitter.com/_ye0lde\">ye0lde</a></li>\n<li><a href=\"https://twitter.com/loop_225\">loop</a></li>\n<li><a href=\"https://twitter.com/MukeshJ_eth\">JMukesh</a></li>\n<li>cryptojedi88</li>\n<li><a href=\"https://twitter.com/defsec_\">defsec</a></li>\n</ol>\n<p>This contest was judged by <a href=\"https://twitter.com/GalloDaSballo\" title=\"judge\">AlexTheEntreprenerd</a>.</p>\n<p>Final report assembled by <a href=\"https://twitter.com/money_lego\">moneylegobatman</a> .</p>\n<h1 id=\"summary\" style=\"position:relative;\"><a href=\"#summary\" aria-label=\"summary permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Summary</h1>\n<p>The C4 analysis yielded an aggregated total of 10 unique vulnerabilities and 41 total findings.  All of the issues presented here are linked back to their original finding</p>\n<p>Of these vulnerabilities, 4 received a risk rating in the category of HIGH severity, 0 received a risk rating in the category of MEDIUM severity, and 6 received a risk rating in the category of LOW severity.</p>\n<p>C4 analysis also identified 10 non-critical recommendations and 21 gas optimizations.</p>\n<h1 id=\"scope\" style=\"position:relative;\"><a href=\"#scope\" aria-label=\"scope permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Scope</h1>\n<p>The code under review can be found within the <a href=\"https://github.com/code-423n4/2021-10-ambire\">C4 Ambire code contest repository</a> is composed of 8 smart contracts written in the Solidity programming language and includes 755 lines of Solidity code.</p>\n<h1 id=\"severity-criteria\" style=\"position:relative;\"><a href=\"#severity-criteria\" aria-label=\"severity criteria permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Severity Criteria</h1>\n<p>C4 assesses the severity of disclosed vulnerabilities according to a methodology based on <a href=\"https://owasp.org/www-community/OWASP_Risk_Rating_Methodology\">OWASP standards</a>.</p>\n<p>Vulnerabilities are divided into three primary risk categories: high, medium, and low.</p>\n<p>High-level considerations for vulnerabilities span the following key areas when conducting assessments:</p>\n<ul>\n<li>Malicious Input Handling</li>\n<li>Escalation of privileges</li>\n<li>Arithmetic</li>\n<li>Gas use</li>\n</ul>\n<p>Further information regarding the severity criteria referenced throughout the submission review process, please refer to the documentation provided on <a href=\"https://code423n4.com\">the C4 website</a>.</p>\n<h1 id=\"high-risk-findings-4\" style=\"position:relative;\"><a href=\"#high-risk-findings-4\" aria-label=\"high risk findings 4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>High Risk Findings (4)</h1>\n<h2 id=\"h-01-prevent-execution-with-invalid-signatures\" style=\"position:relative;\"><a href=\"#h-01-prevent-execution-with-invalid-signatures\" aria-label=\"h 01 prevent execution with invalid signatures permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/13\">[H-01] Prevent execution with invalid signatures</a></h2>\n<p><em>Submitted by gpersoon</em></p>\n<h4 id=\"impact\" style=\"position:relative;\"><a href=\"#impact\" aria-label=\"impact permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h4>\n<p>Suppose one of the supplied <code>addrs\\[i]</code> to the constructor of <code>Identity.sol</code> happens to be 0 ( by accident).</p>\n<p>In that case: <code>privileges\\[0] = 1</code></p>\n<p>Now suppose you call <code>execute()</code> with an invalid signature, then <code>recoverAddrImpl</code> will return a value of 0 and thus signer=0.\nIf you then check ”<code>privileges\\[signer] !=0</code>”  this will be true and anyone can perform any transaction.</p>\n<p>This is clearly an unwanted situation.</p>\n<h4 id=\"proof-of-concept\" style=\"position:relative;\"><a href=\"#proof-of-concept\" aria-label=\"proof of concept permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h4>\n<ul>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/Identity.sol#L23-L30\"><code>Identity.sol#L23</code> L30</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/Identity.sol#L97-L98\"><code>Identity.sol#L97</code> L98</a></li>\n</ul>\n<h4 id=\"recommended-mitigation-steps\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps\" aria-label=\"recommended mitigation steps permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h4>\n<p>In the constructor of <code>Identity.sol</code>, add in the for loop the following:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"0\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">require</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">addrs</span><span class=\"mtk1\">\\[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">] !=</span><span class=\"mtk7\">0</span><span class=\"mtk1\">,</span><span class=\"mtk8\">&quot;Zero not allowed&quot;</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p><strong><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/13#issuecomment-946844237\">Ivshti (Ambire) confirmed</a>:</strong></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/13#issuecomment-946894869\">Ivshti (Ambire) patched</a>:</strong></p>\n<blockquote>\n<p>resolved in <a href=\"https://github.com/AmbireTech/adex-protocol-eth/commit/08d050676773fcdf7ec1c4eb53d51820b7e42534\">https://github.com/AmbireTech/adex-protocol-eth/commit/08d050676773fcdf7ec1c4eb53d51820b7e42534</a></p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/13#issuecomment-948088151\">GalloDaSballo (judge) commented</a>:</strong></p>\n<blockquote>\n<p>This seems to be the risk of having <code>erecover</code> returning zero, any invalid signature ends up being usable from any address to execute arbitrary logic.</p>\n<p>Mitigation can be achieved by either reverting when about to return address(0), which the sponsor has used for mitigation</p>\n<p>The other mitigation is to ensure that an account with address(0) cannot have privileges set to 1</p>\n<p>I believe mitigation from sponsor to be sufficient, however I’d recommend adding a check against having address(0) in the constructor for Identity.sol just to be sure</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/13#issuecomment-948276331\">Ivshti (Ambire) commented</a>:</strong></p>\n<blockquote>\n<p>@GalloDeSballo an extra check is superfluous IMO, not only cause the revert on 0 in SIgnatureValidatorV2 guarantees that this is fixed, but also because it has to be in three places: constructor, setAddrPrivilege and the account creation system in <code>js/IdentityProxyDeploy</code> which rolls out bytecode that <code>sstores</code> privileges directly</p>\n</blockquote>\n<h2 id=\"h-02-quickaccmanagersolcancel-wrong-hashtx-makes-it-impossible-to-cancel-a-scheduled-transaction\" style=\"position:relative;\"><a href=\"#h-02-quickaccmanagersolcancel-wrong-hashtx-makes-it-impossible-to-cancel-a-scheduled-transaction\" aria-label=\"h 02 quickaccmanagersolcancel wrong hashtx makes it impossible to cancel a scheduled transaction permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/1\">[H-02] <code>QuickAccManager.sol#cancel()</code> Wrong <code>hashTx</code> makes it impossible to cancel a scheduled transaction</a></h2>\n<p><em>Submitted by WatchPug, also found by gpersoon</em></p>\n<p>In <code>QuickAccManager.sol#cancel()</code>, the <code>hashTx</code> to identify the transaction to be canceled is wrong. The last parameter is missing.</p>\n<p>As a result, users will be unable to cancel a scheduled transaction.</p>\n<p> <a href=\"https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/QuickAccManager.sol#L91-L91\"><code>QuickAccManager.sol#L91</code> L91</a></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"1\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">cancel</span><span class=\"mtk1\">(</span><span class=\"mtk12\">Identity</span><span class=\"mtk1\"> </span><span class=\"mtk12\">identity</span><span class=\"mtk1\">, </span><span class=\"mtk12\">QuickAccount</span><span class=\"mtk1\"> </span><span class=\"mtk12\">calldata</span><span class=\"mtk1\"> </span><span class=\"mtk12\">acc</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">nonce</span><span class=\"mtk1\">, </span><span class=\"mtk12\">bytes</span><span class=\"mtk1\"> </span><span class=\"mtk12\">calldata</span><span class=\"mtk1\"> </span><span class=\"mtk12\">sig</span><span class=\"mtk1\">, Identity.Transaction[] </span><span class=\"mtk12\">calldata</span><span class=\"mtk1\"> </span><span class=\"mtk12\">txns</span><span class=\"mtk1\">) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">bytes32</span><span class=\"mtk1\"> </span><span class=\"mtk12\">accHash</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">keccak256</span><span class=\"mtk1\">(</span><span class=\"mtk12\">abi</span><span class=\"mtk1\">.</span><span class=\"mtk11\">encode</span><span class=\"mtk1\">(</span><span class=\"mtk12\">acc</span><span class=\"mtk1\">));</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">identity</span><span class=\"mtk1\">.</span><span class=\"mtk11\">privileges</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">)) == </span><span class=\"mtk12\">accHash</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&#39;WRONG_ACC_OR_NO_PRIV&#39;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">bytes32</span><span class=\"mtk1\"> </span><span class=\"mtk12\">hash</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">keccak256</span><span class=\"mtk1\">(</span><span class=\"mtk12\">abi</span><span class=\"mtk1\">.</span><span class=\"mtk11\">encode</span><span class=\"mtk1\">(</span><span class=\"mtk12\">CANCEL_PREFIX</span><span class=\"mtk1\">, </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">), </span><span class=\"mtk12\">block</span><span class=\"mtk1\">.</span><span class=\"mtk12\">chainid</span><span class=\"mtk1\">, </span><span class=\"mtk12\">accHash</span><span class=\"mtk1\">, </span><span class=\"mtk12\">nonce</span><span class=\"mtk1\">, </span><span class=\"mtk12\">txns</span><span class=\"mtk1\">, </span><span class=\"mtk4\">false</span><span class=\"mtk1\">));</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">signer</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">SignatureValidator</span><span class=\"mtk1\">.</span><span class=\"mtk11\">recoverAddr</span><span class=\"mtk1\">(</span><span class=\"mtk12\">hash</span><span class=\"mtk1\">, </span><span class=\"mtk12\">sig</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">signer</span><span class=\"mtk1\"> == </span><span class=\"mtk12\">acc</span><span class=\"mtk1\">.</span><span class=\"mtk12\">one</span><span class=\"mtk1\"> || </span><span class=\"mtk12\">signer</span><span class=\"mtk1\"> == </span><span class=\"mtk12\">acc</span><span class=\"mtk1\">.</span><span class=\"mtk12\">two</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&#39;INVALID_SIGNATURE&#39;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk3\">// @NOTE: should we allow cancelling even when it&#39;s matured? probably not, otherwise there&#39;s a minor grief</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk3\">// opportunity: someone wants to cancel post-maturity, and you front them with execScheduled</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">bytes32</span><span class=\"mtk1\"> </span><span class=\"mtk12\">hashTx</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">keccak256</span><span class=\"mtk1\">(</span><span class=\"mtk12\">abi</span><span class=\"mtk1\">.</span><span class=\"mtk11\">encode</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">), </span><span class=\"mtk12\">block</span><span class=\"mtk1\">.</span><span class=\"mtk12\">chainid</span><span class=\"mtk1\">, </span><span class=\"mtk12\">accHash</span><span class=\"mtk1\">, </span><span class=\"mtk12\">nonce</span><span class=\"mtk1\">, </span><span class=\"mtk12\">txns</span><span class=\"mtk1\">));</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">scheduled</span><span class=\"mtk1\">[</span><span class=\"mtk12\">hashTx</span><span class=\"mtk1\">] != </span><span class=\"mtk7\">0</span><span class=\"mtk1\"> &amp;&amp; </span><span class=\"mtk12\">block</span><span class=\"mtk1\">.</span><span class=\"mtk12\">timestamp</span><span class=\"mtk1\"> &lt; </span><span class=\"mtk12\">scheduled</span><span class=\"mtk1\">[</span><span class=\"mtk12\">hashTx</span><span class=\"mtk1\">], </span><span class=\"mtk8\">&#39;TOO_LATE&#39;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk4\">delete</span><span class=\"mtk1\"> </span><span class=\"mtk12\">scheduled</span><span class=\"mtk1\">[</span><span class=\"mtk12\">hashTx</span><span class=\"mtk1\">];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">emit</span><span class=\"mtk1\"> </span><span class=\"mtk11\">LogCancelled</span><span class=\"mtk1\">(</span><span class=\"mtk12\">hashTx</span><span class=\"mtk1\">, </span><span class=\"mtk12\">accHash</span><span class=\"mtk1\">, </span><span class=\"mtk12\">signer</span><span class=\"mtk1\">, </span><span class=\"mtk12\">block</span><span class=\"mtk1\">.</span><span class=\"mtk12\">timestamp</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<h5 id=\"recommendation\" style=\"position:relative;\"><a href=\"#recommendation\" aria-label=\"recommendation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommendation</h5>\n<p>Change to:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"2\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">bytes32</span><span class=\"mtk1\"> </span><span class=\"mtk12\">hashTx</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">keccak256</span><span class=\"mtk1\">(</span><span class=\"mtk12\">abi</span><span class=\"mtk1\">.</span><span class=\"mtk11\">encode</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">), </span><span class=\"mtk12\">block</span><span class=\"mtk1\">.</span><span class=\"mtk12\">chainid</span><span class=\"mtk1\">, </span><span class=\"mtk12\">accHash</span><span class=\"mtk1\">, </span><span class=\"mtk12\">nonce</span><span class=\"mtk1\">, </span><span class=\"mtk12\">txns</span><span class=\"mtk1\">, </span><span class=\"mtk4\">false</span><span class=\"mtk1\">));</span></span></span></code></pre>\n<p><strong><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/1#issuecomment-946823825\">Ivshti (Ambire) confirmed and resolved</a>:</strong></p>\n<blockquote>\n<p>Great find, resolved in <a href=\"https://github.com/AmbireTech/adex-protocol-eth/commit/5c5e6f0cb47e83793dafc08630577b93500c86ab\">https://github.com/AmbireTech/adex-protocol-eth/commit/5c5e6f0cb47e83793dafc08630577b93500c86ab</a></p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/1#issuecomment-950416817\">GalloDaSballo (judge) commented</a>:</strong></p>\n<blockquote>\n<p>The warden has found that the method <code>cancel</code> was calculating the wrong <code>hashTx</code>, this hash, used to verify which transaction to cancel, making it impossible to cancel a transaction.</p>\n<p>The sponsor has mitigated in a  subsequent pr</p>\n</blockquote>\n<h2 id=\"h-03-signature-replay-attacks-for-different-identities-nonce-on-wrong-party\" style=\"position:relative;\"><a href=\"#h-03-signature-replay-attacks-for-different-identities-nonce-on-wrong-party\" aria-label=\"h 03 signature replay attacks for different identities nonce on wrong party permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/39\">[H-03] Signature replay attacks for different identities (nonce on wrong party)</a></h2>\n<p><em>Submitted by cmichel, also found by WatchPug</em></p>\n<p>A single <code>QuickAccount</code> can serve as the “privilege” for multiple identities, see the comment in <code>QuickAccManager.sol</code>:</p>\n<blockquote>\n<p>NOTE: a single accHash can control multiple identities, as long as those identities set it’s hash in privileges[address(this)]. this is by design</p>\n</blockquote>\n<p>If there exist two different identities that <em>both share the same QuickAccount</em> (<code>identity1.privileges(address(this)) == identity2.privileges(address(this)) == accHash</code>) the following attack is possible in <code>QuickAccManager.send</code>:</p>\n<p>Upon observing a valid <code>send</code> on the first identity, the same transactions can be replayed on the second identity by an attacker calling <code>send</code> with the same arguments and just changing the <code>identity</code> to the second identity.</p>\n<p>This is because the <code>identity</code> is not part of the <code>hash</code>. Including the <strong>nonce of</strong> the identity in the hash is not enough.</p>\n<p>Two fresh identities will both take on nonces on zero and lead to the same hash.</p>\n<h4 id=\"impact-1\" style=\"position:relative;\"><a href=\"#impact-1\" aria-label=\"impact 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h4>\n<p>Transactions on one identity can be replayed on another one if it uses the same <code>QuickAccount</code>.\nFor example, a transaction paying a contractor can be replayed by the contract on the second identity earning the payment twice.</p>\n<h4 id=\"recommended-mitigation-steps-1\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-1\" aria-label=\"recommended mitigation steps 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h4>\n<ol>\n<li>Nonces should not be indexed by the identity but by the <code>accHash</code>. This is because nonces are used to stop replay attacks and thus need to be on the <em>signer</em> (<code>QuickAccount</code> in this case), not on the target contract to call.</li>\n<li>The <code>identity</code> <em>address</em> itself needs to be part of <code>hash</code> as otherwise the <code>send</code> can be frontrun and executed by anyone on the other identity by switching out the <code>identity</code> parameter.</li>\n</ol>\n<h4 id=\"other-occurrences\" style=\"position:relative;\"><a href=\"#other-occurrences\" aria-label=\"other occurrences permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Other occurrences</h4>\n<p>This issue of using the wrong nonce (on the <code>identity</code> which means the nonces repeat per identity) and not including <code>identity</code> address leads to other attacks throughout the <code>QuickAccManager</code>:</p>\n<ul>\n<li><code>cancel</code>: attacker can use the same signature to cancel the same transactions on the second identity</li>\n<li><code>execScheduled</code>: can frontrun this call and execute it on the second identity instead. This will make the original transaction fail as <code>scheduled[hash]</code> is deleted.</li>\n<li><code>sendTransfer</code>: same transfers can be replayed on second identity</li>\n<li><code>sendTxns</code>: same transactions can be replayed on second identity</li>\n</ul>\n<p><strong><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/39#issuecomment-946825757\">Ivshti (Ambire) confirmed</a>:</strong></p>\n<blockquote>\n<p>duplicate of #24, but it’s better documented</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/39#issuecomment-946999413\">Ivshti (Ambire) patched</a>:</strong></p>\n<blockquote>\n<p>mitigation step 1 is not going to be done, since there’s already plenty of upper level code relying on indexing by identity, and it doesn’t really hurt if the replay attack is mitigated</p>\n<p>plus, it makes it harder to look up the nonce value, as we have to compute the accHash in the client-side code</p>\n<p>the replay attack has been fixed here <a href=\"https://github.com/AmbireTech/adex-protocol-eth/commit/f70ca38f368da30c9881d1ee5554fd0161c94486\">https://github.com/AmbireTech/adex-protocol-eth/commit/f70ca38f368da30c9881d1ee5554fd0161c94486</a></p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/39#issuecomment-950825823\">GalloDaSballo (judge) commented</a>:</strong></p>\n<blockquote>\n<p>The warden identified a Signature Replay attack, allowing to re-use a signature throughout the system.</p>\n<p>Requiring the identity to be part of the signatures mitigates the vulnerability</p>\n<p>The sponsor has mitigated in a subsequent PR</p>\n</blockquote>\n<h2 id=\"h-04-quickaccmanager-smart-contract-signature-verification-can-be-exploited\" style=\"position:relative;\"><a href=\"#h-04-quickaccmanager-smart-contract-signature-verification-can-be-exploited\" aria-label=\"h 04 quickaccmanager smart contract signature verification can be exploited permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/40\">[H-04] <code>QuickAccManager</code> Smart Contract signature verification can be exploited</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>Several different signature modes can be used and <code>Identity.execute</code> forwards the <code>signature</code> parameter to the <code>SignatureValidator</code> library.\nThe returned <code>signer</code> is then used for the <code>privileges</code> check:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"3\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">signer</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">SignatureValidator</span><span class=\"mtk1\">.</span><span class=\"mtk11\">recoverAddrImpl</span><span class=\"mtk1\">(</span><span class=\"mtk12\">hash</span><span class=\"mtk1\">, </span><span class=\"mtk12\">signature</span><span class=\"mtk1\">, </span><span class=\"mtk4\">true</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// signer will be QuickAccountContract</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">privileges</span><span class=\"mtk1\">[</span><span class=\"mtk12\">signer</span><span class=\"mtk1\">] != </span><span class=\"mtk11\">bytes32</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">), </span><span class=\"mtk8\">&#39;INSUFFICIENT_PRIVILEGE&#39;</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p>It’s possible to create a smart contract mode signature (<code>SignatureMode.SmartWallet</code>) for arbitrary transactions as the <code>QuickAccManager.isValidSignature</code> uses an attacker-controlled <code>id</code> identity contract for the privileges check.\nAn attacker can just create an attacker contract returning the desired values and the smart-wallet signature appears to be valid:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"4\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// @audit id is attacker-controlled</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">payable</span><span class=\"mtk1\"> </span><span class=\"mtk12\">id</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">timelock</span><span class=\"mtk1\">, </span><span class=\"mtk12\">bytes</span><span class=\"mtk1\"> </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">sig1</span><span class=\"mtk1\">, </span><span class=\"mtk12\">bytes</span><span class=\"mtk1\"> </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">sig2</span><span class=\"mtk1\">) = </span><span class=\"mtk12\">abi</span><span class=\"mtk1\">.</span><span class=\"mtk11\">decode</span><span class=\"mtk1\">(</span><span class=\"mtk12\">signature</span><span class=\"mtk1\">, (</span><span class=\"mtk12\">address</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint</span><span class=\"mtk1\">, </span><span class=\"mtk12\">bytes</span><span class=\"mtk1\">, </span><span class=\"mtk12\">bytes</span><span class=\"mtk1\">));</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// @audit this may not be used for authorization, attacker can return desired value</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk11\">Identity</span><span class=\"mtk1\">(</span><span class=\"mtk12\">id</span><span class=\"mtk1\">).</span><span class=\"mtk11\">privileges</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">)) == </span><span class=\"mtk12\">accHash</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk3\">// bytes4(keccak256(&quot;isValidSignature(bytes32,bytes)&quot;)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk7\">0x1626ba7e</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">} </span><span class=\"mtk15\">else</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk7\">0xffffffff</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<h4 id=\"poc\" style=\"position:relative;\"><a href=\"#poc\" aria-label=\"poc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>POC</h4>\n<p>Assume an <code>Identity</code> contract is set up with a <code>QuickAccManager</code> as the <code>privileges</code> account, i.e. <code>privileges[accHash] != 0</code>.</p>\n<p>We can construct a <code>SignatureMode.SmartWallet</code> signature for an <em>arbitrary</em> hash:</p>\n<ol>\n<li>Call <code>Identity.execute(txns, spoofedSignature)</code> where <code>spoofedSignature = abi.encode(attackerContract, timelock=0, sig1=0, sig2=0, address(quickAccountManager), SignatureMode.SmartWallet)</code></li>\n<li>This will call <code>recoverAddrImpl(txnsHash, spoofedSignature, true)</code>, decode the bytes <strong>at the end</strong> of <code>spoofedSignature</code> and determine <code>mode = SignatureMode.SmartWallet</code> and <code>wallet = quickAccountManager</code>. It will cut off these arguments and call <code>quickAccountManager.isValidSignature(txnsHash, (attackerContract, 0, 0, 0))</code></li>\n<li>The <code>QuickAccManager</code> will decode the signature, construct <code>accHash</code> which is the hash of all zeroes (due to failed signatures returning 0). It will then call <code>attacker.privileges(address(this))</code> and the attacker contract can return the <code>accHash</code> that matches an account hash of failed signatures, i.e., <code>keccak256(abi.encode(QuickAccount(0,0,0)))</code>. The comparison is satisfied and it returns the success value.</li>\n<li>The checks in <code>Identity.execute</code> pass and the transactions <code>txns</code> are executed.</li>\n</ol>\n<h4 id=\"impact-2\" style=\"position:relative;\"><a href=\"#impact-2\" aria-label=\"impact 2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h4>\n<p>Any <code>Identity</code> contract using <code>QuickAccManager</code> can be exploited.\nFunds can then be stolen from the wallet.</p>\n<h4 id=\"recommendation-1\" style=\"position:relative;\"><a href=\"#recommendation-1\" aria-label=\"recommendation 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommendation</h4>\n<p>The issue is that <code>QuickAccManager</code> blindly trusts the values in <code>signature</code>.\nIt might be enough to remove the <code>id</code> from the <code>signature</code> and use <code>msg.sender</code> as the identity instead: <code>Identity(msg.sender).privileges(address(this)) == accHash</code>.\nThis seems to work with the current <code>Identity</code> implementation but might not work if this is extended and the <code>isValidSignature</code> is called from another contract and wants to verify a signature on a different identity.\nIn that case, the <code>Identity/SignatureValidator</code> may not blindly forward the attacker-supplied signature and instead needs to re-encode the parameters with trusted values before calling <code>QuickAccManager</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/40#issuecomment-946828671\">Ivshti (Ambire) confirmed and patched</a>:</strong></p>\n<blockquote>\n<p>great find! Mitigated in <a href=\"https://github.com/AmbireTech/adex-protocol-eth/commit/17c073d037ded76d56d6145faa92c1959fd47226\">https://github.com/AmbireTech/adex-protocol-eth/commit/17c073d037ded76d56d6145faa92c1959fd47226</a> but still figuring out whether this is the best way to do it</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/40#issuecomment-950840624\">GalloDaSballo (judge) commented</a>:</strong></p>\n<blockquote>\n<p>May need to sit on this one for another day before I can fully comment</p>\n<p>Fundamentally by calling Identity.execute with mostly 0 data, you are able to call back to <code>QuickAccManager. isValidSignature</code> which, due to the implementation of <code>ecrecover</code> at the time, will return valid checks for address(0), allowing to bypass all the logic and returning true for the signature, allowing for the execution of arbitrary code.</p>\n<p>Again, need to sit on this one</p>\n<p>But wouldn’t you also be able to set a malicious smartContractWallet as the <code>IERC1271Wallet</code>, hence you can sidestep the entire logic, as your malicious contract wallet can be programmed to always return true on any input value?</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/40#issuecomment-950849976\">Ivshti (Ambire) commented</a>:</strong></p>\n<blockquote>\n<p>@GalloDaSballo (judge) this doesn’t have to do with <code>address(0)</code></p>\n<p>Using smart wallets for signatures by itself is not a problem - since they authorize as themselves.</p>\n<p>The fundamental root of this issue is that ERC 1271 was designed with the assumption that 1 contract = 1 wallet. And as such, <code>isValidSignature</code> only returns <code>true</code>/<code>false</code>. This makes sense, as essentially we’re asking the wallet “is this a valid signature from you”, and then the wallet decides how to actually validate this it depending on it’s own behavior and permissions.</p>\n<p>However, the QuickAccManager is a singleton contract - one single QuickAccManager represents multiple users. As such, combining it with ERC 1271 is a logical misunderstanding, as we can’t really ask it “is this a valid sig for X identity” through the ERC 1271 interface. So instead, we encode the identity that we’re signing as in the sig itself, but then a malicious user could call a top-level identity with a sig that validates in the singleton <code>QuickAccManager</code>, but meant to validate with a differerent identity.</p>\n<p>Because what we pass to <code>isValidSignature</code> is opaque data (the smart wallet may be any contract with any logic, not just our <code>QuickAccManager</code>) we can’t just peak into the sig and see if it’s meant to validate with the caller identity.</p>\n<p>Excellent finding IMO</p>\n<p>The current mitigation is hacky, and essentially leads to an <code>isValidSignature</code> implementation that is unusable (and doesn’t make sense) off-chain, but we prefer it to introducing a new sig type especially for QuickAccManager.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/40#issuecomment-950870846\">GalloDaSballo (judge) commented</a>:</strong></p>\n<blockquote>\n<p>@Ivshti (Ambire) To clarify:\nWould adding <code>privileges[QuickAccountManager] = bytes32(uint(1))</code>enable the exploit?</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/40#issuecomment-950871925\">Ivshti (Ambire) commented</a>:</strong></p>\n<blockquote>\n<p>@GalloDaSballo (judge) yes, it would. Any authorized quickAcc would enable the exploit</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/40#issuecomment-950906951\">GalloDaSballo (judge) commented</a>:</strong></p>\n<blockquote>\n<p>I’m starting to get this</p>\n<p>The <code>id</code> sent to <code>isValidSignature</code> is an untrusted, unverified address\nThe contract at that address can be programmed to have a function <code>privileges</code> which would return any <code>bytes32</code> value to match <code>accHash</code>\nThis effectively allows to run arbitrary transactions.</p>\n<p>A way to mitigate would be to have a way to ensure the called <code>id</code> is trusted\nA registry of trusted ids may be effective</p>\n<p>The mitigation the sponsor has chosen does solve for only using trusted Identities as in the case of a malicious Identity, the Identity would just validate it’s own transaction, not putting other Identities funds at risk.</p>\n<p>An alternative solution would be to change the<code>IdentityFactory</code> to use the OpenZeppelin Clones Library (or similar) to ensure that the correct Logic is deployed (by deploying a minimal-proxy pointing to the trusted implementation).\nThis would require a fair tech-lift and would limit the type of deployments that the IdentityFactory can perform.</p>\n<p>The exploit was severe and the sponsor has mitigated by checking the <code>msg.sender</code> against the <code>id</code> provided in the signature</p>\n</blockquote>\n<h1 id=\"low-risk-findings-6\" style=\"position:relative;\"><a href=\"#low-risk-findings-6\" aria-label=\"low risk findings 6 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Low Risk Findings (6)</h1>\n<ul>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/56\">[L-01] <code>ecrecover</code> may return empty address</a>\n<em>Submitted by pauliax</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/55\">[L-02] <code>block.chainid</code> may change in case of a hardfork</a>\n<em>Submitted by pauliax</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/54\">[L-03] Hardcoded WETH</a>\n<em>Submitted by pauliax</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/32\">[L-04] <code>Zapper</code> should <code>safeApprove(0)</code> first</a>\n<em>Submitted by cmichel</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/37\">[L-05] If zero address is added as privilege anyone can execute arbitrary transactions</a>\n<em>Submitted by cmichel, also found by pmerkleplant</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/3\">[L-06] Address with privilege for <code>QuickAccount</code> with <code>address(0)</code>’s can execute arbitrary transactions</a>\n<em>Submitted by pmerkleplant</em></li>\n</ul>\n<h1 id=\"non-critical-findings-10\" style=\"position:relative;\"><a href=\"#non-critical-findings-10\" aria-label=\"non critical findings 10 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Non-Critical Findings (10)</h1>\n<ul>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/67\">[N-01] create2 assembly</a>\n<em>Submitted by pauliax</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/66\">[N-02] Hex selector</a>\n<em>Submitted by pauliax</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/11\">[N-03] Some code is commented out</a>\n<em>Submitted by loop</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/45\">[N-04] Inconsistent code style of for loops</a>\n<em>Submitted by WatchPug</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/53\">[N-05] lack of require message</a>\n<em>Submitted by JMukesh</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/51\">[N-06] use of floating pragma</a>\n<em>Submitted by JMukesh</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/38\">[N-07] No check for signature malleability</a>\n<em>Submitted by cmichel</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/36\">[N-08] <code>Identity</code> fallback returns too many bytes</a>\n<em>Submitted by cmichel</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/35\">[N-09] No ERC20 safe* versions called &#x26; no return values checked</a>\n<em>Submitted by cmichel, also found by JMukesh, loop, cryptojedi88, defsec, and loop</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/33\">[N-10] <code>Zapper</code> only works for whitelisted tokens</a>\n<em>Submitted by cmichel</em></li>\n</ul>\n<h1 id=\"gas-optimizations-21\" style=\"position:relative;\"><a href=\"#gas-optimizations-21\" aria-label=\"gas optimizations 21 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Gas Optimizations (21)</h1>\n<ul>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/31\">[G-01] <code>QuickAccManager.sol</code> Constants should be marked as <code>constant</code></a>\n<em>Submitted by WatchPug, also found by JMukesh</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/25\">[G-02] <code>QuickAccManager.sol#send()</code> Avoid unnecessary read from storage can save gas</a>\n<em>Submitted by WatchPug</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/26\">[G-03] Cache array length in for loops can save gas</a>\n<em>Submitted by WatchPug</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/27\">[G-04] <code>Zapper.sol#wrapETH()</code> Use <code>WETH.deposit</code> can save some gas</a>\n<em>Submitted by WatchPug, also found by cryptojedi88</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/28\">[G-05] <code>Zapper.sol#tradeV3Single()</code> Remove unnecessary variable can make the code simpler and save gas</a>\n<em>Submitted by WatchPug</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/29\">[G-06] Unnecessary storage variables</a>\n<em>Submitted by WatchPug, also found by pauliax and pmerkleplant</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/30\">[G-07] Cache storage variables in the stack can save gas</a>\n<em>Submitted by WatchPug, also found by pauliax</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/46\">[G-08] Adding unchecked directive can save gas</a>\n<em>Submitted by WatchPug, also found by pauliax and ye0lde</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/41\">[G-09] Gas: <code>BytesLib</code> addition can be unchecked</a>\n<em>Submitted by cmichel</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/42\">[G-10] Gas: <code>SignatureValidatorV2.recoverAddrImpl</code> should use <code>else if</code></a>\n<em>Submitted by cmichel</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/14\">[G-11] Safe some gas on the nonce increment</a>\n<em>Submitted by gpersoon</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/15\">[G-12] Compare with 0 and 1 in a more efficient way</a>\n<em>Submitted by gpersoon</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/10\">[G-13] IdentityFactory.withdraw can be external</a>\n<em>Submitted by loop</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/57\">[G-14] Duplicate math operations</a>\n<em>Submitted by pauliax</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/58\">[G-15] LibBytes uses itself</a>\n<em>Submitted by pauliax</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/65\">[G-16] Only prepare tx when the fee is present</a>\n<em>Submitted by pauliax</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/4\">[G-17] Set <code>QuickAccManager::DOMAIN_SEPARATOR</code> as immutable</a>\n<em>Submitted by pmerkleplant</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/6\">[G-18] Set <code>IdentityFactory::creator</code> as immutable</a>\n<em>Submitted by pmerkleplant</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/7\">[G-19] Set <code>QuickAccManager::CANCEL_PREFIX</code> as constant</a>\n<em>Submitted by pmerkleplant</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/16\">[G-20] Long Revert Strings</a>\n<em>Submitted by ye0lde</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-10-ambire-findings/issues/17\">[G-21] Assignment Of Variable To Default (<code>Identity.sol</code>)</a>\n<em>Submitted by ye0lde</em></li>\n</ul>\n<h1 id=\"disclosures\" style=\"position:relative;\"><a href=\"#disclosures\" aria-label=\"disclosures permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Disclosures</h1>\n<p>C4 is an open organization governed by participants in the community.</p>\n<p>C4 Contests incentivize the discovery of exploits, vulnerabilities, and bugs in smart contracts. Security researchers are rewarded at an increasing rate for finding higher-risk issues. Contest submissions are judged by a knowledgeable security researcher and solidity developer and disclosed to sponsoring developers. C4 does not conduct formal verification regarding the provided code but instead provides final verification.</p>\n<p>C4 does not provide any guarantee or warranty regarding the security of this project. All smart contract software should be used at the sole risk and responsibility of users.</p>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n  .dark-default-dark {\n    background-color: #1E1E1E;\n    color: #D4D4D4;\n  }\n  .dark-default-dark .mtk11 { color: #DCDCAA; }\n  .dark-default-dark .mtk1 { color: #D4D4D4; }\n  .dark-default-dark .mtk12 { color: #9CDCFE; }\n  .dark-default-dark .mtk7 { color: #B5CEA8; }\n  .dark-default-dark .mtk8 { color: #CE9178; }\n  .dark-default-dark .mtk4 { color: #569CD6; }\n  .dark-default-dark .mtk3 { color: #6A9955; }\n  .dark-default-dark .mtk15 { color: #C586C0; }\n  .dark-default-dark .grvsc-line-highlighted::before {\n    background-color: var(--grvsc-line-highlighted-background-color, rgba(255, 255, 255, 0.1));\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(255, 255, 255, 0.5));\n  }\n</style>",
  "toc": "<ul>\n<li>\n<p><a href=\"#overview\">Overview</a></p>\n<ul>\n<li><a href=\"#about-c4\">About C4</a></li>\n<li><a href=\"#wardens\">Wardens</a></li>\n</ul>\n</li>\n<li><a href=\"#summary\">Summary</a></li>\n<li><a href=\"#scope\">Scope</a></li>\n<li><a href=\"#severity-criteria\">Severity Criteria</a></li>\n<li>\n<p><a href=\"#high-risk-findings-4\">High Risk Findings (4)</a></p>\n<ul>\n<li><a href=\"#h-01-prevent-execution-with-invalid-signatures\">[H-01] Prevent execution with invalid signatures</a></li>\n<li><a href=\"#h-02-quickaccmanagersolcancel-wrong-hashtx-makes-it-impossible-to-cancel-a-scheduled-transaction\">[H-02] <code>QuickAccManager.sol#cancel()</code> Wrong <code>hashTx</code> makes it impossible to cancel a scheduled transaction</a></li>\n<li><a href=\"#h-03-signature-replay-attacks-for-different-identities-nonce-on-wrong-party\">[H-03] Signature replay attacks for different identities (nonce on wrong party)</a></li>\n<li><a href=\"#h-04-quickaccmanager-smart-contract-signature-verification-can-be-exploited\">[H-04] <code>QuickAccManager</code> Smart Contract signature verification can be exploited</a></li>\n</ul>\n</li>\n<li><a href=\"#low-risk-findings-6\">Low Risk Findings (6)</a></li>\n<li><a href=\"#non-critical-findings-10\">Non-Critical Findings (10)</a></li>\n<li><a href=\"#gas-optimizations-21\">Gas Optimizations (21)</a></li>\n<li><a href=\"#disclosures\">Disclosures</a></li>\n</ul>",
  "md": "\n# Overview\n\n## About C4\n\nCode 423n4 (C4) is an open organization consisting of security researchers, auditors, developers, and individuals with domain expertise in smart contracts.\n\nA C4 code contest is an event in which community participants, referred to as Wardens, review, audit, or analyze smart contract logic in exchange for a bounty provided by sponsoring projects.\n\nDuring the code contest outlined in this document, C4 conducted an analysis of the Ambire smart contract system written in Solidity. The code contest took place between October 15—October 18 2021.\n\n## Wardens\n\n11 Wardens contributed reports to the Ambire code contest:\n\n1. [cmichel](https://twitter.com/cmichelio)\n2. [gpersoon](https://twitter.com/gpersoon)\n3. WatchPug\n   - [jtp](https://github.com/jack-the-pug)\n   - [ming](https://github.com/mingwatch)\n4. [pauliax](https://twitter.com/SolidityDev)\n5. [pmerkleplant](https://twitter.com/PMerkleplant)\n6. [ye0lde](https://twitter.com/_ye0lde)\n7. [loop](https://twitter.com/loop_225)\n8. [JMukesh](https://twitter.com/MukeshJ_eth)\n9.  cryptojedi88\n10. [defsec](https://twitter.com/defsec_)\n\nThis contest was judged by [AlexTheEntreprenerd](https://twitter.com/GalloDaSballo (judge)).\n\nFinal report assembled by [moneylegobatman](https://twitter.com/money_lego) .\n\n# Summary\n\nThe C4 analysis yielded an aggregated total of 10 unique vulnerabilities and 41 total findings.  All of the issues presented here are linked back to their original finding\n\nOf these vulnerabilities, 4 received a risk rating in the category of HIGH severity, 0 received a risk rating in the category of MEDIUM severity, and 6 received a risk rating in the category of LOW severity.\n\nC4 analysis also identified 10 non-critical recommendations and 21 gas optimizations.\n\n# Scope\n\nThe code under review can be found within the [C4 Ambire code contest repository](https://github.com/code-423n4/2021-10-ambire) is composed of 8 smart contracts written in the Solidity programming language and includes 755 lines of Solidity code.\n\n# Severity Criteria\n\nC4 assesses the severity of disclosed vulnerabilities according to a methodology based on [OWASP standards](https://owasp.org/www-community/OWASP_Risk_Rating_Methodology).\n\nVulnerabilities are divided into three primary risk categories: high, medium, and low.\n\nHigh-level considerations for vulnerabilities span the following key areas when conducting assessments:\n\n- Malicious Input Handling\n- Escalation of privileges\n- Arithmetic\n- Gas use\n\nFurther information regarding the severity criteria referenced throughout the submission review process, please refer to the documentation provided on [the C4 website](https://code423n4.com).\n\n# High Risk Findings (4)\n\n## [[H-01] Prevent execution with invalid signatures](https://github.com/code-423n4/2021-10-ambire-findings/issues/13)\n_Submitted by gpersoon_\n\n#### Impact\nSuppose one of the supplied `addrs\\[i]` to the constructor of `Identity.sol` happens to be 0 ( by accident).\n\nIn that case: `privileges\\[0] = 1`\n\nNow suppose you call `execute()` with an invalid signature, then `recoverAddrImpl` will return a value of 0 and thus signer=0.\nIf you then check \"`privileges\\[signer] !=0`\"  this will be true and anyone can perform any transaction.\n\nThis is clearly an unwanted situation.\n\n#### Proof of Concept\n  - [`Identity.sol#L23` L30](https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/Identity.sol#L23-L30)\n  - [`Identity.sol#L97` L98](https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/Identity.sol#L97-L98)\n\n#### Recommended Mitigation Steps\nIn the constructor of `Identity.sol`, add in the for loop the following:\n\n```solidity\nrequire (addrs\\[i] !=0,\"Zero not allowed\");\n```\n\n**[Ivshti (Ambire) confirmed](https://github.com/code-423n4/2021-10-ambire-findings/issues/13#issuecomment-946844237):**\n\n**[Ivshti (Ambire) patched](https://github.com/code-423n4/2021-10-ambire-findings/issues/13#issuecomment-946894869):**\n > resolved in https://github.com/AmbireTech/adex-protocol-eth/commit/08d050676773fcdf7ec1c4eb53d51820b7e42534\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-10-ambire-findings/issues/13#issuecomment-948088151):**\n > This seems to be the risk of having `erecover` returning zero, any invalid signature ends up being usable from any address to execute arbitrary logic.\n>\n> Mitigation can be achieved by either reverting when about to return address(0), which the sponsor has used for mitigation\n>\n> The other mitigation is to ensure that an account with address(0) cannot have privileges set to 1\n>\n> I believe mitigation from sponsor to be sufficient, however I'd recommend adding a check against having address(0) in the constructor for Identity.sol just to be sure\n>\n\n**[Ivshti (Ambire) commented](https://github.com/code-423n4/2021-10-ambire-findings/issues/13#issuecomment-948276331):**\n > @GalloDeSballo an extra check is superfluous IMO, not only cause the revert on 0 in SIgnatureValidatorV2 guarantees that this is fixed, but also because it has to be in three places: constructor, setAddrPrivilege and the account creation system in `js/IdentityProxyDeploy` which rolls out bytecode that `sstores` privileges directly\n\n## [[H-02] `QuickAccManager.sol#cancel()` Wrong `hashTx` makes it impossible to cancel a scheduled transaction](https://github.com/code-423n4/2021-10-ambire-findings/issues/1)\n_Submitted by WatchPug, also found by gpersoon_\n\nIn `QuickAccManager.sol#cancel()`, the `hashTx` to identify the transaction to be canceled is wrong. The last parameter is missing.\n\nAs a result, users will be unable to cancel a scheduled transaction.\n\n [`QuickAccManager.sol#L91` L91](https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/QuickAccManager.sol#L91-L91)\n```solidity\nfunction cancel(Identity identity, QuickAccount calldata acc, uint nonce, bytes calldata sig, Identity.Transaction[] calldata txns) external {\n  bytes32 accHash = keccak256(abi.encode(acc));\n  require(identity.privileges(address(this)) == accHash, 'WRONG_ACC_OR_NO_PRIV');\n\n  bytes32 hash = keccak256(abi.encode(CANCEL_PREFIX, address(this), block.chainid, accHash, nonce, txns, false));\n  address signer = SignatureValidator.recoverAddr(hash, sig);\n  require(signer == acc.one || signer == acc.two, 'INVALID_SIGNATURE');\n\n  // @NOTE: should we allow cancelling even when it's matured? probably not, otherwise there's a minor grief\n  // opportunity: someone wants to cancel post-maturity, and you front them with execScheduled\n  bytes32 hashTx = keccak256(abi.encode(address(this), block.chainid, accHash, nonce, txns));\n  require(scheduled[hashTx] != 0 && block.timestamp < scheduled[hashTx], 'TOO_LATE');\n  delete scheduled[hashTx];\n\n  emit LogCancelled(hashTx, accHash, signer, block.timestamp);\n}\n```\n\n##### Recommendation\nChange to:\n\n```solidity\nbytes32 hashTx = keccak256(abi.encode(address(this), block.chainid, accHash, nonce, txns, false));\n```\n\n**[Ivshti (Ambire) confirmed and resolved](https://github.com/code-423n4/2021-10-ambire-findings/issues/1#issuecomment-946823825):**\n > Great find, resolved in https://github.com/AmbireTech/adex-protocol-eth/commit/5c5e6f0cb47e83793dafc08630577b93500c86ab\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-10-ambire-findings/issues/1#issuecomment-950416817):**\n > The warden has found that the method `cancel` was calculating the wrong `hashTx`, this hash, used to verify which transaction to cancel, making it impossible to cancel a transaction.\n>\n> The sponsor has mitigated in a  subsequent pr\n\n## [[H-03] Signature replay attacks for different identities (nonce on wrong party)](https://github.com/code-423n4/2021-10-ambire-findings/issues/39)\n_Submitted by cmichel, also found by WatchPug_\n\nA single `QuickAccount` can serve as the \"privilege\" for multiple identities, see the comment in `QuickAccManager.sol`:\n\n> NOTE: a single accHash can control multiple identities, as long as those identities set it's hash in privileges\\[address(this)]. this is by design\n\nIf there exist two different identities that *both share the same QuickAccount* (`identity1.privileges(address(this)) == identity2.privileges(address(this)) == accHash`) the following attack is possible in `QuickAccManager.send`:\n\nUpon observing a valid `send` on the first identity, the same transactions can be replayed on the second identity by an attacker calling `send` with the same arguments and just changing the `identity` to the second identity.\n\nThis is because the `identity` is not part of the `hash`. Including the **nonce of** the identity in the hash is not enough.\n\nTwo fresh identities will both take on nonces on zero and lead to the same hash.\n\n#### Impact\nTransactions on one identity can be replayed on another one if it uses the same `QuickAccount`.\nFor example, a transaction paying a contractor can be replayed by the contract on the second identity earning the payment twice.\n\n#### Recommended Mitigation Steps\n\n1.  Nonces should not be indexed by the identity but by the `accHash`. This is because nonces are used to stop replay attacks and thus need to be on the *signer* (`QuickAccount` in this case), not on the target contract to call.\n2.  The `identity` *address* itself needs to be part of `hash` as otherwise the `send` can be frontrun and executed by anyone on the other identity by switching out the `identity` parameter.\n\n#### Other occurrences\nThis issue of using the wrong nonce (on the `identity` which means the nonces repeat per identity) and not including `identity` address leads to other attacks throughout the `QuickAccManager`:\n\n*   `cancel`: attacker can use the same signature to cancel the same transactions on the second identity\n*   `execScheduled`: can frontrun this call and execute it on the second identity instead. This will make the original transaction fail as `scheduled[hash]` is deleted.\n*   `sendTransfer`: same transfers can be replayed on second identity\n*   `sendTxns`: same transactions can be replayed on second identity\n\n\n**[Ivshti (Ambire) confirmed](https://github.com/code-423n4/2021-10-ambire-findings/issues/39#issuecomment-946825757):**\n > duplicate of #24, but it's better documented\n\n**[Ivshti (Ambire) patched](https://github.com/code-423n4/2021-10-ambire-findings/issues/39#issuecomment-946999413):**\n > mitigation step 1 is not going to be done, since there's already plenty of upper level code relying on indexing by identity, and it doesn't really hurt if the replay attack is mitigated\n>\n> plus, it makes it harder to look up the nonce value, as we have to compute the accHash in the client-side code\n>\n> the replay attack has been fixed here https://github.com/AmbireTech/adex-protocol-eth/commit/f70ca38f368da30c9881d1ee5554fd0161c94486\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-10-ambire-findings/issues/39#issuecomment-950825823):**\n > The warden identified a Signature Replay attack, allowing to re-use a signature throughout the system.\n>\n> Requiring the identity to be part of the signatures mitigates the vulnerability\n>\n> The sponsor has mitigated in a subsequent PR\n\n## [[H-04] `QuickAccManager` Smart Contract signature verification can be exploited](https://github.com/code-423n4/2021-10-ambire-findings/issues/40)\n_Submitted by cmichel_\n\nSeveral different signature modes can be used and `Identity.execute` forwards the `signature` parameter to the `SignatureValidator` library.\nThe returned `signer` is then used for the `privileges` check:\n\n```solidity\naddress signer = SignatureValidator.recoverAddrImpl(hash, signature, true);\n// signer will be QuickAccountContract\nrequire(privileges[signer] != bytes32(0), 'INSUFFICIENT_PRIVILEGE');\n```\n\nIt's possible to create a smart contract mode signature (`SignatureMode.SmartWallet`) for arbitrary transactions as the `QuickAccManager.isValidSignature` uses an attacker-controlled `id` identity contract for the privileges check.\nAn attacker can just create an attacker contract returning the desired values and the smart-wallet signature appears to be valid:\n\n```solidity\n// @audit id is attacker-controlled\n(address payable id, uint timelock, bytes memory sig1, bytes memory sig2) = abi.decode(signature, (address, uint, bytes, bytes));\n// @audit this may not be used for authorization, attacker can return desired value\nif (Identity(id).privileges(address(this)) == accHash) {\n  // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\n  return 0x1626ba7e;\n} else {\n  return 0xffffffff;\n}\n```\n\n#### POC\nAssume an `Identity` contract is set up with a `QuickAccManager` as the `privileges` account, i.e. `privileges[accHash] != 0`.\n\nWe can construct a `SignatureMode.SmartWallet` signature for an *arbitrary* hash:\n\n1.  Call `Identity.execute(txns, spoofedSignature)` where `spoofedSignature = abi.encode(attackerContract, timelock=0, sig1=0, sig2=0, address(quickAccountManager), SignatureMode.SmartWallet)`\n2.  This will call `recoverAddrImpl(txnsHash, spoofedSignature, true)`, decode the bytes **at the end** of `spoofedSignature` and determine `mode = SignatureMode.SmartWallet` and `wallet = quickAccountManager`. It will cut off these arguments and call `quickAccountManager.isValidSignature(txnsHash, (attackerContract, 0, 0, 0))`\n3.  The `QuickAccManager` will decode the signature, construct `accHash` which is the hash of all zeroes (due to failed signatures returning 0). It will then call `attacker.privileges(address(this))` and the attacker contract can return the `accHash` that matches an account hash of failed signatures, i.e., `keccak256(abi.encode(QuickAccount(0,0,0)))`. The comparison is satisfied and it returns the success value.\n4.  The checks in `Identity.execute` pass and the transactions `txns` are executed.\n\n#### Impact\nAny `Identity` contract using `QuickAccManager` can be exploited.\nFunds can then be stolen from the wallet.\n\n#### Recommendation\nThe issue is that `QuickAccManager` blindly trusts the values in `signature`.\nIt might be enough to remove the `id` from the `signature` and use `msg.sender` as the identity instead: `Identity(msg.sender).privileges(address(this)) == accHash`.\nThis seems to work with the current `Identity` implementation but might not work if this is extended and the `isValidSignature` is called from another contract and wants to verify a signature on a different identity.\nIn that case, the `Identity/SignatureValidator` may not blindly forward the attacker-supplied signature and instead needs to re-encode the parameters with trusted values before calling `QuickAccManager`.\n\n**[Ivshti (Ambire) confirmed and patched](https://github.com/code-423n4/2021-10-ambire-findings/issues/40#issuecomment-946828671):**\n > great find! Mitigated in https://github.com/AmbireTech/adex-protocol-eth/commit/17c073d037ded76d56d6145faa92c1959fd47226 but still figuring out whether this is the best way to do it\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-10-ambire-findings/issues/40#issuecomment-950840624):**\n > May need to sit on this one for another day before I can fully comment\n>\n> Fundamentally by calling Identity.execute with mostly 0 data, you are able to call back to `QuickAccManager. isValidSignature` which, due to the implementation of `ecrecover` at the time, will return valid checks for address(0), allowing to bypass all the logic and returning true for the signature, allowing for the execution of arbitrary code.\n>\n> Again, need to sit on this one\n>\n> But wouldn't you also be able to set a malicious smartContractWallet as the `IERC1271Wallet`, hence you can sidestep the entire logic, as your malicious contract wallet can be programmed to always return true on any input value?\n\n**[Ivshti (Ambire) commented](https://github.com/code-423n4/2021-10-ambire-findings/issues/40#issuecomment-950849976):**\n > @GalloDaSballo (judge) this doesn't have to do with `address(0)`\n>\n> Using smart wallets for signatures by itself is not a problem - since they authorize as themselves.\n>\n> The fundamental root of this issue is that ERC 1271 was designed with the assumption that 1 contract = 1 wallet. And as such, `isValidSignature` only returns `true`/`false`. This makes sense, as essentially we're asking the wallet \"is this a valid signature from you\", and then the wallet decides how to actually validate this it depending on it's own behavior and permissions.\n>\n> However, the QuickAccManager is a singleton contract - one single QuickAccManager represents multiple users. As such, combining it with ERC 1271 is a logical misunderstanding, as we can't really ask it \"is this a valid sig for X identity\" through the ERC 1271 interface. So instead, we encode the identity that we're signing as in the sig itself, but then a malicious user could call a top-level identity with a sig that validates in the singleton `QuickAccManager`, but meant to validate with a differerent identity.\n>\n> Because what we pass to `isValidSignature` is opaque data (the smart wallet may be any contract with any logic, not just our `QuickAccManager`) we can't just peak into the sig and see if it's meant to validate with the caller identity.\n>\n> Excellent finding IMO\n>\n> The current mitigation is hacky, and essentially leads to an `isValidSignature` implementation that is unusable (and doesn't make sense) off-chain, but we prefer it to introducing a new sig type especially for QuickAccManager.\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-10-ambire-findings/issues/40#issuecomment-950870846):**\n > @Ivshti (Ambire) To clarify:\n> Would adding `privileges[QuickAccountManager] = bytes32(uint(1))`enable the exploit?\n\n**[Ivshti (Ambire) commented](https://github.com/code-423n4/2021-10-ambire-findings/issues/40#issuecomment-950871925):**\n > @GalloDaSballo (judge) yes, it would. Any authorized quickAcc would enable the exploit\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-10-ambire-findings/issues/40#issuecomment-950906951):**\n > I'm starting to get this\n>\n> The `id` sent to `isValidSignature` is an untrusted, unverified address\n> The contract at that address can be programmed to have a function `privileges` which would return any `bytes32` value to match `accHash`\n> This effectively allows to run arbitrary transactions.\n>\n> A way to mitigate would be to have a way to ensure the called `id` is trusted\n> A registry of trusted ids may be effective\n>\n> The mitigation the sponsor has chosen does solve for only using trusted Identities as in the case of a malicious Identity, the Identity would just validate it's own transaction, not putting other Identities funds at risk.\n>\n> An alternative solution would be to change the`IdentityFactory` to use the OpenZeppelin Clones Library (or similar) to ensure that the correct Logic is deployed (by deploying a minimal-proxy pointing to the trusted implementation).\n> This would require a fair tech-lift and would limit the type of deployments that the IdentityFactory can perform.\n>\n> The exploit was severe and the sponsor has mitigated by checking the `msg.sender` against the `id` provided in the signature\n>\n\n# Low Risk Findings (6)\n\n- [[L-01] `ecrecover` may return empty address](https://github.com/code-423n4/2021-10-ambire-findings/issues/56)\n_Submitted by pauliax_\n- [[L-02] `block.chainid` may change in case of a hardfork](https://github.com/code-423n4/2021-10-ambire-findings/issues/55)\n_Submitted by pauliax_\n- [[L-03] Hardcoded WETH](https://github.com/code-423n4/2021-10-ambire-findings/issues/54)\n_Submitted by pauliax_\n- [[L-04] `Zapper` should `safeApprove(0)` first](https://github.com/code-423n4/2021-10-ambire-findings/issues/32)\n_Submitted by cmichel_\n- [[L-05] If zero address is added as privilege anyone can execute arbitrary transactions](https://github.com/code-423n4/2021-10-ambire-findings/issues/37)\n_Submitted by cmichel, also found by pmerkleplant_\n- [[L-06] Address with privilege for `QuickAccount` with `address(0)`'s can execute arbitrary transactions](https://github.com/code-423n4/2021-10-ambire-findings/issues/3)\n_Submitted by pmerkleplant_\n\n# Non-Critical Findings (10)\n\n- [[N-01] create2 assembly](https://github.com/code-423n4/2021-10-ambire-findings/issues/67)\n_Submitted by pauliax_\n- [[N-02] Hex selector](https://github.com/code-423n4/2021-10-ambire-findings/issues/66)\n_Submitted by pauliax_\n- [[N-03] Some code is commented out](https://github.com/code-423n4/2021-10-ambire-findings/issues/11)\n_Submitted by loop_\n- [[N-04] Inconsistent code style of for loops](https://github.com/code-423n4/2021-10-ambire-findings/issues/45)\n_Submitted by WatchPug_\n- [[N-05] lack of require message](https://github.com/code-423n4/2021-10-ambire-findings/issues/53)\n_Submitted by JMukesh_\n- [[N-06] use of floating pragma](https://github.com/code-423n4/2021-10-ambire-findings/issues/51)\n_Submitted by JMukesh_\n- [[N-07] No check for signature malleability](https://github.com/code-423n4/2021-10-ambire-findings/issues/38)\n_Submitted by cmichel_\n- [[N-08] `Identity` fallback returns too many bytes](https://github.com/code-423n4/2021-10-ambire-findings/issues/36)\n_Submitted by cmichel_\n- [[N-09] No ERC20 safe* versions called & no return values checked](https://github.com/code-423n4/2021-10-ambire-findings/issues/35)\n_Submitted by cmichel, also found by JMukesh, loop, cryptojedi88, defsec, and loop_\n- [[N-10] `Zapper` only works for whitelisted tokens](https://github.com/code-423n4/2021-10-ambire-findings/issues/33)\n_Submitted by cmichel_\n\n# Gas Optimizations (21)\n\n- [[G-01] `QuickAccManager.sol` Constants should be marked as `constant`](https://github.com/code-423n4/2021-10-ambire-findings/issues/31)\n_Submitted by WatchPug, also found by JMukesh_\n- [[G-02] `QuickAccManager.sol#send()` Avoid unnecessary read from storage can save gas](https://github.com/code-423n4/2021-10-ambire-findings/issues/25)\n_Submitted by WatchPug_\n- [[G-03] Cache array length in for loops can save gas](https://github.com/code-423n4/2021-10-ambire-findings/issues/26)\n_Submitted by WatchPug_\n- [[G-04] `Zapper.sol#wrapETH()` Use `WETH.deposit` can save some gas](https://github.com/code-423n4/2021-10-ambire-findings/issues/27)\n_Submitted by WatchPug, also found by cryptojedi88_\n- [[G-05] `Zapper.sol#tradeV3Single()` Remove unnecessary variable can make the code simpler and save gas](https://github.com/code-423n4/2021-10-ambire-findings/issues/28)\n_Submitted by WatchPug_\n- [[G-06] Unnecessary storage variables](https://github.com/code-423n4/2021-10-ambire-findings/issues/29)\n_Submitted by WatchPug, also found by pauliax and pmerkleplant_\n- [[G-07] Cache storage variables in the stack can save gas](https://github.com/code-423n4/2021-10-ambire-findings/issues/30)\n_Submitted by WatchPug, also found by pauliax_\n- [[G-08] Adding unchecked directive can save gas](https://github.com/code-423n4/2021-10-ambire-findings/issues/46)\n_Submitted by WatchPug, also found by pauliax and ye0lde_\n- [[G-09] Gas: `BytesLib` addition can be unchecked](https://github.com/code-423n4/2021-10-ambire-findings/issues/41)\n_Submitted by cmichel_\n- [[G-10] Gas: `SignatureValidatorV2.recoverAddrImpl` should use `else if`](https://github.com/code-423n4/2021-10-ambire-findings/issues/42)\n_Submitted by cmichel_\n- [[G-11] Safe some gas on the nonce increment](https://github.com/code-423n4/2021-10-ambire-findings/issues/14)\n_Submitted by gpersoon_\n- [[G-12] Compare with 0 and 1 in a more efficient way](https://github.com/code-423n4/2021-10-ambire-findings/issues/15)\n_Submitted by gpersoon_\n- [[G-13] IdentityFactory.withdraw can be external](https://github.com/code-423n4/2021-10-ambire-findings/issues/10)\n_Submitted by loop_\n- [[G-14] Duplicate math operations](https://github.com/code-423n4/2021-10-ambire-findings/issues/57)\n_Submitted by pauliax_\n- [[G-15] LibBytes uses itself](https://github.com/code-423n4/2021-10-ambire-findings/issues/58)\n_Submitted by pauliax_\n- [[G-16] Only prepare tx when the fee is present](https://github.com/code-423n4/2021-10-ambire-findings/issues/65)\n_Submitted by pauliax_\n- [[G-17] Set `QuickAccManager::DOMAIN_SEPARATOR` as immutable](https://github.com/code-423n4/2021-10-ambire-findings/issues/4)\n_Submitted by pmerkleplant_\n- [[G-18] Set `IdentityFactory::creator` as immutable](https://github.com/code-423n4/2021-10-ambire-findings/issues/6)\n_Submitted by pmerkleplant_\n- [[G-19] Set `QuickAccManager::CANCEL_PREFIX` as constant](https://github.com/code-423n4/2021-10-ambire-findings/issues/7)\n_Submitted by pmerkleplant_\n- [[G-20] Long Revert Strings](https://github.com/code-423n4/2021-10-ambire-findings/issues/16)\n_Submitted by ye0lde_\n- [[G-21] Assignment Of Variable To Default (`Identity.sol`)](https://github.com/code-423n4/2021-10-ambire-findings/issues/17)\n_Submitted by ye0lde_\n\n# Disclosures\n\nC4 is an open organization governed by participants in the community.\n\nC4 Contests incentivize the discovery of exploits, vulnerabilities, and bugs in smart contracts. Security researchers are rewarded at an increasing rate for finding higher-risk issues. Contest submissions are judged by a knowledgeable security researcher and solidity developer and disclosed to sponsoring developers. C4 does not conduct formal verification regarding the provided code but instead provides final verification.\n\nC4 does not provide any guarantee or warranty regarding the security of this project. All smart contract software should be used at the sole risk and responsibility of users.\n"
}