{
  "circa": {
    "title": "Marginswap",
    "sponsor": "Marginswap",
    "slug": "2021-04-marginswap",
    "date": "2021-05-03",
    "findings": "https://github.com/code-423n4/2021-04-marginswap-findings/issues",
    "contest": 3
  },
  "html": "<h1 id=\"overview\" style=\"position:relative;\"><a href=\"#overview\" aria-label=\"overview permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Overview</h1>\n<h2 id=\"about-c4\" style=\"position:relative;\"><a href=\"#about-c4\" aria-label=\"about c4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>About C4</h2>\n<p>Code 432n4 (C4) is an open organization that consists of security researchers, auditors, developers, and individuals with domain expertise in the area of smart contracts.</p>\n<p>A C4 code contest is an event in which community participants, referred to as Wardens, review, audit, or analyze smart contract logic in exchange for a bounty provided by sponsoring projects.</p>\n<p>During the code contest outlined in this document, C4 conducted an analysis of Marginswap’s smart contract system written in Solidity. The code contest took place between April 2 and April 7, 2021.</p>\n<h2 id=\"wardens\" style=\"position:relative;\"><a href=\"#wardens\" aria-label=\"wardens permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Wardens</h2>\n<p>5 Wardens contributed reports to the Marginswap code contest:</p>\n<ul>\n<li><a href=\"https://twitter.com/cmichelio\">cmichel</a></li>\n<li><a href=\"https://twitter.com/gpersoon\">gpersoon</a></li>\n<li><a href=\"https://twitter.com/jvaqa\">jvaqa</a></li>\n<li><a href=\"https://twitter.com/SolidityDev\">pauliax</a></li>\n<li><a href=\"https://twitter.com/_smonica_\">s1mo</a></li>\n</ul>\n<p>This contest was judged by <a href=\"https://twitter.com/0xzak\">Zak Cole</a>.</p>\n<p>Final report assembled by <a href=\"https://twitter.com/sockdrawermoney\">sockdrawermoney</a>.</p>\n<h1 id=\"summary\" style=\"position:relative;\"><a href=\"#summary\" aria-label=\"summary permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Summary</h1>\n<p>The C4 analysis yielded an aggregated total of 64 unique vulnerabilities. All of the issues presented here are linked back to their original finding.</p>\n<p>Of these vulnerabilities, 12 received a risk rating in the category of HIGH severity, 12 received a risk rating in the category of MEDIUM severity, and 34 received a risk rating in the category of LOW severity.</p>\n<p>C4 analysis also identified an aggregate total of 8 non-critical recommendations.</p>\n<h1 id=\"scope\" style=\"position:relative;\"><a href=\"#scope\" aria-label=\"scope permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Scope</h1>\n<p>The code under review can be found within the <a href=\"https://github.com/code-423n4/2021-04-marginswap\">C4 code contest repository</a> and comprises 19 smart contracts written in the Solidity programming language.</p>\n<h1 id=\"severity-criteria\" style=\"position:relative;\"><a href=\"#severity-criteria\" aria-label=\"severity criteria permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Severity Criteria</h1>\n<p>C4 assesses severity of disclosed vulnerabilities according to a methodology based on <a href=\"https://owasp.org/www-community/OWASP_Risk_Rating_Methodology\">OWASP standards</a>.</p>\n<p>Vulnerabilities are divided into 3 primary risk categories: high, medium, and low.</p>\n<p>High-level considerations for vulnerabilities span the following key areas when conducting assessments:</p>\n<ul>\n<li>Malicious Input Handling</li>\n<li>Escalation of privileges</li>\n<li>Arithmetic</li>\n<li>Gas use</li>\n</ul>\n<p>Further information regarding the severity criteria referenced throughout the submission review process, please refer to the documentation provided on <a href=\"https://code423n4.com\">the C4 website</a>.</p>\n<h1 id=\"high-risk-findings\" style=\"position:relative;\"><a href=\"#high-risk-findings\" aria-label=\"high risk findings permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>High Risk Findings</h1>\n<h2 id=\"h-01-re-entrancy-bug-allows-inflating-balance\" style=\"position:relative;\"><a href=\"#h-01-re-entrancy-bug-allows-inflating-balance\" aria-label=\"h 01 re entrancy bug allows inflating balance permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/19\">[H-01] Re-entrancy bug allows inflating balance</a></h2>\n<p>One can call the <code>MarginRouter.crossSwapExactTokensForTokens</code> function first with a fake contract disguised as a token pair:\n<code>crossSwapExactTokensForTokens(0.0001 WETH, 0, [ATTACKER_CONTRACT], [WETH, WBTC])</code>. When the amounts are computed by the <code>amounts = UniswapStyleLib.getAmountsOut(amountIn - fees, pairs, tokens);</code> call, the attacker contract returns fake reserves that yield 1 WBTC for the tiny input. The resulting amount is credited through <code>registerTrade</code>. Afterwards, <code>_swapExactT4T([0.0001 WETH, 1 WBTC], 0, [ATTACKER_CONTRACT], [WETH, WBTC])</code> is called with the fake pair and token amounts. At some point <code>_swap</code> is called, the starting balance is stored in <code>startingBalance</code>, and the attacker contract call allows a re-entrancy:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"0\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">pair</span><span class=\"mtk1\">.</span><span class=\"mtk11\">swap</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0.0001</span><span class=\"mtk1\"> </span><span class=\"mtk12\">WETH</span><span class=\"mtk1\">, </span><span class=\"mtk7\">1</span><span class=\"mtk1\"> </span><span class=\"mtk12\">WBTC</span><span class=\"mtk1\">, </span><span class=\"mtk12\">FUND</span><span class=\"mtk1\">, </span><span class=\"mtk4\">new</span><span class=\"mtk1\"> </span><span class=\"mtk10\">bytes</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">)); </span><span class=\"mtk3\">// can re-enter here</span></span></span></code></pre>\n<p>From the ATTACKER<em>CONTRACT we re-enter the `MarginRouter.crossSwapExactTokensForTokens(30 WETH, 0, WETH</em>WBTC<em>PAIR, [WETH, WBTC])<code>function with the actual WETH &#x3C;> WBTC pair contract. All checks pass, the FUND receives the actual amount, the outer</code></em>swap<code>continues execution after the re-entrancy and the</code>endingBalance >= startingBalance + amounts[amounts.length - 1]` check passes as well because the inner swap successfully deposited these funds. We end up doing 1 real trade but being credited twice the output amount.</p>\n<p>This allows someone to be credited multiples of the actual swap result. This can be repeated many times and finally, all tokens can be stolen.</p>\n<p>Recommend adding re-entrancy guards (from OpenZeppelin) to all external functions of <code>MarginRouter</code>. There might be several attack vectors of this function as the attacker controls many parameters. The idea of first doing an estimation with <code>UniswapStyleLib.getAmountsOut(amountIn - fees, pairs, tokens)</code> and updating the user with these estimated amounts, before doing the actual trade, feels quite vulnerable to me. Consider removing the estimation and only doing the actual trade first, then calling <code>registerTrade</code> with the actual trade amounts returned.</p>\n<h2 id=\"h-02-missing-fromtoken--totoken-check\" style=\"position:relative;\"><a href=\"#h-02-missing-fromtoken--totoken-check\" aria-label=\"h 02 missing fromtoken  totoken check permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/20\">[H-02] Missing <code>fromToken != toToken</code> check</a></h2>\n<p>Attacker calls <code>MarginRouter.crossSwapExactTokensForTokens</code> with a fake pair and the same token[0] == token[1].\n<code>crossSwapExactTokensForTokens(1000 WETH, 0, [ATTACKER_CONTRACT], [WETH, WETH])</code>. When the amounts are computed by the <code>amounts = UniswapStyleLib.getAmountsOut(amountIn - fees, pairs, tokens);</code> call, the attacker contract returns fake reserves that yield 0 output. When <code>_swapExactT4T</code> is called, the funds are sent to the fake contract and doing nothing passes all checks in <code>_swap</code> call that follows because the <code>startingBalance</code> is stored <em>after</em> the initial Fund withdraw to the pair.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"1\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">_swapExactT4T</span><span class=\"mtk1\">() {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk3\">// withdraw happens here</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">Fund</span><span class=\"mtk1\">(</span><span class=\"mtk11\">fund</span><span class=\"mtk1\">()).</span><span class=\"mtk11\">withdraw</span><span class=\"mtk1\">(</span><span class=\"mtk12\">tokens</span><span class=\"mtk1\">[</span><span class=\"mtk7\">0</span><span class=\"mtk1\">], </span><span class=\"mtk12\">pairs</span><span class=\"mtk1\">[</span><span class=\"mtk7\">0</span><span class=\"mtk1\">], </span><span class=\"mtk12\">amounts</span><span class=\"mtk1\">[</span><span class=\"mtk7\">0</span><span class=\"mtk1\">]);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">_swap</span><span class=\"mtk1\">(</span><span class=\"mtk12\">amounts</span><span class=\"mtk1\">, </span><span class=\"mtk12\">pairs</span><span class=\"mtk1\">, </span><span class=\"mtk12\">tokens</span><span class=\"mtk1\">, </span><span class=\"mtk11\">fund</span><span class=\"mtk1\">());</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">_swap</span><span class=\"mtk1\">() {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">startingBalance</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">IERC20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">outToken</span><span class=\"mtk1\">).</span><span class=\"mtk11\">balanceOf</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_to</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">endingBalance</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">IERC20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">outToken</span><span class=\"mtk1\">).</span><span class=\"mtk11\">balanceOf</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_to</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk3\">// passes as startingBalance == endingBalance + 0</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">      </span><span class=\"mtk12\">endingBalance</span><span class=\"mtk1\"> &gt;= </span><span class=\"mtk12\">startingBalance</span><span class=\"mtk1\"> + </span><span class=\"mtk12\">amounts</span><span class=\"mtk1\">[</span><span class=\"mtk12\">amounts</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span><span class=\"mtk1\"> - </span><span class=\"mtk7\">1</span><span class=\"mtk1\">],</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">      </span><span class=\"mtk8\">&quot;Defective AMM route; balances don&#39;t match&quot;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  );</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p>The full impact is not yet known as <code>registerTrade</code> could still fail when subtracting the <code>inAmount</code> and adding 0 <code>outAmount</code>.\nAt least, this attack is similar to a withdrawal which is supposed to only occur after a certain <code>coolingOffPeriod</code> has passed, but this time-lock is circumvented with this attack.</p>\n<p>Recommend moving the fund withdrawal to the first pair <strong>after</strong> the <code>startingBalance</code> assignment. Check <code>fromToken != toToken</code> as cyclical trades (arbitrages) are likely not what margin traders are after. Consider if the same check is required for <code>registerTradeAndBorrow</code> / <code>adjustAmounts</code> functions.</p>\n<h2 id=\"h-03-price-feed-can-be-manipulated\" style=\"position:relative;\"><a href=\"#h-03-price-feed-can-be-manipulated\" aria-label=\"h 03 price feed can be manipulated permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/21\">[H-03] Price feed can be manipulated</a></h2>\n<p>Anyone can trigger an update to the price feed by calling <code>PriceAware.getCurrentPriceInPeg(token, inAmount, forceCurBlock=true)</code>.\nIf the update window has passed, the price will be computed by simulating a Uniswap-like trade with the amounts.\nThis simulation uses the reserves of the Uniswap pairs which can be changed drastically using flash loans to yield almost arbitrary output amounts, and thus prices. Wrong prices break the core functionality of the contracts such as borrowing on margin, liquidations, etc.</p>\n<p>Recommend against using the Uniswap spot price as the real price. Uniswap itself warns against this and instead recommends implementing a <a href=\"https://uniswap.org/docs/v2/smart-contract-integration/building-an-oracle/\">TWAP price oracle</a> using the <code>price*CumulativeLast</code> variables.</p>\n<h2 id=\"h-04-inconsistent-usage-of-applyinterest\" style=\"position:relative;\"><a href=\"#h-04-inconsistent-usage-of-applyinterest\" aria-label=\"h 04 inconsistent usage of applyinterest permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/64\">[H-04] Inconsistent usage of <code>applyInterest</code></a></h2>\n<p>It is unclear if the function <code>applyInterest</code> is supposed to return a new balance with the interest applied or only the accrued interest? There are various usages of it, some calls add the return value to the old amount:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"2\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">return</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">bond</span><span class=\"mtk1\">.</span><span class=\"mtk12\">amount</span><span class=\"mtk1\"> +</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">applyInterest</span><span class=\"mtk1\">(</span><span class=\"mtk12\">bond</span><span class=\"mtk1\">.</span><span class=\"mtk12\">amount</span><span class=\"mtk1\">, </span><span class=\"mtk12\">cumulativeYield</span><span class=\"mtk1\">, </span><span class=\"mtk12\">yieldQuotientFP</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">and</span><span class=\"mtk1\"> </span><span class=\"mtk12\">some</span><span class=\"mtk1\"> not:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">balanceWithInterest</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">applyInterest</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">balance</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">yA</span><span class=\"mtk1\">.</span><span class=\"mtk12\">accumulatorFP</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">yieldQuotientFP</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">);</span></span></span></code></pre>\n<p>This makes the code misbehave and return the wrong values for the balance and accrued interest.</p>\n<p>Recommend making it consistent in all cases when calling this function.</p>\n<h2 id=\"h-05-wrong-liquidation-logic\" style=\"position:relative;\"><a href=\"#h-05-wrong-liquidation-logic\" aria-label=\"h 05 wrong liquidation logic permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/23\">[H-05] Wrong liquidation logic</a></h2>\n<p>The <code>belowMaintenanceThreshold</code> function decides if a trader can be liquidated:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"3\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">belowMaintenanceThreshold</span><span class=\"mtk1\">(</span><span class=\"mtk12\">CrossMarginAccount</span><span class=\"mtk1\"> </span><span class=\"mtk12\">storage</span><span class=\"mtk1\"> </span><span class=\"mtk12\">account</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">internal</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">bool</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">{</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">loan</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">loanInPeg</span><span class=\"mtk1\">(</span><span class=\"mtk12\">account</span><span class=\"mtk1\">, </span><span class=\"mtk4\">true</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">holdings</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">holdingsInPeg</span><span class=\"mtk1\">(</span><span class=\"mtk12\">account</span><span class=\"mtk1\">, </span><span class=\"mtk4\">true</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// The following should hold:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// holdings / loan &gt;= 1.1</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// =&gt;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk7\">100</span><span class=\"mtk1\"> * </span><span class=\"mtk12\">holdings</span><span class=\"mtk1\"> &gt;= </span><span class=\"mtk12\">liquidationThresholdPercent</span><span class=\"mtk1\"> * </span><span class=\"mtk12\">loan</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p>The inequality in the last equation is wrong because it says the higher the holdings (margin + loan) compared to the loan, the higher the chance of being liquidated. The inverse equality was probably intended <code>return 100 * holdings &#x3C;= liquidationThresholdPercent * loan;</code>. Users that shouldn’t be liquidated can be liquidated, and users that should be liquidated cannot get liquidated.</p>\n<h2 id=\"h-06-users-are-credited-more-tokens-when-paying-back-debt-with-registertradeandborrow\" style=\"position:relative;\"><a href=\"#h-06-users-are-credited-more-tokens-when-paying-back-debt-with-registertradeandborrow\" aria-label=\"h 06 users are credited more tokens when paying back debt with registertradeandborrow permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/24\">[H-06] Users are credited more tokens when paying back debt with <code>registerTradeAndBorrow</code></a></h2>\n<p>The <code>registerTradeAndBorrow</code> is called with the results of a trade (<code>inAmount</code>, <code>outAmount</code>). It first tries to pay back any debt with the <code>outAmount</code>. However, the <strong>full</strong> <code>outAmount</code> is credited to the user again as a deposit in the <code>adjustAmounts(account, tokenFrom, tokenTo, sellAmount, outAmount);</code> call. As the user pays back their debt and is credited the same amount again, they are essentially credited twice the <code>outAmount</code>, making a profit of one <code>outAmount</code>. This can be withdrawn and the process can be repeated until the funds are empty.</p>\n<p>In the <code>adjustAmounts</code> call, it should only credit <code>outAmount - extinguishableDebt</code> as a deposit like in <code>registerDeposit</code>.\nThe <code>registerDeposit</code> function correctly handles this case.</p>\n<h2 id=\"h-07-accountholdstoken-is-never-set\" style=\"position:relative;\"><a href=\"#h-07-accountholdstoken-is-never-set\" aria-label=\"h 07 accountholdstoken is never set permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/25\">[H-07] <code>account.holdsToken</code> is never set</a></h2>\n<p>The <code>addHolding</code> function does not update the <code>account.holdsToken</code> map.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"4\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">addHolding</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">CrossMarginAccount</span><span class=\"mtk1\"> </span><span class=\"mtk12\">storage</span><span class=\"mtk1\"> </span><span class=\"mtk12\">account</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">token</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">depositAmount</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">) </span><span class=\"mtk11\">internal</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (!</span><span class=\"mtk11\">hasHoldingToken</span><span class=\"mtk1\">(</span><span class=\"mtk12\">account</span><span class=\"mtk1\">, </span><span class=\"mtk12\">token</span><span class=\"mtk1\">)) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// SHOULD SET account.holdsToken here</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">account</span><span class=\"mtk1\">.</span><span class=\"mtk12\">holdingTokens</span><span class=\"mtk1\">.</span><span class=\"mtk11\">push</span><span class=\"mtk1\">(</span><span class=\"mtk12\">token</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">account</span><span class=\"mtk1\">.</span><span class=\"mtk12\">holdings</span><span class=\"mtk1\">[</span><span class=\"mtk12\">token</span><span class=\"mtk1\">] += </span><span class=\"mtk12\">depositAmount</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p>This leads to a critical vulnerability where deposits of the same token keep being pushed to the <code>account.holdingTokens</code> array but the sum is correctly updated in <code>account.holdings[token]</code>. However, because of the duplicate token in the <code>holdingTokens</code> array the same token is counted several times in the <code>getHoldingAmounts</code> function:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"5\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">getHoldingAmounts</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">trader</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">external</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">view</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">override</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">address</span><span class=\"mtk1\">[] </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">holdingTokens</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\">[] </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">holdingAmounts</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    )</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">{</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">CrossMarginAccount</span><span class=\"mtk1\"> </span><span class=\"mtk12\">storage</span><span class=\"mtk1\"> </span><span class=\"mtk12\">account</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">marginAccounts</span><span class=\"mtk1\">[</span><span class=\"mtk12\">trader</span><span class=\"mtk1\">];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">holdingTokens</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">account</span><span class=\"mtk1\">.</span><span class=\"mtk12\">holdingTokens</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">holdingAmounts</span><span class=\"mtk1\"> = </span><span class=\"mtk4\">new</span><span class=\"mtk1\"> </span><span class=\"mtk10\">uint256</span><span class=\"mtk1\">[](</span><span class=\"mtk12\">account</span><span class=\"mtk1\">.</span><span class=\"mtk12\">holdingTokens</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">for</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">idx</span><span class=\"mtk1\"> = </span><span class=\"mtk7\">0</span><span class=\"mtk1\">; </span><span class=\"mtk12\">holdingTokens</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk12\">idx</span><span class=\"mtk1\">; </span><span class=\"mtk12\">idx</span><span class=\"mtk1\">++) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">tokenAddress</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">holdingTokens</span><span class=\"mtk1\">[</span><span class=\"mtk12\">idx</span><span class=\"mtk1\">];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk3\">// RETURNS SUM OF THE BALANCE FOR EACH TOKEN ENTRY</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">holdingAmounts</span><span class=\"mtk1\">[</span><span class=\"mtk12\">idx</span><span class=\"mtk1\">] = </span><span class=\"mtk12\">account</span><span class=\"mtk1\">.</span><span class=\"mtk12\">holdings</span><span class=\"mtk1\">[</span><span class=\"mtk12\">tokenAddress</span><span class=\"mtk1\">];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p>The <code>MarginRouter.crossCloseAccount</code> function uses these wrong amounts to withdraw all tokens:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"6\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">crossCloseAccount</span><span class=\"mtk1\">() </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    (</span><span class=\"mtk12\">address</span><span class=\"mtk1\">[] </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">holdingTokens</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\">[] </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">holdingAmounts</span><span class=\"mtk1\">) =</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">IMarginTrading</span><span class=\"mtk1\">(</span><span class=\"mtk11\">marginTrading</span><span class=\"mtk1\">()).</span><span class=\"mtk11\">getHoldingAmounts</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// requires all debts paid off</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">IMarginTrading</span><span class=\"mtk1\">(</span><span class=\"mtk11\">marginTrading</span><span class=\"mtk1\">()).</span><span class=\"mtk11\">registerLiquidation</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">for</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">i</span><span class=\"mtk1\">; </span><span class=\"mtk12\">holdingTokens</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk12\">i</span><span class=\"mtk1\">; </span><span class=\"mtk12\">i</span><span class=\"mtk1\">++) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk11\">Fund</span><span class=\"mtk1\">(</span><span class=\"mtk11\">fund</span><span class=\"mtk1\">()).</span><span class=\"mtk11\">withdraw</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk12\">holdingTokens</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">],</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk12\">holdingAmounts</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">]</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        );</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p>An attacker can just deposit the same token X times which increases their balance by X times the actual value.\nThis inflated balance can then be withdrawn to steal all tokens.</p>\n<p>Recommend correctly setting the <code>account.holdsToken</code> map in <code>addHolding</code>.</p>\n<h2 id=\"h-08-rewards-cannot-be-withdrawn\" style=\"position:relative;\"><a href=\"#h-08-rewards-cannot-be-withdrawn\" aria-label=\"h 08 rewards cannot be withdrawn permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/26\">[H-08] Rewards cannot be withdrawn</a></h2>\n<p>The rewards for a recipient in <code>IncentiveDistribution.sol</code> are stored in the storage mapping indexed by recipient <code>accruedReward[recipient]</code> and the recipient is the actual margin trader account, see <code>updateAccruedReward</code>.</p>\n<p>These rewards are supposed to be withdrawn through the <code>withdrawReward</code> function but <code>msg.sender</code> is used here instead of a <code>recipient</code> (<code>withdrawer</code>) parameter.\nHowever, <code>msg.sender</code> is enforced to be the incentive reporter and can therefore not be the margin trader.</p>\n<p>Nobody can withdraw the rewards.</p>\n<p>Recommend removing the <code>isIncentiveReporter(msg.sender)</code> check from <code>withdrawReward</code> function.</p>\n<h2 id=\"h-09-lastupdatedday-not-initialized\" style=\"position:relative;\"><a href=\"#h-09-lastupdatedday-not-initialized\" aria-label=\"h 09 lastupdatedday not initialized permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/14\">[H-09] lastUpdatedDay not initialized</a></h2>\n<p>The variable lastUpdatedDay in IncentiveDistribution.sol is not (properly) initialized. This means the function updateDayTotals will end up in a very large loop which will lead to an out of gas error. Even if the loop would end, the variable currentDailyDistribution would be updated very often. Thus updateDayTotals cannot be performed.</p>\n<p>The entire IncentiveDistribution does not work. If the loop would stop, the variable currentDailyDistribution is not accurate, resulting in a far lower incentive distribution than expected.</p>\n<p>Recommend initializing lastUpdatedDay with something like block.timestamp / (1 days)</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"7\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">lastUpdatedDay</span><span class=\"mtk1\">; # ==&gt; </span><span class=\"mtk12\">lastUpdatedDay</span><span class=\"mtk1\"> = </span><span class=\"mtk7\">0</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\"># </span><span class=\"mtk12\">When</span><span class=\"mtk1\"> </span><span class=\"mtk12\">the</span><span class=\"mtk1\"> </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">updateDayTotals</span><span class=\"mtk1\"> </span><span class=\"mtk11\">is</span><span class=\"mtk1\"> </span><span class=\"mtk11\">called</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk11\">public</span><span class=\"mtk1\"> </span><span class=\"mtk11\">nowDay</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">block</span><span class=\"mtk1\">.</span><span class=\"mtk11\">timestamp</span><span class=\"mtk1\"> / (1 </span><span class=\"mtk12\">days</span><span class=\"mtk1\">); #==&gt; ~ </span><span class=\"mtk7\">18721</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">dayDiff</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">nowDay</span><span class=\"mtk1\"> - </span><span class=\"mtk12\">lastUpdatedDay</span><span class=\"mtk1\">; #==&gt; </span><span class=\"mtk7\">18721</span><span class=\"mtk1\">-</span><span class=\"mtk7\">0</span><span class=\"mtk1\"> = </span><span class=\"mtk7\">18721</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">for</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">i</span><span class=\"mtk1\"> = </span><span class=\"mtk7\">0</span><span class=\"mtk1\">; </span><span class=\"mtk12\">i</span><span class=\"mtk1\"> &lt; </span><span class=\"mtk12\">dayDiff</span><span class=\"mtk1\">; </span><span class=\"mtk12\">i</span><span class=\"mtk1\">++) { # </span><span class=\"mtk12\">very</span><span class=\"mtk1\"> </span><span class=\"mtk12\">long</span><span class=\"mtk1\"> </span><span class=\"mtk11\">loop</span><span class=\"mtk1\"> (</span><span class=\"mtk7\">18721</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">currentDailyDistribution</span><span class=\"mtk1\"> = ....</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">#</span><span class=\"mtk12\">will</span><span class=\"mtk1\"> </span><span class=\"mtk12\">result</span><span class=\"mtk1\"> </span><span class=\"mtk4\">in</span><span class=\"mtk1\"> </span><span class=\"mtk12\">an</span><span class=\"mtk1\"> </span><span class=\"mtk12\">out</span><span class=\"mtk1\"> </span><span class=\"mtk4\">of</span><span class=\"mtk1\"> </span><span class=\"mtk12\">gas</span><span class=\"mtk1\"> </span><span class=\"mtk12\">error</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">## [[</span><span class=\"mtk12\">H</span><span class=\"mtk1\">-</span><span class=\"mtk7\">10</span><span class=\"mtk1\">] </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">buyBond</span><span class=\"mtk1\"> </span><span class=\"mtk11\">charges</span><span class=\"mtk1\"> </span><span class=\"mtk11\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk11\">sender</span><span class=\"mtk1\"> </span><span class=\"mtk11\">twice</span><span class=\"mtk1\">](</span><span class=\"mtk12\">https</span><span class=\"mtk1\">:</span><span class=\"mtk3\">//github.com/code-423n4/2021-04-marginswap-findings/issues/38)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk10\">function</span><span class=\"mtk1\"> </span><span class=\"mtk10\">buyBond</span><span class=\"mtk1\"> </span><span class=\"mtk10\">transfers</span><span class=\"mtk1\"> </span><span class=\"mtk10\">amount</span><span class=\"mtk1\"> </span><span class=\"mtk10\">from</span><span class=\"mtk1\"> </span><span class=\"mtk10\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk10\">sender</span><span class=\"mtk1\"> </span><span class=\"mtk10\">twice</span><span class=\"mtk1\">:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk10\">Fund</span><span class=\"mtk1\">(</span><span class=\"mtk10\">fund</span><span class=\"mtk1\">()).</span><span class=\"mtk10\">depositFor</span><span class=\"mtk1\">(</span><span class=\"mtk10\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk10\">sender</span><span class=\"mtk1\">, </span><span class=\"mtk10\">issuer</span><span class=\"mtk1\">, </span><span class=\"mtk10\">amount</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk10\">collectToken</span><span class=\"mtk1\">(</span><span class=\"mtk12\">issuer</span><span class=\"mtk1\">, msg.sender, </span><span class=\"mtk12\">amount</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<h2 id=\"h-11-impossible-to-call-withdrawreward-fails-due-to-run-out-of-gas\" style=\"position:relative;\"><a href=\"#h-11-impossible-to-call-withdrawreward-fails-due-to-run-out-of-gas\" aria-label=\"h 11 impossible to call withdrawreward fails due to run out of gas permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/65\">[H-11] Impossible to call withdrawReward fails due to run out of gas</a></h2>\n<p>The withdrawReward (<a href=\"https://github.com/code-423n4/marginswap/blob/main/contracts/IncentiveDistribution.sol#L224\">https://github.com/code-423n4/marginswap/blob/main/contracts/IncentiveDistribution.sol#L224</a>) fails due to the loop at <a href=\"https://github.com/code-423n4/marginswap/blob/main/contracts/IncentiveDistribution.sol#L269\">https://github.com/code-423n4/marginswap/blob/main/contracts/IncentiveDistribution.sol#L269</a>. Based on testing, the dayDiff would be 18724 and with a gasLimit of 9500000 it stops at iteration 270 due to the fact that lastUpdatedDay is not initialized so is 0. Other than that it could run out of gas also for the loop of allTranches (<a href=\"https://github.com/code-423n4/marginswap/blob/main/contracts/IncentiveDistribution.sol#L281\">https://github.com/code-423n4/marginswap/blob/main/contracts/IncentiveDistribution.sol#L281</a>) because it’s an unbounded array.</p>\n<p>I’m not sure of the logic behind the shrinking of the daily distribution but i think that maybe you just missed to initialize the lastUpdatedDay to the day of deployment? If that’s the case it resolves partially the problem because allTranches is theoretically unbounded even though only the owner can add element to it and you should do deeply testing to understand how many elements it can have until it run out of gas. I read the comment that says you tried to shift the gas to the withdrawal people maybe you went too further and is it worth rethinking the design?</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/65#issuecomment-816212433\">werg (Marginswap) confirmed</a>:</strong></p>\n<blockquote>\n<p>Exactly. we need to initialize lastUpdatedDay.</p>\n</blockquote>\n<h1 id=\"medium-risk-findings\" style=\"position:relative;\"><a href=\"#medium-risk-findings\" aria-label=\"medium risk findings permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Medium Risk Findings</h1>\n<h2 id=\"m-01-no-default-liquidationthresholdpercent\" style=\"position:relative;\"><a href=\"#m-01-no-default-liquidationthresholdpercent\" aria-label=\"m 01 no default liquidationthresholdpercent permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/28\">[M-01] No default <code>liquidationThresholdPercent</code></a></h2>\n<p>The <code>IsolatedMarginTrading</code> contract does not define a default <code>liquidationThresholdPercent</code> which means it is set to 0. The <code>belowMaintenanceThreshold</code> function uses this value and anyone could be liquidated due to <code>100 * holdings >= liquidationThresholdPercent * loan = 0</code> being always true.</p>\n<p>Anyone can be liquidated immediately. If the faulty <code>belowMaintenanceThreshold</code> function is fixed (see other issue), then nobody could be liquidated which is bad as well.</p>\n<p>Recommend setting a default liquidation threshold like in <code>CrossMarginTrading</code> contracts.</p>\n<h2 id=\"m-02-missing-checks-if-pairs-equal-tokens\" style=\"position:relative;\"><a href=\"#m-02-missing-checks-if-pairs-equal-tokens\" aria-label=\"m 02 missing checks if pairs equal tokens permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/29\">[M-02] Missing checks if pairs equal tokens</a></h2>\n<p>The <code>UniswapStyleLib.getAmountsOut</code>, <code>PriceAware.setLiquidationPath</code> (and others) don’t check that <code>path.length + 1 == tokens.length</code> which should always hold true. Also, it does not check that the tokens actually match the pair. It’s easy to set faulty liquidation paths which then end up reverting the liquidation transactions.</p>\n<h2 id=\"m-03-no-entry-checks-in-crossswapexacttokensforexacttokens\" style=\"position:relative;\"><a href=\"#m-03-no-entry-checks-in-crossswapexacttokensforexacttokens\" aria-label=\"m 03 no entry checks in crossswapexacttokensforexacttokens permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/4\">[M-03] No entry checks in crossSwap[Exact]TokensFor[Exact]Tokens</a></h2>\n<p>The functions crossSwapTokensForExactTokens and crossSwapExactTokensForTokens of MarginRouter.sol do not check who is calling the function. They also do not check the contents of pairs and tokens nor do they check if the size of pairs and tokens is the same.</p>\n<p><code>registerTradeAndBorrow</code> within <code>registerTrade</code> does seem to do an entry check (require(isMarginTrader(msg.sender)…) however as this is an external function msg.sender is the address of MarginRouter.sol, which will verify ok.</p>\n<p>Calling these functions allow the caller to trade on behalf of marginswap, which could result in losing funds. It’s possible to construct all parameters to circumvent the checks. Also the “pairs” can be fully specified; they are contract addresses that are called from getAmountsIn / getAmountsOut and from pair.swap. This way you can call arbitrary (self constructed) code, which can reentrantly call the marginswap code.</p>\n<p>Recommend limiting who can call the functions. Perhaps whitelist contents of pairs and tokens. Check the size of pairs and tokens is the same.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/4#issuecomment-813047489\">werg (Marginswap) confirmed</a>:</strong></p>\n<blockquote>\n<p>This has merit: particularly the part about self-constructed pairs. We either need much more rigorous checks or a a process for vetting &#x26; approving pairs. The latter is likely more gas efficient.</p>\n</blockquote>\n<h2 id=\"m-04-maintainer-can-be-pushed-out\" style=\"position:relative;\"><a href=\"#m-04-maintainer-can-be-pushed-out\" aria-label=\"m 04 maintainer can be pushed out permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/5\">[M-04] maintainer can be pushed out</a></h2>\n<p>The function liquidate (in both <code>CrossMarginLiquidation.sol</code> and <code>IsolatedMarginLiquidation.sol</code>) can be called by everyone. If an attacker calls this repeatedly then the maintainer will be punished and eventually be reported as maintainerIsFailing\nAnd then the attacker can take the payouts.</p>\n<p>When a non authorized address repeatedly calls liquidate then the following happens: <code>isAuthorized = false</code> which means <code>maintenanceFailures[currentMaintainer]</code> increases. After sufficient calls it will be higher than the threshold and then\n<code>maintainerIsFailing()</code> will be true. This results in <code>canTakeNow</code> being true, which finally means the following will be executed:</p>\n<p><code>Fund(fund()).withdraw(PriceAware.peg, msg.sender, maintainerCut);</code></p>\n<p>An attacker can push out a maintainer and take over the liquidation revenues.</p>\n<p>Recommend put authorization on who can call the liquidate function, review the maintainer punishment scheme.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/5#issuecomment-813044805\">werg (Marginswap) disputed</a>:</strong></p>\n<blockquote>\n<p>I believe this issue is not a vulnerability, due to the checks in lines 326-335. Even if someone comes in first and claims the maintainer is failing they can do their job in the same or next block and get all / most of their failure record extinguished.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/5#issuecomment-824102934\">zscole (Judge)</a>:</strong></p>\n<blockquote>\n<p>Acknowledging feedback from @werg, but maintaining the reported risk level of <code>medium</code> since this has implications on token logic.</p>\n</blockquote>\n<h2 id=\"m-05-several-function-have-no-entry-check\" style=\"position:relative;\"><a href=\"#m-05-several-function-have-no-entry-check\" aria-label=\"m 05 several function have no entry check permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/9\">[M-05] Several function have no entry check</a></h2>\n<p>The following functions have no entry check or a trivial entry check:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"8\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">withdrawHourlyBond</span><span class=\"mtk1\"> </span><span class=\"mtk12\">Lending</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">closeHourlyBondAccount</span><span class=\"mtk1\"> </span><span class=\"mtk12\">Lending</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">haircut</span><span class=\"mtk1\"> </span><span class=\"mtk12\">Lending</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">addDelegate</span><span class=\"mtk1\">(</span><span class=\"mtk12\">own</span><span class=\"mtk1\"> </span><span class=\"mtk12\">adress</span><span class=\"mtk1\">...) </span><span class=\"mtk12\">Admin</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">removeDelegate</span><span class=\"mtk1\">(</span><span class=\"mtk12\">own</span><span class=\"mtk1\"> </span><span class=\"mtk12\">adress</span><span class=\"mtk1\">...) </span><span class=\"mtk12\">Admin</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">depositStake</span><span class=\"mtk1\"> </span><span class=\"mtk12\">Admin</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">disburseLiqStakeAttacks</span><span class=\"mtk1\"> </span><span class=\"mtk12\">CrossMarginLiquidation</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">disburseLiqStakeAttacks</span><span class=\"mtk1\"> </span><span class=\"mtk12\">IsolatedMarginLiquidation</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">getCurrentPriceInPeg</span><span class=\"mtk1\"> </span><span class=\"mtk12\">PriceAware</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sol</span></span></span></code></pre>\n<p>By manipulating the input values (for example extremely large values), you might be able to disturb the internal administration of the contract, thus perhaps locking function or giving wrong rates.</p>\n<p>Recommend checking the functions to see if they are completely risk free and add entry checks if they are not, and add a comment to notify the function is meant to be called by everyone.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/9#issuecomment-813043345\">werg (Marginswap)</a>:</strong></p>\n<blockquote>\n<ul>\n<li><code>withdrawHourlyBond</code>: could not find vulnerability, since solidity 0.8.x fails on underflow in HourlyBondSubscriptionLending.sol:115 in case of unauthorized access.</li>\n<li><code>closeHourlyBondAccount</code>: same story since both call into <code>_withdrawHourlyBond</code></li>\n<li><code>haircut</code>: trivially guarded in one way, though this actually has merit in another way — if at some point down the road an attacker were able to establish a token, make it popular enough for us to add it to cross margin, but include in that token contract a malicious function that calls haircut, they could then void everybody’s bonds in their token. I don’t see how it would be profitable, it’s definitely an expensive long con, but… we should add an extra guard to make sure it’s an isolated margin trading contract.</li>\n<li><code>addDelegate</code> has a guard.</li>\n<li><code>removeDelegate</code> has a guard as well, or am I missing something here?</li>\n<li><code>depositStake</code> fails for unfunded requests in the safe transfer in <code>Fund.depositFor</code></li>\n<li><code>disburseLiqStakeAttacks</code> should be universally accessible by design</li>\n<li><code>getCurrentPriceInPeg</code> only updates state in a rate limited way, hence fine for it to be public</li>\n</ul>\n<p>I will add comments to the effect. Thanks again</p>\n</blockquote>\n<h2 id=\"m-06-users-can-drain-funds-from-marginswap-by-making-undercollateralized-borrows-if-the-price-of-a-token-has-moved-more-than-10-since-the-last-marginswap-borrowliquidation-involving-accounts-holding-that-token\" style=\"position:relative;\"><a href=\"#m-06-users-can-drain-funds-from-marginswap-by-making-undercollateralized-borrows-if-the-price-of-a-token-has-moved-more-than-10-since-the-last-marginswap-borrowliquidation-involving-accounts-holding-that-token\" aria-label=\"m 06 users can drain funds from marginswap by making undercollateralized borrows if the price of a token has moved more than 10 since the last marginswap borrowliquidation involving accounts holding that token permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/67\">[M-06] Users Can Drain Funds From MarginSwap By Making Undercollateralized Borrows If The Price Of A Token Has Moved More Than 10% Since The Last MarginSwap Borrow/Liquidation Involving Accounts Holding That Token.</a></h2>\n<p>Users Can Drain Funds From MarginSwap By Making Undercollateralized Borrows If The Price Of A Token Has Moved More Than 10% Since The Last MarginSwap Borrow/Liquidation Involving Accounts Holding That Token.</p>\n<p>MarginSwap’s internal price oracle is only updated for a particular token if a borrow or liquidation is attempted for an account that is lending/borrowing that particular token.</p>\n<p>For a less popular token, the price could move quite a bit without any borrow or liquidation being called on any account lending/borrowing that token, especially if MarginSwap does not end up being wildly popular, or if it supports lesser known assets.\nIf the Uniswap price has moved more than 10% (liquidationThresholdPercent - 100) without a borrow or liquidation on an account lending/borrowing that particular token occurring on MarginSwap, then Alice can make undercollateralized loans, leaving behind her collateral and draining funds from the contract.</p>\n<p>(1) Alice waits for the Uniswap price for any token to move more than 10% (liquidationThresholdPercent - 100) without a borrow or liquidation occurring for any account lending/borrowing that token occurring on MarginSwap.\n(2) When this condition is satisfied, Alice can loop the following actions:\n(2.1) If the price has fallen, Alice can use the token as collateral (making sure to use more than UPDATE<em>MAX</em>PEG<em>AMOUNT worth of the token in ETH), borrow ether from MarginSwap, sell the ether for the token on Uniswap, and repeat, leaving coolingOffPeriod blocks between each lend and borrow.\n(2.2) If the price has risen, Alice can use ether as collateral, borrow the token from MarginSwap (making sure to use more than UPDATE</em>MAX<em>PEG</em>AMOUNT worth of the token in ETH), sell the token for ether on Uniswap, and repeat, leaving coolingOffPeriod blocks between each lend and borrow.</p>\n<p>Because the MarginSwap price is now stale, Alice can borrow more than 100% of the actual value of her collateral, since MarginSwap believes the borrowed funds to only be worth 90% or less than their actual current market value.</p>\n<p>The various defenses that MarginSwap has employed against undercollateralized loans are all bypassed:\n(a) The exponential moving price average stored within MarginSwap is not updated, because Alice borrows at least UPDATE<em>MAX</em>PEG<em>AMOUNT worth of the token in ETH, so MarginSwap.PriceAware.getPriceFromAMM skips the price update due to the “outAmount &#x3C; UPDATE</em>MAX<em>PEG</em>AMOUNT” condition failing.\n(b) CoolingOffPeriod can be bypassed by Alice splitting her deposits and borrows up by 20 blocks (the current value of CoolingOffPeriod). Since deposits do not trigger a price oracle update, Alice can even deposit ahead of time as the price is nearing 10% off of peg, allowing her to perform the borrow right when 10% is passed.\n(c) MarginSwap.Lending.registerBorrow check is bypassed. The check is “meta.totalLending >= meta.totalBorrowed”, but this is a global check that only ensures that the contract as a whole has sufficient tokens to fund Alice’s borrow. Alice simply needs to ensure that she only borrows up to the amount of tokens that the contract currently owns.</p>\n<p>Even if the issue of the price oracle stalling were to be fixed by using a large enough UPDATE<em>MAX</em>PEG_AMOUNT, since the moving average updates so slowly (MarginSwap is currently set at moving 8/1000th towards new price every 8 blocks) and only when actions are taken on MarginSwap (which may not be frequent on lesser known tokens or if MarginSwap is not too popular), Alice can still take out undercollateralized loans for a period of time before the price oracle catches up.\nThe real solution here is to use UniswapV2/SushiSwap/UniswapV3’s built in TWAP price oracle, especially since MarginSwap is built on top of Uniswap/Sushiswap.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/67#issuecomment-816204245\">werg (Marginswap) acknowledged</a>:</strong></p>\n<blockquote>\n<p>I believe the issue above is referring to the “overcollateralized borrow” functionality, because there is talk of withdrawing. In any case of withdrawal (whether immediately or not) it is not the <code>liquidationThresholdPercent</code> which governs how much a user may withdraw. Rather, we check whether the account has positive balance (i.e. the value of assets exceeds the loan).</p>\n<p>In the current system, at 3x possible leverage level, users can withdraw maximally 66% of the face value (to the system) they deposited. If a user deposited collateral that had dropped in price by 10% it would allow them to withdraw around 73% of the real value. — Not undercollateralized.\nThe price of an asset would have to have dropped by 33%, without the system catching on, for Alice to break even (without considering gas cost).</p>\n<p>Cross margin trading will only be available for a select set of tokens with high enough trading volume. Anyone will be able to update the price if our exponential weighted average is out of date.\nNevertheless, risk remains as in any lending system.</p>\n<ul>\n<li>We will consider adding an additional buffer around immediate withdrawals</li>\n<li>If staleness becomes an issue the protocol can institute rewards for updating the price</li>\n</ul>\n<p>also of course there are liquidators waiting in the wings to make their cut on underwater accounts and liquidators can update the price.</p>\n</blockquote>\n<h2 id=\"m-07-diffmaxminruntime-gets-default-value-of-0\" style=\"position:relative;\"><a href=\"#m-07-diffmaxminruntime-gets-default-value-of-0\" aria-label=\"m 07 diffmaxminruntime gets default value of 0 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/37\">[M-07] diffMaxMinRuntime gets default value of 0</a></h2>\n<p><code>uint256 public diffMaxMinRuntime;`` This variable is never set nor updated so it gets a default value of 0.</code>diffMaxMinRuntime` with 0 value is making the calculations that use it either always return 0 (when multiplying) or fail (when dividing) when calculating bucket indexes or sizes.</p>\n<p>Recommend setting the appropriate value for diffMaxMinRuntime and update it whenever min or max runtime variables change.</p>\n<h2 id=\"m-08-priceaware-uses-prices-from-getamountsout\" style=\"position:relative;\"><a href=\"#m-08-priceaware-uses-prices-from-getamountsout\" aria-label=\"m 08 priceaware uses prices from getamountsout permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/39\">[M-08] PriceAware uses prices from getAmountsOut</a></h2>\n<p><code>getPriceFromAMM</code> relies on values returned from getAmountsOut which can be manipulated (e.g. with the large capital or the help of flash loans). The impact is reduced with UPDATE<em>MIN</em>PEG<em>AMOUNT and UPDATE</em>MAX<em>PEG</em>AMOUNT, however, it is not entirely eliminated.</p>\n<p>Uniswap v2 recommends using their TWAP oracle: <a href=\"https://uniswap.org/docs/v2/core-concepts/oracles/\">https://uniswap.org/docs/v2/core-concepts/oracles/</a></p>\n<h2 id=\"m-09-isolated-margin-contracts-declare-but-do-not-set-the-value-of-liquidationthresholdpercent\" style=\"position:relative;\"><a href=\"#m-09-isolated-margin-contracts-declare-but-do-not-set-the-value-of-liquidationthresholdpercent\" aria-label=\"m 09 isolated margin contracts declare but do not set the value of liquidationthresholdpercent permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/40\">[M-09] Isolated margin contracts declare but do not set the value of liquidationThresholdPercent</a></h2>\n<p>CrossMarginTrading sets value of liquidationThresholdPercent in the constructor: <code>liquidationThresholdPercent = 110;</code> Isolated margin contracts declare but do not set the value of liquidationThresholdPercent.</p>\n<p>Recommend setting the initial value for the liquidationThresholdPercent in Isolated margin contracts.</p>\n<p>This makes function belowMaintenanceThreshold to always return true unless a value is set via function setLiquidationThresholdPercent. Comments indicate that the value should also be set to 110:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"9\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// The following should hold:</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// holdings / loan &gt;= 1.1</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// =&gt; holdings &gt;= loan \\* 1.1</span></span></span></code></pre>\n<h2 id=\"m-10-add-a-timelock-to-functions-that-set-key-variables\" style=\"position:relative;\"><a href=\"#m-10-add-a-timelock-to-functions-that-set-key-variables\" aria-label=\"m 10 add a timelock to functions that set key variables permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/70\">[M-10] Add a timelock to functions that set key variables</a></h2>\n<p>Functions like <code>setLeveragePercent</code> and <code>setLiquidationThresholdPercent</code> for both <a href=\"https://github.com/code-423n4/marginswap/blob/main/contracts/IsolatedMarginTrading.sol\"><code>IsolatedMarginTrading</code></a> and <a href=\"https://github.com/code-423n4/marginswap/blob/main/contracts/CrossMarginTrading.sol\"><code>CrossMarginTrading</code></a> should be put behind a timelock because they would give more trust to users. Currently, the owner could call them whenever they want and a position could become liquidable from a block to the other.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/70#issuecomment-816168032\">werg (Marginswap) acknowledged</a>:</strong></p>\n<blockquote>\n<p>Timelock will be handled by governance</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/70#issuecomment-824944141\">zscole commented</a>:</strong></p>\n<blockquote>\n<p>Maintaining submission rating of <code>2 (Med Risk)</code> because this presents a vulnerability at the time of review.</p>\n</blockquote>\n<h1 id=\"low-risk-findings\" style=\"position:relative;\"><a href=\"#low-risk-findings\" aria-label=\"low risk findings permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Low Risk Findings</h1>\n<h2 id=\"l-01-events-not-indexed\" style=\"position:relative;\"><a href=\"#l-01-events-not-indexed\" aria-label=\"l 01 events not indexed permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/27\">[L-01] Events not indexed</a></h2>\n<p>The <code>CrossDeposit</code>, <code>CrossTrade</code>, <code>CrossWithdraw</code>, <code>CrossBorrow</code>, <code>CrossOvercollateralizedBorrow</code> events in <code>MarginRouter</code> are not indexed. Off-chain scripts cannot efficiently filter these events.</p>\n<p>Recommend adding an index on important arguments like <code>trader</code>.</p>\n<h2 id=\"l-02-getreserves-does-not-check-if-tokens-match\" style=\"position:relative;\"><a href=\"#l-02-getreserves-does-not-check-if-tokens-match\" aria-label=\"l 02 getreserves does not check if tokens match permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/30\">[L-02] <code>getReserves</code> does not check if tokens match</a></h2>\n<p>The <code>UniswapStyleLib.getReserves</code> function does not check if the tokens are the pair’s underlying tokens.\nIt blindly assumes that the tokens are in the wrong order if the first one does not match but they could also be completely different tokens.</p>\n<p>It could be the case that output amounts are computed for completely different tokens because a wrong pair was provided.</p>\n<h2 id=\"l-03-role-9-in-rolessol\" style=\"position:relative;\"><a href=\"#l-03-role-9-in-rolessol\" aria-label=\"l 03 role 9 in rolessol permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/10\">[L-03] Role 9 in Roles.sol</a></h2>\n<p>Roles.sol contains the following: `roles[msg.sender][9] = true;<code></code></p>\n<p>It’s not clear what the number 9 means. In RoleAware.sol there is a constant with the value 9: <code>uint256 constant TOKEN_ACTIVATOR = 9;</code></p>\n<p>The code is more difficult to read without an explanation for the number 9. In case the code would be refactored in the future and the constants in RoleAware.sol are renumbered, the value in Roles.sol would no longer correspond to the right value.</p>\n<p>Recommend moving the constants from <code>Roles.sol</code> to <code>RoleAware.sol</code> and replace 9 with the appropriate constant.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/10#issuecomment-813037820\">werg (Marginswap) confirmed</a></strong></p>\n<h2 id=\"l-04-multisig-wallets-cant-be-used-for-liquidate\" style=\"position:relative;\"><a href=\"#l-04-multisig-wallets-cant-be-used-for-liquidate\" aria-label=\"l 04 multisig wallets cant be used for liquidate permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/13\">[L-04] Multisig wallets can’t be used for liquidate</a></h2>\n<p>The function liquidate, which is defined in both <code>CrossMarginLiquidation.sol</code> and <code>IsolatedMarginLiquidation.sol</code>, includes the modifier noIntermediary. This modifier prevents the use of Multisig wallets.</p>\n<p>If the maintainer happens to use a multisig wallet they might not experience any issues until they try to call the function liquidate. At that moment they can’t successfully call the function.</p>\n<p>Recommend verifying if the prevention to use multisig wallets is intentional. In that case add a comment to the liquidate functions. If it is not intentional update the code so multisigs wallets can be supported.</p>\n<h2 id=\"l-05-different-solidity-version-in-uniswapstylelibsol\" style=\"position:relative;\"><a href=\"#l-05-different-solidity-version-in-uniswapstylelibsol\" aria-label=\"l 05 different solidity version in uniswapstylelibsol permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/6\">[L-05] Different solidity version in UniswapStyleLib.sol</a></h2>\n<p>The solidity version in UniswapStyleLib.sol (>=0.5.0) is different than the solidity version in the other contracts (e.g. ^0.8.0)\nAlso math actions are present in the functions getAmountOut and getAmountIn that could easily lead to an underflow or division by 0; (note safemath is not used). Note: In solidity 0.8.0 safemath like protections are default.</p>\n<p>The impact is low because UniswapStyleLib is a library and the solidity version of the contract that uses the library is used (e.g. ^0.8.0), which has safemath like protections. It is cleaner to have the same solidity version everywhere.</p>\n<p>getAmountIn(3,1,1000) would give division by 0\ngetAmountIn(1,1,1) will underflow denominator</p>\n<h2 id=\"l-06-sorttokens-can-be-simplified\" style=\"position:relative;\"><a href=\"#l-06-sorttokens-can-be-simplified\" aria-label=\"l 06 sorttokens can be simplified permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/7\">[L-06] sortTokens can be simplified</a></h2>\n<p>The function sortTokens UniswapStyleLib.sol returns 2 values, but only the first return value is used:\n<code>MarginRouter.sol: (address token0, ) = UniswapStyleLib.sortTokens...</code>\n<code>UniswapStyleLib.sol: (address token0, ) = sortTokens..</code></p>\n<p>In both cases the used return value is compared to the first parameter of the function call. Conclusion: the function is only used to determine the smaller of the two tokens, not really to sort tokens.</p>\n<p>Recommend simplifying the code:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"10\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">ASmallerThanB</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">tokenA</span><span class=\"mtk1\">, </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">tokenB</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">internal</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">pure</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">bool</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">{</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">tokenA</span><span class=\"mtk1\"> != </span><span class=\"mtk12\">tokenB</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;Identical address!&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">tokenA</span><span class=\"mtk1\"> != </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">), </span><span class=\"mtk8\">&quot;Zero address!&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">tokenB</span><span class=\"mtk1\"> != </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">), </span><span class=\"mtk8\">&quot;Zero address!&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk12\">tokenA</span><span class=\"mtk1\"> &lt; </span><span class=\"mtk12\">tokenB</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<h2 id=\"l-07-duplicated-code-in-adminviewcurrentmaintenancestaker\" style=\"position:relative;\"><a href=\"#l-07-duplicated-code-in-adminviewcurrentmaintenancestaker\" aria-label=\"l 07 duplicated code in adminviewcurrentmaintenancestaker permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/69\">[L-07] Duplicated Code In Admin.viewCurrentMaintenanceStaker()</a></h2>\n<p>There are four lines of code that are duplicated in <code>viewCurrentMaintenanceStaker</code>.</p>\n<p>Change this:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"11\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">maintenanceStakePerBlock</span><span class=\"mtk1\"> &gt; </span><span class=\"mtk12\">currentStake</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// skip</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">staker</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">nextMaintenanceStaker</span><span class=\"mtk1\">[</span><span class=\"mtk12\">staker</span><span class=\"mtk1\">];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">currentStake</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">getMaintenanceStakerStake</span><span class=\"mtk1\">(</span><span class=\"mtk12\">staker</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">} </span><span class=\"mtk15\">else</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">startBlock</span><span class=\"mtk1\"> += </span><span class=\"mtk12\">currentStake</span><span class=\"mtk1\"> / </span><span class=\"mtk12\">maintenanceStakePerBlock</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">staker</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">nextMaintenanceStaker</span><span class=\"mtk1\">[</span><span class=\"mtk12\">staker</span><span class=\"mtk1\">];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">currentStake</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">getMaintenanceStakerStake</span><span class=\"mtk1\">(</span><span class=\"mtk12\">staker</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p>To this:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"12\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">maintenanceStakePerBlock</span><span class=\"mtk1\"> &lt;= </span><span class=\"mtk12\">currentStake</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">     += </span><span class=\"mtk12\">currentStake</span><span class=\"mtk1\"> / </span><span class=\"mtk12\">maintenanceStakePerBlock</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">staker</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">nextMaintenanceStaker</span><span class=\"mtk1\">[</span><span class=\"mtk12\">staker</span><span class=\"mtk1\">];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">currentStake</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">getMaintenanceStakerStake</span><span class=\"mtk1\">(</span><span class=\"mtk12\">staker</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<h2 id=\"l-08-magic-numbers-used-in-admin_stake-when-constant-defined-above-can-be-used-instead\" style=\"position:relative;\"><a href=\"#l-08-magic-numbers-used-in-admin_stake-when-constant-defined-above-can-be-used-instead\" aria-label=\"l 08 magic numbers used in admin_stake when constant defined above can be used instead permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/71\">[L-08] Magic Numbers used in Admin._stake() When Constant Defined Above Can Be Used Instead</a></h2>\n<p>Magic Numbers are used in <code>Admin.\\_stake()</code>, which both obscure the purpose of the function and unnecessarily lead to potential error if the constants are changed during development. Since they are used to refer to a constant defined in RoleAware, and Admin inherits from RoleAware, then Admin can simply call that constant.</p>\n<p>In <code>Admin.\\_stake()</code>, change this:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"13\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">IncentiveDistribution</span><span class=\"mtk1\">(</span><span class=\"mtk11\">incentiveDistributor</span><span class=\"mtk1\">()).</span><span class=\"mtk11\">addToClaimAmount</span><span class=\"mtk1\">(</span><span class=\"mtk7\">1</span><span class=\"mtk1\">,</span><span class=\"mtk12\">holder</span><span class=\"mtk1\">,</span><span class=\"mtk12\">amount</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p>to this:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"14\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">IncentiveDistribution</span><span class=\"mtk1\">(</span><span class=\"mtk11\">incentiveDistributor</span><span class=\"mtk1\">()).</span><span class=\"mtk11\">addToClaimAmount</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">FUND_TRANSFERER</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">holder</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">amount</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">);</span></span></span></code></pre>\n<h2 id=\"l-09-function-inittranche-should-check-that-the-share-parameter-is--0\" style=\"position:relative;\"><a href=\"#l-09-function-inittranche-should-check-that-the-share-parameter-is--0\" aria-label=\"l 09 function inittranche should check that the share parameter is  0 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/35\">[L-09] function initTranche should check that the share parameter is > 0</a></h2>\n<p>function <code>initTranche</code> should check that the “share” parameter is > 0, otherwise, it may be possible to initialize the same tranche again.</p>\n<h2 id=\"l-10-runtime--1-hours-error-message-discrepancy\" style=\"position:relative;\"><a href=\"#l-10-runtime--1-hours-error-message-discrepancy\" aria-label=\"l 10 runtime  1 hours error message discrepancy permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/36\">[L-10] runtime > 1 hours error message discrepancy</a></h2>\n<p>Here, the revert message says that the value needs to be at least 1 hour, however, the code allows value only above the 1 hour (> instead of >=):\n<code>require(runtime > 1 hours, \"Min runtime needs to be at least 1 hour\");</code></p>\n<p>There is no real impact on security here, just a discrepancy between the check and message.</p>\n<h2 id=\"l-11-setleveragepercent-should-check-that-new-_leveragepercent--100\" style=\"position:relative;\"><a href=\"#l-11-setleveragepercent-should-check-that-new-_leveragepercent--100\" aria-label=\"l 11 setleveragepercent should check that new _leveragepercent  100 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/41\">[L-11] setLeveragePercent should check that new _leveragePercent >= 100</a></h2>\n<p>function <code>setLeveragePercent</code> should check that the <code>\\_leveragePercent >= 100</code> so that this calculation will not fail later:\n<code>(leveragePercent - 100)</code></p>\n<p>This variable can only be set by admin so as long as he sets the appropriate value it should be fine.</p>\n<h2 id=\"l-12-an-erroneous-constructors-argument-could-block-the-withdrawreward\" style=\"position:relative;\"><a href=\"#l-12-an-erroneous-constructors-argument-could-block-the-withdrawreward\" aria-label=\"l 12 an erroneous constructors argument could block the withdrawreward permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/33\">[L-12] An erroneous constructor’s argument could block the withdrawReward</a></h2>\n<p>The constructor of <a href=\"https://github.com/code-423n4/marginswap/blob/main/contracts/IncentiveDistribution.sol#L32\"><code>IncentiveDistribution</code></a> take as argument the address of MFI token but it doesn’t check that is != address(0). Not worth an issue alone but <code>IncentiveDistribution</code> imports <code>IERC20.sol</code> and never uses it.</p>\n<p>In case the address(0) is passed as argument the <code>withdrawReward</code> would fail and due to the fact that <a href=\"%5D(https://github.com/code-423n4/marginswap/blob/main/contracts/IncentiveDistribution.sol#L261)\">MFI is immutable</a> the only solution would be to redeploy the contract meanwhile losing trust from the users.</p>\n<p>Deploy <code>IncentiveDistribution</code> with 0 as <code>\\_MFI argument</code> and then call <code>withdrawReward</code>.</p>\n<h2 id=\"l-13-not-emitting-event-for-important-state-changes\" style=\"position:relative;\"><a href=\"#l-13-not-emitting-event-for-important-state-changes\" aria-label=\"l 13 not emitting event for important state changes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/61\">[L-13] Not emitting event for important state changes</a></h2>\n<p>When changing state variables events are not emitted.</p>\n<p><a href=\"https://github.com/code-423n4/marginswap/blob/main/contracts/PriceAware.sol\">PriceAware</a>:</p>\n<ul>\n<li>setPriceUpdateWindow</li>\n<li>setUpdateRate</li>\n<li>setUpdateMaxPegAmount</li>\n<li>setUpdateMinPegAmount\nLending (<a href=\"https://github.com/code-423n4/marginswap/blob/main/contracts/Lending.sol\">https://github.com/code-423n4/marginswap/blob/main/contracts/Lending.sol</a>):</li>\n<li>activateIssuer</li>\n<li>deactivateIssuer</li>\n<li>setLendingCap</li>\n<li>setLendingBuffer</li>\n<li>setHourlyYieldAPR</li>\n<li>setRuntimeWeights\nIncentiveDistribution (<a href=\"https://github.com/code-423n4/marginswap/blob/main/contracts/IncentiveDistribution.sol#L261\">https://github.com/code-423n4/marginswap/blob/main/contracts/IncentiveDistribution.sol#L261</a>):</li>\n<li>setTrancheShare</li>\n<li>initTranche\nIsolatedMarginTrading and CrossMarginTrading (<a href=\"https://github.com/code-423n4/marginswap/blob/main/contracts/IsolatedMarginTrading.sol\">https://github.com/code-423n4/marginswap/blob/main/contracts/IsolatedMarginTrading.sol</a> - <a href=\"https://github.com/code-423n4/marginswap/blob/main/contracts/CrossMarginTrading.sol\">https://github.com/code-423n4/marginswap/blob/main/contracts/CrossMarginTrading.sol</a>):</li>\n<li>setCoolingOffPeriod</li>\n<li>setLeveragePercent</li>\n<li>setLiquidationThresholdPercent</li>\n</ul>\n<p>The events emitted by <a href=\"https://github.com/code-423n4/marginswap/blob/main/contracts/MarginRouter.sol\">MarginRouter</a> don’t have indexed parameter.</p>\n<p>Recommended mitigation:</p>\n<ul>\n<li>For <code>set... function</code> emit events with old and new value.</li>\n<li>For <code>initTranche</code>, event <code>InitTranche(uint256 tranche, uint256 share)</code>\n0 For <code>activateIssuer</code>, event <code>ActivateIssuer(address issuer, address token)</code>\nFor <code>deactivateIssuer</code>, event <code>DeactivateIssuer(address issuer)</code></li>\n</ul>\n<p>For events emitted by MarginRouter, recommend indexing the trader address to make it filterable.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/61#issuecomment-816218019\">werg (Marginswap)</a>:</strong></p>\n<blockquote>\n<p>We may sprinkle in a few more events before launch, but in the interest of gas savings we try not to emit events for state that can be queried using view functions.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/61#issuecomment-824941755\">zscole commented</a>:</strong></p>\n<blockquote>\n<p>Reducing this from submitted rating of <code>2 (Med Risk)</code> to <code>1 (Low Risk)</code> since it presents no immediate risk to the security of the system, but could have implications on overall functionality.</p>\n</blockquote>\n<h1 id=\"non-critical-findings\" style=\"position:relative;\"><a href=\"#non-critical-findings\" aria-label=\"non critical findings permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Non-Critical Findings</h1>\n<ul>\n<li><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/22\">[N-01] Liquidations can be sandwich attacked</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/31\">[N-02] Unlocked Pragma</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/11\">[N-03] No function for TOKEN_ADMIN in RoleAware.sol</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/12\">[N-04] isStakePenalizer differtent than other functions in RoleAware.sol</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/15\">[N-05] Natspec comments not used in a consistent way</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/16\">[N-06] Function parameter named timestamp</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/17\">[N-07] Naming convention for internal functions not used consistently</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/8\">[N-08] Todo’s left in code</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/66\">[N-09] The First User To Borrow a Particular Token Can Drain Funds In MarginSwap by Making An Undercollateralized Borrow Using Flash Loans</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/34\">[N-10] function crossWithdrawETH does not emit withdraw event</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/42\">[N-11] All caps indicates that the value should be constant</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/43\">[N-12] TODOs left in code</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/44\">[N-13] Consistent function names</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/45\">[N-14] Useless overflow comments</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/46\">[N-15] Variable is declared and initialized with different values</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/47\">[N-16] Code duplication in viewCurrentMaintenanceStaker</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/48\">[N-17] Misleading revert messages</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/49\">[N-18] setUpdateMaxPegAmount and setUpdateMinPegAmount do not check boundaries</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/53\">[N-22] Liquidators may be a subject of front-running attacks</a></li>\n</ul>\n<h1 id=\"gas-optimizations\" style=\"position:relative;\"><a href=\"#gas-optimizations\" aria-label=\"gas optimizations permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Gas Optimizations</h1>\n<ul>\n<li><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/54\">[G-01] Error codes</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/55\">[G-02] Same calculations are done twice</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/56\">[G-03] Unused variables</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/57\">[G-04] Only process value if amount is greater than 0</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/58\">[G-05] Not used imports</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/59\">[G-06] Extract storage variable to a memory variable</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/60\">[G-07] Do not send value if holdingsValue is 0</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-04-marginswap-findings/issues/62\">[G-08] Useless addition of 0</a></li>\n</ul>\n<h1 id=\"disclosures\" style=\"position:relative;\"><a href=\"#disclosures\" aria-label=\"disclosures permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Disclosures</h1>\n<p>C4 is an open organization governed by participants in the community.</p>\n<p>C4 Contests incentivize the discovery of exploits, vulnerabilities, and bugs in smart contracts. Security researchers are rewarded at an increasing rate for finding higher risk issues. Contest submissions are judged by a knowledgeable security researcher and solidity developer and disclosed to sponsoring developers. C4 does not conduct formal verification regarding the provided code, but instead provides final verification.</p>\n<p>C4 does not provide any guarantee or warranty regarding the security of this project. All smart contract software should be used at the sole risk and responsibility of users.</p>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n  .dark-default-dark {\n    background-color: #1E1E1E;\n    color: #D4D4D4;\n  }\n  .dark-default-dark .mtk12 { color: #9CDCFE; }\n  .dark-default-dark .mtk1 { color: #D4D4D4; }\n  .dark-default-dark .mtk11 { color: #DCDCAA; }\n  .dark-default-dark .mtk7 { color: #B5CEA8; }\n  .dark-default-dark .mtk4 { color: #569CD6; }\n  .dark-default-dark .mtk10 { color: #4EC9B0; }\n  .dark-default-dark .mtk3 { color: #6A9955; }\n  .dark-default-dark .mtk8 { color: #CE9178; }\n  .dark-default-dark .mtk15 { color: #C586C0; }\n  .dark-default-dark .grvsc-line-highlighted::before {\n    background-color: var(--grvsc-line-highlighted-background-color, rgba(255, 255, 255, 0.1));\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(255, 255, 255, 0.5));\n  }\n</style>",
  "toc": "<ul>\n<li>\n<p><a href=\"#overview\">Overview</a></p>\n<ul>\n<li><a href=\"#about-c4\">About C4</a></li>\n<li><a href=\"#wardens\">Wardens</a></li>\n</ul>\n</li>\n<li><a href=\"#summary\">Summary</a></li>\n<li><a href=\"#scope\">Scope</a></li>\n<li><a href=\"#severity-criteria\">Severity Criteria</a></li>\n<li>\n<p><a href=\"#high-risk-findings\">High Risk Findings</a></p>\n<ul>\n<li><a href=\"#h-01-re-entrancy-bug-allows-inflating-balance\">[H-01] Re-entrancy bug allows inflating balance</a></li>\n<li><a href=\"#h-02-missing-fromtoken--totoken-check\">[H-02] Missing <code>fromToken != toToken</code> check</a></li>\n<li><a href=\"#h-03-price-feed-can-be-manipulated\">[H-03] Price feed can be manipulated</a></li>\n<li><a href=\"#h-04-inconsistent-usage-of-applyinterest\">[H-04] Inconsistent usage of <code>applyInterest</code></a></li>\n<li><a href=\"#h-05-wrong-liquidation-logic\">[H-05] Wrong liquidation logic</a></li>\n<li><a href=\"#h-06-users-are-credited-more-tokens-when-paying-back-debt-with-registertradeandborrow\">[H-06] Users are credited more tokens when paying back debt with <code>registerTradeAndBorrow</code></a></li>\n<li><a href=\"#h-07-accountholdstoken-is-never-set\">[H-07] <code>account.holdsToken</code> is never set</a></li>\n<li><a href=\"#h-08-rewards-cannot-be-withdrawn\">[H-08] Rewards cannot be withdrawn</a></li>\n<li><a href=\"#h-09-lastupdatedday-not-initialized\">[H-09] lastUpdatedDay not initialized</a></li>\n<li><a href=\"#h-11-impossible-to-call-withdrawreward-fails-due-to-run-out-of-gas\">[H-11] Impossible to call withdrawReward fails due to run out of gas</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#medium-risk-findings\">Medium Risk Findings</a></p>\n<ul>\n<li><a href=\"#m-01-no-default-liquidationthresholdpercent\">[M-01] No default <code>liquidationThresholdPercent</code></a></li>\n<li><a href=\"#m-02-missing-checks-if-pairs-equal-tokens\">[M-02] Missing checks if pairs equal tokens</a></li>\n<li><a href=\"#m-03-no-entry-checks-in-crossswapexacttokensforexacttokens\">[M-03] No entry checks in crossSwap[Exact]TokensFor[Exact]Tokens</a></li>\n<li><a href=\"#m-04-maintainer-can-be-pushed-out\">[M-04] maintainer can be pushed out</a></li>\n<li><a href=\"#m-05-several-function-have-no-entry-check\">[M-05] Several function have no entry check</a></li>\n<li><a href=\"#m-06-users-can-drain-funds-from-marginswap-by-making-undercollateralized-borrows-if-the-price-of-a-token-has-moved-more-than-10-since-the-last-marginswap-borrowliquidation-involving-accounts-holding-that-token\">[M-06] Users Can Drain Funds From MarginSwap By Making Undercollateralized Borrows If The Price Of A Token Has Moved More Than 10% Since The Last MarginSwap Borrow/Liquidation Involving Accounts Holding That Token.</a></li>\n<li><a href=\"#m-07-diffmaxminruntime-gets-default-value-of-0\">[M-07] diffMaxMinRuntime gets default value of 0</a></li>\n<li><a href=\"#m-08-priceaware-uses-prices-from-getamountsout\">[M-08] PriceAware uses prices from getAmountsOut</a></li>\n<li><a href=\"#m-09-isolated-margin-contracts-declare-but-do-not-set-the-value-of-liquidationthresholdpercent\">[M-09] Isolated margin contracts declare but do not set the value of liquidationThresholdPercent</a></li>\n<li><a href=\"#m-10-add-a-timelock-to-functions-that-set-key-variables\">[M-10] Add a timelock to functions that set key variables</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#low-risk-findings\">Low Risk Findings</a></p>\n<ul>\n<li><a href=\"#l-01-events-not-indexed\">[L-01] Events not indexed</a></li>\n<li><a href=\"#l-02-getreserves-does-not-check-if-tokens-match\">[L-02] <code>getReserves</code> does not check if tokens match</a></li>\n<li><a href=\"#l-03-role-9-in-rolessol\">[L-03] Role 9 in Roles.sol</a></li>\n<li><a href=\"#l-04-multisig-wallets-cant-be-used-for-liquidate\">[L-04] Multisig wallets can’t be used for liquidate</a></li>\n<li><a href=\"#l-05-different-solidity-version-in-uniswapstylelibsol\">[L-05] Different solidity version in UniswapStyleLib.sol</a></li>\n<li><a href=\"#l-06-sorttokens-can-be-simplified\">[L-06] sortTokens can be simplified</a></li>\n<li><a href=\"#l-07-duplicated-code-in-adminviewcurrentmaintenancestaker\">[L-07] Duplicated Code In Admin.viewCurrentMaintenanceStaker()</a></li>\n<li><a href=\"#l-08-magic-numbers-used-in-admin_stake-when-constant-defined-above-can-be-used-instead\">[L-08] Magic Numbers used in Admin._stake() When Constant Defined Above Can Be Used Instead</a></li>\n<li><a href=\"#l-09-function-inittranche-should-check-that-the-share-parameter-is--0\">[L-09] function initTranche should check that the share parameter is > 0</a></li>\n<li><a href=\"#l-10-runtime--1-hours-error-message-discrepancy\">[L-10] runtime > 1 hours error message discrepancy</a></li>\n<li><a href=\"#l-11-setleveragepercent-should-check-that-new-_leveragepercent--100\">[L-11] setLeveragePercent should check that new _leveragePercent >= 100</a></li>\n<li><a href=\"#l-12-an-erroneous-constructors-argument-could-block-the-withdrawreward\">[L-12] An erroneous constructor’s argument could block the withdrawReward</a></li>\n<li><a href=\"#l-13-not-emitting-event-for-important-state-changes\">[L-13] Not emitting event for important state changes</a></li>\n</ul>\n</li>\n<li><a href=\"#non-critical-findings\">Non-Critical Findings</a></li>\n<li><a href=\"#gas-optimizations\">Gas Optimizations</a></li>\n<li><a href=\"#disclosures\">Disclosures</a></li>\n</ul>",
  "md": "\n# Overview\n\n## About C4\n\nCode 432n4 (C4) is an open organization that consists of security researchers, auditors, developers, and individuals with domain expertise in the area of smart contracts.\n\nA C4 code contest is an event in which community participants, referred to as Wardens, review, audit, or analyze smart contract logic in exchange for a bounty provided by sponsoring projects.\n\nDuring the code contest outlined in this document, C4 conducted an analysis of Marginswap’s smart contract system written in Solidity. The code contest took place between April 2 and April 7, 2021.\n\n## Wardens\n\n5 Wardens contributed reports to the Marginswap code contest:\n\n- [cmichel](https://twitter.com/cmichelio)\n- [gpersoon](https://twitter.com/gpersoon)\n- [jvaqa](https://twitter.com/jvaqa)\n- [pauliax](https://twitter.com/SolidityDev)\n- [s1mo](https://twitter.com/_smonica_)\n\nThis contest was judged by [Zak Cole](https://twitter.com/0xzak).\n\nFinal report assembled by [sockdrawermoney](https://twitter.com/sockdrawermoney).\n\n# Summary\n\nThe C4 analysis yielded an aggregated total of 64 unique vulnerabilities. All of the issues presented here are linked back to their original finding.\n\nOf these vulnerabilities, 12 received a risk rating in the category of HIGH severity, 12 received a risk rating in the category of MEDIUM severity, and 34 received a risk rating in the category of LOW severity.\n\nC4 analysis also identified an aggregate total of 8 non-critical recommendations.\n\n# Scope\n\nThe code under review can be found within the [C4 code contest repository](https://github.com/code-423n4/2021-04-marginswap) and comprises 19 smart contracts written in the Solidity programming language.\n\n# Severity Criteria\n\nC4 assesses severity of disclosed vulnerabilities according to a methodology based on [OWASP standards](https://owasp.org/www-community/OWASP_Risk_Rating_Methodology).\n\nVulnerabilities are divided into 3 primary risk categories: high, medium, and low.\n\nHigh-level considerations for vulnerabilities span the following key areas when conducting assessments:\n\n- Malicious Input Handling\n- Escalation of privileges\n- Arithmetic\n- Gas use\n\nFurther information regarding the severity criteria referenced throughout the submission review process, please refer to the documentation provided on [the C4 website](https://code423n4.com).\n\n# High Risk Findings\n\n## [[H-01] Re-entrancy bug allows inflating balance](https://github.com/code-423n4/2021-04-marginswap-findings/issues/19)\n\n\nOne can call the `MarginRouter.crossSwapExactTokensForTokens` function first with a fake contract disguised as a token pair:\n`crossSwapExactTokensForTokens(0.0001 WETH, 0, [ATTACKER_CONTRACT], [WETH, WBTC])`. When the amounts are computed by the `amounts = UniswapStyleLib.getAmountsOut(amountIn - fees, pairs, tokens);` call, the attacker contract returns fake reserves that yield 1 WBTC for the tiny input. The resulting amount is credited through `registerTrade`. Afterwards, `_swapExactT4T([0.0001 WETH, 1 WBTC], 0, [ATTACKER_CONTRACT], [WETH, WBTC])` is called with the fake pair and token amounts. At some point `_swap` is called, the starting balance is stored in `startingBalance`, and the attacker contract call allows a re-entrancy:\n\n```solidity\npair.swap(0.0001 WETH, 1 WBTC, FUND, new bytes(0)); // can re-enter here\n```\n\nFrom the ATTACKER_CONTRACT we re-enter the `MarginRouter.crossSwapExactTokensForTokens(30 WETH, 0, WETH_WBTC_PAIR, [WETH, WBTC])` function with the actual WETH <> WBTC pair contract. All checks pass, the FUND receives the actual amount, the outer `_swap` continues execution after the re-entrancy and the `endingBalance >= startingBalance + amounts[amounts.length - 1]` check passes as well because the inner swap successfully deposited these funds. We end up doing 1 real trade but being credited twice the output amount.\n\nThis allows someone to be credited multiples of the actual swap result. This can be repeated many times and finally, all tokens can be stolen.\n\nRecommend adding re-entrancy guards (from OpenZeppelin) to all external functions of `MarginRouter`. There might be several attack vectors of this function as the attacker controls many parameters. The idea of first doing an estimation with `UniswapStyleLib.getAmountsOut(amountIn - fees, pairs, tokens)` and updating the user with these estimated amounts, before doing the actual trade, feels quite vulnerable to me. Consider removing the estimation and only doing the actual trade first, then calling `registerTrade` with the actual trade amounts returned.\n\n## [[H-02] Missing `fromToken != toToken` check](https://github.com/code-423n4/2021-04-marginswap-findings/issues/20)\n\nAttacker calls `MarginRouter.crossSwapExactTokensForTokens` with a fake pair and the same token[0] == token[1].\n`crossSwapExactTokensForTokens(1000 WETH, 0, [ATTACKER_CONTRACT], [WETH, WETH])`. When the amounts are computed by the `amounts = UniswapStyleLib.getAmountsOut(amountIn - fees, pairs, tokens);` call, the attacker contract returns fake reserves that yield 0 output. When `_swapExactT4T` is called, the funds are sent to the fake contract and doing nothing passes all checks in `_swap` call that follows because the `startingBalance` is stored _after_ the initial Fund withdraw to the pair.\n\n```solidity\nfunction _swapExactT4T() {\n  // withdraw happens here\n    Fund(fund()).withdraw(tokens[0], pairs[0], amounts[0]);\n    _swap(amounts, pairs, tokens, fund());\n}\n\nfunction _swap() {\n  uint256 startingBalance = IERC20(outToken).balanceOf(_to);\n  uint256 endingBalance = IERC20(outToken).balanceOf(_to);\n  // passes as startingBalance == endingBalance + 0\n  require(\n      endingBalance >= startingBalance + amounts[amounts.length - 1],\n      \"Defective AMM route; balances don't match\"\n  );\n}\n```\n\nThe full impact is not yet known as `registerTrade` could still fail when subtracting the `inAmount` and adding 0 `outAmount`.\nAt least, this attack is similar to a withdrawal which is supposed to only occur after a certain `coolingOffPeriod` has passed, but this time-lock is circumvented with this attack.\n\nRecommend moving the fund withdrawal to the first pair **after** the `startingBalance` assignment. Check `fromToken != toToken` as cyclical trades (arbitrages) are likely not what margin traders are after. Consider if the same check is required for `registerTradeAndBorrow` / `adjustAmounts` functions.\n\n## [[H-03] Price feed can be manipulated](https://github.com/code-423n4/2021-04-marginswap-findings/issues/21)\n\nAnyone can trigger an update to the price feed by calling `PriceAware.getCurrentPriceInPeg(token, inAmount, forceCurBlock=true)`.\nIf the update window has passed, the price will be computed by simulating a Uniswap-like trade with the amounts.\nThis simulation uses the reserves of the Uniswap pairs which can be changed drastically using flash loans to yield almost arbitrary output amounts, and thus prices. Wrong prices break the core functionality of the contracts such as borrowing on margin, liquidations, etc.\n\nRecommend against using the Uniswap spot price as the real price. Uniswap itself warns against this and instead recommends implementing a [TWAP price oracle](https://uniswap.org/docs/v2/smart-contract-integration/building-an-oracle/) using the `price*CumulativeLast` variables.\n\n## [[H-04] Inconsistent usage of `applyInterest`](https://github.com/code-423n4/2021-04-marginswap-findings/issues/64)\n\nIt is unclear if the function `applyInterest` is supposed to return a new balance with the interest applied or only the accrued interest? There are various usages of it, some calls add the return value to the old amount:\n\n```solidity\nreturn\nbond.amount +\napplyInterest(bond.amount, cumulativeYield, yieldQuotientFP);\nand some not:\n\nbalanceWithInterest = applyInterest(\nbalance,\nyA.accumulatorFP,\nyieldQuotientFP\n);\n```\n\nThis makes the code misbehave and return the wrong values for the balance and accrued interest.\n\nRecommend making it consistent in all cases when calling this function.\n\n## [[H-05] Wrong liquidation logic](https://github.com/code-423n4/2021-04-marginswap-findings/issues/23)\n\nThe `belowMaintenanceThreshold` function decides if a trader can be liquidated:\n\n```solidity\nfunction belowMaintenanceThreshold(CrossMarginAccount storage account)\n    internal\n    returns (bool)\n{\n    uint256 loan = loanInPeg(account, true);\n    uint256 holdings = holdingsInPeg(account, true);\n    // The following should hold:\n    // holdings / loan >= 1.1\n    // =>\n    return 100 * holdings >= liquidationThresholdPercent * loan;\n}\n```\n\nThe inequality in the last equation is wrong because it says the higher the holdings (margin + loan) compared to the loan, the higher the chance of being liquidated. The inverse equality was probably intended `return 100 * holdings <= liquidationThresholdPercent * loan;`. Users that shouldn't be liquidated can be liquidated, and users that should be liquidated cannot get liquidated.\n\n## [[H-06] Users are credited more tokens when paying back debt with `registerTradeAndBorrow`](https://github.com/code-423n4/2021-04-marginswap-findings/issues/24)\n\nThe `registerTradeAndBorrow` is called with the results of a trade (`inAmount`, `outAmount`). It first tries to pay back any debt with the `outAmount`. However, the **full** `outAmount` is credited to the user again as a deposit in the `adjustAmounts(account, tokenFrom, tokenTo, sellAmount, outAmount);` call. As the user pays back their debt and is credited the same amount again, they are essentially credited twice the `outAmount`, making a profit of one `outAmount`. This can be withdrawn and the process can be repeated until the funds are empty.\n\nIn the `adjustAmounts` call, it should only credit `outAmount - extinguishableDebt` as a deposit like in `registerDeposit`.\nThe `registerDeposit` function correctly handles this case.\n\n## [[H-07] `account.holdsToken` is never set](https://github.com/code-423n4/2021-04-marginswap-findings/issues/25)\n\nThe `addHolding` function does not update the `account.holdsToken` map.\n\n```solidity\nfunction addHolding(\n    CrossMarginAccount storage account,\n    address token,\n    uint256 depositAmount\n) internal {\n    if (!hasHoldingToken(account, token)) {\n        // SHOULD SET account.holdsToken here\n        account.holdingTokens.push(token);\n    }\n\n    account.holdings[token] += depositAmount;\n}\n```\n\nThis leads to a critical vulnerability where deposits of the same token keep being pushed to the `account.holdingTokens` array but the sum is correctly updated in `account.holdings[token]`. However, because of the duplicate token in the `holdingTokens` array the same token is counted several times in the `getHoldingAmounts` function:\n\n```solidity\nfunction getHoldingAmounts(address trader)\n    external\n    view\n    override\n    returns (\n        address[] memory holdingTokens,\n        uint256[] memory holdingAmounts\n    )\n{\n    CrossMarginAccount storage account = marginAccounts[trader];\n    holdingTokens = account.holdingTokens;\n\n    holdingAmounts = new uint256[](account.holdingTokens.length);\n    for (uint256 idx = 0; holdingTokens.length > idx; idx++) {\n        address tokenAddress = holdingTokens[idx];\n        // RETURNS SUM OF THE BALANCE FOR EACH TOKEN ENTRY\n        holdingAmounts[idx] = account.holdings[tokenAddress];\n    }\n}\n```\n\nThe `MarginRouter.crossCloseAccount` function uses these wrong amounts to withdraw all tokens:\n\n```solidity\nfunction crossCloseAccount() external {\n    (address[] memory holdingTokens, uint256[] memory holdingAmounts) =\n        IMarginTrading(marginTrading()).getHoldingAmounts(msg.sender);\n\n    // requires all debts paid off\n    IMarginTrading(marginTrading()).registerLiquidation(msg.sender);\n\n    for (uint256 i; holdingTokens.length > i; i++) {\n        Fund(fund()).withdraw(\n            holdingTokens[i],\n            msg.sender,\n            holdingAmounts[i]\n        );\n    }\n}\n```\n\nAn attacker can just deposit the same token X times which increases their balance by X times the actual value.\nThis inflated balance can then be withdrawn to steal all tokens.\n\nRecommend correctly setting the `account.holdsToken` map in `addHolding`.\n\n## [[H-08] Rewards cannot be withdrawn](https://github.com/code-423n4/2021-04-marginswap-findings/issues/26)\n\nThe rewards for a recipient in `IncentiveDistribution.sol` are stored in the storage mapping indexed by recipient `accruedReward[recipient]` and the recipient is the actual margin trader account, see `updateAccruedReward`.\n\nThese rewards are supposed to be withdrawn through the `withdrawReward` function but `msg.sender` is used here instead of a `recipient` (`withdrawer`) parameter.\nHowever, `msg.sender` is enforced to be the incentive reporter and can therefore not be the margin trader.\n\nNobody can withdraw the rewards.\n\nRecommend removing the ` isIncentiveReporter(msg.sender)` check from `withdrawReward` function.\n\n## [[H-09] lastUpdatedDay not initialized](https://github.com/code-423n4/2021-04-marginswap-findings/issues/14)\n\nThe variable lastUpdatedDay in IncentiveDistribution.sol is not (properly) initialized. This means the function updateDayTotals will end up in a very large loop which will lead to an out of gas error. Even if the loop would end, the variable currentDailyDistribution would be updated very often. Thus updateDayTotals cannot be performed.\n\nThe entire IncentiveDistribution does not work. If the loop would stop, the variable currentDailyDistribution is not accurate, resulting in a far lower incentive distribution than expected.\n\nRecommend initializing lastUpdatedDay with something like block.timestamp / (1 days)\n\n```solidity\nuint256 lastUpdatedDay; # ==> lastUpdatedDay = 0\n\n# When the function updateDayTotals is called:\nuint256 public nowDay = block.timestamp / (1 days); #==> ~ 18721\nuint256 dayDiff = nowDay - lastUpdatedDay; #==> 18721-0 = 18721\n\nfor (uint256 i = 0; i < dayDiff; i++) { # very long loop (18721)\ncurrentDailyDistribution = ....\n}\n#will result in an out of gas error\n\n## [[H-10] function buyBond charges msg.sender twice](https://github.com/code-423n4/2021-04-marginswap-findings/issues/38)\n\nfunction buyBond transfers amount from msg.sender twice:\nFund(fund()).depositFor(msg.sender, issuer, amount);\n...\ncollectToken(issuer, msg.sender, amount);\n```\n\n## [[H-11] Impossible to call withdrawReward fails due to run out of gas](https://github.com/code-423n4/2021-04-marginswap-findings/issues/65)\n\nThe withdrawReward (https://github.com/code-423n4/marginswap/blob/main/contracts/IncentiveDistribution.sol#L224) fails due to the loop at https://github.com/code-423n4/marginswap/blob/main/contracts/IncentiveDistribution.sol#L269. Based on testing, the dayDiff would be 18724 and with a gasLimit of 9500000 it stops at iteration 270 due to the fact that lastUpdatedDay is not initialized so is 0. Other than that it could run out of gas also for the loop of allTranches (https://github.com/code-423n4/marginswap/blob/main/contracts/IncentiveDistribution.sol#L281) because it's an unbounded array.\n\nI'm not sure of the logic behind the shrinking of the daily distribution but i think that maybe you just missed to initialize the lastUpdatedDay to the day of deployment? If that's the case it resolves partially the problem because allTranches is theoretically unbounded even though only the owner can add element to it and you should do deeply testing to understand how many elements it can have until it run out of gas. I read the comment that says you tried to shift the gas to the withdrawal people maybe you went too further and is it worth rethinking the design?\n\n**[werg (Marginswap) confirmed](https://github.com/code-423n4/2021-04-marginswap-findings/issues/65#issuecomment-816212433):**\n\n> Exactly. we need to initialize lastUpdatedDay.\n\n# Medium Risk Findings\n\n## [[M-01] No default `liquidationThresholdPercent`](https://github.com/code-423n4/2021-04-marginswap-findings/issues/28)\n\nThe `IsolatedMarginTrading` contract does not define a default `liquidationThresholdPercent` which means it is set to 0. The `belowMaintenanceThreshold` function uses this value and anyone could be liquidated due to `100 * holdings >= liquidationThresholdPercent * loan = 0` being always true.\n\nAnyone can be liquidated immediately. If the faulty `belowMaintenanceThreshold` function is fixed (see other issue), then nobody could be liquidated which is bad as well.\n\nRecommend setting a default liquidation threshold like in `CrossMarginTrading` contracts.\n\n## [[M-02] Missing checks if pairs equal tokens](https://github.com/code-423n4/2021-04-marginswap-findings/issues/29)\n\nThe `UniswapStyleLib.getAmountsOut`, `PriceAware.setLiquidationPath` (and others) don't check that `path.length + 1 == tokens.length` which should always hold true. Also, it does not check that the tokens actually match the pair. It's easy to set faulty liquidation paths which then end up reverting the liquidation transactions.\n\n## [[M-03] No entry checks in crossSwap[Exact]TokensFor[Exact]Tokens](https://github.com/code-423n4/2021-04-marginswap-findings/issues/4)\n\nThe functions crossSwapTokensForExactTokens and crossSwapExactTokensForTokens of MarginRouter.sol do not check who is calling the function. They also do not check the contents of pairs and tokens nor do they check if the size of pairs and tokens is the same.\n\n`registerTradeAndBorrow` within `registerTrade` does seem to do an entry check (require(isMarginTrader(msg.sender)...) however as this is an external function msg.sender is the address of MarginRouter.sol, which will verify ok.\n\nCalling these functions allow the caller to trade on behalf of marginswap, which could result in losing funds. It's possible to construct all parameters to circumvent the checks. Also the \"pairs\" can be fully specified; they are contract addresses that are called from getAmountsIn / getAmountsOut and from pair.swap. This way you can call arbitrary (self constructed) code, which can reentrantly call the marginswap code.\n\nRecommend limiting who can call the functions. Perhaps whitelist contents of pairs and tokens. Check the size of pairs and tokens is the same.\n\n**[werg (Marginswap) confirmed](https://github.com/code-423n4/2021-04-marginswap-findings/issues/4#issuecomment-813047489):**\n\n> This has merit: particularly the part about self-constructed pairs. We either need much more rigorous checks or a a process for vetting & approving pairs. The latter is likely more gas efficient.\n\n## [[M-04] maintainer can be pushed out](https://github.com/code-423n4/2021-04-marginswap-findings/issues/5)\n\nThe function liquidate (in both `CrossMarginLiquidation.sol` and `IsolatedMarginLiquidation.sol`) can be called by everyone. If an attacker calls this repeatedly then the maintainer will be punished and eventually be reported as maintainerIsFailing\nAnd then the attacker can take the payouts.\n\nWhen a non authorized address repeatedly calls liquidate then the following happens: `isAuthorized = false` which means `maintenanceFailures[currentMaintainer]` increases. After sufficient calls it will be higher than the threshold and then\n`maintainerIsFailing()` will be true. This results in `canTakeNow` being true, which finally means the following will be executed:\n\n`Fund(fund()).withdraw(PriceAware.peg, msg.sender, maintainerCut);`\n\nAn attacker can push out a maintainer and take over the liquidation revenues.\n\nRecommend put authorization on who can call the liquidate function, review the maintainer punishment scheme.\n\n**[werg (Marginswap) disputed](https://github.com/code-423n4/2021-04-marginswap-findings/issues/5#issuecomment-813044805):**\n\n> I believe this issue is not a vulnerability, due to the checks in lines 326-335. Even if someone comes in first and claims the maintainer is failing they can do their job in the same or next block and get all / most of their failure record extinguished.\n\n**[zscole (Judge)](https://github.com/code-423n4/2021-04-marginswap-findings/issues/5#issuecomment-824102934):**\n\n> Acknowledging feedback from @werg, but maintaining the reported risk level of `medium` since this has implications on token logic.\n\n## [[M-05] Several function have no entry check](https://github.com/code-423n4/2021-04-marginswap-findings/issues/9)\n\nThe following functions have no entry check or a trivial entry check:\n\n```solidity\nwithdrawHourlyBond Lending.sol\ncloseHourlyBondAccount Lending.sol\nhaircut Lending.sol\naddDelegate(own adress...) Admin.sol\nremoveDelegate(own adress...) Admin.sol\ndepositStake Admin.sol\ndisburseLiqStakeAttacks CrossMarginLiquidation.sol\ndisburseLiqStakeAttacks IsolatedMarginLiquidation.sol\ngetCurrentPriceInPeg PriceAware.sol\n```\n\nBy manipulating the input values (for example extremely large values), you might be able to disturb the internal administration of the contract, thus perhaps locking function or giving wrong rates.\n\nRecommend checking the functions to see if they are completely risk free and add entry checks if they are not, and add a comment to notify the function is meant to be called by everyone.\n\n**[werg (Marginswap)](https://github.com/code-423n4/2021-04-marginswap-findings/issues/9#issuecomment-813043345):**\n\n> - `withdrawHourlyBond`: could not find vulnerability, since solidity 0.8.x fails on underflow in HourlyBondSubscriptionLending.sol:115 in case of unauthorized access.\n> - `closeHourlyBondAccount`: same story since both call into `_withdrawHourlyBond`\n> - `haircut`: trivially guarded in one way, though this actually has merit in another way -- if at some point down the road an attacker were able to establish a token, make it popular enough for us to add it to cross margin, but include in that token contract a malicious function that calls haircut, they could then void everybody's bonds in their token. I don't see how it would be profitable, it's definitely an expensive long con, but... we should add an extra guard to make sure it's an isolated margin trading contract.\n> - `addDelegate` has a guard.\n> - `removeDelegate` has a guard as well, or am I missing something here?\n> - `depositStake` fails for unfunded requests in the safe transfer in `Fund.depositFor`\n> - `disburseLiqStakeAttacks` should be universally accessible by design\n> - `getCurrentPriceInPeg` only updates state in a rate limited way, hence fine for it to be public\n>\n> I will add comments to the effect. Thanks again\n\n## [[M-06] Users Can Drain Funds From MarginSwap By Making Undercollateralized Borrows If The Price Of A Token Has Moved More Than 10% Since The Last MarginSwap Borrow/Liquidation Involving Accounts Holding That Token.](https://github.com/code-423n4/2021-04-marginswap-findings/issues/67)\n\nUsers Can Drain Funds From MarginSwap By Making Undercollateralized Borrows If The Price Of A Token Has Moved More Than 10% Since The Last MarginSwap Borrow/Liquidation Involving Accounts Holding That Token.\n\nMarginSwap's internal price oracle is only updated for a particular token if a borrow or liquidation is attempted for an account that is lending/borrowing that particular token.\n\nFor a less popular token, the price could move quite a bit without any borrow or liquidation being called on any account lending/borrowing that token, especially if MarginSwap does not end up being wildly popular, or if it supports lesser known assets.\nIf the Uniswap price has moved more than 10% (liquidationThresholdPercent - 100) without a borrow or liquidation on an account lending/borrowing that particular token occurring on MarginSwap, then Alice can make undercollateralized loans, leaving behind her collateral and draining funds from the contract.\n\n(1) Alice waits for the Uniswap price for any token to move more than 10% (liquidationThresholdPercent - 100) without a borrow or liquidation occurring for any account lending/borrowing that token occurring on MarginSwap.\n(2) When this condition is satisfied, Alice can loop the following actions:\n(2.1) If the price has fallen, Alice can use the token as collateral (making sure to use more than UPDATE_MAX_PEG_AMOUNT worth of the token in ETH), borrow ether from MarginSwap, sell the ether for the token on Uniswap, and repeat, leaving coolingOffPeriod blocks between each lend and borrow.\n(2.2) If the price has risen, Alice can use ether as collateral, borrow the token from MarginSwap (making sure to use more than UPDATE_MAX_PEG_AMOUNT worth of the token in ETH), sell the token for ether on Uniswap, and repeat, leaving coolingOffPeriod blocks between each lend and borrow.\n\nBecause the MarginSwap price is now stale, Alice can borrow more than 100% of the actual value of her collateral, since MarginSwap believes the borrowed funds to only be worth 90% or less than their actual current market value.\n\nThe various defenses that MarginSwap has employed against undercollateralized loans are all bypassed:\n(a) The exponential moving price average stored within MarginSwap is not updated, because Alice borrows at least UPDATE_MAX_PEG_AMOUNT worth of the token in ETH, so MarginSwap.PriceAware.getPriceFromAMM skips the price update due to the \"outAmount < UPDATE_MAX_PEG_AMOUNT\" condition failing.\n(b) CoolingOffPeriod can be bypassed by Alice splitting her deposits and borrows up by 20 blocks (the current value of CoolingOffPeriod). Since deposits do not trigger a price oracle update, Alice can even deposit ahead of time as the price is nearing 10% off of peg, allowing her to perform the borrow right when 10% is passed.\n(c) MarginSwap.Lending.registerBorrow check is bypassed. The check is \"meta.totalLending >= meta.totalBorrowed\", but this is a global check that only ensures that the contract as a whole has sufficient tokens to fund Alice's borrow. Alice simply needs to ensure that she only borrows up to the amount of tokens that the contract currently owns.\n\nEven if the issue of the price oracle stalling were to be fixed by using a large enough UPDATE_MAX_PEG_AMOUNT, since the moving average updates so slowly (MarginSwap is currently set at moving 8/1000th towards new price every 8 blocks) and only when actions are taken on MarginSwap (which may not be frequent on lesser known tokens or if MarginSwap is not too popular), Alice can still take out undercollateralized loans for a period of time before the price oracle catches up.\nThe real solution here is to use UniswapV2/SushiSwap/UniswapV3's built in TWAP price oracle, especially since MarginSwap is built on top of Uniswap/Sushiswap.\n\n**[werg (Marginswap) acknowledged](https://github.com/code-423n4/2021-04-marginswap-findings/issues/67#issuecomment-816204245):**\n\n> I believe the issue above is referring to the \"overcollateralized borrow\" functionality, because there is talk of withdrawing. In any case of withdrawal (whether immediately or not) it is not the `liquidationThresholdPercent` which governs how much a user may withdraw. Rather, we check whether the account has positive balance (i.e. the value of assets exceeds the loan).\n>\n> In the current system, at 3x possible leverage level, users can withdraw maximally 66% of the face value (to the system) they deposited. If a user deposited collateral that had dropped in price by 10% it would allow them to withdraw around 73% of the real value. -- Not undercollateralized.\n> The price of an asset would have to have dropped by 33%, without the system catching on, for Alice to break even (without considering gas cost).\n>\n> Cross margin trading will only be available for a select set of tokens with high enough trading volume. Anyone will be able to update the price if our exponential weighted average is out of date.\n> Nevertheless, risk remains as in any lending system.\n>\n> - We will consider adding an additional buffer around immediate withdrawals\n> - If staleness becomes an issue the protocol can institute rewards for updating the price\n>\n> also of course there are liquidators waiting in the wings to make their cut on underwater accounts and liquidators can update the price.\n\n## [[M-07] diffMaxMinRuntime gets default value of 0](https://github.com/code-423n4/2021-04-marginswap-findings/issues/37)\n\n` uint256 public diffMaxMinRuntime;`` This variable is never set nor updated so it gets a default value of 0.  `diffMaxMinRuntime` with 0 value is making the calculations that use it either always return 0 (when multiplying) or fail (when dividing) when calculating bucket indexes or sizes.\n\nRecommend setting the appropriate value for diffMaxMinRuntime and update it whenever min or max runtime variables change.\n\n## [[M-08] PriceAware uses prices from getAmountsOut](https://github.com/code-423n4/2021-04-marginswap-findings/issues/39)\n\n`getPriceFromAMM` relies on values returned from getAmountsOut which can be manipulated (e.g. with the large capital or the help of flash loans). The impact is reduced with UPDATE_MIN_PEG_AMOUNT and UPDATE_MAX_PEG_AMOUNT, however, it is not entirely eliminated.\n\nUniswap v2 recommends using their TWAP oracle: https://uniswap.org/docs/v2/core-concepts/oracles/\n\n## [[M-09] Isolated margin contracts declare but do not set the value of liquidationThresholdPercent](https://github.com/code-423n4/2021-04-marginswap-findings/issues/40)\n\nCrossMarginTrading sets value of liquidationThresholdPercent in the constructor: `liquidationThresholdPercent = 110;` Isolated margin contracts declare but do not set the value of liquidationThresholdPercent.\n\nRecommend setting the initial value for the liquidationThresholdPercent in Isolated margin contracts.\n\nThis makes function belowMaintenanceThreshold to always return true unless a value is set via function setLiquidationThresholdPercent. Comments indicate that the value should also be set to 110:\n\n```solidity\n// The following should hold:\n// holdings / loan >= 1.1\n// => holdings >= loan \\* 1.1\n```\n\n## [[M-10] Add a timelock to functions that set key variables](https://github.com/code-423n4/2021-04-marginswap-findings/issues/70)\n\nFunctions like `setLeveragePercent` and `setLiquidationThresholdPercent` for both [`IsolatedMarginTrading`](https://github.com/code-423n4/marginswap/blob/main/contracts/IsolatedMarginTrading.sol) and [`CrossMarginTrading`](https://github.com/code-423n4/marginswap/blob/main/contracts/CrossMarginTrading.sol) should be put behind a timelock because they would give more trust to users. Currently, the owner could call them whenever they want and a position could become liquidable from a block to the other.\n\n**[werg (Marginswap) acknowledged](https://github.com/code-423n4/2021-04-marginswap-findings/issues/70#issuecomment-816168032):**\n\n> Timelock will be handled by governance\n\n**[zscole commented](https://github.com/code-423n4/2021-04-marginswap-findings/issues/70#issuecomment-824944141):**\n\n> Maintaining submission rating of `2 (Med Risk)` because this presents a vulnerability at the time of review.\n\n# Low Risk Findings\n\n## [[L-01] Events not indexed](https://github.com/code-423n4/2021-04-marginswap-findings/issues/27)\n\nThe `CrossDeposit`, `CrossTrade`, `CrossWithdraw`, `CrossBorrow`, `CrossOvercollateralizedBorrow` events in `MarginRouter` are not indexed. Off-chain scripts cannot efficiently filter these events.\n\nRecommend adding an index on important arguments like `trader`.\n\n## [[L-02] `getReserves` does not check if tokens match](https://github.com/code-423n4/2021-04-marginswap-findings/issues/30)\n\nThe `UniswapStyleLib.getReserves` function does not check if the tokens are the pair's underlying tokens.\nIt blindly assumes that the tokens are in the wrong order if the first one does not match but they could also be completely different tokens.\n\nIt could be the case that output amounts are computed for completely different tokens because a wrong pair was provided.\n\n## [[L-03] Role 9 in Roles.sol](https://github.com/code-423n4/2021-04-marginswap-findings/issues/10)\n\nRoles.sol contains the following: `roles[msg.sender][9] = true;``\n\nIt's not clear what the number 9 means. In RoleAware.sol there is a constant with the value 9: `uint256 constant TOKEN_ACTIVATOR = 9;`\n\nThe code is more difficult to read without an explanation for the number 9. In case the code would be refactored in the future and the constants in RoleAware.sol are renumbered, the value in Roles.sol would no longer correspond to the right value.\n\nRecommend moving the constants from `Roles.sol` to `RoleAware.sol` and replace 9 with the appropriate constant.\n\n**[werg (Marginswap) confirmed](https://github.com/code-423n4/2021-04-marginswap-findings/issues/10#issuecomment-813037820)**\n\n## [[L-04] Multisig wallets can't be used for liquidate](https://github.com/code-423n4/2021-04-marginswap-findings/issues/13)\n\nThe function liquidate, which is defined in both `CrossMarginLiquidation.sol` and `IsolatedMarginLiquidation.sol`, includes the modifier noIntermediary. This modifier prevents the use of Multisig wallets.\n\nIf the maintainer happens to use a multisig wallet they might not experience any issues until they try to call the function liquidate. At that moment they can't successfully call the function.\n\nRecommend verifying if the prevention to use multisig wallets is intentional. In that case add a comment to the liquidate functions. If it is not intentional update the code so multisigs wallets can be supported.\n\n## [[L-05] Different solidity version in UniswapStyleLib.sol](https://github.com/code-423n4/2021-04-marginswap-findings/issues/6)\n\nThe solidity version in UniswapStyleLib.sol (>=0.5.0) is different than the solidity version in the other contracts (e.g. ^0.8.0)\nAlso math actions are present in the functions getAmountOut and getAmountIn that could easily lead to an underflow or division by 0; (note safemath is not used). Note: In solidity 0.8.0 safemath like protections are default.\n\nThe impact is low because UniswapStyleLib is a library and the solidity version of the contract that uses the library is used (e.g. ^0.8.0), which has safemath like protections. It is cleaner to have the same solidity version everywhere.\n\ngetAmountIn(3,1,1000) would give division by 0\ngetAmountIn(1,1,1) will underflow denominator\n\n## [[L-06] sortTokens can be simplified](https://github.com/code-423n4/2021-04-marginswap-findings/issues/7)\n\nThe function sortTokens UniswapStyleLib.sol returns 2 values, but only the first return value is used:\n`MarginRouter.sol: (address token0, ) = UniswapStyleLib.sortTokens...`\n`UniswapStyleLib.sol: (address token0, ) = sortTokens..`\n\nIn both cases the used return value is compared to the first parameter of the function call. Conclusion: the function is only used to determine the smaller of the two tokens, not really to sort tokens.\n\nRecommend simplifying the code:\n\n```solidity\nfunction ASmallerThanB(address tokenA, address tokenB)\ninternal\npure\nreturns (bool)\n{\n    require(tokenA != tokenB, \"Identical address!\");\n    require(tokenA != address(0), \"Zero address!\");\n    require(tokenB != address(0), \"Zero address!\");\n    return tokenA < tokenB;\n}\n```\n\n## [[L-07] Duplicated Code In Admin.viewCurrentMaintenanceStaker()](https://github.com/code-423n4/2021-04-marginswap-findings/issues/69)\n\nThere are four lines of code that are duplicated in `viewCurrentMaintenanceStaker`.\n\nChange this:\n\n```solidity\nif (maintenanceStakePerBlock > currentStake) {\n    // skip\n    staker = nextMaintenanceStaker[staker];\n    currentStake = getMaintenanceStakerStake(staker);\n} else {\n    startBlock += currentStake / maintenanceStakePerBlock;\n    staker = nextMaintenanceStaker[staker];\n    currentStake = getMaintenanceStakerStake(staker);\n}\n```\n\nTo this:\n\n```solidity\nif (maintenanceStakePerBlock <= currentStake) {\n     += currentStake / maintenanceStakePerBlock;\n}\nstaker = nextMaintenanceStaker[staker];\ncurrentStake = getMaintenanceStakerStake(staker);\n```\n\n## [[L-08] Magic Numbers used in Admin.\\_stake() When Constant Defined Above Can Be Used Instead](https://github.com/code-423n4/2021-04-marginswap-findings/issues/71)\n\nMagic Numbers are used in `Admin.\\_stake()`, which both obscure the purpose of the function and unnecessarily lead to potential error if the constants are changed during development. Since they are used to refer to a constant defined in RoleAware, and Admin inherits from RoleAware, then Admin can simply call that constant.\n\nIn `Admin.\\_stake()`, change this:\n\n```solidity\nIncentiveDistribution(incentiveDistributor()).addToClaimAmount(1,holder,amount);\n```\n\nto this:\n\n```solidity\nIncentiveDistribution(incentiveDistributor()).addToClaimAmount(\nFUND_TRANSFERER,\nholder,\namount\n);\n```\n\n## [[L-09] function initTranche should check that the share parameter is > 0](https://github.com/code-423n4/2021-04-marginswap-findings/issues/35)\n\nfunction `initTranche` should check that the \"share\" parameter is > 0, otherwise, it may be possible to initialize the same tranche again.\n\n## [[L-10] runtime > 1 hours error message discrepancy](https://github.com/code-423n4/2021-04-marginswap-findings/issues/36)\n\nHere, the revert message says that the value needs to be at least 1 hour, however, the code allows value only above the 1 hour (> instead of >=):\n`require(runtime > 1 hours, \"Min runtime needs to be at least 1 hour\");`\n\nThere is no real impact on security here, just a discrepancy between the check and message.\n\n## [[L-11] setLeveragePercent should check that new \\_leveragePercent >= 100](https://github.com/code-423n4/2021-04-marginswap-findings/issues/41)\n\nfunction `setLeveragePercent` should check that the `\\_leveragePercent >= 100` so that this calculation will not fail later:\n`(leveragePercent - 100)`\n\nThis variable can only be set by admin so as long as he sets the appropriate value it should be fine.\n\n## [[L-12] An erroneous constructor's argument could block the withdrawReward](https://github.com/code-423n4/2021-04-marginswap-findings/issues/33)\n\nThe constructor of [`IncentiveDistribution`](https://github.com/code-423n4/marginswap/blob/main/contracts/IncentiveDistribution.sol#L32) take as argument the address of MFI token but it doesn't check that is != address(0). Not worth an issue alone but `IncentiveDistribution` imports `IERC20.sol` and never uses it.\n\nIn case the address(0) is passed as argument the `withdrawReward` would fail and due to the fact that [MFI is immutable](<](https://github.com/code-423n4/marginswap/blob/main/contracts/IncentiveDistribution.sol#L261)>) the only solution would be to redeploy the contract meanwhile losing trust from the users.\n\nDeploy `IncentiveDistribution` with 0 as `\\_MFI argument` and then call `withdrawReward`.\n\n## [[L-13] Not emitting event for important state changes](https://github.com/code-423n4/2021-04-marginswap-findings/issues/61)\n\nWhen changing state variables events are not emitted.\n\n[PriceAware](https://github.com/code-423n4/marginswap/blob/main/contracts/PriceAware.sol):\n\n- setPriceUpdateWindow\n- setUpdateRate\n- setUpdateMaxPegAmount\n- setUpdateMinPegAmount\n  Lending (https://github.com/code-423n4/marginswap/blob/main/contracts/Lending.sol):\n- activateIssuer\n- deactivateIssuer\n- setLendingCap\n- setLendingBuffer\n- setHourlyYieldAPR\n- setRuntimeWeights\n  IncentiveDistribution (https://github.com/code-423n4/marginswap/blob/main/contracts/IncentiveDistribution.sol#L261):\n- setTrancheShare\n- initTranche\n  IsolatedMarginTrading and CrossMarginTrading (https://github.com/code-423n4/marginswap/blob/main/contracts/IsolatedMarginTrading.sol - https://github.com/code-423n4/marginswap/blob/main/contracts/CrossMarginTrading.sol):\n- setCoolingOffPeriod\n- setLeveragePercent\n- setLiquidationThresholdPercent\n\nThe events emitted by [MarginRouter](https://github.com/code-423n4/marginswap/blob/main/contracts/MarginRouter.sol) don't have indexed parameter.\n\nRecommended mitigation:\n\n- For `set... function` emit events with old and new value.\n- For `initTranche`, event `InitTranche(uint256 tranche, uint256 share)`\n  0 For `activateIssuer`, event `ActivateIssuer(address issuer, address token)`\n  For `deactivateIssuer`, event `DeactivateIssuer(address issuer)`\n\nFor events emitted by MarginRouter, recommend indexing the trader address to make it filterable.\n\n**[werg (Marginswap)](https://github.com/code-423n4/2021-04-marginswap-findings/issues/61#issuecomment-816218019):**\n\n> We may sprinkle in a few more events before launch, but in the interest of gas savings we try not to emit events for state that can be queried using view functions.\n\n**[zscole commented](https://github.com/code-423n4/2021-04-marginswap-findings/issues/61#issuecomment-824941755):**\n\n> Reducing this from submitted rating of `2 (Med Risk)` to `1 (Low Risk)` since it presents no immediate risk to the security of the system, but could have implications on overall functionality.\n\n# Non-Critical Findings\n\n- [[N-01] Liquidations can be sandwich attacked](https://github.com/code-423n4/2021-04-marginswap-findings/issues/22)\n- [[N-02] Unlocked Pragma](https://github.com/code-423n4/2021-04-marginswap-findings/issues/31)\n- [[N-03] No function for TOKEN_ADMIN in RoleAware.sol](https://github.com/code-423n4/2021-04-marginswap-findings/issues/11)\n- [[N-04] isStakePenalizer differtent than other functions in RoleAware.sol](https://github.com/code-423n4/2021-04-marginswap-findings/issues/12)\n- [[N-05] Natspec comments not used in a consistent way](https://github.com/code-423n4/2021-04-marginswap-findings/issues/15)\n- [[N-06] Function parameter named timestamp](https://github.com/code-423n4/2021-04-marginswap-findings/issues/16)\n- [[N-07] Naming convention for internal functions not used consistently](https://github.com/code-423n4/2021-04-marginswap-findings/issues/17)\n- [[N-08] Todo's left in code](https://github.com/code-423n4/2021-04-marginswap-findings/issues/8)\n- [[N-09] The First User To Borrow a Particular Token Can Drain Funds In MarginSwap by Making An Undercollateralized Borrow Using Flash Loans](https://github.com/code-423n4/2021-04-marginswap-findings/issues/66)\n- [[N-10] function crossWithdrawETH does not emit withdraw event](https://github.com/code-423n4/2021-04-marginswap-findings/issues/34)\n- [[N-11] All caps indicates that the value should be constant](https://github.com/code-423n4/2021-04-marginswap-findings/issues/42)\n- [[N-12] TODOs left in code](https://github.com/code-423n4/2021-04-marginswap-findings/issues/43)\n- [[N-13] Consistent function names](https://github.com/code-423n4/2021-04-marginswap-findings/issues/44)\n- [[N-14] Useless overflow comments](https://github.com/code-423n4/2021-04-marginswap-findings/issues/45)\n- [[N-15] Variable is declared and initialized with different values](https://github.com/code-423n4/2021-04-marginswap-findings/issues/46)\n- [[N-16] Code duplication in viewCurrentMaintenanceStaker](https://github.com/code-423n4/2021-04-marginswap-findings/issues/47)\n- [[N-17] Misleading revert messages](https://github.com/code-423n4/2021-04-marginswap-findings/issues/48)\n- [[N-18] setUpdateMaxPegAmount and setUpdateMinPegAmount do not check boundaries](https://github.com/code-423n4/2021-04-marginswap-findings/issues/49)\n- [[N-22] Liquidators may be a subject of front-running attacks](https://github.com/code-423n4/2021-04-marginswap-findings/issues/53)\n\n# Gas Optimizations\n\n- [[G-01] Error codes](https://github.com/code-423n4/2021-04-marginswap-findings/issues/54)\n- [[G-02] Same calculations are done twice](https://github.com/code-423n4/2021-04-marginswap-findings/issues/55)\n- [[G-03] Unused variables](https://github.com/code-423n4/2021-04-marginswap-findings/issues/56)\n- [[G-04] Only process value if amount is greater than 0](https://github.com/code-423n4/2021-04-marginswap-findings/issues/57)\n- [[G-05] Not used imports](https://github.com/code-423n4/2021-04-marginswap-findings/issues/58)\n- [[G-06] Extract storage variable to a memory variable](https://github.com/code-423n4/2021-04-marginswap-findings/issues/59)\n- [[G-07] Do not send value if holdingsValue is 0](https://github.com/code-423n4/2021-04-marginswap-findings/issues/60)\n- [[G-08] Useless addition of 0](https://github.com/code-423n4/2021-04-marginswap-findings/issues/62)\n\n# Disclosures\n\nC4 is an open organization governed by participants in the community.\n\nC4 Contests incentivize the discovery of exploits, vulnerabilities, and bugs in smart contracts. Security researchers are rewarded at an increasing rate for finding higher risk issues. Contest submissions are judged by a knowledgeable security researcher and solidity developer and disclosed to sponsoring developers. C4 does not conduct formal verification regarding the provided code, but instead provides final verification.\n\nC4 does not provide any guarantee or warranty regarding the security of this project. All smart contract software should be used at the sole risk and responsibility of users.\n"
}