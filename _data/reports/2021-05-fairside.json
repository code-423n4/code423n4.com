{
  "circa": {
    "title": "FairSide",
    "sponsor": "FairSide",
    "slug": "2021-05-fairside",
    "date": "2021-07-07",
    "findings": "https://github.com/code-423n4/2021-05-fairside-findings/issues",
    "contest": 11
  },
  "html": "<h1 id=\"overview\" style=\"position:relative;\"><a href=\"#overview\" aria-label=\"overview permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Overview</h1>\n<h2 id=\"about-c4\" style=\"position:relative;\"><a href=\"#about-c4\" aria-label=\"about c4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>About C4</h2>\n<p>Code 432n4 (C4) is an open organization consisting of security researchers, auditors, developers, and individuals with domain expertise in smart contracts.</p>\n<p>A C4 code contest is an event in which community participants, referred to as Wardens, review, audit, or analyze smart contract logic in exchange for a bounty provided by sponsoring projects.</p>\n<p>During the code contest outlined in this document, C4 conducted an analysis of the FairSide smart contract system written in Solidity. The code contest took place between May 20 and May 26, 2021.</p>\n<h2 id=\"wardens\" style=\"position:relative;\"><a href=\"#wardens\" aria-label=\"wardens permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Wardens</h2>\n<p>8 Wardens contributed reports to the FairSide code contest:</p>\n<ul>\n<li><a href=\"https://twitter.com/cmichelio\">cmichel</a></li>\n<li><a href=\"https://github.com/x9453\">shw</a></li>\n<li><a href=\"https://twitter.com/0xRajeev\">0xRajeev</a></li>\n<li><a href=\"https://twitter.com/a_delamo\">a_delamo</a></li>\n<li><a href=\"https://twitter.com/SolidityDev\">Thunder</a></li>\n<li><a href=\"https://twitter.com/gpersoon\">gpersoon</a></li>\n<li><a href=\"https://twitter.com/MukeshJ_eth\">Jmukesh</a></li>\n<li><a href=\"https://twitter.com/_smonica_\">s1m0</a></li>\n</ul>\n<p>This contest was judged by <a href=\"https://twitter.com/cemozer_\">Cem</a>.</p>\n<p>Final report assembled by <a href=\"https://twitter.com/_ninek_\">ninek</a> and <a href=\"https://twitter.com/money_lego\">moneylegobatman</a>.</p>\n<h1 id=\"summary\" style=\"position:relative;\"><a href=\"#summary\" aria-label=\"summary permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Summary</h1>\n<p>The C4 analysis yielded an aggregated total of 45 unique vulnerabilities. All of the issues presented here are linked back to their original finding.</p>\n<p>Of these vulnerabilities, 8 received a risk rating in the category of HIGH severity, 12 received a risk rating in the category of MEDIUM severity, and 7 received a risk rating in the category of LOW severity.</p>\n<p>C4 analysis also identified 18 non-critical recommendations.</p>\n<h1 id=\"scope\" style=\"position:relative;\"><a href=\"#scope\" aria-label=\"scope permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Scope</h1>\n<p>The code under review can be found within the <a href=\"https://github.com/code-423n4/2021-05-fairside\">C4 code contest repository</a> and comprises 21 smart contracts written in the Solidity programming language.</p>\n<h1 id=\"severity-criteria\" style=\"position:relative;\"><a href=\"#severity-criteria\" aria-label=\"severity criteria permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Severity Criteria</h1>\n<p>C4 assesses the severity of disclosed vulnerabilities according to a methodology based on <a href=\"https://owasp.org/www-community/OWASP_Risk_Rating_Methodology\">OWASP standards</a>.</p>\n<p>Vulnerabilities are divided into three primary risk categories: high, medium, and low.</p>\n<p>High-level considerations for vulnerabilities span the following key areas when conducting assessments:</p>\n<ul>\n<li>Malicious Input Handling</li>\n<li>Escalation of privileges</li>\n<li>Arithmetic</li>\n<li>Gas use</li>\n</ul>\n<p>Further information regarding the severity criteria referenced throughout the submission review process, please refer to the documentation provided on <a href=\"https://code423n4.com\">the C4 website</a>.</p>\n<h1 id=\"high-risk-findings\" style=\"position:relative;\"><a href=\"#high-risk-findings\" aria-label=\"high risk findings permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>High Risk Findings</h1>\n<h2 id=\"h-01-conviction-scoring-fails-to-initialize-and-bootstrap\" style=\"position:relative;\"><a href=\"#h-01-conviction-scoring-fails-to-initialize-and-bootstrap\" aria-label=\"h 01 conviction scoring fails to initialize and bootstrap permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/26\">[H-01] Conviction scoring fails to initialize and bootstrap</a></h2>\n<p>Conviction scores for new addresses/users fail to initialize+bootstrap in <code>ERC20ConvictionScore</code>’s <code>_updateConvictionScore()</code> because a new user’s <code>numCheckpoints</code> will be zero and never gets initialized.</p>\n<p>This effectively means that FairSide conviction scoring fails to bootstrap at all, leading to the failure of the protocol’s pivotal feature.</p>\n<p>When Alice transfers FSD tokens to Bob for the first time, <code>_beforeTokenTransfer(Alice, Bob, 100)</code> is triggered which calls <code>_updateConvictionScore(Bob, 100)</code> on Line55 of ERC20ConvictionScore.sol.</p>\n<p>In function <code>_updateConvictionScore()</code>, given that this is the first time Bob is receiving FSD tokens, <code>numCheckpoints[Bob]</code> will be 0 (Line116) which will make <code>ts = 0</code> (Line120), and Bob’s FSD balance will also be zero (Bob never has got FSD tokens prior to this) which makes <code>convictionDelta = 0</code> (Line122) and not let control go past Line129.</p>\n<p>This means that a new checkpoint never gets written, i.e., conviction score never gets initialized, for Bob or for any user for that matter.</p>\n<p>FairSide’s adjustment of Compound’s conviction scoring is based on time and therefore needs an initialization to take place vs Compound’s implementation. Therefore, a new checkpoint needs to be created+initialized for a new user during token transfer.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/26#issuecomment-852189540\">fairside-core (FairSide) confirmed</a>:</strong></p>\n<blockquote>\n<p>Fixed in <a href=\"https://github.com/fairside-core/2021-05-fairside/pull/18\">PR#18</a>.</p>\n</blockquote>\n<h2 id=\"h-02-locked-funds-are-debited-twice-from-the-user-during-tokenization-leading-to-fund-loss\" style=\"position:relative;\"><a href=\"#h-02-locked-funds-are-debited-twice-from-the-user-during-tokenization-leading-to-fund-loss\" aria-label=\"h 02 locked funds are debited twice from the user during tokenization leading to fund loss permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/29\">[H-02] Locked funds are debited twice from the user during tokenization leading to fund loss</a></h2>\n<p>During tokenization of conviction scores, the user can optionally provide FSDs to be locked to let it continue conviction accrual. However, the amount of FSDs specified for locking are debited from the user twice, leading to fund loss.</p>\n<p>This, in effect, forces the user to unknowingly and unintentionally lock twice the amount of FSD tokens, leading to a loss of the specified ‘locked’ number of tokens.</p>\n<p>Alice decides to tokenize her conviction score into an NFT and specifies 100 FSD tokens to be locked in her call to <code>tokenizeConviction(100)</code>. 100 FSD tokens are transferred from her FSD balance to <code>FairSideConviction</code> contract on Line282 of <code>ERC20ConvictionScore.sol</code>. However, in <code>FairSideConviction.createConvictionNFT()</code>, the specified locked amount is transferred again from Alice to the contract on Line50 of <code>FairSideConviction.sol</code>.</p>\n<p>The impact is that Alice wanted to lock only 100 FSD tokens, but the FairSide protocol has debited 200 tokens from her balance leading to a loss of 100 FSD tokens.</p>\n<p>Recommend removing the redundant transfer of FSD tokens on Line282 in <code>tokenizeConviction()</code> of <code>ERC20ConvictionScore.sol</code>.</p>\n<h2 id=\"h-03-locked-funds-from-tokenization-are-credited-twice-to-user-leading-to-protocol-fund-loss\" style=\"position:relative;\"><a href=\"#h-03-locked-funds-from-tokenization-are-credited-twice-to-user-leading-to-protocol-fund-loss\" aria-label=\"h 03 locked funds from tokenization are credited twice to user leading to protocol fund loss permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/30\">[H-03] Locked funds from tokenization are credited twice to user leading to protocol fund loss</a></h2>\n<p>The tokens optionally locked during tokenization are released twice on acquiring conviction back from an NFT. (The incorrect double debit of locked funds during tokenization has been filed as a separate finding because it is not necessarily related and occurs in different parts of the code.)</p>\n<p>When a user wants to acquire back the conviction score captured by an NFT, the FSD tokens locked, if any, are released to the user as well. However, this is incorrectly done twice. Released amount is transferred once on Line123 in <code>_release()</code> (via <code>acquireConviction</code> -> <code>burn</code>) of FairSideConviction.sol and again immediately after the burn on Line316 in <code>acquireConviction()</code> of <code>ERC20ConvictionScore.sol</code>.</p>\n<p>This leads to loss of protocol funds.</p>\n<p>Alice tokenizes her conviction score into an NFT and locks 100 FSDs. Bob buys the NFT from Alice and acquires the conviction score back from the NFT. But instead of 100 FSDs that were supposed to be locked with the NFT, Bob receives 100+100 = 200 FSDs from FairSide protocol.</p>\n<p>Recommend removing the redundant transfer of FSD tokens from protocol to the user on Line316 in <code>acquireConviction()</code> of <code>ERC20ConvictionScore.sol</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/30#issuecomment-850995532\">fairside-core (FairSide) questioned</a>:</strong></p>\n<blockquote>\n<p>This is directly related to #29 as it refers to the same workflow, as seen in #74 as a single submission. I believe splitting this into two findings is unfair for the first party, and secondly, it does not make sense because there is a valid argument for disagreeing with the severity seen on #74. Can we close this and merge it with #29?</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/30#issuecomment-852171754\">fairside-core (FairSide) commented</a>:</strong></p>\n<blockquote>\n<p>Fixed in <a href=\"https://github.com/fairside-core/2021-05-fairside/pull/3\">PR#3</a>.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/30#issuecomment-856199389\">cemozerr (Judge) commented</a>:</strong></p>\n<blockquote>\n<p>Labeling issues #29 and #30 as separate issues because they both pose major issues, which lead to temporary loss of funds, in two different workflows. One when tokenizing convictions and another when acquiring convictions.</p>\n</blockquote>\n<h2 id=\"h-04-erc20convictionscores-governancedelta-should-be-subtracted-when-user-is-not-a-governor-anymore\" style=\"position:relative;\"><a href=\"#h-04-erc20convictionscores-governancedelta-should-be-subtracted-when-user-is-not-a-governor-anymore\" aria-label=\"h 04 erc20convictionscores governancedelta should be subtracted when user is not a governor anymore permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/40\">[H-04] <code>ERC20ConvictionScore</code>’s <code>governanceDelta</code> should be subtracted when user is not a governor anymore</a></h2>\n<p>The <code>TOTAL_GOVERNANCE_SCORE</code> is supposed to track the sum of the credit scores of all governors.</p>\n<p>In <code>ERC20ConvictionScore._updateConvictionScore</code>, when the user does not fulfill the governance criteria anymore and is therefore removed, the <code>governanceDelta</code> should be negative, but it’s positive.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"0\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">isGovernance</span><span class=\"mtk1\">[</span><span class=\"mtk12\">user</span><span class=\"mtk1\">] = </span><span class=\"mtk4\">false</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">governanceDelta</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">getPriorConvictionScore</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">user</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">block</span><span class=\"mtk1\">.</span><span class=\"mtk12\">number</span><span class=\"mtk1\"> - </span><span class=\"mtk7\">1</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">);</span></span></span></code></pre>\n<p>It then gets added to the new total:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"1\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">uint224</span><span class=\"mtk1\"> </span><span class=\"mtk12\">totalGCSNew</span><span class=\"mtk1\"> =</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">add224</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">totalGCSOld</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">governanceDelta</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk8\">&quot;ERC20ConvictionScore::_updateConvictionTotals: conviction score amount overflows&quot;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    );</span></span></span></code></pre>\n<p>The <code>TOTAL_GOVERNANCE_SCORE</code> tracks wrong data leading to issues throughout all contracts like wrong <code>FairSideDAO.totalVotes</code> data, which can then be used by anyone to pass proposals in the worst case.</p>\n<p>Or <code>totalVotes</code> can be arbitrarily inflated and break the voting mechanism as no proposals can reach the quorum (percentage of <code>totalVotes</code>) anymore.</p>\n<p>Recommend returning a negative signed integer for this case and adding it to the new total.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/40#issuecomment-852167769\">fairside-core (FairSide) confirmed</a>:</strong></p>\n<blockquote>\n<p>Fixed in <a href=\"https://github.com/fairside-core/2021-05-fairside/pull/14\">PR#14</a>.</p>\n</blockquote>\n<h2 id=\"h-05-withdrawablewithdraw-does-not-decrease-pendingwithdrawals\" style=\"position:relative;\"><a href=\"#h-05-withdrawablewithdraw-does-not-decrease-pendingwithdrawals\" aria-label=\"h 05 withdrawablewithdraw does not decrease pendingwithdrawals permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/48\">[H-05] <code>Withdrawable.withdraw</code> does not decrease <code>pendingWithdrawals</code></a></h2>\n<p>The name <code>pendingWithdrawals</code> indicates that this storage variable tracks the withdrawals that need yet to be paid out. Furthermore, this matches the behavior in <code>_increaseWithdrawal</code>. As such, it should be decreased when withdrawing in <code>withdraw</code>, but it is not.</p>\n<p>The <code>getReserveBalance</code> function consistently under-reports the actual reserve balance, which leads to the wrong mint amounts being used in the <code>FSD.mint</code> calculation.</p>\n<p>Recommend decreasing <code>pendingWithdrawals</code> by the withdrawn amount.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/72#issuecomment-850998007\">fairside-core (FairSide) confirmed (in duplicate issue #72)</a></strong></p>\n<blockquote>\n<p>One of two easter eggs!\nFixed in PR#5.</p>\n</blockquote>\n<h2 id=\"h-06-incorrect-type-conversion-in-the-contract-abc-makes-users-unable-to-burn-fsd-tokens\" style=\"position:relative;\"><a href=\"#h-06-incorrect-type-conversion-in-the-contract-abc-makes-users-unable-to-burn-fsd-tokens\" aria-label=\"h 06 incorrect type conversion in the contract abc makes users unable to burn fsd tokens permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/77\">[H-06] Incorrect type conversion in the contract <code>ABC</code> makes users unable to burn FSD tokens</a></h2>\n<p>The function <code>_calculateDeltaOfFSD</code> of contract <code>ABC</code> incorrectly converts an <code>int256</code> type parameter, <code>_reserveDelta</code>, to <code>uint256</code> by explicit conversion, which in general results in an extremely large number when the provided parameter is negative. The extremely large number could cause a SafeMath operation <code>sub</code> at line 43 to revert, and thus the FSD tokens cannot be burned as <code>_reserveDelta</code> is negative when burning FSD tokens.</p>\n<p>Simply calling <code>fsd.burn</code> after a successful <code>fsd.mint</code> will trigger this bug.</p>\n<p>Recommend using the solidity function <code>abs</code> to get the <code>_reserveDelta</code> absolute value.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/77#issuecomment-851029859\">fairside-core (FairSide) confirmed:</a></strong></p>\n<blockquote>\n<p>Fixed in <a href=\"https://github.com/fairside-core/2021-05-fairside/pull/1\">PR#1</a>.</p>\n</blockquote>\n<h2 id=\"h-07-erc20convictionscore_updateconvictionscore-uses-stale-credit-score-for-governancedelta\" style=\"position:relative;\"><a href=\"#h-07-erc20convictionscore_updateconvictionscore-uses-stale-credit-score-for-governancedelta\" aria-label=\"h 07 erc20convictionscore_updateconvictionscore uses stale credit score for governancedelta permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/41\">[H-07] <code>ERC20ConvictionScore._updateConvictionScore</code> uses stale credit score for <code>governanceDelta</code></a></h2>\n<p>In <code>ERC20ConvictionScore._updateConvictionScore</code>, when the user does not fulfill the governance criteria anymore, the <code>governanceDelta</code> is the old conviction score of the previous block.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"2\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">isGovernance</span><span class=\"mtk1\">[</span><span class=\"mtk12\">user</span><span class=\"mtk1\">] = </span><span class=\"mtk4\">false</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">governanceDelta</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">getPriorConvictionScore</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">user</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">block</span><span class=\"mtk1\">.</span><span class=\"mtk12\">number</span><span class=\"mtk1\"> - </span><span class=\"mtk7\">1</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">);</span></span></span></code></pre>\n<p>The user could increase their conviction/governance score first (in the same block) and then lose their status in a second transaction. After which, the total governance conviction score would only be reduced by the previous score.</p>\n<p>** Example:**\nBlock n - 10000: User is a governor and has a credit score of 1000, which was also contributed to the <code>TOTAL_GOVERNANCE_SCORE</code>\nBlock n:</p>\n<ul>\n<li>User updates their own conviction score using the public <code>updateConvictionScore</code> function, which increases the credit score by 5000 based on the accumulated time. The total governance credit score increased by 5000, making the user contribute 6000 credit score to governance in total.</li>\n<li>User transfers their whole balance away, the balance drops below <code>governanceMinimumBalance</code>, and the user is not a governor anymore. The <code>governanceDelta</code> update of the transfer should be 6000 (user’s whole credit score), but it’s only <code>1000</code> because it takes the snapshot of block n - 1.</li>\n</ul>\n<p>In this way, the <code>TOTAL_GOVERNANCE_SCORE</code> score can be inflated and, in the worst case, break the voting mechanism, as no proposals can reach the quorum (percentage of <code>totalVotes</code>) anymore.</p>\n<p>Recommend using the current conviction store which should be <code>governanceDelta = checkpoints[user][userCheckpointsLength - 1].convictionScore</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/41#issuecomment-851013838\">fairside-core (FairSide) confirmed but disagreed with severity</a>:</strong></p>\n<blockquote>\n<p>As with the other governance-related issues, this would once again cause dilution of all users and would not really be a viable attack vector. As such, I believe it is better suited for a medium severity (2) label.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/41#issuecomment-852122483\">fairside-core (FairSide) disputed</a>:</strong></p>\n<blockquote>\n<p>This issue is actually quite deeper. When a transaction occurs in the same block, the logic paths within the <code>if</code> block will not execute (due to time elapsed being 0), meaning that the conviction score will not be properly accounted for if I have a single normal transaction where I am still governance and consequently lose my governance in a second transaction. As such, the code needs to be adjusted to check governance eligibility outside of the if block as well (if no time has passed -> same block transaction).</p>\n<p>The code highlighted in the finding is actually <strong>correct</strong>. The conviction score should be reduced by the previous blocks as the newly accrued conviction score was never accounted for in governance. The proposed solution would lead to more conviction being reduced than it should. However, the finding did point out something wrong, so not sure whether it should be nullified or not.</p>\n<p>I believe it should be awarded as it was on the right track to find the underlying issue!</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/41#issuecomment-852128302\">fairside-core (FairSide) re-confirmed</a>:</strong></p>\n<blockquote>\n<p>Fixed in <a href=\"https://github.com/fairside-core/2021-05-fairside/pull/13\">PR#13</a>.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/41#issuecomment-857035642\">cemozerr (Judge) commented</a>:</strong></p>\n<blockquote>\n<p>Labeling this issue as valid because although it wasn’t 100% right on suggesting where the code was problematic, it did point out that the users could wrongfully transfer their whole balance and update their conviction score in the same block to keep their conviction score high, and then potentially do harmful things to the protocol by using their wrong conviction scores.</p>\n</blockquote>\n<h2 id=\"h-08-incorrect-implementation-of-arctan-in-the-contract-fairsideformula\" style=\"position:relative;\"><a href=\"#h-08-incorrect-implementation-of-arctan-in-the-contract-fairsideformula\" aria-label=\"h 08 incorrect implementation of arctan in the contract fairsideformula permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/73\">[H-08] Incorrect implementation of arctan in the contract <code>FairSideFormula</code></a></h2>\n<p>The current implementation of the arctan formula in the contract <code>FairSideFormula</code> is inconsistent with the referenced paper and could cause incorrect results when the input parameter is negative. The erroneous formula affects the function <code>calculateDeltaOfFSD</code> and the number of FSD tokens minted or burned.</p>\n<p>The function <code>_arctan</code> misses two <code>abs</code> on the variable `a’. The correct implementation should be:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"3\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">_arctan</span><span class=\"mtk1\">(</span><span class=\"mtk12\">bytes16</span><span class=\"mtk1\"> </span><span class=\"mtk12\">a</span><span class=\"mtk1\">) </span><span class=\"mtk11\">private</span><span class=\"mtk1\"> </span><span class=\"mtk11\">pure</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">bytes16</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">a</span><span class=\"mtk1\">.</span><span class=\"mtk11\">mul</span><span class=\"mtk1\">(</span><span class=\"mtk12\">PI_4</span><span class=\"mtk1\">).</span><span class=\"mtk11\">sub</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk12\">a</span><span class=\"mtk1\">.</span><span class=\"mtk11\">mul</span><span class=\"mtk1\">(</span><span class=\"mtk12\">a</span><span class=\"mtk1\">.</span><span class=\"mtk11\">abs</span><span class=\"mtk1\">().</span><span class=\"mtk11\">sub</span><span class=\"mtk1\">(</span><span class=\"mtk12\">ONE</span><span class=\"mtk1\">)).</span><span class=\"mtk11\">mul</span><span class=\"mtk1\">(</span><span class=\"mtk12\">APPROX_A</span><span class=\"mtk1\">.</span><span class=\"mtk11\">add</span><span class=\"mtk1\">(</span><span class=\"mtk12\">APPROX_B</span><span class=\"mtk1\">.</span><span class=\"mtk11\">mul</span><span class=\"mtk1\">(</span><span class=\"mtk12\">a</span><span class=\"mtk1\">.</span><span class=\"mtk11\">abs</span><span class=\"mtk1\">())))</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        );</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p>Notice that <code>_arctan</code> is called by <code>arctan</code>, and <code>arctan</code> is called by <code>arcs</code> with <code>ONE.sub(arcInner)</code> provided as the input parameter. Since <code>arcInner = MULTIPLIER_INNER_ARCTAN.mul(x).div(fS3_4)</code> can be a large number (recall that <code>x</code> is the capital pool), it is possible that the parameter <code>a</code> is negative.</p>\n<p>Recommend modifying the <code>_arctan</code> function as above.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/73#issuecomment-851048764\">fairside-core (FairSide) confirmed</a>:</strong></p>\n<blockquote>\n<p>Fixed in <a href=\"https://github.com/fairside-core/2021-05-fairside/pull/4\">PR#4</a>.</p>\n</blockquote>\n<h1 id=\"medium-risk-findings\" style=\"position:relative;\"><a href=\"#medium-risk-findings\" aria-label=\"medium risk findings permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Medium Risk Findings</h1>\n<h2 id=\"m-01-incorrect-use-of-_addtribute-instead-of-_addgovernancetribute\" style=\"position:relative;\"><a href=\"#m-01-incorrect-use-of-_addtribute-instead-of-_addgovernancetribute\" aria-label=\"m 01 incorrect use of _addtribute instead of _addgovernancetribute permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/20\">[M-01] Incorrect use of <code>_addTribute</code> instead of <code>_addGovernanceTribute</code></a></h2>\n<p>As part of the <code>purchaseMembership()</code> function, the <code>addRegistrationTributeGovernance()</code> function is called by the FSD network to update tribute when 7.5% is contributed towards governance. However, this function incorrectly calls <code>_addTribute()</code> (as is also done in <code>addRegistrationTribute</code>) instead of <code>_addGovernanceTribute()</code>.</p>\n<p>The impact of this is that <code>governanceTributes</code> never gets updated, rendering all of the tribute accounting logic incorrect.</p>\n<p>Recommend using <code>_addGovernanceTribute()</code> instead of <code>_addTribute</code> on L140 of FSD.sol</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/20#issuecomment-851000383\">fairside-core (FairSide) confirmed</a>:</strong></p>\n<blockquote>\n<p>The second of the two easter eggs!</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/20#issuecomment-852195810\">fairside-core (FairSide) commented</a>:</strong></p>\n<blockquote>\n<p>Fixed in <a href=\"https://github.com/fairside-core/2021-05-fairside/pull/20\">PR#20</a>.</p>\n</blockquote>\n<h2 id=\"m-02-call-to-swapexacttokensforeth-in-liquidatedai-will-always-fail\" style=\"position:relative;\"><a href=\"#m-02-call-to-swapexacttokensforeth-in-liquidatedai-will-always-fail\" aria-label=\"m 02 call to swapexacttokensforeth in liquidatedai will always fail permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/21\">[M-02] Call to <code>swapExactTokensForETH</code> in <code>liquidateDai()</code> will always fail</a></h2>\n<p><code>liquidateDai()</code> calls Uniswap’s <code>swapExactTokensForETH</code> to swap Dai to ETH. This will work if <code>msg.sender</code> (i.e., the FSD contract) has already given the router an allowance amount that is at least as much as the input token Dai.</p>\n<p>Given that there is no prior approval, the call to UniswapV2 router for swapping will fail. This is because <code>msg.sender</code> has not approved UniswapV2 with an allowance for the tokens that are attempting to be swapped.</p>\n<p>The impact is that, while working with the Dai stablecoin, <code>updateCostShareRequest()</code> will fail and revert.</p>\n<p>Recommend adding FSD approval to UniswapV2 with an allowance for the tokens that are attempting to be swapped.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/21#issuecomment-852193172\">fairside-core (FairSide) confirmed</a>:</strong></p>\n<blockquote>\n<p>Fixed in <a href=\"https://github.com/fairside-core/2021-05-fairside/pull/19\">PR#19</a>.</p>\n</blockquote>\n<h2 id=\"m-03-conviction-totals-not-updated-during-tokenization\" style=\"position:relative;\"><a href=\"#m-03-conviction-totals-not-updated-during-tokenization\" aria-label=\"m 03 conviction totals not updated during tokenization permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/28\">[M-03] Conviction totals not updated during tokenization</a></h2>\n<p><code>_updateConvictionScore()</code> function returns <code>convictionDelta</code> and <code>governanceDelta</code> which need to be used immediately in a call to <code>_updateConvictionTotals (convictionDelta, governanceDelta)</code> for updating the conviction totals of conviction and governance-enabled conviction for the entire FairSide network.</p>\n<p>This updating of totals after a call to <code>_updateConvictionScore()</code> is done on Line70 in <code>_beforeTokenTransfer()</code> and on Line367 in <code>updateConvictionScore()</code> of ERC20ConvictionScore.sol.</p>\n<p>However, the return values of <code>_updateConvictionScore()</code> are ignored on Line284 in <code>tokenizeConviction()</code> and are not used to update the totals using <code>_updateConvictionTotals(convictionDelta, governanceDelta)</code>.</p>\n<p>The impact of this is that when a user tokenizes their conviction score, their conviction deltas are updated and recorded (only if the funds locked are zero, which is incorrect and reported separately in a different finding), but the totals are not updated. This leads to incorrect accounting of <code>TOTAL_CONVICTION_SCORE</code> and <code>TOTAL_GOVERNANCE_SCORE</code>, which are used to calculate tributes, and therefore will lead to incorrect tribute calculations.</p>\n<p><strong>EXAMPLE:</strong></p>\n<blockquote>\n<p>Alice calls <code>tokenizeConviction()</code> to convert her conviction score into an NFT. Her conviction deltas (as returned by <code>_updateConvictionScore()</code>) are ignored. Furthermore, <code>TOTAL_CONVICTION_SCORE</code> and <code>TOTAL_GOVERNANCE_SCORE</code> values are not updated. As a result, the tributes rewarded are proportionally more than what they should have been. This is because the conviction score totals are used as the denominator in <code>availableTribute()</code> and <code>availableGovernanceTribute()</code>.</p>\n</blockquote>\n<p>Recommend using the return values of the <code>_updateConvictionScore()</code> function (i.e. <code>convictionDelta</code> and <code>governanceDelta</code>) on Line284 of <code>ERC20ConvictionScore.sol</code>, and then use them in a call to <code>_updateConvictionTotals(convictionDelta, governanceDelta)</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/28#issuecomment-852185047\">fairside-core (FairSide) confirmed</a>:</strong></p>\n<blockquote>\n<p>Fixed in <a href=\"https://github.com/fairside-core/2021-05-fairside/pull/17\">PR#17</a>.</p>\n</blockquote>\n<h2 id=\"m-04-eth-may-get-stuck-in-contract\" style=\"position:relative;\"><a href=\"#m-04-eth-may-get-stuck-in-contract\" aria-label=\"m 04 eth may get stuck in contract permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/58\">[M-04] Eth may get stuck in contract</a></h2>\n<p>The Istanbul hardfork increases the gas cost of the SLOAD operation and therefore breaks some existing smart contracts.</p>\n<p>In file <code>withdrawable.sol</code>, contract uses <code>transfer()</code> to send eth from contract to EOA due which eth can get stuck.</p>\n<p>The reason behind this is that, after the Istanbul hardfork, any smart contract that uses <code>transfer()</code> or <code>send()</code> is taking a hard dependency on gas costs by forwarding a fixed amount of gas (2300). This forwards 2300 gas, which may not be enough if the recipient is a contract and the cost of gas changes.</p>\n<p>Recommend using <code>call()</code> to send eth.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/67#issuecomment-851001069\">fairside-core (FairSide) confirmed (separately in issue #67)</a>:</strong></p>\n<blockquote>\n<p>Although I am fine with the severity, perhaps it may not be applicable given that even after EIP-3074, transfers will not fail with proper access lists, and I highly doubt the transfer method will fail to work altogether anytime soon.</p>\n</blockquote>\n<blockquote>\n<p>Fixed in PR#8.</p>\n</blockquote>\n<h2 id=\"m-05-bug-inside-abdkmathquad-library\" style=\"position:relative;\"><a href=\"#m-05-bug-inside-abdkmathquad-library\" aria-label=\"m 05 bug inside abdkmathquad library permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/32\">[M-05] Bug inside ABDKMathQuad library</a></h2>\n<p>The <code>FairSideFormula</code> library is using the <code>ABDKMathQuad</code> library underneath. According to the <code>ABDKMathQuad</code> README, the range of values is the following:</p>\n<blockquote>\n<p>The minimum strictly positive (subnormal) value is 2^−16494 ≈ 10^−4965 and has a precision of only one bit. The minimum positive normal value is 2^−16382 ≈ 3.3621 × 10^−4932 and has a precision of 113 bits, i.e., ±2^−16494 as well. The maximum representable value is 2^16384 − 2^16271 ≈ 1.1897 × 10^4932.</p>\n</blockquote>\n<p>Using Echidna, a fuzzing tool for smart contracts, I found some edge cases in which some of the operations do not work as expected. This is the test code I ran using <code>echidna-test contracts/TestABDKMathQuad --contract TestABDKMathQuad</code>. see <a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/32\">issue</a> for more details.</p>\n<p>If we check in Remix, we can see that there is a small difference when converting from UInt to Bytes16 (and vice versa). This issue is probably the same with all the other operations.</p>\n<p>Recommend using some fuzzing tool like <a href=\"https://github.com/crytic/echidna\">Echidna</a> to verify that there are no edge cases.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/32#issuecomment-851014825\">fairside-core (FairSide) acknowledged</a>:</strong></p>\n<blockquote>\n<p>I am slightly mixed about this finding. We did employ fuzz tests during the audit we had gone through, and they were unable to pinpoint any issues in the value range we expect the curve to be utilized in. This is definitely a good suggestion and one we will assimilate. However, I am not sure how one would judge the severity of this.</p>\n</blockquote>\n<h2 id=\"m-06-pendingwithdrawals-just-increments\" style=\"position:relative;\"><a href=\"#m-06-pendingwithdrawals-just-increments\" aria-label=\"m 06 pendingwithdrawals just increments permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/38\">[M-06] pendingWithdrawals just increments</a></h2>\n<p>Sponsor commented that this related to another bug and referenced ”[H-05] <code>Withdrawable.withdraw</code> does not decrease <code>pendingWithdrawals</code>”\nsee issue <a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/48\">#48</a> for more details.</p>\n<h2 id=\"m-07-nfts-can-never-be-redeemed-back-to-their-conviction-scores-leading-to-lockloss-of-funds\" style=\"position:relative;\"><a href=\"#m-07-nfts-can-never-be-redeemed-back-to-their-conviction-scores-leading-to-lockloss-of-funds\" aria-label=\"m 07 nfts can never be redeemed back to their conviction scores leading to lockloss of funds permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/31\">[M-07] NFTs can never be redeemed back to their conviction scores leading to lock/loss of funds</a></h2>\n<p>Besides the conviction scores of users, there appears to be tracking of the FairSide protocol’s tokenized conviction score as a whole (using <code>fscAddress = address(fairSideConviction)</code>). This is evident in the attempted reduction of the protocol’s score when a user acquires conviction back from an NFT. However, the complementary accrual of the user’s conviction score to <code>fscAddress</code> when the user tokenizes their conviction score to mint an NFT is missing in <code>tokenizeConviction()</code>.</p>\n<p>Because of this missing update of the conviction score to <code>fscAddress</code> upon tokenization, there are no checkpoints written for <code>fscAddress</code>. There also doesn’t appear to be any initialization for bootstrapping this address’s conviction score checkpoints. As a result, the <code>sub224()</code> on Line350 of <code>ERC20ConvictionScore.sol</code> will always fail with an underflow. This is because <code>fscOld = 0</code> (because <code>fscNum = 0</code>) and <code>convictionScore > 0</code>, effectively reverting all calls to <code>acquireConviction()</code>.</p>\n<p>The impact of this is that all tokenized NFTs can never be redeemed back to their conviction scores leading to a lock/loss of FSD funds for users who tokenized/sold/bought FairSide NFTs.</p>\n<p><strong>Proof of Concept:</strong></p>\n<ol>\n<li>Alice tokenizes her conviction score into an NFT. She sells that NFT to Bob, who pays an amount commensurate with the conviction score captured by that NFT (as valued by the market) and any FSDs locked with the NFT.</li>\n<li>Bob then attempts to redeem the bought NFT back to the conviction score to use it on the FairSide network. But the call to <code>acquireConviction()</code> fails. Bob is never able to redeem Alice’s NFT and has lost the funds used to buy it.</li>\n</ol>\n<p>Recommend adding appropriate logic to bootstrap, initialize <code>fscAddress</code> ’s tokenized conviction score checkpoints, and update it during tokenization.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/31#issuecomment-851012992\">fairside-core (FairSide) confirmed</a>:</strong></p>\n<blockquote>\n<p>Although the finding is correct, FSDs will not be permanently locked in the NFT as they can still be redeemed via the dedicated <code>release</code> function on the conviction NFT implementation. As such, I would label this a medium-level finding, given that the conviction scores will indeed be lost.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/31#issuecomment-852182498\">fairside-core (FairSide) commented</a>:</strong></p>\n<blockquote>\n<p>Fixed in <a href=\"https://github.com/fairside-core/2021-05-fairside/pull/16\">PR#16</a>.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/31#issuecomment-856306057\">cemozerr (Judge) commented</a>:</strong></p>\n<blockquote>\n<p>Labeling this as medium risk as FSDs will not be permanently locked.</p>\n</blockquote>\n<h2 id=\"m-08-erc20convictionscore-allows-transfers-to-special-total_governance_score-address\" style=\"position:relative;\"><a href=\"#m-08-erc20convictionscore-allows-transfers-to-special-total_governance_score-address\" aria-label=\"m 08 erc20convictionscore allows transfers to special total_governance_score address permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/42\">[M-08] <code>ERC20ConvictionScore</code> allows transfers to special <code>TOTAL_GOVERNANCE_SCORE</code> address</a></h2>\n<p>The credit score of the special <code>address(type(uint160).max)</code> is supposed to represent the sum of the credit scores of all users that are governors.</p>\n<p>But, any user can directly transfer to this address, increasing its balance and accumulating a credit score in <code>_updateConvictionScore(to=address(uint160.max), amount)</code>.</p>\n<p>It’ll first write a snapshot of this address’ balance, which should be very low:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"4\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// in _updateConvictionScore</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">_writeCheckpoint</span><span class=\"mtk1\">(</span><span class=\"mtk12\">user</span><span class=\"mtk1\">, </span><span class=\"mtk12\">userNum</span><span class=\"mtk1\">, </span><span class=\"mtk12\">userNew</span><span class=\"mtk1\">) = </span><span class=\"mtk11\">_writeCheckpoint</span><span class=\"mtk1\">(</span><span class=\"mtk12\">TOTAL_GOVERNANCE_SCORE</span><span class=\"mtk1\">, </span><span class=\"mtk12\">userNum</span><span class=\"mtk1\">, </span><span class=\"mtk12\">checkpoints</span><span class=\"mtk1\">[</span><span class=\"mtk12\">user</span><span class=\"mtk1\">][</span><span class=\"mtk12\">userNum</span><span class=\"mtk1\"> - </span><span class=\"mtk7\">1</span><span class=\"mtk1\">].</span><span class=\"mtk12\">convictionScore</span><span class=\"mtk1\"> + </span><span class=\"mtk12\">convictionDelta</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p>This address then accumulates a score based on its balance, which can be updated using <code>updateConvictionScore(uint160.max)</code> and breaks the invariant.</p>\n<p>Increasing it might be useful for non-governors that don’t pass the voting threshold and want to grief the proposal voting system by increasing the <code>quorumVotes</code> threshold required for proposals to pass. By manipulating <code>FairSideDAO.totalVotes</code>, <code>totalVotes</code> can be arbitrarily inflated and break the voting mechanism as no proposals can reach the quorum (percentage of <code>totalVotes</code>) anymore.</p>\n<p>Recommend disallowing transfers from/to this address. Or better, track the total governance credit score in a separate variable, not in an address.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/42#issuecomment-851013350\">fairside-core (FairSide) confirmed</a>:</strong></p>\n<blockquote>\n<p>This is actually what #61 is meant to be used for. I would label this a medium-level finding as it would simply dilute the voting rights of users at the expense of permanently losing FSD, which should not be a viable vector.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/42#issuecomment-852107565\">fairside-core (FairSide) resolved</a>:</strong></p>\n<blockquote>\n<p>Indirectly fixed by <a href=\"https://github.com/fairside-core/2021-05-fairside/pull/10\">PR#10</a>.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/42#issuecomment-857038152\">cemozerr (Judge) commented</a>:</strong></p>\n<blockquote>\n<p>Labeling this as medium risk as it would not pose a threat to user funds yet stall the governance process.</p>\n</blockquote>\n<h2 id=\"m-09-should-check-return-data-from-chainlink-aggregators\" style=\"position:relative;\"><a href=\"#m-09-should-check-return-data-from-chainlink-aggregators\" aria-label=\"m 09 should check return data from chainlink aggregators permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/70\">[M-09] Should check return data from Chainlink aggregators</a></h2>\n<p>The <code>getEtherPrice</code> function in the contract <code>FSDNetwork</code> fetches the ETH price from a Chainlink aggregator using the <code>latestRoundData</code> function. However, there are no checks on <code>roundID</code> nor <code>timeStamp</code>, resulting in stale prices.</p>\n<p>Recommend adding checks on the return data with proper revert messages if the price is stale or the round is incomplete, for example:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"5\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">(</span><span class=\"mtk12\">uint80</span><span class=\"mtk1\"> </span><span class=\"mtk12\">roundID</span><span class=\"mtk1\">, </span><span class=\"mtk12\">int256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">price</span><span class=\"mtk1\">, , </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">timeStamp</span><span class=\"mtk1\">, </span><span class=\"mtk12\">uint80</span><span class=\"mtk1\"> </span><span class=\"mtk12\">answeredInRound</span><span class=\"mtk1\">) = </span><span class=\"mtk12\">ETH_CHAINLINK</span><span class=\"mtk1\">.</span><span class=\"mtk11\">latestRoundData</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">answeredInRound</span><span class=\"mtk1\"> &gt;= </span><span class=\"mtk12\">roundID</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;...&quot;</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">timeStamp</span><span class=\"mtk1\"> != </span><span class=\"mtk7\">0</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;...&quot;</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/70#issuecomment-851051273\">fairside-core (FairSide) confirmed</a>:</strong></p>\n<blockquote>\n<p>Fixed in <a href=\"https://github.com/fairside-core/2021-05-fairside/pull/7\">PR#7</a>.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/70#issuecomment-857059051\">cemozerr (Judge) commented</a>:</strong></p>\n<blockquote>\n<p>Labeling this as medium risk as stale ether price could put funds at risk.</p>\n</blockquote>\n<h2 id=\"m-10-graceperiod-not-increased-after-membership-extension\" style=\"position:relative;\"><a href=\"#m-10-graceperiod-not-increased-after-membership-extension\" aria-label=\"m 10 graceperiod not increased after membership extension permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/6\">[M-10] <code>gracePeriod</code> not increased after membership extension</a></h2>\n<p>In the function <code>purchaseMembership</code> of FSDNetwork.sol, when the membership is extended, <code>membership[msg.sender].creation</code> is increased. However, <code>membership[msg.sender].gracePeriod</code> is not increased.\nThis might lead to a <code>gracePeriod</code> that is lower than expected. It seems logical to also increase the <code>gracePeriod</code>.</p>\n<p>FSDNetwork.sol:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"6\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">purchaseMembership</span><span class=\"mtk1\">(</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">costShareBenefit</span><span class=\"mtk1\">) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">     ...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">      </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">membership</span><span class=\"mtk1\">[</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">].</span><span class=\"mtk12\">creation</span><span class=\"mtk1\"> == </span><span class=\"mtk7\">0</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            ...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk12\">membership</span><span class=\"mtk1\">[</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">].</span><span class=\"mtk12\">creation</span><span class=\"mtk1\">       = </span><span class=\"mtk12\">block</span><span class=\"mtk1\">.</span><span class=\"mtk12\">timestamp</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">            </span><span class=\"mtk12\">membership</span><span class=\"mtk1\">[</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">].</span><span class=\"mtk12\">gracePeriod</span><span class=\"mtk1\"> =  </span><span class=\"mtk12\">membership</span><span class=\"mtk1\">[</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">].</span><span class=\"mtk12\">creation</span><span class=\"mtk1\"> +  </span><span class=\"mtk12\">MEMBERSHIP_DURATION</span><span class=\"mtk1\"> +  </span><span class=\"mtk7\">60</span><span class=\"mtk1\"> </span><span class=\"mtk12\">days</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        } </span><span class=\"mtk15\">else</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">          ....</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">          </span><span class=\"mtk12\">membership</span><span class=\"mtk1\">[</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">].</span><span class=\"mtk12\">creation</span><span class=\"mtk1\"> += </span><span class=\"mtk12\">durationIncrease</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">   }</span></span></span></code></pre>\n<p>Recommend checking to see if <code>gracePeriod</code> has to be increased and then adding the necessary logic when that is the case.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/6#issuecomment-851017171\">fairside-core (FairSide) confirmed</a>:</strong></p>\n<blockquote>\n<p>This should be bumped to a medium severity finding as it actually does not affect the membership duration at all if the <code>gracePeriod</code> is not updated.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/6#issuecomment-852198632\">fairside-core (FairSide) commented</a>:</strong></p>\n<blockquote>\n<p>Fixed in <a href=\"https://github.com/fairside-core/2021-05-fairside/pull/21\">PR#21</a>.</p>\n</blockquote>\n<h2 id=\"m-11-the-variable-fshareratio-is-vulnerable-to-manipulation-by-flash-minting-and-burning\" style=\"position:relative;\"><a href=\"#m-11-the-variable-fshareratio-is-vulnerable-to-manipulation-by-flash-minting-and-burning\" aria-label=\"m 11 the variable fshareratio is vulnerable to manipulation by flash minting and burning permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/75\">[M-11] The variable <code>fShareRatio</code> is vulnerable to manipulation by flash minting and burning</a></h2>\n<p>The variable <code>fShareRatio</code> in the function <code>purchaseMembership</code> of contract <code>FSDNetwork</code> is vulnerable to manipulation by flash minting and burning, which could affect several critical logics, such as the check of enough capital in the pool (line 139-142) and the staking rewards (line 179-182).</p>\n<p>The <code>fShareRatio</code> is calculated (line 136) by:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"7\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">(</span><span class=\"mtk12\">fsd</span><span class=\"mtk1\">.</span><span class=\"mtk11\">getReserveBalance</span><span class=\"mtk1\">() - </span><span class=\"mtk12\">totalOpenRequests</span><span class=\"mtk1\">).</span><span class=\"mtk11\">mul</span><span class=\"mtk1\">(</span><span class=\"mtk7\">1</span><span class=\"mtk1\"> </span><span class=\"mtk12\">ether</span><span class=\"mtk1\">) / </span><span class=\"mtk12\">fShare</span><span class=\"mtk1\">;</span></span></span></code></pre>\n<p>Where <code>fsd.getReserveBalance()</code> can be significantly increased by a user minting a large amount of FSD tokens with flash loans. In that case, the increased <code>fShareRatio</code> could affect the function <code>purchaseMembership</code> results. For Example, the user could purchase the membership even if the <code>fShareRatio</code> is &#x3C; 100% previously, or the user could earn more staking rewards than before to reduce the membership fees. Although performing flash minting and burning might not be profitable overall since a 3.5% tribute fee is required when burning FSD tokens, it is still important to be aware of the possible manipulation of <code>fShareRatio</code>.</p>\n<p>Recommend forcing users to wait for (at least) a block to prevent flash minting and burning.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/75#issuecomment-850994783\">fairside-core (FairSide) confirmed</a>:</strong></p>\n<blockquote>\n<p>I believe this to be a minor (1) or none (0) severity issue given that the manipulation of <code>fShareRatio</code> is unsustainable due to the fee, and the Example given is actually not possible. Suppose I affect <code>fShareRatio</code> to go above 100% to purchase a membership. In that case, I will be unable to burn the necessary FSD to go below 100% again as burning is disabled when the ratio is or would go to below 100%.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/75#issuecomment-851032182\">fairside-core (FairSide) resolved</a>:</strong></p>\n<blockquote>\n<p>Fixed in <a href=\"https://github.com/fairside-core/2021-05-fairside/pull/2\">PR#2</a>.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/75#issuecomment-857099487\">cemozerr (Judge) commented</a>:</strong></p>\n<blockquote>\n<p>Labeling this as low risk as a 3.5% tribute fee makes it very unlikely that these flash minting will be profitable.</p>\n</blockquote>\n<h2 id=\"m-12-erc20convictionscoreacquireconviction-implements-wrong-governance-checks\" style=\"position:relative;\"><a href=\"#m-12-erc20convictionscoreacquireconviction-implements-wrong-governance-checks\" aria-label=\"m 12 erc20convictionscoreacquireconviction implements wrong governance checks permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/45\">[M-12] <code>ERC20ConvictionScore.acquireConviction</code> implements wrong governance checks</a></h2>\n<p>There are two issues with the governance checks when acquiring them from an NFT:</p>\n<h4 id=\"issue-1-missing-balance-check\" style=\"position:relative;\"><a href=\"#issue-1-missing-balance-check\" aria-label=\"issue 1 missing balance check permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>(Issue 1) Missing balance check</strong></h4>\n<p>The governance checks in <code>_updateConvictionScore</code> are:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"8\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">!</span><span class=\"mtk12\">isGovernance</span><span class=\"mtk1\">[</span><span class=\"mtk12\">user</span><span class=\"mtk1\">]</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">&amp;&amp; </span><span class=\"mtk12\">userConvictionScore</span><span class=\"mtk1\"> &gt;= </span><span class=\"mtk12\">governanceThreshold</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">&amp;&amp; </span><span class=\"mtk11\">balanceOf</span><span class=\"mtk1\">(</span><span class=\"mtk12\">user</span><span class=\"mtk1\">) &gt;= </span><span class=\"mtk12\">governanceMinimumBalance</span><span class=\"mtk1\">;</span></span></span></code></pre>\n<p>Whereas in <code>acquireConviction</code>, only <code>userConvictionScore >= governanceThreshold</code> is checked but not <code>&#x26;&#x26; balanceOf(user) >= governanceMinimumBalance</code>.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"9\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">else</span><span class=\"mtk1\"> </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    !</span><span class=\"mtk12\">isGovernance</span><span class=\"mtk1\">[</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">] &amp;&amp; </span><span class=\"mtk12\">userNew</span><span class=\"mtk1\"> &gt;= </span><span class=\"mtk12\">governanceThreshold</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">isGovernance</span><span class=\"mtk1\">[</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">] = </span><span class=\"mtk4\">true</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<h4 id=\"issue-2-the-wasgovernance-might-be-outdated\" style=\"position:relative;\"><a href=\"#issue-2-the-wasgovernance-might-be-outdated\" aria-label=\"issue 2 the wasgovernance might be outdated permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>(Issue 2) the <code>wasGovernance</code> might be outdated</strong></h4>\n<p>The second issue is that at the time of NFT creation, the <code>governanceThreshold</code> or <code>governanceMinimumBalance</code> was different and would not qualify for a governor now.\nThe NFT’s governance state is blindly appplied to the new user:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"10\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">wasGovernance</span><span class=\"mtk1\"> &amp;&amp; !</span><span class=\"mtk12\">isGovernance</span><span class=\"mtk1\">[</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">]) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">isGovernance</span><span class=\"mtk1\">[</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">] = </span><span class=\"mtk4\">true</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p>This allows a user to circumvent any governance parameter changes by front-running the change with an NFT creation. It’s easy to circumvent the balance check to become a governor by minting and redeeming your own NFT. One can also circumvent any governance parameter increases by front-running these actions with an NFT creation and then backrunning with a redemption.</p>\n<p>Recommend adding the missing balance check-in <code>acquireConviction</code>, removing the <code>wasGovernance</code> governance transfer from the NFT, and recomputing it based solely on the current <code>governanceThreshold</code> / <code>governanceMinimumBalance</code> settings.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/45#issuecomment-851009327\">fairside-core (FairSide) confirmed</a>:</strong></p>\n<blockquote>\n<p>The latter of the two issue “types” is actually desired behavior. If a user was historically a governance member, the NFT should boast the exact same rights, and new thresholds should not retroactively apply. The former, however, is a valid issue as it allows circumventing the balance check!</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/45#issuecomment-852116812\">fairside-core (FairSide) resolved</a>:</strong></p>\n<blockquote>\n<p>Fixed in <a href=\"https://github.com/fairside-core/2021-05-fairside/pull/12\">PR#12</a>.</p>\n</blockquote>\n<h1 id=\"low-risk-findings\" style=\"position:relative;\"><a href=\"#low-risk-findings\" aria-label=\"low risk findings permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Low Risk Findings</h1>\n<h2 id=\"l-01-lack-of-zero-address-checks-for-immutable-addresses-will-force-contract-redeployment-if-zero-address-used-accidentally\" style=\"position:relative;\"><a href=\"#l-01-lack-of-zero-address-checks-for-immutable-addresses-will-force-contract-redeployment-if-zero-address-used-accidentally\" aria-label=\"l 01 lack of zero address checks for immutable addresses will force contract redeployment if zero address used accidentally permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/18\">[L-01] Lack of zero-address checks for immutable addresses will force contract redeployment if zero-address used accidentally</a></h2>\n<p>Zero-address checks as input validation on address parameters are always a best practice. This is especially true for critical addresses that are immutable and set in the constructor because they cannot be changed later. Accidentally using zero addresses here will lead to failing logic or force contract redeployment and increased gas costs.</p>\n<p>Recommend adding zero-address input validation for these addresses in the constructor.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/56#issuecomment-851005065\">fairside-core (FairSide) acknowledged (in separate issue #56)</a>:</strong></p>\n<blockquote>\n<p>Adding the respective require checks significantly increases the bytecode size of the contract, and all relate to privileged functions (constructor functions or functions voted on by the DAO). As such, I believe this to be a non-critical (0) issue.</p>\n</blockquote>\n<h2 id=\"l-02-dangerous-solidity-compiler-pragma-range-that-spans-breaking-versions\" style=\"position:relative;\"><a href=\"#l-02-dangerous-solidity-compiler-pragma-range-that-spans-breaking-versions\" aria-label=\"l 02 dangerous solidity compiler pragma range that spans breaking versions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/25\">[L-02] Dangerous Solidity compiler pragma range that spans breaking versions</a></h2>\n<p>All contracts use a Solidity compiler pragma range >=0.6.0 &#x3C;0.8.0, which spans a breaking change version 0.7.0. This compiler range is very broad and includes many syntactic/semantic changes across the versions. Specifically, see silent changes in <a href=\"https://docs.soliditylang.org/en/v0.7.0/070-breaking-changes.html#silent-changes-of-the-semantics\">https://docs.soliditylang.org/en/v0.7.0/070-breaking-changes.html#silent-changes-of-the-semantics</a>.</p>\n<p>For Example, this compiler range allows testing with Solidity compiler version 0.6.x but deployment with 0.7.x. While any breaking syntactic changes will be caught at compile time, there is a risk that the silent change in 0.7.0, which applies to exponentiation/shift operand types, might affect the FairSide formula or other mathematical calculations, thus breaking assumptions and accounting.</p>\n<p>The opposite scenario may also happen where testing is performed with Solidity compiler version 0.7.x but deployed with 0.6.x, which may allow bugs fixed in 0.7.x to be present in the deployed code.</p>\n<p>Recommend using the same compiler version both for testing and deployment by enforcing this in the pragma itself. An unlocked/floating pragma is risky, especially one that ranges across a breaking compiler minor version.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/66\">fairside-core (FairSide) acknowledged (in separate Issue #66)</a>:</strong></p>\n<blockquote>\n<p>he pragma statements were left unlocked to allow flexibility in development. Since this is not a functional finding, it should be marked as 0 (non-critical).</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/66#issuecomment-856221090\">cemozerr (Judge) commented (in separate Issue #66)</a>:</strong></p>\n<blockquote>\n<p>Duplicate of #25. Labeling it as low risk as it could indeed cause the contracts to accidentally be compiled or deployed using an outdated or buggy compiler version</p>\n</blockquote>\n<h2 id=\"l-03-usage-of-transfer\" style=\"position:relative;\"><a href=\"#l-03-usage-of-transfer\" aria-label=\"l 03 usage of transfer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/47\">[L-03] Usage of transfer</a></h2>\n<p>In <code>Withdrawable.withdraw</code>: The <code>address.transfer</code> function is used to send ETH to an account. It is restricted to a low amount of gas and might fail if gas costs change in the future or if a smart contract’s fallback function handler implements anything non-trivial.</p>\n<p>Recommend considering using the lower-level <code>.call{value: value}</code> instead and checking its success return value.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/67\">fairside-core (FairSide) confirmed and commented (in separate issue #67):</a></strong></p>\n<blockquote>\n<p>Although I am fine with the severity, perhaps it may not be applicable given that even after EIP-3074 transfers will not fail with proper access lists, and I highly doubt the transfer method will fail to work altogether anytime soon.\nFixed in PR#8.</p>\n</blockquote>\n<h2 id=\"l-04-missing-use-of-dsmath-functions-may-lead-to-underflowsoverflows\" style=\"position:relative;\"><a href=\"#l-04-missing-use-of-dsmath-functions-may-lead-to-underflowsoverflows\" aria-label=\"l 04 missing use of dsmath functions may lead to underflowsoverflows permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/19\">[L-04] Missing use of DSMath functions may lead to underflows/overflows</a></h2>\n<p>The FairSide contracts use DappHub’s DSMath safe arithmetic library that provides overflow/underflow protection. But, the safe DSMath functions are not used in many places, especially in the FSD <code>mint</code>/<code>burn</code> functions.</p>\n<p>While there do not appear to be any obvious integer overflows/underflows in the conditions envisioned, there could be exceptional paths where overflows/underflows may be triggered, leading to minting/burning an unexpected number of tokens.</p>\n<p>Recommend using DSMath <code>add</code>/<code>sub</code> functions instead of +/- in all places.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/19#issuecomment-851016313\">fairside-core (FairSide) acknowledged</a>:</strong></p>\n<blockquote>\n<p>All linked segments are guaranteed not to overflow / underflow. In detail:</p>\n<ol>\n<li>The <code>getReserveBalance</code> always takes into account the actual balance of the contract, which will always be greater-than-or-equal to <code>msg.value</code>.</li>\n<li>The <code>bonded</code> amount is always a percentage of <code>msg.value</code></li>\n<li>The <code>tribute</code> amount is always a percentage of <code>capitalDesired</code></li>\n<li>The <code>reserveWithdrawn</code> will always be less than or equal to <code>etherBalanceAtBurn</code></li>\n</ol>\n<p>Due to the above, I would label the finding as non-critical. In general, SafeMath utilization is avoided in any case that it can be to reduce gas costs.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/19#issuecomment-856249509\">cemozerr (Judge) commented</a>:</strong></p>\n<blockquote>\n<p>Labeling this as low risk as not using dsmath might lead to exceptional paths where overflows/underflows may be triggered, even if those paths are not enumerated above.</p>\n</blockquote>\n<h2 id=\"l-05-convictionless-mapping-is-not-used\" style=\"position:relative;\"><a href=\"#l-05-convictionless-mapping-is-not-used\" aria-label=\"l 05 convictionless mapping is not used permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/61\">[L-05] <code>convictionless</code> mapping is not used</a></h2>\n<p><code>convictionless</code> can be set via function <code>setConvictionless</code>; however, it is not used anywhere across the system, thus making it useless. Based on the comment above this variable, I expect to see it used in functions like <code>_updateConvictionScore</code>.</p>\n<p>Recommend either remove this mapping or use it where intended.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/61#issuecomment-851003714\">fairside-core (FairSide) confirmed</a>:</strong></p>\n<blockquote>\n<p>Quite strange no one else identified this one! The absence of usage was a merging mistake; this particular mapping is slightly important to the overall operation of FairSide as certain parties should not accrue conviction, such as the Governance wallet. I believe it should be increased to medium-level severity.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/61#issuecomment-852107094\">fairside-core (FairSide) resolved</a>:</strong></p>\n<blockquote>\n<p>Fixed in <a href=\"https://github.com/fairside-core/2021-05-fairside/pull/10\">PR#10</a>.</p>\n</blockquote>\n<h2 id=\"l-06-flash-minting-and-burning-can-reduce-the-paid-fees-when-purchasing-a-membership-or-opening-a-cost-share-request\" style=\"position:relative;\"><a href=\"#l-06-flash-minting-and-burning-can-reduce-the-paid-fees-when-purchasing-a-membership-or-opening-a-cost-share-request\" aria-label=\"l 06 flash minting and burning can reduce the paid fees when purchasing a membership or opening a cost share request permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/76\">[L-06] Flash minting and burning can reduce the paid fees when purchasing a membership or opening a cost-share request</a></h2>\n<p>Users can pay fewer FSD tokens when purchasing a membership or opening a cost-share request by flash minting and burning FSD tokens, which could significantly affect the FSD spot price.</p>\n<p>The function <code>getFSDPrice</code> returns the current FSD price based on the reserves in the capital pool (see lines 353-364 in contract <code>FSDNetwork</code>). Notice that when minting and burning FSD tokens, the <code>fsd.getReserveBalance()</code> increases but not the <code>fShare</code>. Therefore, according to the pricing formula, <code>FairSideFormula.f</code>, the FSD price increases when minting, and vice versa, decreases when burning.</p>\n<p>When purchasing a membership, the number of FSD tokens that a user should pay is calculated based on the current FSD price, which is vulnerable to manipulation by flash minting and burning. Consider a user performing the following actions (all are done within a single transaction or flashbot bundle):</p>\n<ol>\n<li>The user mints a large number of FSD (by using flash loans) to raise the current FSD price.</li>\n<li>The user purchases a membership by calling <code>purchaseMembership</code>. Since the price of FSD is relatively high, the user pays fewer FSD tokens for the membership fee than before.</li>\n<li>The user burns the previously minted FSD tokens, losing 3.5% of his capital for the tribute fees.</li>\n</ol>\n<p>Although the user pays for the 3.5% tribute fees, it is still possible to make a profit. Suppose that the price of FSD to ETH is <code>p_1</code> and <code>p_2</code> before and after minting, respectively. The user purchases a membership with <code>x</code> ETH <code>costShareBenefit</code> and uses <code>y</code> ETH to flash mint the FSD tokens. In a regular purchase, the user pays <code>0.04x / p_1</code> FSD tokens, equivalent to <code>0.04x</code> ETH. By performing flash mints and burns, the user pays <code>0.04x / p_2</code> FSD tokens, which is, in fact, equivalent to <code>0.04x * p_1 / p_2</code> ETH. He also pays <code>0.035y</code> ETH for tribute fees. The profit user made is <code>0.04x * (1 - p1 / p2) - 0.035y</code> (ETH), where <code>p2</code> and <code>y</code> are dependent to each other but independent to <code>x</code>. Thus, the profit can be positive if <code>costShareBenefit</code> is large enough.</p>\n<p>The same vulnerability exists when a user opens a cost-share request, where the <code>bounty</code> to pay is calculated based on the current price of FSD tokens.</p>\n<p>Recommend forcing users to wait for (at least) a block to prevent flash minting and burning.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/76#issuecomment-850994061\">fairside-core (FairSide) questioned</a>:</strong></p>\n<blockquote>\n<p>The issue relies on <code>costShareBenefit</code> being large enough, which is inherently limited to a % of the capital pool, meaning that the arbitrage opportunity present here is inexistent or highly unlikely to be beneficial. Can we reach out to the submitter to request them to prove that even with the <code>costShareBenefit</code> % limit, this is a sustainable attack by providing us with numbers? If no such numbers are present, I would decrease the severity of this to either minor (1) or none (0).</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/76#issuecomment-857095193\">cemozerr (Judge) commented</a>:</strong></p>\n<blockquote>\n<p>Will wait for a proof from the auditor, shw, for this one.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/76#issuecomment-860028778\">x9453 commented</a>:</strong></p>\n<blockquote>\n<p>Hi, thanks for giving me a chance to clarify this finding.</p>\n<p>After realizing that a user’s <code>costShareBenefit</code> is limited to a % of the capital pool (5% as specified in the code), I would say this attack is not successful according to the following estimation of the upper-bound of user’s profit:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"\" data-index=\"11\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">   User&#39;s profit</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"> = 0.04x * (1 - p1 / p2) - 0.035y</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">&lt;= 0.04x - 0.035y</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">&lt;= 0.04 * 0.05 * (z + y) - 0.035y</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"> = 0.002z - 0.033y</span></span></code></pre>\n<p>where <code>z</code> is the amount of ETH in the capital pool before minting. A negative coefficient of `y’ implies that using a flash loan does not help to increase the profit but to decrease it.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/76#issuecomment-860513934\">x9453 commented</a>:</strong></p>\n<blockquote>\n<p>After some thoughts, I think the estimation should also consider how flash loan affects on the FSD’s price to be more accurate. According to the price formula, we have <code>p1 = A + z^4 / (C * fShare^3)</code> and <code>p2 = A + (z + y)^4 / (C * fShare^3)</code> (assuming the best case, where <code>fShare</code> does not increase). Let <code>r = y / z</code>, the ratio of flash loan to the capital pool, then we can approximate <code>p1 / p2 = z^4 / (z + y)^4 = 1 / (r + 1)^4</code>. Therefore,</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"\" data-index=\"12\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">  User&#39;s profit</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">= 0.04x * (1 - p1 / p2) - 0.035y</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">= 0.04 * 0.05 * (z + y) * (1 - 1 / (r + 1)^4) - 0.035y</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">= (0.002 * (r + 1) * (1 - 1 / (r + 1)^4) - 0.035r) * z</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">= f(r) * z</span></span></code></pre>\n<p><a href=\"https://www.wolframalpha.com/input/?i=0.002%28x%2B1%29%281-1%2F%28x%2B1%29%5E4%29-0.035x\">WolframAlpha</a> tells us that <code>f(r) &#x3C; 0</code> for all <code>r > 0</code>, meaning that the user does not make a profit no matter how much flash loan he borrowed.</p>\n<p>It is worth mentioning that different % of withdrawal fee, cost share benefit limit, and tribute fee could lead to different results. That is, the constants, <code>0.002</code> and <code>0.035</code>, determine whether user’s profit can be positive (i.e., there exists <code>r > 0</code> s.t. <code>f(r) > 0</code>). Further calculation shows that this happens if the product of the withdrawal fee and cost share benefit limit is greater than the tribute fee divided by 4, which is unlikely in normal settings. Please let me know if you need more details or a PoC on this.</p>\n</blockquote>\n<h2 id=\"l-07-check-if-variables-are-initialized\" style=\"position:relative;\"><a href=\"#l-07-check-if-variables-are-initialized\" aria-label=\"l 07 check if variables are initialized permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/59\">[L-07] Check if variables are initialized</a></h2>\n<p>A variable named <code>fairSideConviction</code> is set in the contract FSD function <code>setFairSideConviction</code>. However, functions that use this variable do not check that it is already initialized. For example, function <code>tokenizeConviction</code> in contract <code>ERC20ConvictionScore</code> may transfer tokens to the 0x0 address:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"13\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">   </span><span class=\"mtk11\">_transfer</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">, </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk12\">fairSideConviction</span><span class=\"mtk1\">), </span><span class=\"mtk12\">locked</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p>This will make these tokens inaccessible and basically burned. It would be better if the code explicitly checked before that <code>address(fairSideConviction) != address(0)</code></p>\n<p>Rating this as low because I expect that, in practice, these variables will be initialized as soon as possible.</p>\n<p>Also, this may be an additional small issue. Still, I think it would make sense if functions <code>setFairSideConviction</code> and <code>setFairSideNetwork</code> explicitly check that the parameter is not 0x0 address as it is theoretically possible to invoke these functions again and again when the address is empty.</p>\n<p>Recommend requiring <code>address(fairSideConviction) != address(0)</code> where this variable is used. Same can be applied to fsdNetwork variable.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/59#issuecomment-851005154\">fairside-core (FairSide) acknowledged</a>:</strong></p>\n<blockquote>\n<p>This function is invoked directly in the deployment script and cannot be raced. As such, I think this should be set as non-critical (0).</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/59#issuecomment-856218166\">cemozerr (Judge) commented</a>:</strong></p>\n<blockquote>\n<p>Labeling this as low risk, as the issue could pose a problem in this case, the deployment script has a bug.</p>\n</blockquote>\n<h1 id=\"non-critical-findings\" style=\"position:relative;\"><a href=\"#non-critical-findings\" aria-label=\"non critical findings permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Non-Critical Findings</h1>\n<h2 id=\"n-01-use-of-ecrecover-is-susceptible-to-signature-malleability\" style=\"position:relative;\"><a href=\"#n-01-use-of-ecrecover-is-susceptible-to-signature-malleability\" aria-label=\"n 01 use of ecrecover is susceptible to signature malleability permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/17\">[N-01] Use of <code>ecrecover</code> is susceptible to signature malleability</a></h2>\n<p>The <code>ecrecover</code> function is used in <code>castVoteBySig()</code> to recover the voter’s address from the signature. The built-in EVM precompile <code>ecrecover</code> is susceptible to signature malleability, which could lead to replay attacks (references: <a href=\"https://swcregistry.io/docs/SWC-117\">https://swcregistry.io/docs/SWC-117</a>, <a href=\"https://swcregistry.io/docs/SWC-121\">https://swcregistry.io/docs/SWC-121</a>, and <a href=\"https://medium.com/cryptronics/signature-replay-vulnerabilities-in-smart-contracts-3b6f7596df57\">https://medium.com/cryptronics/signature-replay-vulnerabilities-in-smart-contracts-3b6f7596df57</a>).</p>\n<p>While this is not immediately exploitable in the DAO use case because the voter address is checked against <code>receipt.voted</code> to prevent re-voting, this may become a vulnerability if used elsewhere.</p>\n<p>Recommend considering using OpenZeppelin’s ECDSA library (which prevents this malleability) instead of the built-in function.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/17#issuecomment-851015227\">fairside-core (FairSide) acknowledged</a>:</strong></p>\n<blockquote>\n<p>While this is a valid finding, it also exists in the Compound codebase and, as mentioned in the description, is not an active issue. I would label as non-critical (0).</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/17#issuecomment-856184599\">cemozerr (Judge) commented</a>:</strong></p>\n<blockquote>\n<p>Labeling this issue as non-critical, as the issue with <code>ecrecover</code> would only be a problem if not aided with another check to prevent re-voting.</p>\n</blockquote>\n<h2 id=\"n-02-fairsidedaosecs_per_block-is-inaccurate\" style=\"position:relative;\"><a href=\"#n-02-fairsidedaosecs_per_block-is-inaccurate\" aria-label=\"n 02 fairsidedaosecs_per_block is inaccurate permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/34\">[N-02] <code>FairSideDAO.SECS_PER_BLOCK</code> is inaccurate</a></h2>\n<p>The <code>SECS_PER_BLOCK</code> is currently set to 15s on Ethereum, but it’s closer to 13.5s on average. The voting period will be shorter than in reality which might lead to users not getting enough time.</p>\n<p>Recommend using a more accurate representation of <code>SECS_PER_BLOCK</code> for the deployed chain.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/34#issuecomment-851014659\">fairside-core (FairSide) acknowledged</a>:</strong></p>\n<blockquote>\n<p>This parameter is meant to be updated prior to deployment and is susceptible to network fluctuations. As such, this is something that will be tuned prior to deployment and should be considered a non-critical issue as there is no on-chain way to reliably calculate the median block time.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/34#issuecomment-856203415\">cemozerr (Judge) commented</a>:</strong></p>\n<blockquote>\n<p>Labeling this issue as non-critical as @fairside-core’s comments on the constant value being dependent on network conditions is right.</p>\n</blockquote>\n<h2 id=\"n-03-wrong-error-message-in-__castoffchainvotes\" style=\"position:relative;\"><a href=\"#n-03-wrong-error-message-in-__castoffchainvotes\" aria-label=\"n 03 wrong error message in __castoffchainvotes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/36\">[N-03] Wrong error message in <code>__castOffchainVotes</code></a></h2>\n<p>The error message states:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"14\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">proposal</span><span class=\"mtk1\">.</span><span class=\"mtk12\">offchain</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk8\">&quot;FairSideDAO::__castOffchainVotes: proposal is meant to be voted offchain&quot;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">);</span></span></span></code></pre>\n<p>But it should be ”… meant to be voted onchain”.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/36#issuecomment-851002517\">fairside-core (FairSide) confirmed</a>:</strong></p>\n<blockquote>\n<p>The change requested simply changes the text reported to off-chain processes and does not accompany a change in functionality.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/36#issuecomment-852170358\">fairside-core (FairSide) resolved</a>:</strong></p>\n<blockquote>\n<p>Fixed in <a href=\"https://github.com/fairside-core/2021-05-fairside/pull/15\">PR#15</a>.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/36#issuecomment-856204235\">cemozerr (Judge) commented</a>:</strong></p>\n<blockquote>\n<p>Labeling this as non-critical as the issue does not pose any risk to functionality.</p>\n</blockquote>\n<h2 id=\"n-04-non-existing-function-returns\" style=\"position:relative;\"><a href=\"#n-04-non-existing-function-returns\" aria-label=\"n 04 non existing function returns permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/10\">[N-04] non existing function returns</a></h2>\n<p>The functions <code>castVote</code> and  <code>castVoteBySig</code> of FairSideDAO.sol have no “returns” parameters,\nhowever they do call “return” at the end of the function. This is confusing for the readers of the code.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"15\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">castVote</span><span class=\"mtk1\">(</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">proposalId</span><span class=\"mtk1\">, </span><span class=\"mtk12\">bool</span><span class=\"mtk1\"> </span><span class=\"mtk12\">support</span><span class=\"mtk1\">) </span><span class=\"mtk11\">public</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk11\">_castVote</span><span class=\"mtk1\">(</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">, </span><span class=\"mtk12\">proposalId</span><span class=\"mtk1\">, </span><span class=\"mtk12\">support</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">castVoteBySig</span><span class=\"mtk1\">( .. ) </span><span class=\"mtk11\">public</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    ...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk11\">_castVote</span><span class=\"mtk1\">(</span><span class=\"mtk12\">signatory</span><span class=\"mtk1\">, </span><span class=\"mtk12\">proposalId</span><span class=\"mtk1\">, </span><span class=\"mtk12\">support</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p>Recommend removing the “return” statements from <code>castVote</code> and <code>castVoteBySig</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/10#issuecomment-852200367\">fairside-core (FairSide) confirmed</a>:</strong></p>\n<blockquote>\n<p>Fixed in <a href=\"https://github.com/fairside-core/2021-05-fairside/pull/22\">PR#22</a>.</p>\n</blockquote>\n<h2 id=\"n-05-totalcostsharebenefit--vs-totalcostsharebenefits-\" style=\"position:relative;\"><a href=\"#n-05-totalcostsharebenefit--vs-totalcostsharebenefits-\" aria-label=\"n 05 totalcostsharebenefit  vs totalcostsharebenefits  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/3\">[N-05] <code>totalCostShareBenefit</code>  vs <code>totalCostShareBenefits</code> </a></h2>\n<p>The function <code>purchaseMembership</code> of FSDNetwork.sol contains a variable that is very similar to a global variable. It’s easy to confuse the two, possibly introducing errors in the future. These variables are <code>totalCostShareBenefit</code>, and <code>totalCostShareBenefits</code>.</p>\n<p>FSDNetwork.sol:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"16\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">public</span><span class=\"mtk1\"> </span><span class=\"mtk12\">totalCostShareBenefits</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">purchaseMembership</span><span class=\"mtk1\">(</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">costShareBenefit</span><span class=\"mtk1\">) </span><span class=\"mtk11\">external</span><span class=\"mtk1\"> {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">totalCostShareBenefit</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">membership</span><span class=\"mtk1\">[</span><span class=\"mtk12\">msg</span><span class=\"mtk1\">.</span><span class=\"mtk12\">sender</span><span class=\"mtk1\">].</span><span class=\"mtk12\">availableCostShareBenefits</span><span class=\"mtk1\">.</span><span class=\"mtk11\">add</span><span class=\"mtk1\">(</span><span class=\"mtk12\">costShareBenefit</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        ...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">totalCostShareBenefits</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">totalCostShareBenefits</span><span class=\"mtk1\">.</span><span class=\"mtk11\">add</span><span class=\"mtk1\">(</span><span class=\"mtk12\">costShareBenefit</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p>Recommend changing one of the variables to an obviously different name.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/3\">fairside-core (FairSide) acknowledged</a></strong></p>\n<h2 id=\"n-06-misleading-error-messages\" style=\"position:relative;\"><a href=\"#n-06-misleading-error-messages\" aria-label=\"n 06 misleading error messages permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/11\">[N-06] Misleading error messages</a></h2>\n<p>There are misleading copy-pasted error messages. For Example, function <code>liquidateEth</code> has a misleading revert message:</p>\n<blockquote>\n<p>“FSD::payClaim: Insufficient Privileges”</p>\n</blockquote>\n<p>Same situation with functions <code>liquidateDai</code>, <code>setConvictionless</code>, <code>_addGovernanceTribute</code>. Function <code>_calculateDeltaOfFSD</code> has it misspelled. contract <code>Timelock</code> constructor uses ’<code>setDelay</code>‘.</p>\n<p>Recommending that it should be <code>payClaim</code> -> <code>liquidateEth</code>, etc., to identify the real name of the function where the error happened.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/64#issuecomment-851053596\">fairside-core (FairSide) confirmed and resolved (in separate issue #64)</a>:</strong></p>\n<blockquote>\n<p>Fixed in <a href=\"https://github.com/fairside-core/2021-05-fairside/pull/9\">PR#9</a>.</p>\n</blockquote>\n<h2 id=\"n-07-revert-messages-are-wrong\" style=\"position:relative;\"><a href=\"#n-07-revert-messages-are-wrong\" aria-label=\"n 07 revert messages are wrong permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/64\">[N-07] Revert messages are wrong</a></h2>\n<p>The following revert messages refer to a different function instead of the one where they actually are, making it harder to understand the flow of the program in case of error.</p>\n<ul>\n<li><a href=\"https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/FSD.sol#L166\">l. 166</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/FSD.sol#L185\">l. 185</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/FSD.sol#L254\">l. 254</a></li>\n</ul>\n<p>Recommend setting the messages with the correct function name.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/64#issuecomment-851053596\">fairside-core (FairSide) confirmed and resolved</a>:</strong></p>\n<blockquote>\n<p>Fixed in <a href=\"https://github.com/fairside-core/2021-05-fairside/pull/9\">PR#9</a>.</p>\n</blockquote>\n<h2 id=\"n-08-constant-values-used-inline\" style=\"position:relative;\"><a href=\"#n-08-constant-values-used-inline\" aria-label=\"n 08 constant values used inline permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/4\">[N-08] Constant values used inline</a></h2>\n<p>In several locations, constant values are used inline in the code. Normally, you would define those as constants to be able to review and update them easier.</p>\n<p>Recommend using constants for constant values.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/4#issuecomment-851002002\">fairside-core (FairSide) acknowledged</a>:</strong></p>\n<blockquote>\n<p>Similar to #65</p>\n</blockquote>\n<h2 id=\"n-09-events-in-fairsidedao-are-not-indexed\" style=\"position:relative;\"><a href=\"#n-09-events-in-fairsidedao-are-not-indexed\" aria-label=\"n 09 events in fairsidedao are not indexed permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/69\">[N-09] Events in <code>FairSideDAO</code> are not indexed</a></h2>\n<p>Events in the <code>FairSideDAO</code> contract are not indexed, making it difficult for off-chain scripts (such as the front-ends of dApps) to filter these events efficiently.</p>\n<p>Recommend adding the <code>indexed</code> keyword to the events. For Example:\n<code>event ProposalExecuted(uint256 indexed id);</code></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/69#issuecomment-850999838\">fairside-core (FairSide) acknowledged</a>:</strong></p>\n<blockquote>\n<p>Findings that do not alter the functionality of the contracts should not be labeled as anything else than 0 (Non-Critical). This purely relates to off-chain integration.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/69#issuecomment-856224024\">cemozerr (Judge) commented</a>:</strong></p>\n<blockquote>\n<p>Labeling this as non-critical as @fairside-core’s comment is correct.</p>\n</blockquote>\n<h2 id=\"n-10-lack-of-input-validation-of-id-in-getconvictionscore\" style=\"position:relative;\"><a href=\"#n-10-lack-of-input-validation-of-id-in-getconvictionscore\" aria-label=\"n 10 lack of input validation of id in getconvictionscore permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/60\">[N-10] lack of input validation of id in <code>getConvictionScore()</code></a></h2>\n<p><code>tokenId</code> shouldn’t be zero because it is initialized to 1. But  due to lack of input validation in <code>getConvictionScore(uint256 id)</code>, <code>tokenId</code> can be zero.</p>\n<p>Recommend adding a condition to check input values.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/60#issuecomment-851004133\">fairside-core (FairSide) acknowledged</a>:</strong></p>\n<blockquote>\n<p>Usage of an ID equal to <code>0</code> will yield <code>0</code> for its conviction score, and it cannot lead to any misbehavior of the contracts to my knowledge.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/60#issuecomment-856307025\">cemozerr (Judge) commented</a>:</strong></p>\n<blockquote>\n<p>Labeling this as non-critical as <code>getConvictionScore</code> returning 0 seems to have no impact on the protocol.</p>\n</blockquote>\n<h2 id=\"n-11-validatevotehash-does-not-confirm-the-vote-result\" style=\"position:relative;\"><a href=\"#n-11-validatevotehash-does-not-confirm-the-vote-result\" aria-label=\"n 11 validatevotehash does not confirm the vote result permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/37\">[N-11] <code>validateVoteHash</code> does not confirm the vote result</a></h2>\n<p>The <code>validateVoteHash</code> function only checks if the individual voting power (conviction score) is indeed correct, but it does not verify if the outcome of the vote is correct, i.e., it is possible for a guardian to submit completely different <code>forVotes</code>/<code>againstVotes</code> in <code>__castOffchainVotes</code> changing the proposal outcome.</p>\n<p>The guardian needs to be trusted to submit the correct <code>forVotes</code> and <code>againstVotes</code> to match the votes in the <code>voteHash</code>. The issue is that this cannot be easily verified.</p>\n<p>Legitimate users can be tricked into thinking the result is correct by checking if their vote &#x26; support is contained in <code>votes</code> and recomputing the <code>voteHash</code> themselves. They then call <code>validateVoteHash</code>, which “confirms” the guardian result. However, in reality, the guardian could have submitted arbitrary <code>forVotes</code>/<code>againstVotes</code> values.</p>\n<p>This makes the current validation system kind of useless.</p>\n<p>Recommend summing up the for/against votes in the <code>votes</code> array of <code>validateVoteHash</code> and check if it matches the <code>proposal.forVotes/againstVotes</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/37#issuecomment-851005971\">fairside-core (FairSide) acknowledged</a>:</strong></p>\n<blockquote>\n<p>The <code>VotePack</code> struct contains a <code>bool</code> indicating whether there was support for a proposal or not. The <code>validateVoteHash</code> function hashes all submitted votes meaning that it is impossible to obscure the for and against votes as they can be calculated off-chain.</p>\n<p>In any case, this is purely an off-chain utility function, and as such, the severity should be reduced to non-critical (0).</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/37#issuecomment-856310206\">cemozerr (Judge) commented</a>:</strong></p>\n<blockquote>\n<p>Labeling this as non-critical as <code>validateVoteHash</code> is an external function.</p>\n</blockquote>\n<h1 id=\"gas-optimizations\" style=\"position:relative;\"><a href=\"#gas-optimizations\" aria-label=\"gas optimizations permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Gas Optimizations</h1>\n<h2 id=\"g-01-gas-optimizations---checkpoints-from-erc20convictionscore\" style=\"position:relative;\"><a href=\"#g-01-gas-optimizations---checkpoints-from-erc20convictionscore\" aria-label=\"g 01 gas optimizations   checkpoints from erc20convictionscore permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/54\">[G-01] Gas optimizations - checkpoints from <code>ERC20ConvictionScore</code></a></h2>\n<p>In <code>ERC20ConvictionScore.sol</code>, we store</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"17\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// Conviction score based on # of days multiplied by # of FSD &amp; NFT</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// @notice A record of conviction score checkpoints for each account, by index</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">mapping</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> </span><span class=\"mtk11\">mapping</span><span class=\"mtk1\">(</span><span class=\"mtk12\">uint32</span><span class=\"mtk1\"> </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> </span><span class=\"mtk12\">Checkpoint</span><span class=\"mtk1\">)) </span><span class=\"mtk12\">public</span><span class=\"mtk1\"> </span><span class=\"mtk12\">checkpoints</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// @notice The number of checkpoints for each account</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">mapping</span><span class=\"mtk1\">(</span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk4\">=&gt;</span><span class=\"mtk1\"> </span><span class=\"mtk12\">uint32</span><span class=\"mtk1\">) </span><span class=\"mtk12\">public</span><span class=\"mtk1\"> </span><span class=\"mtk12\">numCheckpoints</span><span class=\"mtk1\">;</span></span></span></code></pre>\n<p>These two state variables are used in the following way: (see <a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/54\">Issue #54</a> for referenced code)</p>\n<p>Checking the contract seems like using <code>mapping(address => Checkpoint[]) public checkpoints;</code> would provide the same functionality while using less storage.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/54#issuecomment-851007512\">fairside-core (FairSide) questioned</a>:</strong></p>\n<blockquote>\n<p>I am unsure what this relates to. Can we have some further information from a_delamo?</p>\n</blockquote>\n<h2 id=\"g-02-reduce-reads-in-purchasemembership-method\" style=\"position:relative;\"><a href=\"#g-02-reduce-reads-in-purchasemembership-method\" aria-label=\"g 02 reduce reads in purchasemembership method permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/55\">[G-02] Reduce reads in <code>purchaseMembership</code> method</a></h2>\n<p>The method <code>purchaseMembership</code> in the <code>FSDNetwork</code> contract contains the code below.\nInside this method, we are constantly reading from the mapping <code>membership</code>, so why not use just one read <code>Membership userMembership = membership[msg.sender]</code> and use this instance for everything related to memberships as each read we are currently doing has an impact on the gas cost.</p>\n<p>See <a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/55\">Issue #55</a> for referenced code.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/55#issuecomment-852113491\">fairside-core (FairSide) confirmed and resolved</a>:</strong></p>\n<blockquote>\n<p>Fixed in <a href=\"https://github.com/fairside-core/2021-05-fairside/pull/11\">PR#11</a>.</p>\n</blockquote>\n<h2 id=\"g-03-use-external-instead-of-public-methods\" style=\"position:relative;\"><a href=\"#g-03-use-external-instead-of-public-methods\" aria-label=\"g 03 use external instead of public methods permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/57\">[G-03] Use external instead of public methods</a></h2>\n<p>The following methods are public and could be external. External is more optimized for gas than public and, as such, should be used as much as possible. See <a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/57\">issue #57</a> for examples and more info at <a href=\"https://ethereum.stackexchange.com/a/19391\">https://ethereum.stackexchange.com/a/19391</a></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/57#issuecomment-851007235\">fairside-core (FairSide) acknowledged</a>:</strong></p>\n<blockquote>\n<p>As the Stack Overflow post indicates, the optimization is only really applicable when arrays are involved. We will retain the functions as is and adjust them as necessary further down in the development cycle.</p>\n</blockquote>\n<h2 id=\"g-04-improvements-arctan\" style=\"position:relative;\"><a href=\"#g-04-improvements-arctan\" aria-label=\"g 04 improvements arctan permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/2\">[G-04] Improvements arctan</a></h2>\n<p>The performance (gas usage) of the current arctan implementation is:\n<code>arctan(ONE)</code> ~ 5126  Gas (with solidity 0.6.8)</p>\n<p>The main cause of the gas usage is the library <code>ABDKMathQuad</code> which implements IEEE 754 quadruple-precision binary floating-point numbers. However, the arctan approximation has relatively low precision.</p>\n<p>The PDF “higher<em>order</em>approximations” in <a href=\"https://www.researchgate.net/publication/258792323_Full_Quadrant_Approximations_for_the_Arctangent_Function_Tips_and_Tricks\">this article</a> shows different formulas for the approximation for arctan, which have higher precision than the current implementation.</p>\n<p>The third-order approximation is:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"\" data-index=\"18\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">arctan(x)  ∼ π/2 * sgn(x)*φ(abs(x))</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">φ(x) = { a*x + x^2 + x^3 } / { 1 + (a+1)x + (a+1)x^2 + x^3 }</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">a=0.6399276529</span></span></code></pre>\n<p>I’ve made an implementation (see below), which takes a lot less gas:\narctan_uint(1 * precision) ~ 574 Gas (with solidity 0.6.8)</p>\n<p>The implementation takes a different approach to floating points: it multiples all numbers by precision. The precision factor can be adjusted as long as all temporary variables stay below 2^256 (the max value of a uint)</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"19\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">pragma</span><span class=\"mtk1\"> </span><span class=\"mtk12\">solidity</span><span class=\"mtk1\"> </span><span class=\"mtk7\">0.6</span><span class=\"mtk1\">.</span><span class=\"mtk7\">8</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">contract</span><span class=\"mtk1\"> </span><span class=\"mtk12\">Test</span><span class=\"mtk1\">{</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">   </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">constant</span><span class=\"mtk1\"> </span><span class=\"mtk12\">precision</span><span class=\"mtk1\">=</span><span class=\"mtk7\">10</span><span class=\"mtk1\">**</span><span class=\"mtk7\">30</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">   </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">constant</span><span class=\"mtk1\"> </span><span class=\"mtk12\">pi</span><span class=\"mtk1\">=</span><span class=\"mtk7\">3.1415926535E30</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">   </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">constant</span><span class=\"mtk1\"> </span><span class=\"mtk12\">pidiv2</span><span class=\"mtk1\">=</span><span class=\"mtk12\">pi</span><span class=\"mtk1\">/</span><span class=\"mtk7\">2</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">   </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">constant</span><span class=\"mtk1\"> </span><span class=\"mtk12\">a1</span><span class=\"mtk1\">=</span><span class=\"mtk7\">0.6399276529E30</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">   </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">constant</span><span class=\"mtk1\"> </span><span class=\"mtk12\">aplus1</span><span class=\"mtk1\">=</span><span class=\"mtk7\">1.6399276529E30</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">   </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">arctan_uint</span><span class=\"mtk1\">(</span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">x</span><span class=\"mtk1\">) </span><span class=\"mtk11\">public</span><span class=\"mtk1\"> </span><span class=\"mtk11\">pure</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">       </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">xsquare</span><span class=\"mtk1\">   = </span><span class=\"mtk12\">x</span><span class=\"mtk1\">*</span><span class=\"mtk12\">x</span><span class=\"mtk1\">/</span><span class=\"mtk12\">precision</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">       </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">xtriple</span><span class=\"mtk1\">     = </span><span class=\"mtk12\">xsquare</span><span class=\"mtk1\"> * </span><span class=\"mtk12\">x</span><span class=\"mtk1\">/</span><span class=\"mtk12\">precision</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">       </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">aplus1x</span><span class=\"mtk1\">   = </span><span class=\"mtk12\">aplus1</span><span class=\"mtk1\"> * </span><span class=\"mtk12\">x</span><span class=\"mtk1\">/</span><span class=\"mtk12\">precision</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">       </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">top</span><span class=\"mtk1\">         = </span><span class=\"mtk12\">a1</span><span class=\"mtk1\"> * </span><span class=\"mtk12\">x</span><span class=\"mtk1\">/</span><span class=\"mtk12\">precision</span><span class=\"mtk1\"> + </span><span class=\"mtk12\">xsquare</span><span class=\"mtk1\"> + </span><span class=\"mtk12\">xtriple</span><span class=\"mtk1\">; </span><span class=\"mtk3\">// a*x + x^2 + x^3</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">       </span><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">bottom</span><span class=\"mtk1\">  = </span><span class=\"mtk12\">precision</span><span class=\"mtk1\"> + </span><span class=\"mtk12\">aplus1x</span><span class=\"mtk1\"> + </span><span class=\"mtk12\">aplus1x</span><span class=\"mtk1\">*</span><span class=\"mtk12\">x</span><span class=\"mtk1\">/</span><span class=\"mtk12\">precision</span><span class=\"mtk1\"> + </span><span class=\"mtk12\">xtriple</span><span class=\"mtk1\">; </span><span class=\"mtk3\">// 1 + (a+1)x + (a+1)x^2 + x^3</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">       </span><span class=\"mtk15\">return</span><span class=\"mtk1\">         </span><span class=\"mtk12\">pidiv2</span><span class=\"mtk1\">*</span><span class=\"mtk12\">top</span><span class=\"mtk1\">/</span><span class=\"mtk12\">bottom</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">   }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">   </span><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">test_arctan_uint</span><span class=\"mtk1\">() </span><span class=\"mtk11\">public</span><span class=\"mtk1\"> </span><span class=\"mtk11\">pure</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint</span><span class=\"mtk1\">){</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">       </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk11\">arctan_uint</span><span class=\"mtk1\">(</span><span class=\"mtk12\">precision</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">   }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p>Recommend defining which resolution is required and take the necessary formula from the higher<em>order</em>approximations.pdf document. Change the math library to a simple “precision” based implementation (as shown above). This will also require adapting other code. Also, set the “precision” constant to the required precision and adjust the constants to the required number of decimals.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/2#issuecomment-851016512\">fairside-core (FairSide) acknowledged</a>:</strong></p>\n<blockquote>\n<p>Although the optimization is acknowledged, it will not be applied given that we already use ABDK math across the full codebase.</p>\n</blockquote>\n<h2 id=\"g-05-repetitive-storage-access\" style=\"position:relative;\"><a href=\"#g-05-repetitive-storage-access\" aria-label=\"g 05 repetitive storage access permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/15\">[G-05] Repetitive storage access</a></h2>\n<p>The function <code>_addTribute</code> can reuse <code>lastTribute</code> to reduce the numbers of storage access: tributes<code>[totalTributes - 1].amount = add224(...)</code> can be replaced with <code>lastTribute.amount = add224(...)</code> as it is already a storage pointer that can be assigned a value with no need to recalculate the index and access the array again. Same situation with function <code>_addGovernanceTribute</code> and <code>governanceTributes</code>.</p>\n<p>Recommend making <code>lastTribute.amount = add224(...)</code></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/15#issuecomment-852202577\">fairside-core (FairSide) confirmed and resolved</a>:</strong></p>\n<blockquote>\n<p>Fixed in <a href=\"https://github.com/fairside-core/2021-05-fairside/pull/23\">PR#23</a>.</p>\n</blockquote>\n<h2 id=\"g-06-gas-optimization-for-the-rootpows-function-in-fairsideformula\" style=\"position:relative;\"><a href=\"#g-06-gas-optimization-for-the-rootpows-function-in-fairsideformula\" aria-label=\"g 06 gas optimization for the rootpows function in fairsideformula permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/71\">[G-06] Gas optimization for the <code>rootPows</code> function in <code>FairSideFormula</code></a></h2>\n<p>Gas optimization is possible for the current <code>rootPows</code> implementation.\nThe original implementation of <code>rootPows</code> requires 4 <code>mul</code> and 2 <code>sqrt</code>:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"20\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">rootPows</span><span class=\"mtk1\">(</span><span class=\"mtk12\">bytes16</span><span class=\"mtk1\"> </span><span class=\"mtk12\">x</span><span class=\"mtk1\">) </span><span class=\"mtk11\">private</span><span class=\"mtk1\"> </span><span class=\"mtk11\">pure</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">bytes16</span><span class=\"mtk1\">, </span><span class=\"mtk12\">bytes16</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// fourth root</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">x</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">x</span><span class=\"mtk1\">.</span><span class=\"mtk11\">sqrt</span><span class=\"mtk1\">().</span><span class=\"mtk11\">sqrt</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// to the power of 3</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">x</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">_pow3</span><span class=\"mtk1\">(</span><span class=\"mtk12\">x</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// we offset the root on the second arg</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">x</span><span class=\"mtk1\">, </span><span class=\"mtk12\">x</span><span class=\"mtk1\">.</span><span class=\"mtk11\">mul</span><span class=\"mtk1\">(</span><span class=\"mtk12\">x</span><span class=\"mtk1\">));</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p>However, the calculation process can be simplified to be more gas-efficient than the original with only 1 <code>mul</code> and 2 <code>sqrt</code> requried:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"21\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">rootPows</span><span class=\"mtk1\">(</span><span class=\"mtk12\">bytes16</span><span class=\"mtk1\"> </span><span class=\"mtk12\">x</span><span class=\"mtk1\">) </span><span class=\"mtk11\">private</span><span class=\"mtk1\"> </span><span class=\"mtk11\">pure</span><span class=\"mtk1\"> </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">bytes16</span><span class=\"mtk1\">, </span><span class=\"mtk12\">bytes16</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">bytes16</span><span class=\"mtk1\"> </span><span class=\"mtk12\">x1_2</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">x</span><span class=\"mtk1\">.</span><span class=\"mtk11\">sqrt</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">bytes16</span><span class=\"mtk1\"> </span><span class=\"mtk12\">x3_2</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">x</span><span class=\"mtk1\">.</span><span class=\"mtk11\">mul</span><span class=\"mtk1\">(</span><span class=\"mtk12\">x1_2</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">bytes16</span><span class=\"mtk1\"> </span><span class=\"mtk12\">x3_4</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">x3_2</span><span class=\"mtk1\">.</span><span class=\"mtk11\">sqrt</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">x3_4</span><span class=\"mtk1\">, </span><span class=\"mtk12\">x3_2</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p>Recommend changing the implementation of <code>rootPows</code> as mentioned above.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/71#issuecomment-850998359\">fairside-core (FairSide) questioned</a>:</strong></p>\n<blockquote>\n<p>Optimization is confirmed (basically constructs x^3/2 then applies root on it). Given that this is a gas optimization, perhaps the severity should be noted down to 1? I’ll leave this up to the judges.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-05-fairside-findings/issues/71#issuecomment-851050066\">fairside-core (FairSide) confirmed and resolved</a>:</strong></p>\n<blockquote>\n<p>Fixed in <a href=\"https://github.com/fairside-core/2021-05-fairside/pull/6\">PR#6</a>.</p>\n</blockquote>\n<h1 id=\"disclosures\" style=\"position:relative;\"><a href=\"#disclosures\" aria-label=\"disclosures permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Disclosures</h1>\n<p>C4 is an open organization governed by participants in the community.</p>\n<p>C4 Contests incentivize the discovery of exploits, vulnerabilities, and bugs in smart contracts. Security researchers are rewarded at an increasing rate for finding higher-risk issues. Contest submissions are judged by a knowledgeable security researcher and solidity developer and disclosed to sponsoring developers. C4 does not conduct formal verification regarding the provided code but instead provides final verification.</p>\n<p>C4 does not provide any guarantee or warranty regarding the security of this project. All smart contract software should be used at the sole risk and responsibility of users.</p>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n  .dark-default-dark {\n    background-color: #1E1E1E;\n    color: #D4D4D4;\n  }\n  .dark-default-dark .mtk12 { color: #9CDCFE; }\n  .dark-default-dark .mtk1 { color: #D4D4D4; }\n  .dark-default-dark .mtk4 { color: #569CD6; }\n  .dark-default-dark .mtk11 { color: #DCDCAA; }\n  .dark-default-dark .mtk7 { color: #B5CEA8; }\n  .dark-default-dark .mtk8 { color: #CE9178; }\n  .dark-default-dark .mtk15 { color: #C586C0; }\n  .dark-default-dark .mtk3 { color: #6A9955; }\n  .dark-default-dark .grvsc-line-highlighted::before {\n    background-color: var(--grvsc-line-highlighted-background-color, rgba(255, 255, 255, 0.1));\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(255, 255, 255, 0.5));\n  }\n</style>",
  "toc": "<ul>\n<li>\n<p><a href=\"#overview\">Overview</a></p>\n<ul>\n<li><a href=\"#about-c4\">About C4</a></li>\n<li><a href=\"#wardens\">Wardens</a></li>\n</ul>\n</li>\n<li><a href=\"#summary\">Summary</a></li>\n<li><a href=\"#scope\">Scope</a></li>\n<li><a href=\"#severity-criteria\">Severity Criteria</a></li>\n<li>\n<p><a href=\"#high-risk-findings\">High Risk Findings</a></p>\n<ul>\n<li><a href=\"#h-01-conviction-scoring-fails-to-initialize-and-bootstrap\">[H-01] Conviction scoring fails to initialize and bootstrap</a></li>\n<li><a href=\"#h-02-locked-funds-are-debited-twice-from-the-user-during-tokenization-leading-to-fund-loss\">[H-02] Locked funds are debited twice from the user during tokenization leading to fund loss</a></li>\n<li><a href=\"#h-03-locked-funds-from-tokenization-are-credited-twice-to-user-leading-to-protocol-fund-loss\">[H-03] Locked funds from tokenization are credited twice to user leading to protocol fund loss</a></li>\n<li><a href=\"#h-04-erc20convictionscores-governancedelta-should-be-subtracted-when-user-is-not-a-governor-anymore\">[H-04] <code>ERC20ConvictionScore</code>’s <code>governanceDelta</code> should be subtracted when user is not a governor anymore</a></li>\n<li><a href=\"#h-05-withdrawablewithdraw-does-not-decrease-pendingwithdrawals\">[H-05] <code>Withdrawable.withdraw</code> does not decrease <code>pendingWithdrawals</code></a></li>\n<li><a href=\"#h-06-incorrect-type-conversion-in-the-contract-abc-makes-users-unable-to-burn-fsd-tokens\">[H-06] Incorrect type conversion in the contract <code>ABC</code> makes users unable to burn FSD tokens</a></li>\n<li><a href=\"#h-07-erc20convictionscore_updateconvictionscore-uses-stale-credit-score-for-governancedelta\">[H-07] <code>ERC20ConvictionScore._updateConvictionScore</code> uses stale credit score for <code>governanceDelta</code></a></li>\n<li><a href=\"#h-08-incorrect-implementation-of-arctan-in-the-contract-fairsideformula\">[H-08] Incorrect implementation of arctan in the contract <code>FairSideFormula</code></a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#medium-risk-findings\">Medium Risk Findings</a></p>\n<ul>\n<li><a href=\"#m-01-incorrect-use-of-_addtribute-instead-of-_addgovernancetribute\">[M-01] Incorrect use of <code>_addTribute</code> instead of <code>_addGovernanceTribute</code></a></li>\n<li><a href=\"#m-02-call-to-swapexacttokensforeth-in-liquidatedai-will-always-fail\">[M-02] Call to <code>swapExactTokensForETH</code> in <code>liquidateDai()</code> will always fail</a></li>\n<li><a href=\"#m-03-conviction-totals-not-updated-during-tokenization\">[M-03] Conviction totals not updated during tokenization</a></li>\n<li><a href=\"#m-04-eth-may-get-stuck-in-contract\">[M-04] Eth may get stuck in contract</a></li>\n<li><a href=\"#m-05-bug-inside-abdkmathquad-library\">[M-05] Bug inside ABDKMathQuad library</a></li>\n<li><a href=\"#m-06-pendingwithdrawals-just-increments\">[M-06] pendingWithdrawals just increments</a></li>\n<li><a href=\"#m-07-nfts-can-never-be-redeemed-back-to-their-conviction-scores-leading-to-lockloss-of-funds\">[M-07] NFTs can never be redeemed back to their conviction scores leading to lock/loss of funds</a></li>\n<li><a href=\"#m-08-erc20convictionscore-allows-transfers-to-special-total_governance_score-address\">[M-08] <code>ERC20ConvictionScore</code> allows transfers to special <code>TOTAL_GOVERNANCE_SCORE</code> address</a></li>\n<li><a href=\"#m-09-should-check-return-data-from-chainlink-aggregators\">[M-09] Should check return data from Chainlink aggregators</a></li>\n<li><a href=\"#m-10-graceperiod-not-increased-after-membership-extension\">[M-10] <code>gracePeriod</code> not increased after membership extension</a></li>\n<li><a href=\"#m-11-the-variable-fshareratio-is-vulnerable-to-manipulation-by-flash-minting-and-burning\">[M-11] The variable <code>fShareRatio</code> is vulnerable to manipulation by flash minting and burning</a></li>\n<li><a href=\"#m-12-erc20convictionscoreacquireconviction-implements-wrong-governance-checks\">[M-12] <code>ERC20ConvictionScore.acquireConviction</code> implements wrong governance checks</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#low-risk-findings\">Low Risk Findings</a></p>\n<ul>\n<li><a href=\"#l-01-lack-of-zero-address-checks-for-immutable-addresses-will-force-contract-redeployment-if-zero-address-used-accidentally\">[L-01] Lack of zero-address checks for immutable addresses will force contract redeployment if zero-address used accidentally</a></li>\n<li><a href=\"#l-02-dangerous-solidity-compiler-pragma-range-that-spans-breaking-versions\">[L-02] Dangerous Solidity compiler pragma range that spans breaking versions</a></li>\n<li><a href=\"#l-03-usage-of-transfer\">[L-03] Usage of transfer</a></li>\n<li><a href=\"#l-04-missing-use-of-dsmath-functions-may-lead-to-underflowsoverflows\">[L-04] Missing use of DSMath functions may lead to underflows/overflows</a></li>\n<li><a href=\"#l-05-convictionless-mapping-is-not-used\">[L-05] <code>convictionless</code> mapping is not used</a></li>\n<li><a href=\"#l-06-flash-minting-and-burning-can-reduce-the-paid-fees-when-purchasing-a-membership-or-opening-a-cost-share-request\">[L-06] Flash minting and burning can reduce the paid fees when purchasing a membership or opening a cost-share request</a></li>\n<li><a href=\"#l-07-check-if-variables-are-initialized\">[L-07] Check if variables are initialized</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#non-critical-findings\">Non-Critical Findings</a></p>\n<ul>\n<li><a href=\"#n-01-use-of-ecrecover-is-susceptible-to-signature-malleability\">[N-01] Use of <code>ecrecover</code> is susceptible to signature malleability</a></li>\n<li><a href=\"#n-02-fairsidedaosecs_per_block-is-inaccurate\">[N-02] <code>FairSideDAO.SECS_PER_BLOCK</code> is inaccurate</a></li>\n<li><a href=\"#n-03-wrong-error-message-in-__castoffchainvotes\">[N-03] Wrong error message in <code>__castOffchainVotes</code></a></li>\n<li><a href=\"#n-04-non-existing-function-returns\">[N-04] non existing function returns</a></li>\n<li><a href=\"#n-05-totalcostsharebenefit--vs-totalcostsharebenefits-\">[N-05] <code>totalCostShareBenefit</code>  vs <code>totalCostShareBenefits</code> </a></li>\n<li><a href=\"#n-06-misleading-error-messages\">[N-06] Misleading error messages</a></li>\n<li><a href=\"#n-07-revert-messages-are-wrong\">[N-07] Revert messages are wrong</a></li>\n<li><a href=\"#n-08-constant-values-used-inline\">[N-08] Constant values used inline</a></li>\n<li><a href=\"#n-09-events-in-fairsidedao-are-not-indexed\">[N-09] Events in <code>FairSideDAO</code> are not indexed</a></li>\n<li><a href=\"#n-10-lack-of-input-validation-of-id-in-getconvictionscore\">[N-10] lack of input validation of id in <code>getConvictionScore()</code></a></li>\n<li><a href=\"#n-11-validatevotehash-does-not-confirm-the-vote-result\">[N-11] <code>validateVoteHash</code> does not confirm the vote result</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#gas-optimizations\">Gas Optimizations</a></p>\n<ul>\n<li><a href=\"#g-01-gas-optimizations---checkpoints-from-erc20convictionscore\">[G-01] Gas optimizations - checkpoints from <code>ERC20ConvictionScore</code></a></li>\n<li><a href=\"#g-02-reduce-reads-in-purchasemembership-method\">[G-02] Reduce reads in <code>purchaseMembership</code> method</a></li>\n<li><a href=\"#g-03-use-external-instead-of-public-methods\">[G-03] Use external instead of public methods</a></li>\n<li><a href=\"#g-04-improvements-arctan\">[G-04] Improvements arctan</a></li>\n<li><a href=\"#g-05-repetitive-storage-access\">[G-05] Repetitive storage access</a></li>\n<li><a href=\"#g-06-gas-optimization-for-the-rootpows-function-in-fairsideformula\">[G-06] Gas optimization for the <code>rootPows</code> function in <code>FairSideFormula</code></a></li>\n</ul>\n</li>\n<li><a href=\"#disclosures\">Disclosures</a></li>\n</ul>",
  "md": "\n# Overview\n\n## About C4\n\nCode 432n4 (C4) is an open organization consisting of security researchers, auditors, developers, and individuals with domain expertise in smart contracts.\n\nA C4 code contest is an event in which community participants, referred to as Wardens, review, audit, or analyze smart contract logic in exchange for a bounty provided by sponsoring projects.\n\nDuring the code contest outlined in this document, C4 conducted an analysis of the FairSide smart contract system written in Solidity. The code contest took place between May 20 and May 26, 2021.\n\n## Wardens\n\n8 Wardens contributed reports to the FairSide code contest:\n\n- [cmichel](https://twitter.com/cmichelio)\n- [shw](https://github.com/x9453)\n- [0xRajeev](https://twitter.com/0xRajeev)\n- [a_delamo](https://twitter.com/a_delamo)\n- [Thunder](https://twitter.com/SolidityDev)\n- [gpersoon](https://twitter.com/gpersoon)\n- [Jmukesh](https://twitter.com/MukeshJ_eth)\n- [s1m0](https://twitter.com/_smonica_)\n\nThis contest was judged by [Cem](https://twitter.com/cemozer_).\n\nFinal report assembled by [ninek](https://twitter.com/_ninek_) and [moneylegobatman](https://twitter.com/money_lego).\n\n# Summary\n\nThe C4 analysis yielded an aggregated total of 45 unique vulnerabilities. All of the issues presented here are linked back to their original finding.\n\nOf these vulnerabilities, 8 received a risk rating in the category of HIGH severity, 12 received a risk rating in the category of MEDIUM severity, and 7 received a risk rating in the category of LOW severity.\n\nC4 analysis also identified 18 non-critical recommendations.\n\n# Scope\n\nThe code under review can be found within the [C4 code contest repository](https://github.com/code-423n4/2021-05-fairside) and comprises 21 smart contracts written in the Solidity programming language.\n\n# Severity Criteria\n\nC4 assesses the severity of disclosed vulnerabilities according to a methodology based on [OWASP standards](https://owasp.org/www-community/OWASP_Risk_Rating_Methodology).\n\nVulnerabilities are divided into three primary risk categories: high, medium, and low.\n\nHigh-level considerations for vulnerabilities span the following key areas when conducting assessments:\n\n- Malicious Input Handling\n- Escalation of privileges\n- Arithmetic\n- Gas use\n\nFurther information regarding the severity criteria referenced throughout the submission review process, please refer to the documentation provided on [the C4 website](https://code423n4.com).\n\n# High Risk Findings\n## [[H-01] Conviction scoring fails to initialize and bootstrap](https://github.com/code-423n4/2021-05-fairside-findings/issues/26)\n\nConviction scores for new addresses/users fail to initialize+bootstrap in `ERC20ConvictionScore`’s `_updateConvictionScore()` because a new user’s `numCheckpoints` will be zero and never gets initialized.\n\nThis effectively means that FairSide conviction scoring fails to bootstrap at all, leading to the failure of the protocol's pivotal feature.\n\nWhen Alice transfers FSD tokens to Bob for the first time, `_beforeTokenTransfer(Alice, Bob, 100)` is triggered which calls `_updateConvictionScore(Bob, 100)` on Line55 of ERC20ConvictionScore.sol.\n\nIn function `_updateConvictionScore()`, given that this is the first time Bob is receiving FSD tokens, `numCheckpoints[Bob]` will be 0 (Line116) which will make `ts = 0` (Line120), and Bob’s FSD balance will also be zero (Bob never has got FSD tokens prior to this) which makes `convictionDelta = 0` (Line122) and not let control go past Line129.\n\nThis means that a new checkpoint never gets written, i.e., conviction score never gets initialized, for Bob or for any user for that matter.\n\nFairSide's adjustment of Compound's conviction scoring is based on time and therefore needs an initialization to take place vs Compound's implementation. Therefore, a new checkpoint needs to be created+initialized for a new user during token transfer.\n\n**[fairside-core (FairSide) confirmed](https://github.com/code-423n4/2021-05-fairside-findings/issues/26#issuecomment-852189540):**\n> Fixed in [PR#18](https://github.com/fairside-core/2021-05-fairside/pull/18).\n\n\n## [[H-02] Locked funds are debited twice from the user during tokenization leading to fund loss](https://github.com/code-423n4/2021-05-fairside-findings/issues/29)\n\nDuring tokenization of conviction scores, the user can optionally provide FSDs to be locked to let it continue conviction accrual. However, the amount of FSDs specified for locking are debited from the user twice, leading to fund loss.\n\nThis, in effect, forces the user to unknowingly and unintentionally lock twice the amount of FSD tokens, leading to a loss of the specified 'locked' number of tokens.\n\nAlice decides to tokenize her conviction score into an NFT and specifies 100 FSD tokens to be locked in her call to `tokenizeConviction(100)`. 100 FSD tokens are transferred from her FSD balance to `FairSideConviction` contract on Line282 of `ERC20ConvictionScore.sol`. However, in `FairSideConviction.createConvictionNFT()`, the specified locked amount is transferred again from Alice to the contract on Line50 of `FairSideConviction.sol`.\n\nThe impact is that Alice wanted to lock only 100 FSD tokens, but the FairSide protocol has debited 200 tokens from her balance leading to a loss of 100 FSD tokens.\n\nRecommend removing the redundant transfer of FSD tokens on Line282 in `tokenizeConviction()` of `ERC20ConvictionScore.sol`.\n\n## [[H-03] Locked funds from tokenization are credited twice to user leading to protocol fund loss](https://github.com/code-423n4/2021-05-fairside-findings/issues/30)\n\nThe tokens optionally locked during tokenization are released twice on acquiring conviction back from an NFT. (The incorrect double debit of locked funds during tokenization has been filed as a separate finding because it is not necessarily related and occurs in different parts of the code.)\n\nWhen a user wants to acquire back the conviction score captured by an NFT, the FSD tokens locked, if any, are released to the user as well. However, this is incorrectly done twice. Released amount is transferred once on Line123 in `_release()` (via `acquireConviction` -> `burn`) of FairSideConviction.sol and again immediately after the burn on Line316 in `acquireConviction()` of `ERC20ConvictionScore.sol`.\n\nThis leads to loss of protocol funds.\n\nAlice tokenizes her conviction score into an NFT and locks 100 FSDs. Bob buys the NFT from Alice and acquires the conviction score back from the NFT. But instead of 100 FSDs that were supposed to be locked with the NFT, Bob receives 100+100 = 200 FSDs from FairSide protocol.\n\nRecommend removing the redundant transfer of FSD tokens from protocol to the user on Line316 in `acquireConviction()` of `ERC20ConvictionScore.sol`.\n\n**[fairside-core (FairSide) questioned](https://github.com/code-423n4/2021-05-fairside-findings/issues/30#issuecomment-850995532):**\n> This is directly related to #29 as it refers to the same workflow, as seen in #74 as a single submission. I believe splitting this into two findings is unfair for the first party, and secondly, it does not make sense because there is a valid argument for disagreeing with the severity seen on #74. Can we close this and merge it with #29?\n\n**[fairside-core (FairSide) commented](https://github.com/code-423n4/2021-05-fairside-findings/issues/30#issuecomment-852171754):**\n> Fixed in [PR#3](https://github.com/fairside-core/2021-05-fairside/pull/3).\n\n**[cemozerr (Judge) commented](https://github.com/code-423n4/2021-05-fairside-findings/issues/30#issuecomment-856199389):**\n> Labeling issues #29 and #30 as separate issues because they both pose major issues, which lead to temporary loss of funds, in two different workflows. One when tokenizing convictions and another when acquiring convictions.\n\n\n## [[H-04] `ERC20ConvictionScore`'s `governanceDelta` should be subtracted when user is not a governor anymore](https://github.com/code-423n4/2021-05-fairside-findings/issues/40)\n\nThe `TOTAL_GOVERNANCE_SCORE` is supposed to track the sum of the credit scores of all governors.\n\nIn `ERC20ConvictionScore._updateConvictionScore`, when the user does not fulfill the governance criteria anymore and is therefore removed, the `governanceDelta` should be negative, but it's positive.\n\n```solidity\nisGovernance[user] = false;\ngovernanceDelta = getPriorConvictionScore(\n    user,\n    block.number - 1\n);\n```\n\nIt then gets added to the new total:\n\n```solidity\nuint224 totalGCSNew =\n    add224(\n        totalGCSOld,\n        governanceDelta,\n        \"ERC20ConvictionScore::_updateConvictionTotals: conviction score amount overflows\"\n    );\n```\n\nThe `TOTAL_GOVERNANCE_SCORE` tracks wrong data leading to issues throughout all contracts like wrong `FairSideDAO.totalVotes` data, which can then be used by anyone to pass proposals in the worst case.\n\nOr `totalVotes` can be arbitrarily inflated and break the voting mechanism as no proposals can reach the quorum (percentage of `totalVotes`) anymore.\n\nRecommend returning a negative signed integer for this case and adding it to the new total.\n\n**[fairside-core (FairSide) confirmed](https://github.com/code-423n4/2021-05-fairside-findings/issues/40#issuecomment-852167769):**\n> Fixed in [PR#14](https://github.com/fairside-core/2021-05-fairside/pull/14).\n\n## [[H-05] `Withdrawable.withdraw` does not decrease `pendingWithdrawals`](https://github.com/code-423n4/2021-05-fairside-findings/issues/48)\n\nThe name `pendingWithdrawals` indicates that this storage variable tracks the withdrawals that need yet to be paid out. Furthermore, this matches the behavior in `_increaseWithdrawal`. As such, it should be decreased when withdrawing in `withdraw`, but it is not.\n\nThe `getReserveBalance` function consistently under-reports the actual reserve balance, which leads to the wrong mint amounts being used in the `FSD.mint` calculation.\n\nRecommend decreasing `pendingWithdrawals` by the withdrawn amount.\n\n**[fairside-core (FairSide) confirmed (in duplicate issue #72)](https://github.com/code-423n4/2021-05-fairside-findings/issues/72#issuecomment-850998007)**\n> One of two easter eggs!\n> Fixed in PR#5.\n\n## [[H-06] Incorrect type conversion in the contract `ABC` makes users unable to burn FSD tokens](https://github.com/code-423n4/2021-05-fairside-findings/issues/77)\n\nThe function `_calculateDeltaOfFSD` of contract `ABC` incorrectly converts an `int256` type parameter, `_reserveDelta`, to `uint256` by explicit conversion, which in general results in an extremely large number when the provided parameter is negative. The extremely large number could cause a SafeMath operation `sub` at line 43 to revert, and thus the FSD tokens cannot be burned as `_reserveDelta` is negative when burning FSD tokens.\n\nSimply calling `fsd.burn` after a successful `fsd.mint` will trigger this bug.\n\nRecommend using the solidity function `abs` to get the `_reserveDelta` absolute value.\n\n**[fairside-core (FairSide) confirmed:](https://github.com/code-423n4/2021-05-fairside-findings/issues/77#issuecomment-851029859)**\n> Fixed in [PR#1](https://github.com/fairside-core/2021-05-fairside/pull/1).\n\n## [[H-07] `ERC20ConvictionScore._updateConvictionScore` uses stale credit score for `governanceDelta`](https://github.com/code-423n4/2021-05-fairside-findings/issues/41)\n\nIn `ERC20ConvictionScore._updateConvictionScore`, when the user does not fulfill the governance criteria anymore, the `governanceDelta` is the old conviction score of the previous block.\n\n```solidity\nisGovernance[user] = false;\ngovernanceDelta = getPriorConvictionScore(\n    user,\n    block.number - 1\n);\n```\n\nThe user could increase their conviction/governance score first (in the same block) and then lose their status in a second transaction. After which, the total governance conviction score would only be reduced by the previous score.\n\n** Example:**\nBlock n - 10000: User is a governor and has a credit score of 1000, which was also contributed to the `TOTAL_GOVERNANCE_SCORE`\nBlock n:\n- User updates their own conviction score using the public `updateConvictionScore` function, which increases the credit score by 5000 based on the accumulated time. The total governance credit score increased by 5000, making the user contribute 6000 credit score to governance in total.\n- User transfers their whole balance away, the balance drops below `governanceMinimumBalance`, and the user is not a governor anymore. The `governanceDelta` update of the transfer should be 6000 (user's whole credit score), but it's only `1000` because it takes the snapshot of block n - 1.\n\nIn this way, the `TOTAL_GOVERNANCE_SCORE` score can be inflated and, in the worst case, break the voting mechanism, as no proposals can reach the quorum (percentage of `totalVotes`) anymore.\n\nRecommend using the current conviction store which should be `governanceDelta = checkpoints[user][userCheckpointsLength - 1].convictionScore`.\n\n**[fairside-core (FairSide) confirmed but disagreed with severity](https://github.com/code-423n4/2021-05-fairside-findings/issues/41#issuecomment-851013838):**\n> As with the other governance-related issues, this would once again cause dilution of all users and would not really be a viable attack vector. As such, I believe it is better suited for a medium severity (2) label.\n\n**[fairside-core (FairSide) disputed](https://github.com/code-423n4/2021-05-fairside-findings/issues/41#issuecomment-852122483):**\n> This issue is actually quite deeper. When a transaction occurs in the same block, the logic paths within the `if` block will not execute (due to time elapsed being 0), meaning that the conviction score will not be properly accounted for if I have a single normal transaction where I am still governance and consequently lose my governance in a second transaction. As such, the code needs to be adjusted to check governance eligibility outside of the if block as well (if no time has passed -> same block transaction).\n>\n> The code highlighted in the finding is actually **correct**. The conviction score should be reduced by the previous blocks as the newly accrued conviction score was never accounted for in governance. The proposed solution would lead to more conviction being reduced than it should. However, the finding did point out something wrong, so not sure whether it should be nullified or not.\n>\n> I believe it should be awarded as it was on the right track to find the underlying issue!\n\n**[fairside-core (FairSide) re-confirmed](https://github.com/code-423n4/2021-05-fairside-findings/issues/41#issuecomment-852128302):**\n> Fixed in [PR#13](https://github.com/fairside-core/2021-05-fairside/pull/13).\n\n**[cemozerr (Judge) commented](https://github.com/code-423n4/2021-05-fairside-findings/issues/41#issuecomment-857035642):**\n> Labeling this issue as valid because although it wasn't 100% right on suggesting where the code was problematic, it did point out that the users could wrongfully transfer their whole balance and update their conviction score in the same block to keep their conviction score high, and then potentially do harmful things to the protocol by using their wrong conviction scores.\n\n## [[H-08] Incorrect implementation of arctan in the contract `FairSideFormula`](https://github.com/code-423n4/2021-05-fairside-findings/issues/73)\n\nThe current implementation of the arctan formula in the contract `FairSideFormula` is inconsistent with the referenced paper and could cause incorrect results when the input parameter is negative. The erroneous formula affects the function `calculateDeltaOfFSD` and the number of FSD tokens minted or burned.\n\nThe function `_arctan` misses two `abs` on the variable `a'. The correct implementation should be:\n\n```solidity\nfunction _arctan(bytes16 a) private pure returns (bytes16) {\n    return\n        a.mul(PI_4).sub(\n            a.mul(a.abs().sub(ONE)).mul(APPROX_A.add(APPROX_B.mul(a.abs())))\n        );\n}\n```\n\nNotice that `_arctan` is called by `arctan`, and `arctan` is called by `arcs` with `ONE.sub(arcInner)` provided as the input parameter. Since `arcInner = MULTIPLIER_INNER_ARCTAN.mul(x).div(fS3_4)` can be a large number (recall that `x` is the capital pool), it is possible that the parameter `a` is negative.\n\nRecommend modifying the `_arctan` function as above.\n\n**[fairside-core (FairSide) confirmed](https://github.com/code-423n4/2021-05-fairside-findings/issues/73#issuecomment-851048764):**\n> Fixed in [PR#4](https://github.com/fairside-core/2021-05-fairside/pull/4).\n\n# Medium Risk Findings\n\n## [[M-01] Incorrect use of `_addTribute` instead of `_addGovernanceTribute`](https://github.com/code-423n4/2021-05-fairside-findings/issues/20)\n\nAs part of the `purchaseMembership()` function, the `addRegistrationTributeGovernance()` function is called by the FSD network to update tribute when 7.5% is contributed towards governance. However, this function incorrectly calls `_addTribute()` (as is also done in `addRegistrationTribute`) instead of `_addGovernanceTribute()`.\n\nThe impact of this is that `governanceTributes` never gets updated, rendering all of the tribute accounting logic incorrect.\n\nRecommend using `_addGovernanceTribute()` instead of `_addTribute` on L140 of FSD.sol\n\n**[fairside-core (FairSide) confirmed](https://github.com/code-423n4/2021-05-fairside-findings/issues/20#issuecomment-851000383):**\n> The second of the two easter eggs!\n\n**[fairside-core (FairSide) commented](https://github.com/code-423n4/2021-05-fairside-findings/issues/20#issuecomment-852195810):**\n> Fixed in [PR#20](https://github.com/fairside-core/2021-05-fairside/pull/20).\n\n## [[M-02] Call to `swapExactTokensForETH` in `liquidateDai()` will always fail](https://github.com/code-423n4/2021-05-fairside-findings/issues/21)\n\n`liquidateDai()` calls Uniswap’s `swapExactTokensForETH` to swap Dai to ETH. This will work if `msg.sender` (i.e., the FSD contract) has already given the router an allowance amount that is at least as much as the input token Dai.\n\nGiven that there is no prior approval, the call to UniswapV2 router for swapping will fail. This is because `msg.sender` has not approved UniswapV2 with an allowance for the tokens that are attempting to be swapped.\n\nThe impact is that, while working with the Dai stablecoin, `updateCostShareRequest()` will fail and revert.\n\nRecommend adding FSD approval to UniswapV2 with an allowance for the tokens that are attempting to be swapped.\n\n**[fairside-core (FairSide) confirmed](https://github.com/code-423n4/2021-05-fairside-findings/issues/21#issuecomment-852193172):**\n> Fixed in [PR#19](https://github.com/fairside-core/2021-05-fairside/pull/19).\n\n## [[M-03] Conviction totals not updated during tokenization](https://github.com/code-423n4/2021-05-fairside-findings/issues/28)\n\n`_updateConvictionScore()` function returns `convictionDelta` and `governanceDelta` which need to be used immediately in a call to `_updateConvictionTotals (convictionDelta, governanceDelta)` for updating the conviction totals of conviction and governance-enabled conviction for the entire FairSide network.\n\nThis updating of totals after a call to `_updateConvictionScore()` is done on Line70 in `_beforeTokenTransfer()` and on Line367 in `updateConvictionScore()` of ERC20ConvictionScore.sol.\n\nHowever, the return values of `_updateConvictionScore()` are ignored on Line284 in `tokenizeConviction()` and are not used to update the totals using `_updateConvictionTotals(convictionDelta, governanceDelta)`.\n\nThe impact of this is that when a user tokenizes their conviction score, their conviction deltas are updated and recorded (only if the funds locked are zero, which is incorrect and reported separately in a different finding), but the totals are not updated. This leads to incorrect accounting of `TOTAL_CONVICTION_SCORE` and `TOTAL_GOVERNANCE_SCORE`, which are used to calculate tributes, and therefore will lead to incorrect tribute calculations.\n\n**EXAMPLE:**\n> Alice calls `tokenizeConviction()` to convert her conviction score into an NFT. Her conviction deltas (as returned by `_updateConvictionScore()`) are ignored. Furthermore, `TOTAL_CONVICTION_SCORE` and `TOTAL_GOVERNANCE_SCORE` values are not updated. As a result, the tributes rewarded are proportionally more than what they should have been. This is because the conviction score totals are used as the denominator in `availableTribute()` and `availableGovernanceTribute()`.\n\nRecommend using the return values of the `_updateConvictionScore()` function (i.e. `convictionDelta` and `governanceDelta`) on Line284 of `ERC20ConvictionScore.sol`, and then use them in a call to `_updateConvictionTotals(convictionDelta, governanceDelta)`.\n\n**[fairside-core (FairSide) confirmed](https://github.com/code-423n4/2021-05-fairside-findings/issues/28#issuecomment-852185047):**\n> Fixed in [PR#17](https://github.com/fairside-core/2021-05-fairside/pull/17).\n\n## [[M-04] Eth may get stuck in contract](https://github.com/code-423n4/2021-05-fairside-findings/issues/58)\n\nThe Istanbul hardfork increases the gas cost of the SLOAD operation and therefore breaks some existing smart contracts.\n\nIn file `withdrawable.sol`, contract uses `transfer()` to send eth from contract to EOA due which eth can get stuck.\n\nThe reason behind this is that, after the Istanbul hardfork, any smart contract that uses `transfer()` or `send()` is taking a hard dependency on gas costs by forwarding a fixed amount of gas (2300). This forwards 2300 gas, which may not be enough if the recipient is a contract and the cost of gas changes.\n\nRecommend using `call()` to send eth.\n\n**[fairside-core (FairSide) confirmed (separately in issue #67)](https://github.com/code-423n4/2021-05-fairside-findings/issues/67#issuecomment-851001069):**\n> Although I am fine with the severity, perhaps it may not be applicable given that even after EIP-3074, transfers will not fail with proper access lists, and I highly doubt the transfer method will fail to work altogether anytime soon.\n\n> Fixed in PR#8.\n\n## [[M-05] Bug inside ABDKMathQuad library](https://github.com/code-423n4/2021-05-fairside-findings/issues/32)\n\nThe `FairSideFormula` library is using the `ABDKMathQuad` library underneath. According to the `ABDKMathQuad` README, the range of values is the following:\n\n> The minimum strictly positive (subnormal) value is 2^−16494 ≈ 10^−4965 and has a precision of only one bit. The minimum positive normal value is 2^−16382 ≈ 3.3621 × 10^−4932 and has a precision of 113 bits, i.e., ±2^−16494 as well. The maximum representable value is 2^16384 − 2^16271 ≈ 1.1897 × 10^4932.\n\nUsing Echidna, a fuzzing tool for smart contracts, I found some edge cases in which some of the operations do not work as expected. This is the test code I ran using `echidna-test contracts/TestABDKMathQuad --contract TestABDKMathQuad`. see [issue](https://github.com/code-423n4/2021-05-fairside-findings/issues/32) for more details.\n\nIf we check in Remix, we can see that there is a small difference when converting from UInt to Bytes16 (and vice versa). This issue is probably the same with all the other operations.\n\nRecommend using some fuzzing tool like [Echidna](https://github.com/crytic/echidna) to verify that there are no edge cases.\n\n**[fairside-core (FairSide) acknowledged](https://github.com/code-423n4/2021-05-fairside-findings/issues/32#issuecomment-851014825):**\n> I am slightly mixed about this finding. We did employ fuzz tests during the audit we had gone through, and they were unable to pinpoint any issues in the value range we expect the curve to be utilized in. This is definitely a good suggestion and one we will assimilate. However, I am not sure how one would judge the severity of this.\n\n## [[M-06] pendingWithdrawals just increments](https://github.com/code-423n4/2021-05-fairside-findings/issues/38)\n\nSponsor commented that this related to another bug and referenced \"[H-05] `Withdrawable.withdraw` does not decrease `pendingWithdrawals`\"\nsee issue [#48](https://github.com/code-423n4/2021-05-fairside-findings/issues/48) for more details.\n\n## [[M-07] NFTs can never be redeemed back to their conviction scores leading to lock/loss of funds](https://github.com/code-423n4/2021-05-fairside-findings/issues/31)\n\nBesides the conviction scores of users, there appears to be tracking of the FairSide protocol's tokenized conviction score as a whole (using `fscAddress = address(fairSideConviction)`). This is evident in the attempted reduction of the protocol's score when a user acquires conviction back from an NFT. However, the complementary accrual of the user's conviction score to `fscAddress` when the user tokenizes their conviction score to mint an NFT is missing in `tokenizeConviction()`.\n\nBecause of this missing update of the conviction score to `fscAddress` upon tokenization, there are no checkpoints written for `fscAddress`. There also doesn't appear to be any initialization for bootstrapping this address's conviction score checkpoints. As a result, the `sub224()` on Line350 of `ERC20ConvictionScore.sol` will always fail with an underflow. This is because `fscOld = 0` (because `fscNum = 0`) and `convictionScore > 0`, effectively reverting all calls to `acquireConviction()`.\n\nThe impact of this is that all tokenized NFTs can never be redeemed back to their conviction scores leading to a lock/loss of FSD funds for users who tokenized/sold/bought FairSide NFTs.\n\n**Proof of Concept:**\n1. Alice tokenizes her conviction score into an NFT. She sells that NFT to Bob, who pays an amount commensurate with the conviction score captured by that NFT (as valued by the market) and any FSDs locked with the NFT.\n\n2. Bob then attempts to redeem the bought NFT back to the conviction score to use it on the FairSide network. But the call to `acquireConviction()` fails. Bob is never able to redeem Alice's NFT and has lost the funds used to buy it.\n\nRecommend adding appropriate logic to bootstrap, initialize `fscAddress` 's tokenized conviction score checkpoints, and update it during tokenization.\n\n**[fairside-core (FairSide) confirmed](https://github.com/code-423n4/2021-05-fairside-findings/issues/31#issuecomment-851012992):**\n> Although the finding is correct, FSDs will not be permanently locked in the NFT as they can still be redeemed via the dedicated `release` function on the conviction NFT implementation. As such, I would label this a medium-level finding, given that the conviction scores will indeed be lost.\n\n**[fairside-core (FairSide) commented](https://github.com/code-423n4/2021-05-fairside-findings/issues/31#issuecomment-852182498):**\n> Fixed in [PR#16](https://github.com/fairside-core/2021-05-fairside/pull/16).\n\n**[cemozerr (Judge) commented](https://github.com/code-423n4/2021-05-fairside-findings/issues/31#issuecomment-856306057):**\n> Labeling this as medium risk as FSDs will not be permanently locked.\n\n## [[M-08] `ERC20ConvictionScore` allows transfers to special `TOTAL_GOVERNANCE_SCORE` address](https://github.com/code-423n4/2021-05-fairside-findings/issues/42)\n\nThe credit score of the special `address(type(uint160).max)` is supposed to represent the sum of the credit scores of all users that are governors.\n\nBut, any user can directly transfer to this address, increasing its balance and accumulating a credit score in `_updateConvictionScore(to=address(uint160.max), amount)`.\n\nIt'll first write a snapshot of this address' balance, which should be very low:\n\n```solidity\n// in _updateConvictionScore\n_writeCheckpoint(user, userNum, userNew) = _writeCheckpoint(TOTAL_GOVERNANCE_SCORE, userNum, checkpoints[user][userNum - 1].convictionScore + convictionDelta);\n```\n\nThis address then accumulates a score based on its balance, which can be updated using `updateConvictionScore(uint160.max)` and breaks the invariant.\n\nIncreasing it might be useful for non-governors that don't pass the voting threshold and want to grief the proposal voting system by increasing the `quorumVotes` threshold required for proposals to pass. By manipulating `FairSideDAO.totalVotes`, `totalVotes` can be arbitrarily inflated and break the voting mechanism as no proposals can reach the quorum (percentage of `totalVotes`) anymore.\n\nRecommend disallowing transfers from/to this address. Or better, track the total governance credit score in a separate variable, not in an address.\n\n**[fairside-core (FairSide) confirmed](https://github.com/code-423n4/2021-05-fairside-findings/issues/42#issuecomment-851013350):**\n > This is actually what #61 is meant to be used for. I would label this a medium-level finding as it would simply dilute the voting rights of users at the expense of permanently losing FSD, which should not be a viable vector.\n\n**[fairside-core (FairSide) resolved](https://github.com/code-423n4/2021-05-fairside-findings/issues/42#issuecomment-852107565):**\n > Indirectly fixed by [PR#10](https://github.com/fairside-core/2021-05-fairside/pull/10).\n\n**[cemozerr (Judge) commented](https://github.com/code-423n4/2021-05-fairside-findings/issues/42#issuecomment-857038152):**\n > Labeling this as medium risk as it would not pose a threat to user funds yet stall the governance process.\n\n## [[M-09] Should check return data from Chainlink aggregators](https://github.com/code-423n4/2021-05-fairside-findings/issues/70)\n\nThe `getEtherPrice` function in the contract `FSDNetwork` fetches the ETH price from a Chainlink aggregator using the `latestRoundData` function. However, there are no checks on `roundID` nor `timeStamp`, resulting in stale prices.\n\nRecommend adding checks on the return data with proper revert messages if the price is stale or the round is incomplete, for example:\n```Solidity\n(uint80 roundID, int256 price, , uint256 timeStamp, uint80 answeredInRound) = ETH_CHAINLINK.latestRoundData();\nrequire(answeredInRound >= roundID, \"...\");\nrequire(timeStamp != 0, \"...\");\n```\n\n**[fairside-core (FairSide) confirmed](https://github.com/code-423n4/2021-05-fairside-findings/issues/70#issuecomment-851051273):**\n > Fixed in [PR#7](https://github.com/fairside-core/2021-05-fairside/pull/7).\n\n**[cemozerr (Judge) commented](https://github.com/code-423n4/2021-05-fairside-findings/issues/70#issuecomment-857059051):**\n > Labeling this as medium risk as stale ether price could put funds at risk.\n\n## [[M-10] `gracePeriod` not increased after membership extension](https://github.com/code-423n4/2021-05-fairside-findings/issues/6)\n\nIn the function `purchaseMembership` of FSDNetwork.sol, when the membership is extended, `membership[msg.sender].creation` is increased. However, `membership[msg.sender].gracePeriod` is not increased.\nThis might lead to a `gracePeriod` that is lower than expected. It seems logical to also increase the `gracePeriod`.\n\nFSDNetwork.sol:\n```solidity\nfunction purchaseMembership(uint256 costShareBenefit) external {\n     ...\n      if (membership[msg.sender].creation == 0) {\n            ...\n            membership[msg.sender].creation       = block.timestamp;\n            membership[msg.sender].gracePeriod =  membership[msg.sender].creation +  MEMBERSHIP_DURATION +  60 days;\n        } else {\n          ....\n          membership[msg.sender].creation += durationIncrease;\n   }\n```\nRecommend checking to see if `gracePeriod` has to be increased and then adding the necessary logic when that is the case.\n\n**[fairside-core (FairSide) confirmed](https://github.com/code-423n4/2021-05-fairside-findings/issues/6#issuecomment-851017171):**\n > This should be bumped to a medium severity finding as it actually does not affect the membership duration at all if the `gracePeriod` is not updated.\n\n**[fairside-core (FairSide) commented](https://github.com/code-423n4/2021-05-fairside-findings/issues/6#issuecomment-852198632):**\n > Fixed in [PR#21](https://github.com/fairside-core/2021-05-fairside/pull/21).\n\n## [[M-11] The variable `fShareRatio` is vulnerable to manipulation by flash minting and burning](https://github.com/code-423n4/2021-05-fairside-findings/issues/75)\n\nThe variable `fShareRatio` in the function `purchaseMembership` of contract `FSDNetwork` is vulnerable to manipulation by flash minting and burning, which could affect several critical logics, such as the check of enough capital in the pool (line 139-142) and the staking rewards (line 179-182).\n\nThe `fShareRatio` is calculated (line 136) by:\n\n```solidity\n(fsd.getReserveBalance() - totalOpenRequests).mul(1 ether) / fShare;\n```\n\nWhere `fsd.getReserveBalance()` can be significantly increased by a user minting a large amount of FSD tokens with flash loans. In that case, the increased `fShareRatio` could affect the function `purchaseMembership` results. For Example, the user could purchase the membership even if the `fShareRatio` is < 100% previously, or the user could earn more staking rewards than before to reduce the membership fees. Although performing flash minting and burning might not be profitable overall since a 3.5% tribute fee is required when burning FSD tokens, it is still important to be aware of the possible manipulation of `fShareRatio`.\n\nRecommend forcing users to wait for (at least) a block to prevent flash minting and burning.\n\n**[fairside-core (FairSide) confirmed](https://github.com/code-423n4/2021-05-fairside-findings/issues/75#issuecomment-850994783):**\n > I believe this to be a minor (1) or none (0) severity issue given that the manipulation of `fShareRatio` is unsustainable due to the fee, and the Example given is actually not possible. Suppose I affect `fShareRatio` to go above 100% to purchase a membership. In that case, I will be unable to burn the necessary FSD to go below 100% again as burning is disabled when the ratio is or would go to below 100%.\n\n**[fairside-core (FairSide) resolved](https://github.com/code-423n4/2021-05-fairside-findings/issues/75#issuecomment-851032182):**\n > Fixed in [PR#2](https://github.com/fairside-core/2021-05-fairside/pull/2).\n\n**[cemozerr (Judge) commented](https://github.com/code-423n4/2021-05-fairside-findings/issues/75#issuecomment-857099487):**\n > Labeling this as low risk as a 3.5% tribute fee makes it very unlikely that these flash minting will be profitable.\n\n## [[M-12] `ERC20ConvictionScore.acquireConviction` implements wrong governance checks](https://github.com/code-423n4/2021-05-fairside-findings/issues/45)\n\nThere are two issues with the governance checks when acquiring them from an NFT:\n\n#### **(Issue 1) Missing balance check**\nThe governance checks in `_updateConvictionScore` are:\n```solidity\n!isGovernance[user]\n&& userConvictionScore >= governanceThreshold\n&& balanceOf(user) >= governanceMinimumBalance;\n```\nWhereas in `acquireConviction`, only `userConvictionScore >= governanceThreshold` is checked but not `&& balanceOf(user) >= governanceMinimumBalance`.\n\n```solidity\nelse if (\n    !isGovernance[msg.sender] && userNew >= governanceThreshold\n) {\n    isGovernance[msg.sender] = true;\n}\n```\n\n#### **(Issue 2) the `wasGovernance` might be outdated**\n\nThe second issue is that at the time of NFT creation, the `governanceThreshold` or `governanceMinimumBalance` was different and would not qualify for a governor now.\nThe NFT's governance state is blindly appplied to the new user:\n\n```solidity\nif (wasGovernance && !isGovernance[msg.sender]) {\n    isGovernance[msg.sender] = true;\n}\n```\n\nThis allows a user to circumvent any governance parameter changes by front-running the change with an NFT creation. It's easy to circumvent the balance check to become a governor by minting and redeeming your own NFT. One can also circumvent any governance parameter increases by front-running these actions with an NFT creation and then backrunning with a redemption.\n\nRecommend adding the missing balance check-in `acquireConviction`, removing the `wasGovernance` governance transfer from the NFT, and recomputing it based solely on the current `governanceThreshold` / `governanceMinimumBalance` settings.\n\n**[fairside-core (FairSide) confirmed](https://github.com/code-423n4/2021-05-fairside-findings/issues/45#issuecomment-851009327):**\n > The latter of the two issue \"types\" is actually desired behavior. If a user was historically a governance member, the NFT should boast the exact same rights, and new thresholds should not retroactively apply. The former, however, is a valid issue as it allows circumventing the balance check!\n\n**[fairside-core (FairSide) resolved](https://github.com/code-423n4/2021-05-fairside-findings/issues/45#issuecomment-852116812):**\n > Fixed in [PR#12](https://github.com/fairside-core/2021-05-fairside/pull/12).\n\n# Low Risk Findings\n\n## [[L-01] Lack of zero-address checks for immutable addresses will force contract redeployment if zero-address used accidentally](https://github.com/code-423n4/2021-05-fairside-findings/issues/18)\n\nZero-address checks as input validation on address parameters are always a best practice. This is especially true for critical addresses that are immutable and set in the constructor because they cannot be changed later. Accidentally using zero addresses here will lead to failing logic or force contract redeployment and increased gas costs.\n\nRecommend adding zero-address input validation for these addresses in the constructor.\n\n**[fairside-core (FairSide) acknowledged (in separate issue #56)](https://github.com/code-423n4/2021-05-fairside-findings/issues/56#issuecomment-851005065):**\n > Adding the respective require checks significantly increases the bytecode size of the contract, and all relate to privileged functions (constructor functions or functions voted on by the DAO). As such, I believe this to be a non-critical (0) issue.\n\n## [[L-02] Dangerous Solidity compiler pragma range that spans breaking versions](https://github.com/code-423n4/2021-05-fairside-findings/issues/25)\n\nAll contracts use a Solidity compiler pragma range >=0.6.0 <0.8.0, which spans a breaking change version 0.7.0. This compiler range is very broad and includes many syntactic/semantic changes across the versions. Specifically, see silent changes in https://docs.soliditylang.org/en/v0.7.0/070-breaking-changes.html#silent-changes-of-the-semantics.\n\nFor Example, this compiler range allows testing with Solidity compiler version 0.6.x but deployment with 0.7.x. While any breaking syntactic changes will be caught at compile time, there is a risk that the silent change in 0.7.0, which applies to exponentiation/shift operand types, might affect the FairSide formula or other mathematical calculations, thus breaking assumptions and accounting.\n\nThe opposite scenario may also happen where testing is performed with Solidity compiler version 0.7.x but deployed with 0.6.x, which may allow bugs fixed in 0.7.x to be present in the deployed code.\n\nRecommend using the same compiler version both for testing and deployment by enforcing this in the pragma itself. An unlocked/floating pragma is risky, especially one that ranges across a breaking compiler minor version.\n\n**[fairside-core (FairSide) acknowledged (in separate Issue #66)](https://github.com/code-423n4/2021-05-fairside-findings/issues/66):**\n> he pragma statements were left unlocked to allow flexibility in development. Since this is not a functional finding, it should be marked as 0 (non-critical).\n\n**[cemozerr (Judge) commented (in separate Issue #66)](https://github.com/code-423n4/2021-05-fairside-findings/issues/66#issuecomment-856221090):**\n> Duplicate of #25. Labeling it as low risk as it could indeed cause the contracts to accidentally be compiled or deployed using an outdated or buggy compiler version\n\n ##  [[L-03] Usage of transfer](https://github.com/code-423n4/2021-05-fairside-findings/issues/47)\n\nIn `Withdrawable.withdraw`: The `address.transfer` function is used to send ETH to an account. It is restricted to a low amount of gas and might fail if gas costs change in the future or if a smart contract's fallback function handler implements anything non-trivial.\n\nRecommend considering using the lower-level `.call{value: value}` instead and checking its success return value.\n\n**[fairside-core (FairSide) confirmed and commented (in separate issue #67):](https://github.com/code-423n4/2021-05-fairside-findings/issues/67)**\n> Although I am fine with the severity, perhaps it may not be applicable given that even after EIP-3074 transfers will not fail with proper access lists, and I highly doubt the transfer method will fail to work altogether anytime soon.\n> Fixed in PR#8.\n\n## [[L-04] Missing use of DSMath functions may lead to underflows/overflows](https://github.com/code-423n4/2021-05-fairside-findings/issues/19)\n\nThe FairSide contracts use DappHub's DSMath safe arithmetic library that provides overflow/underflow protection. But, the safe DSMath functions are not used in many places, especially in the FSD `mint`/`burn` functions.\n\nWhile there do not appear to be any obvious integer overflows/underflows in the conditions envisioned, there could be exceptional paths where overflows/underflows may be triggered, leading to minting/burning an unexpected number of tokens.\n\nRecommend using DSMath `add`/`sub` functions instead of +/- in all places.\n\n**[fairside-core (FairSide) acknowledged](https://github.com/code-423n4/2021-05-fairside-findings/issues/19#issuecomment-851016313):**\n > All linked segments are guaranteed not to overflow / underflow. In detail:\n>\n> 1. The `getReserveBalance` always takes into account the actual balance of the contract, which will always be greater-than-or-equal to `msg.value`.\n> 2. The `bonded` amount is always a percentage of `msg.value`\n> 3. The `tribute` amount is always a percentage of `capitalDesired`\n> 4. The `reserveWithdrawn` will always be less than or equal to `etherBalanceAtBurn`\n>\n> Due to the above, I would label the finding as non-critical. In general, SafeMath utilization is avoided in any case that it can be to reduce gas costs.\n\n**[cemozerr (Judge) commented](https://github.com/code-423n4/2021-05-fairside-findings/issues/19#issuecomment-856249509):**\n > Labeling this as low risk as not using dsmath might lead to exceptional paths where overflows/underflows may be triggered, even if those paths are not enumerated above.\n\n## [[L-05] `convictionless` mapping is not used](https://github.com/code-423n4/2021-05-fairside-findings/issues/61)\n\n`convictionless` can be set via function `setConvictionless`; however, it is not used anywhere across the system, thus making it useless. Based on the comment above this variable, I expect to see it used in functions like `_updateConvictionScore`.\n\nRecommend either remove this mapping or use it where intended.\n\n**[fairside-core (FairSide) confirmed](https://github.com/code-423n4/2021-05-fairside-findings/issues/61#issuecomment-851003714):**\n > Quite strange no one else identified this one! The absence of usage was a merging mistake; this particular mapping is slightly important to the overall operation of FairSide as certain parties should not accrue conviction, such as the Governance wallet. I believe it should be increased to medium-level severity.\n\n**[fairside-core (FairSide) resolved](https://github.com/code-423n4/2021-05-fairside-findings/issues/61#issuecomment-852107094):**\n > Fixed in [PR#10](https://github.com/fairside-core/2021-05-fairside/pull/10).\n\n## [[L-06] Flash minting and burning can reduce the paid fees when purchasing a membership or opening a cost-share request](https://github.com/code-423n4/2021-05-fairside-findings/issues/76)\n\nUsers can pay fewer FSD tokens when purchasing a membership or opening a cost-share request by flash minting and burning FSD tokens, which could significantly affect the FSD spot price.\n\nThe function `getFSDPrice` returns the current FSD price based on the reserves in the capital pool (see lines 353-364 in contract `FSDNetwork`). Notice that when minting and burning FSD tokens, the `fsd.getReserveBalance()` increases but not the `fShare`. Therefore, according to the pricing formula, `FairSideFormula.f`, the FSD price increases when minting, and vice versa, decreases when burning.\n\nWhen purchasing a membership, the number of FSD tokens that a user should pay is calculated based on the current FSD price, which is vulnerable to manipulation by flash minting and burning. Consider a user performing the following actions (all are done within a single transaction or flashbot bundle):\n\n1. The user mints a large number of FSD (by using flash loans) to raise the current FSD price.\n2. The user purchases a membership by calling `purchaseMembership`. Since the price of FSD is relatively high, the user pays fewer FSD tokens for the membership fee than before.\n3. The user burns the previously minted FSD tokens, losing 3.5% of his capital for the tribute fees.\n\nAlthough the user pays for the 3.5% tribute fees, it is still possible to make a profit. Suppose that the price of FSD to ETH is `p_1` and `p_2` before and after minting, respectively. The user purchases a membership with `x` ETH `costShareBenefit` and uses `y` ETH to flash mint the FSD tokens. In a regular purchase, the user pays `0.04x / p_1` FSD tokens, equivalent to `0.04x` ETH. By performing flash mints and burns, the user pays `0.04x / p_2` FSD tokens, which is, in fact, equivalent to `0.04x * p_1 / p_2` ETH. He also pays `0.035y` ETH for tribute fees. The profit user made is `0.04x * (1 - p1 / p2) - 0.035y` (ETH), where `p2` and `y` are dependent to each other but independent to `x`. Thus, the profit can be positive if `costShareBenefit` is large enough.\n\nThe same vulnerability exists when a user opens a cost-share request, where the `bounty` to pay is calculated based on the current price of FSD tokens.\n\nRecommend forcing users to wait for (at least) a block to prevent flash minting and burning.\n\n**[fairside-core (FairSide) questioned](https://github.com/code-423n4/2021-05-fairside-findings/issues/76#issuecomment-850994061):**\n > The issue relies on `costShareBenefit` being large enough, which is inherently limited to a % of the capital pool, meaning that the arbitrage opportunity present here is inexistent or highly unlikely to be beneficial. Can we reach out to the submitter to request them to prove that even with the `costShareBenefit` % limit, this is a sustainable attack by providing us with numbers? If no such numbers are present, I would decrease the severity of this to either minor (1) or none (0).\n\n**[cemozerr (Judge) commented](https://github.com/code-423n4/2021-05-fairside-findings/issues/76#issuecomment-857095193):**\n > Will wait for a proof from the auditor, shw, for this one.\n\n**[x9453 commented](https://github.com/code-423n4/2021-05-fairside-findings/issues/76#issuecomment-860028778):**\n > Hi, thanks for giving me a chance to clarify this finding.\n>\n> After realizing that a user's `costShareBenefit` is limited to a % of the capital pool (5% as specified in the code), I would say this attack is not successful according to the following estimation of the upper-bound of user's profit:\n>\n> ```\n>    User's profit\n>  = 0.04x * (1 - p1 / p2) - 0.035y\n> <= 0.04x - 0.035y\n> <= 0.04 * 0.05 * (z + y) - 0.035y\n>  = 0.002z - 0.033y\n> ```\n>\n> where `z` is the amount of ETH in the capital pool before minting. A negative coefficient of `y' implies that using a flash loan does not help to increase the profit but to decrease it.\n\n**[x9453 commented](https://github.com/code-423n4/2021-05-fairside-findings/issues/76#issuecomment-860513934):**\n > After some thoughts, I think the estimation should also consider how flash loan affects on the FSD's price to be more accurate. According to the price formula, we have `p1 = A + z^4 / (C * fShare^3)` and `p2 = A + (z + y)^4 / (C * fShare^3)` (assuming the best case, where `fShare` does not increase). Let `r = y / z`, the ratio of flash loan to the capital pool, then we can approximate `p1 / p2 = z^4 / (z + y)^4 = 1 / (r + 1)^4`. Therefore,\n>\n> ```\n>   User's profit\n> = 0.04x * (1 - p1 / p2) - 0.035y\n> = 0.04 * 0.05 * (z + y) * (1 - 1 / (r + 1)^4) - 0.035y\n> = (0.002 * (r + 1) * (1 - 1 / (r + 1)^4) - 0.035r) * z\n> = f(r) * z\n> ```\n>\n> [WolframAlpha](https://www.wolframalpha.com/input/?i=0.002%28x%2B1%29%281-1%2F%28x%2B1%29%5E4%29-0.035x) tells us that `f(r) < 0` for all `r > 0`, meaning that the user does not make a profit no matter how much flash loan he borrowed.\n>\n> It is worth mentioning that different % of withdrawal fee, cost share benefit limit, and tribute fee could lead to different results. That is, the constants, `0.002` and `0.035`, determine whether user's profit can be positive (i.e., there exists `r > 0` s.t. `f(r) > 0`). Further calculation shows that this happens if the product of the withdrawal fee and cost share benefit limit is greater than the tribute fee divided by 4, which is unlikely in normal settings. Please let me know if you need more details or a PoC on this.\n\n\n## [[L-07] Check if variables are initialized](https://github.com/code-423n4/2021-05-fairside-findings/issues/59)\n\nA variable named `fairSideConviction` is set in the contract FSD function `setFairSideConviction`. However, functions that use this variable do not check that it is already initialized. For example, function `tokenizeConviction` in contract `ERC20ConvictionScore` may transfer tokens to the 0x0 address:\n```solidity\n   _transfer(msg.sender, address(fairSideConviction), locked);\n```\nThis will make these tokens inaccessible and basically burned. It would be better if the code explicitly checked before that ```address(fairSideConviction) != address(0)```\n\nRating this as low because I expect that, in practice, these variables will be initialized as soon as possible.\n\nAlso, this may be an additional small issue. Still, I think it would make sense if functions `setFairSideConviction` and `setFairSideNetwork` explicitly check that the parameter is not 0x0 address as it is theoretically possible to invoke these functions again and again when the address is empty.\n\nRecommend requiring ```address(fairSideConviction) != address(0)``` where this variable is used. Same can be applied to fsdNetwork variable.\n\n**[fairside-core (FairSide) acknowledged](https://github.com/code-423n4/2021-05-fairside-findings/issues/59#issuecomment-851005154):**\n > This function is invoked directly in the deployment script and cannot be raced. As such, I think this should be set as non-critical (0).\n\n**[cemozerr (Judge) commented](https://github.com/code-423n4/2021-05-fairside-findings/issues/59#issuecomment-856218166):**\n > Labeling this as low risk, as the issue could pose a problem in this case, the deployment script has a bug.\n\n# Non-Critical Findings\n\n## [[N-01] Use of `ecrecover` is susceptible to signature malleability](https://github.com/code-423n4/2021-05-fairside-findings/issues/17)\n\nThe `ecrecover` function is used in `castVoteBySig()` to recover the voter's address from the signature. The built-in EVM precompile `ecrecover` is susceptible to signature malleability, which could lead to replay attacks (references: https://swcregistry.io/docs/SWC-117, https://swcregistry.io/docs/SWC-121, and https://medium.com/cryptronics/signature-replay-vulnerabilities-in-smart-contracts-3b6f7596df57).\n\nWhile this is not immediately exploitable in the DAO use case because the voter address is checked against `receipt.voted` to prevent re-voting, this may become a vulnerability if used elsewhere.\n\nRecommend considering using OpenZeppelin's ECDSA library (which prevents this malleability) instead of the built-in function.\n\n**[fairside-core (FairSide) acknowledged](https://github.com/code-423n4/2021-05-fairside-findings/issues/17#issuecomment-851015227):**\n > While this is a valid finding, it also exists in the Compound codebase and, as mentioned in the description, is not an active issue. I would label as non-critical (0).\n\n**[cemozerr (Judge) commented](https://github.com/code-423n4/2021-05-fairside-findings/issues/17#issuecomment-856184599):**\n > Labeling this issue as non-critical, as the issue with `ecrecover` would only be a problem if not aided with another check to prevent re-voting.\n\n## [[N-02] `FairSideDAO.SECS_PER_BLOCK` is inaccurate](https://github.com/code-423n4/2021-05-fairside-findings/issues/34)\n\nThe `SECS_PER_BLOCK` is currently set to 15s on Ethereum, but it's closer to 13.5s on average. The voting period will be shorter than in reality which might lead to users not getting enough time.\n\nRecommend using a more accurate representation of `SECS_PER_BLOCK` for the deployed chain.\n\n**[fairside-core (FairSide) acknowledged](https://github.com/code-423n4/2021-05-fairside-findings/issues/34#issuecomment-851014659):**\n > This parameter is meant to be updated prior to deployment and is susceptible to network fluctuations. As such, this is something that will be tuned prior to deployment and should be considered a non-critical issue as there is no on-chain way to reliably calculate the median block time.\n\n**[cemozerr (Judge) commented](https://github.com/code-423n4/2021-05-fairside-findings/issues/34#issuecomment-856203415):**\n > Labeling this issue as non-critical as @fairside-core's comments on the constant value being dependent on network conditions is right.\n\n## [[N-03] Wrong error message in `__castOffchainVotes`](https://github.com/code-423n4/2021-05-fairside-findings/issues/36)\n\nThe error message states:\n\n```solidity\nrequire(\n    proposal.offchain,\n    \"FairSideDAO::__castOffchainVotes: proposal is meant to be voted offchain\"\n);\n```\nBut it should be \"... meant to be voted onchain\".\n\n**[fairside-core (FairSide) confirmed](https://github.com/code-423n4/2021-05-fairside-findings/issues/36#issuecomment-851002517):**\n > The change requested simply changes the text reported to off-chain processes and does not accompany a change in functionality.\n\n**[fairside-core (FairSide) resolved](https://github.com/code-423n4/2021-05-fairside-findings/issues/36#issuecomment-852170358):**\n > Fixed in [PR#15](https://github.com/fairside-core/2021-05-fairside/pull/15).\n\n**[cemozerr (Judge) commented](https://github.com/code-423n4/2021-05-fairside-findings/issues/36#issuecomment-856204235):**\n > Labeling this as non-critical as the issue does not pose any risk to functionality.\n\n## [[N-04] non existing function returns](https://github.com/code-423n4/2021-05-fairside-findings/issues/10)\n\nThe functions `castVote` and  `castVoteBySig` of FairSideDAO.sol have no \"returns\" parameters,\nhowever they do call \"return\" at the end of the function. This is confusing for the readers of the code.\n```solidity\nfunction castVote(uint256 proposalId, bool support) public {\n    return _castVote(msg.sender, proposalId, support);\n}\n\nfunction castVoteBySig( .. ) public {\n    ...\n    return _castVote(signatory, proposalId, support);\n}\n```\nRecommend removing the \"return\" statements from `castVote` and `castVoteBySig`.\n\n**[fairside-core (FairSide) confirmed](https://github.com/code-423n4/2021-05-fairside-findings/issues/10#issuecomment-852200367):**\n > Fixed in [PR#22](https://github.com/fairside-core/2021-05-fairside/pull/22).\n\n## [[N-05] `totalCostShareBenefit`  vs `totalCostShareBenefits` ](https://github.com/code-423n4/2021-05-fairside-findings/issues/3)\n\nThe function `purchaseMembership` of FSDNetwork.sol contains a variable that is very similar to a global variable. It's easy to confuse the two, possibly introducing errors in the future. These variables are `totalCostShareBenefit`, and `totalCostShareBenefits`.\n\nFSDNetwork.sol:\n```solidity\n    uint256 public totalCostShareBenefits;\n    function purchaseMembership(uint256 costShareBenefit) external {\n        uint256 totalCostShareBenefit = membership[msg.sender].availableCostShareBenefits.add(costShareBenefit);\n        ...\n        totalCostShareBenefits = totalCostShareBenefits.add(costShareBenefit);\n```\n\nRecommend changing one of the variables to an obviously different name.\n\n**[fairside-core (FairSide) acknowledged](https://github.com/code-423n4/2021-05-fairside-findings/issues/3)**\n\n## [[N-06] Misleading error messages](https://github.com/code-423n4/2021-05-fairside-findings/issues/11)\n\nThere are misleading copy-pasted error messages. For Example, function `liquidateEth` has a misleading revert message:\n> \"FSD::payClaim: Insufficient Privileges\"\n\nSame situation with functions `liquidateDai`, `setConvictionless`, `_addGovernanceTribute`. Function `_calculateDeltaOfFSD` has it misspelled. contract `Timelock` constructor uses '`setDelay`'.\n\nRecommending that it should be `payClaim` -> `liquidateEth`, etc., to identify the real name of the function where the error happened.\n\n**[fairside-core (FairSide) confirmed and resolved (in separate issue #64)](https://github.com/code-423n4/2021-05-fairside-findings/issues/64#issuecomment-851053596):**\n > Fixed in [PR#9](https://github.com/fairside-core/2021-05-fairside/pull/9).\n\n## [[N-07] Revert messages are wrong](https://github.com/code-423n4/2021-05-fairside-findings/issues/64)\n\nThe following revert messages refer to a different function instead of the one where they actually are, making it harder to understand the flow of the program in case of error.\n* [l. 166](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/FSD.sol#L166)\n* [l. 185](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/FSD.sol#L185)\n* [l. 254](https://github.com/code-423n4/2021-05-fairside/blob/main/contracts/token/FSD.sol#L254)\n\nRecommend setting the messages with the correct function name.\n\n**[fairside-core (FairSide) confirmed and resolved](https://github.com/code-423n4/2021-05-fairside-findings/issues/64#issuecomment-851053596):**\n > Fixed in [PR#9](https://github.com/fairside-core/2021-05-fairside/pull/9).\n\n## [[N-08] Constant values used inline](https://github.com/code-423n4/2021-05-fairside-findings/issues/4)\n\nIn several locations, constant values are used inline in the code. Normally, you would define those as constants to be able to review and update them easier.\n\nRecommend using constants for constant values.\n\n**[fairside-core (FairSide) acknowledged](https://github.com/code-423n4/2021-05-fairside-findings/issues/4#issuecomment-851002002):**\n > Similar to #65\n\n## [[N-09] Events in `FairSideDAO` are not indexed](https://github.com/code-423n4/2021-05-fairside-findings/issues/69)\n\nEvents in the `FairSideDAO` contract are not indexed, making it difficult for off-chain scripts (such as the front-ends of dApps) to filter these events efficiently.\n\nRecommend adding the `indexed` keyword to the events. For Example:\n```event ProposalExecuted(uint256 indexed id);```\n\n**[fairside-core (FairSide) acknowledged](https://github.com/code-423n4/2021-05-fairside-findings/issues/69#issuecomment-850999838):**\n > Findings that do not alter the functionality of the contracts should not be labeled as anything else than 0 (Non-Critical). This purely relates to off-chain integration.\n\n**[cemozerr (Judge) commented](https://github.com/code-423n4/2021-05-fairside-findings/issues/69#issuecomment-856224024):**\n > Labeling this as non-critical as @fairside-core's comment is correct.\n\n## [[N-10] lack of input validation of id in `getConvictionScore()`](https://github.com/code-423n4/2021-05-fairside-findings/issues/60)\n\n`tokenId` shouldn't be zero because it is initialized to 1. But  due to lack of input validation in `getConvictionScore(uint256 id)`, `tokenId` can be zero.\n\nRecommend adding a condition to check input values.\n\n**[fairside-core (FairSide) acknowledged](https://github.com/code-423n4/2021-05-fairside-findings/issues/60#issuecomment-851004133):**\n > Usage of an ID equal to `0` will yield `0` for its conviction score, and it cannot lead to any misbehavior of the contracts to my knowledge.\n\n**[cemozerr (Judge) commented](https://github.com/code-423n4/2021-05-fairside-findings/issues/60#issuecomment-856307025):**\n > Labeling this as non-critical as `getConvictionScore` returning 0 seems to have no impact on the protocol.\n\n## [[N-11] `validateVoteHash` does not confirm the vote result](https://github.com/code-423n4/2021-05-fairside-findings/issues/37)\n\nThe `validateVoteHash` function only checks if the individual voting power (conviction score) is indeed correct, but it does not verify if the outcome of the vote is correct, i.e., it is possible for a guardian to submit completely different `forVotes`/`againstVotes` in `__castOffchainVotes` changing the proposal outcome.\n\nThe guardian needs to be trusted to submit the correct `forVotes` and `againstVotes` to match the votes in the `voteHash`. The issue is that this cannot be easily verified.\n\nLegitimate users can be tricked into thinking the result is correct by checking if their vote & support is contained in `votes` and recomputing the `voteHash` themselves. They then call `validateVoteHash`, which \"confirms\" the guardian result. However, in reality, the guardian could have submitted arbitrary `forVotes`/`againstVotes` values.\n\nThis makes the current validation system kind of useless.\n\nRecommend summing up the for/against votes in the `votes` array of `validateVoteHash` and check if it matches the `proposal.forVotes/againstVotes`.\n\n**[fairside-core (FairSide) acknowledged](https://github.com/code-423n4/2021-05-fairside-findings/issues/37#issuecomment-851005971):**\n > The `VotePack` struct contains a `bool` indicating whether there was support for a proposal or not. The `validateVoteHash` function hashes all submitted votes meaning that it is impossible to obscure the for and against votes as they can be calculated off-chain.\n>\n> In any case, this is purely an off-chain utility function, and as such, the severity should be reduced to non-critical (0).\n\n**[cemozerr (Judge) commented](https://github.com/code-423n4/2021-05-fairside-findings/issues/37#issuecomment-856310206):**\n > Labeling this as non-critical as `validateVoteHash` is an external function.\n\n# Gas Optimizations\n\n## [[G-01] Gas optimizations - checkpoints from `ERC20ConvictionScore`](https://github.com/code-423n4/2021-05-fairside-findings/issues/54)\n\nIn `ERC20ConvictionScore.sol`, we store\n\n```solidity\n    // Conviction score based on # of days multiplied by # of FSD & NFT\n    // @notice A record of conviction score checkpoints for each account, by index\n    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\n\n    // @notice The number of checkpoints for each account\n    mapping(address => uint32) public numCheckpoints;\n```\n\nThese two state variables are used in the following way: (see [Issue #54](https://github.com/code-423n4/2021-05-fairside-findings/issues/54) for referenced code)\n\nChecking the contract seems like using `mapping(address => Checkpoint[]) public checkpoints;` would provide the same functionality while using less storage.\n\n**[fairside-core (FairSide) questioned](https://github.com/code-423n4/2021-05-fairside-findings/issues/54#issuecomment-851007512):**\n > I am unsure what this relates to. Can we have some further information from a_delamo?\n\n## [[G-02] Reduce reads in `purchaseMembership` method](https://github.com/code-423n4/2021-05-fairside-findings/issues/55)\n\nThe method `purchaseMembership` in the `FSDNetwork` contract contains the code below.\nInside this method, we are constantly reading from the mapping `membership`, so why not use just one read `Membership userMembership = membership[msg.sender]` and use this instance for everything related to memberships as each read we are currently doing has an impact on the gas cost.\n\nSee [Issue #55](https://github.com/code-423n4/2021-05-fairside-findings/issues/55) for referenced code.\n\n**[fairside-core (FairSide) confirmed and resolved](https://github.com/code-423n4/2021-05-fairside-findings/issues/55#issuecomment-852113491):**\n > Fixed in [PR#11](https://github.com/fairside-core/2021-05-fairside/pull/11).\n\n## [[G-03] Use external instead of public methods](https://github.com/code-423n4/2021-05-fairside-findings/issues/57)\n\nThe following methods are public and could be external. External is more optimized for gas than public and, as such, should be used as much as possible. See [issue #57](https://github.com/code-423n4/2021-05-fairside-findings/issues/57) for examples and more info at https://ethereum.stackexchange.com/a/19391\n\n**[fairside-core (FairSide) acknowledged](https://github.com/code-423n4/2021-05-fairside-findings/issues/57#issuecomment-851007235):**\n > As the Stack Overflow post indicates, the optimization is only really applicable when arrays are involved. We will retain the functions as is and adjust them as necessary further down in the development cycle.\n\n## [[G-04] Improvements arctan](https://github.com/code-423n4/2021-05-fairside-findings/issues/2)\n\nThe performance (gas usage) of the current arctan implementation is:\n`arctan(ONE)` ~ 5126  Gas (with solidity 0.6.8)\n\nThe main cause of the gas usage is the library `ABDKMathQuad` which implements IEEE 754 quadruple-precision binary floating-point numbers. However, the arctan approximation has relatively low precision.\n\nThe PDF \"higher_order_approximations\" in [this article](https://www.researchgate.net/publication/258792323_Full_Quadrant_Approximations_for_the_Arctangent_Function_Tips_and_Tricks) shows different formulas for the approximation for arctan, which have higher precision than the current implementation.\n\nThe third-order approximation is:\n```\narctan(x)  ∼ π/2 * sgn(x)*φ(abs(x))\nφ(x) = { a*x + x^2 + x^3 } / { 1 + (a+1)x + (a+1)x^2 + x^3 }\na=0.6399276529\n```\n\nI've made an implementation (see below), which takes a lot less gas:\narctan_uint(1 * precision) ~ 574 Gas (with solidity 0.6.8)\n\nThe implementation takes a different approach to floating points: it multiples all numbers by precision. The precision factor can be adjusted as long as all temporary variables stay below 2^256 (the max value of a uint)\n\n```solidity\npragma solidity 0.6.8;\ncontract Test{\n   uint constant precision=10**30;\n   uint constant pi=3.1415926535E30;\n   uint constant pidiv2=pi/2;\n   uint constant a1=0.6399276529E30;\n   uint constant aplus1=1.6399276529E30;\n\n   function arctan_uint(uint x) public pure returns (uint) {\n       uint xsquare   = x*x/precision;\n       uint xtriple     = xsquare * x/precision;\n       uint aplus1x   = aplus1 * x/precision;\n       uint top         = a1 * x/precision + xsquare + xtriple; // a*x + x^2 + x^3\n       uint bottom  = precision + aplus1x + aplus1x*x/precision + xtriple; // 1 + (a+1)x + (a+1)x^2 + x^3\n       return         pidiv2*top/bottom;\n   }\n\n   function test_arctan_uint() public pure returns (uint){\n       return arctan_uint(precision);\n   }\n}\n```\n\nRecommend defining which resolution is required and take the necessary formula from the higher_order_approximations.pdf document. Change the math library to a simple \"precision\" based implementation (as shown above). This will also require adapting other code. Also, set the \"precision\" constant to the required precision and adjust the constants to the required number of decimals.\n\n**[fairside-core (FairSide) acknowledged](https://github.com/code-423n4/2021-05-fairside-findings/issues/2#issuecomment-851016512):**\n > Although the optimization is acknowledged, it will not be applied given that we already use ABDK math across the full codebase.\n\n## [[G-05] Repetitive storage access](https://github.com/code-423n4/2021-05-fairside-findings/issues/15)\n\nThe function `_addTribute` can reuse `lastTribute` to reduce the numbers of storage access: tributes```[totalTributes - 1].amount = add224(...)``` can be replaced with ```lastTribute.amount = add224(...)``` as it is already a storage pointer that can be assigned a value with no need to recalculate the index and access the array again. Same situation with function `_addGovernanceTribute` and `governanceTributes`.\n\nRecommend making ```lastTribute.amount = add224(...)```\n\n**[fairside-core (FairSide) confirmed and resolved](https://github.com/code-423n4/2021-05-fairside-findings/issues/15#issuecomment-852202577):**\n > Fixed in [PR#23](https://github.com/fairside-core/2021-05-fairside/pull/23).\n\n## [[G-06] Gas optimization for the `rootPows` function in `FairSideFormula`](https://github.com/code-423n4/2021-05-fairside-findings/issues/71)\n\nGas optimization is possible for the current `rootPows` implementation.\nThe original implementation of `rootPows` requires 4 `mul` and 2 `sqrt`:\n\n```solidity\nfunction rootPows(bytes16 x) private pure returns (bytes16, bytes16) {\n    // fourth root\n    x = x.sqrt().sqrt();\n    // to the power of 3\n    x = _pow3(x);\n    // we offset the root on the second arg\n    return (x, x.mul(x));\n}\n```\n\nHowever, the calculation process can be simplified to be more gas-efficient than the original with only 1 `mul` and 2 `sqrt` requried:\n\n```solidity\nfunction rootPows(bytes16 x) private pure returns (bytes16, bytes16) {\n    bytes16 x1_2 = x.sqrt();\n    bytes16 x3_2 = x.mul(x1_2);\n    bytes16 x3_4 = x3_2.sqrt();\n    return (x3_4, x3_2);\n}\n```\nRecommend changing the implementation of `rootPows` as mentioned above.\n\n**[fairside-core (FairSide) questioned](https://github.com/code-423n4/2021-05-fairside-findings/issues/71#issuecomment-850998359):**\n > Optimization is confirmed (basically constructs x^3/2 then applies root on it). Given that this is a gas optimization, perhaps the severity should be noted down to 1? I'll leave this up to the judges.\n\n**[fairside-core (FairSide) confirmed and resolved](https://github.com/code-423n4/2021-05-fairside-findings/issues/71#issuecomment-851050066):**\n > Fixed in [PR#6](https://github.com/fairside-core/2021-05-fairside/pull/6).\n\n# Disclosures\n\nC4 is an open organization governed by participants in the community.\n\nC4 Contests incentivize the discovery of exploits, vulnerabilities, and bugs in smart contracts. Security researchers are rewarded at an increasing rate for finding higher-risk issues. Contest submissions are judged by a knowledgeable security researcher and solidity developer and disclosed to sponsoring developers. C4 does not conduct formal verification regarding the provided code but instead provides final verification.\n\nC4 does not provide any guarantee or warranty regarding the security of this project. All smart contract software should be used at the sole risk and responsibility of users.\n"
}