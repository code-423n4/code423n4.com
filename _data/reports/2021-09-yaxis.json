{
  "circa": {
    "title": "yAxis contest",
    "sponsor": "yAxis",
    "slug": "2021-09-yaxis",
    "date": "2021-11-10",
    "findings": "https://github.com/code-423n4/2021-09-yaxis-findings",
    "contest": 30
  },
  "html": "<h1 id=\"overview\" style=\"position:relative;\"><a href=\"#overview\" aria-label=\"overview permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Overview</h1>\n<h2 id=\"about-c4\" style=\"position:relative;\"><a href=\"#about-c4\" aria-label=\"about c4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>About C4</h2>\n<p>Code 432n4 (C4) is an open organization consisting of security researchers, auditors, developers, and individuals with domain expertise in smart contracts.</p>\n<p>A C4 code contest is an event in which community participants, referred to as Wardens, review, audit, or analyze smart contract logic in exchange for a bounty provided by sponsoring projects.</p>\n<p>During the code contest outlined in this document, C4 conducted an analysis of the yAxis smart contract system written in Solidity. The code contest took place between September 9—September 15 2021.</p>\n<h2 id=\"wardens\" style=\"position:relative;\"><a href=\"#wardens\" aria-label=\"wardens permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Wardens</h2>\n<p>13 Wardens contributed reports to the yAxis code contest:</p>\n<ol>\n<li><a href=\"https://twitter.com/cmichelio\">cmichel</a></li>\n<li><a href=\"https://twitter.com/jonah1005w\">jonah1005</a></li>\n<li><a href=\"https://twitter.com/0xRajeev\">0xRajeev</a></li>\n<li><a href=\"https://github.com/0xsanson\">0xsanson</a></li>\n<li><a href=\"https://twitter.com/HickupH\">hickuphh3</a></li>\n<li>\n<p>WatchPug</p>\n<ul>\n<li><a href=\"https://github.com/jack-the-pug\">jtp</a></li>\n<li><a href=\"https://github.com/mingwatch\">ming</a></li>\n</ul>\n</li>\n<li><a href=\"https://twitter.com/_hrkrshnn\">hrkrshnn</a></li>\n<li><a href=\"https://twitter.com/itsmeSTYJ\">itsmeSTYJ</a></li>\n<li><a href=\"https://twitter.com/SolidityDev\">pauliax</a></li>\n<li><a href=\"https://twitter.com/defsec_\">defsec</a></li>\n<li><a href=\"https://twitter.com/gpersoon\">gpersoon</a></li>\n<li><a href=\"https://github.com/verifyfirst\">verifyfirst</a></li>\n</ol>\n<p>This contest was judged by <a href=\"https://twitter.com/GalloDaSballo\">AlexTheEntreprenerd</a>.</p>\n<p>C4 Warden <a href=\"https://twitter.com/gpersoon\">gpersoon</a> also contributed to mitigating issues after the contest closed, hence their handle appears in this report as a contributor to the yAxis repo, as well as alongside their vulnerability reports.</p>\n<p>Final report assembled by <a href=\"https://twitter.com/money_lego\">moneylegobatman</a> and <a href=\"https://twitter.com/CloudEllie1\">CloudEllie</a>.</p>\n<h1 id=\"summary\" style=\"position:relative;\"><a href=\"#summary\" aria-label=\"summary permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Summary</h1>\n<p>The C4 analysis yielded an aggregated total of 50 unique vulnerabilities and 88 total findings.  All of the issues presented here are linked back to their original submissions.</p>\n<p>Of these vulnerabilities, 10 received a risk rating in the category of HIGH severity, 15 received a risk rating in the category of MEDIUM severity, and 25 received a risk rating in the category of LOW severity.</p>\n<p>C4 analysis also identified 11 non-critical recommendations and 27 gas optimizations.</p>\n<h1 id=\"scope\" style=\"position:relative;\"><a href=\"#scope\" aria-label=\"scope permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Scope</h1>\n<p>The code under review can be found within the <a href=\"https://github.com/code-423n4/2021-09-yaxis\">C4 yAxis code contest repository</a> and is composed of 90 smart contracts written in the Solidity programming language and includes 4,933 lines of Solidity code.</p>\n<h1 id=\"severity-criteria\" style=\"position:relative;\"><a href=\"#severity-criteria\" aria-label=\"severity criteria permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Severity Criteria</h1>\n<p>C4 assesses the severity of disclosed vulnerabilities according to a methodology based on <a href=\"https://owasp.org/www-community/OWASP_Risk_Rating_Methodology\">OWASP standards</a>.</p>\n<p>Vulnerabilities are divided into three primary risk categories: high, medium, and low.</p>\n<p>High-level considerations for vulnerabilities span the following key areas when conducting assessments:</p>\n<ul>\n<li>Malicious Input Handling</li>\n<li>Escalation of privileges</li>\n<li>Arithmetic</li>\n<li>Gas use</li>\n</ul>\n<p>Further information regarding the severity criteria referenced throughout the submission review process, please refer to the documentation provided on <a href=\"https://code423n4.com\">the C4 website</a>.</p>\n<h1 id=\"high-risk-findings-10\" style=\"position:relative;\"><a href=\"#high-risk-findings-10\" aria-label=\"high risk findings 10 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>High Risk Findings (10)</h1>\n<h2 id=\"h-01-controllersetcap-sets-wrong-vault-balance\" style=\"position:relative;\"><a href=\"#h-01-controllersetcap-sets-wrong-vault-balance\" aria-label=\"h 01 controllersetcap sets wrong vault balance permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/128\">[H-01] <code>Controller.setCap</code> sets wrong vault balance</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The <code>Controller.setCap</code> function sets a cap for a strategy and withdraws any excess amounts (<code>_diff</code>).\nThe vault balance is decreased by the entire strategy balance instead of by this <code>_diff</code>:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"0\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// @audit why not sub _diff?</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">_vaultDetails</span><span class=\"mtk1\">[</span><span class=\"mtk12\">_vault</span><span class=\"mtk1\">].</span><span class=\"mtk12\">balance</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_vaultDetails</span><span class=\"mtk1\">[</span><span class=\"mtk12\">_vault</span><span class=\"mtk1\">].</span><span class=\"mtk12\">balance</span><span class=\"mtk1\">.</span><span class=\"mtk11\">sub</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_balance</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<h4 id=\"impact\" style=\"position:relative;\"><a href=\"#impact\" aria-label=\"impact permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h4>\n<p>The <code>_vaultDetails[_vault].balance</code> variable does not correctly track the actual vault balances anymore, it will usually <strong>underestimate</strong> the vault balance.\nThis variable is used in <code>Controller.balanceOf()</code>, which in turn is used in <code>Vault.balance()</code>, which in turn is used to determine how many shares to mint / amount to receive when redeeming shares.\nIf the value is less, users will lose money as they can redeem fewer tokens.\nAlso, an attacker can <code>deposit</code> and will receive more shares than they should receive. They can then wait until the balance is correctly updated again and withdraw their shares for a higher amount than they deposited. This leads to the vault losing tokens.</p>\n<h4 id=\"recommended-mitigation-steps\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps\" aria-label=\"recommended mitigation steps permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h4>\n<p>Sub the <code>_diff</code> instead of the <code>balance</code>: <code>_vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_diff);</code></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/128#issuecomment-931659339\">Haz077 (yAxis) confirmed and patched</a>:</strong></p>\n<blockquote>\n<p>Already fixed in code-423n4/2021-09-yaxis#1</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/128#issuecomment-943538237\">GalloDaSballo (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Finding is valid, has been mitigated by sponsor as of 14 days ago</p>\n</blockquote>\n<h2 id=\"h-02--set-cap-breaks-vaults-balance\" style=\"position:relative;\"><a href=\"#h-02--set-cap-breaks-vaults-balance\" aria-label=\"h 02  set cap breaks vaults balance permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/1\">[H-02]  set cap breaks vault’s Balance</a></h2>\n<p><em>Submitted by jonah1005, also found by 0xsanson</em></p>\n<h4 id=\"impact-1\" style=\"position:relative;\"><a href=\"#impact-1\" aria-label=\"impact 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h4>\n<p>In controller.sol’s function <code>setCap</code>, the contract wrongly handles <code>_vaultDetails[_vault].balance</code>. While the balance should be decreased by the difference of strategies balance, it subtracts the remaining balance of the strategy. See <a href=\"https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L262-L278\">Controller.sol L262-L278</a>.\n<code>_vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_balance);</code></p>\n<p>This would result in <code>vaultDetails[_vault].balance</code> being far smaller than the strategy’s value. A user would trigger the assertion at <a href=\"https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L475\">Controller.sol#475</a> and the fund would be locked in the strategy.</p>\n<p>Though <code>setCap</code> is a permission function that only the operator can call, it’s likely to be called and the fund would be locked in the contract. I consider this a high severity issue.</p>\n<h4 id=\"proof-of-concept\" style=\"position:relative;\"><a href=\"#proof-of-concept\" aria-label=\"proof of concept permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h4>\n<p>We can trigger the issue by setting the cap 1 wei smaller than the strategy’s balance.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"python\" data-index=\"1\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">strategy_balance = strategy.functions.balanceOf().call()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">controller.functions.setCap(vault.address, strategy.address, strategy_balance - </span><span class=\"mtk7\">1</span><span class=\"mtk1\">, dai.address).transact()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">## this would be reverted</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">vault.functions.withdrawAll(dai.address).transact()</span></span></span></code></pre>\n<h4 id=\"tools-used\" style=\"position:relative;\"><a href=\"#tools-used\" aria-label=\"tools used permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tools Used</h4>\n<p>Hardhat</p>\n<h4 id=\"recommended-mitigation-steps-1\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-1\" aria-label=\"recommended mitigation steps 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h4>\n<p>I believe the dev would spot the issue in the test if <code>_vaultDetails[_vault].balance</code> is a public variable.</p>\n<p>One possible fix is to subtract the difference of the balance.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"2\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">uint</span><span class=\"mtk1\"> </span><span class=\"mtk12\">previousBalance</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">IStrategy</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_strategy</span><span class=\"mtk1\">).</span><span class=\"mtk11\">balanceOf</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">_vaultDetails</span><span class=\"mtk1\">[</span><span class=\"mtk12\">_vault</span><span class=\"mtk1\">].</span><span class=\"mtk12\">balance</span><span class=\"mtk1\">.</span><span class=\"mtk11\">sub</span><span class=\"mtk1\">(</span><span class=\"mtk12\">previousBalance</span><span class=\"mtk1\">.</span><span class=\"mtk11\">sub</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_amount</span><span class=\"mtk1\">));</span></span></span></code></pre>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/1#issuecomment-917659418\">transferAndCall (yAxis) confirmed and patched</a>:</strong></p>\n<blockquote>\n<p>Please review <a href=\"https://github.com/code-423n4/2021-09-yaxis/pull/1\">https://github.com/code-423n4/2021-09-yaxis/pull/1</a> to verify resolution.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/1#issuecomment-941742896\">GalloDaSballo (judge) commented</a>:</strong></p>\n<blockquote>\n<p>High risk vulnerability due to incorrect logic which can impact protocol functionality</p>\n<p>Sponsor has mitigated</p>\n</blockquote>\n<h2 id=\"h-03-no-safety-check-in-addtoken\" style=\"position:relative;\"><a href=\"#h-03-no-safety-check-in-addtoken\" aria-label=\"h 03 no safety check in addtoken permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/3\">[H-03] No safety check in <code>addToken</code></a></h2>\n<p><em>Submitted by jonah1005, also found by hrkrshnn and 0xRajeev</em></p>\n<h4 id=\"impact-2\" style=\"position:relative;\"><a href=\"#impact-2\" aria-label=\"impact 2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h4>\n<p>There’s no safety check in <code>Manager.sol</code> <code>addToken</code>. There are two possible cases that might happen.</p>\n<ol>\n<li>One token being added twice in a Vault. Token would be counted doubly in the vault. Ref: <a href=\"https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Vault.sol#L293-L303\">Vault.sol#L293-L303</a>. There would be two item in the array when querying <code>manager.getTokens(address(this));</code>.</li>\n<li>A token first being added to two vaults. The value calculation of the first vault would be broken. As <code>vaults[_token] = _vault;</code> would point to the other vault.</li>\n</ol>\n<p>Permission keys should always be treated cautiously. However, calling the same initialize function twice should not be able to destroy the vault. Also, as the protocol develops, there’s likely that one token is supported in two vaults. The DAO may mistakenly add the same token twice. I consider this a high-risk issue.</p>\n<h4 id=\"proof-of-concept-1\" style=\"position:relative;\"><a href=\"#proof-of-concept-1\" aria-label=\"proof of concept 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h4>\n<p>Adding same token twice would not raise any error here.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"3\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">manager</span><span class=\"mtk1\">.</span><span class=\"mtk12\">functions</span><span class=\"mtk1\">.</span><span class=\"mtk11\">addToken</span><span class=\"mtk1\">(</span><span class=\"mtk12\">vault</span><span class=\"mtk1\">.</span><span class=\"mtk12\">address</span><span class=\"mtk1\">, </span><span class=\"mtk12\">dai</span><span class=\"mtk1\">.</span><span class=\"mtk12\">address</span><span class=\"mtk1\">).</span><span class=\"mtk11\">transact</span><span class=\"mtk1\">()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">manager</span><span class=\"mtk1\">.</span><span class=\"mtk12\">functions</span><span class=\"mtk1\">.</span><span class=\"mtk11\">addToken</span><span class=\"mtk1\">(</span><span class=\"mtk12\">vault</span><span class=\"mtk1\">.</span><span class=\"mtk12\">address</span><span class=\"mtk1\">, </span><span class=\"mtk12\">dai</span><span class=\"mtk1\">.</span><span class=\"mtk12\">address</span><span class=\"mtk1\">).</span><span class=\"mtk11\">transact</span><span class=\"mtk1\">()</span></span></span></code></pre>\n<h4 id=\"tools-used-1\" style=\"position:relative;\"><a href=\"#tools-used-1\" aria-label=\"tools used 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tools Used</h4>\n<p>Hardhat</p>\n<h4 id=\"recommended-mitigation-steps-2\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-2\" aria-label=\"recommended mitigation steps 2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h4>\n<p>I recommend to add two checks</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"4\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">vaults</span><span class=\"mtk1\">[</span><span class=\"mtk12\">_token</span><span class=\"mtk1\">] == </span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk7\">0</span><span class=\"mtk1\">));</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">bool</span><span class=\"mtk1\"> </span><span class=\"mtk12\">notFound</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">True</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">for</span><span class=\"mtk1\">(</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">i</span><span class=\"mtk1\">; </span><span class=\"mtk12\">i</span><span class=\"mtk1\"> &lt; </span><span class=\"mtk12\">tokens</span><span class=\"mtk1\">[</span><span class=\"mtk12\">_vault</span><span class=\"mtk1\">].</span><span class=\"mtk12\">length</span><span class=\"mtk1\">; </span><span class=\"mtk12\">i</span><span class=\"mtk1\">++) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">tokens</span><span class=\"mtk1\">[</span><span class=\"mtk12\">_vault</span><span class=\"mtk1\">] == </span><span class=\"mtk12\">_token</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">notFound</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">False</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">require</span><span class=\"mtk1\">(</span><span class=\"mtk12\">notFound</span><span class=\"mtk1\">, </span><span class=\"mtk8\">&quot;duplicate token&quot;</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/3#issuecomment-917665371\">transferAndCall (yAxis) confirmed and patched</a>:</strong></p>\n<blockquote>\n<p>Please review <a href=\"https://github.com/code-423n4/2021-09-yaxis/pull/2\">https://github.com/code-423n4/2021-09-yaxis/pull/2</a> to verify resolution.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/3#issuecomment-942792919\">GalloDaSballo (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Lack of check for duplicates can cause undefined behaviour, sponsor mitigated by adding a require check</p>\n</blockquote>\n<h2 id=\"h-04-controller-does-not-raise-an-error-when-theres-insufficient-liquidity\" style=\"position:relative;\"><a href=\"#h-04-controller-does-not-raise-an-error-when-theres-insufficient-liquidity\" aria-label=\"h 04 controller does not raise an error when theres insufficient liquidity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/28\">[H-04] Controller does not raise an error when there’s insufficient liquidity</a></h2>\n<p><em>Submitted by jonah1005, also found by 0xRajeev and WatchPug</em></p>\n<h4 id=\"impact-3\" style=\"position:relative;\"><a href=\"#impact-3\" aria-label=\"impact 3 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h4>\n<p>When a user tries to withdraw the token from the vault, the vault would withdraw the token from the controller if there’s insufficient liquidity in the vault. However, the controller does not raise an error when there’s insufficient liquidity in the controller/ strategies. The user would lose his shares while getting nothing.</p>\n<p>An MEV searcher could apply this attack on any withdrawal. When an attacker found an unconfirmed tx that tries to withdraw 1M dai, he can do such sandwich attack.</p>\n<ol>\n<li>Deposits USDC into the vault.</li>\n<li>Withdraw all dai left in the vault/controller/strategy.</li>\n<li>Place the vitims tx here. The victim would get zero dai while burning 1 M share. <strong>This would pump the share price.</strong></li>\n<li>Withdraw all liquidity.</li>\n</ol>\n<p>All users would be vulnerable to MEV attackers. I consider this is a high-risk issue.</p>\n<h4 id=\"proof-of-concept-2\" style=\"position:relative;\"><a href=\"#proof-of-concept-2\" aria-label=\"proof of concept 2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h4>\n<p>Here’s web3.py script to reproduce the issue.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"python\" data-index=\"5\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">deposit_amount = </span><span class=\"mtk7\">100000</span><span class=\"mtk1\"> * </span><span class=\"mtk7\">10</span><span class=\"mtk1\">**</span><span class=\"mtk7\">18</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">user = w3.eth.accounts[</span><span class=\"mtk7\">0</span><span class=\"mtk1\">]</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">get_token(dai, user, deposit_amount)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">dai.functions.approve(vault.address, deposit_amount + margin_deposit).transact()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">vault.functions.deposit(dai.address, deposit_amount).transact()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">vault.functions.withdrawAll(usdt.address).transact()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">#</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">print</span><span class=\"mtk1\">(</span><span class=\"mtk8\">&quot;usdt amount: &quot;</span><span class=\"mtk1\">, usdt.functions.balanceOf(user).call())</span></span></span></code></pre>\n<h4 id=\"recommended-mitigation-steps-3\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-3\" aria-label=\"recommended mitigation steps 3 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h4>\n<p>There are two issues involved.\nFirst, users pay the slippage when they try to withdraw. I do not find this fair. Users have to pay extra gas to withdraw liquidity from strategy, convert the token, and still paying the slippage. I recommend writing a view function for the frontend to display how much slippage the user has to pay (<a href=\"https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L448-L479\">Controler.sol L448-L479</a>).</p>\n<p>Second, the controller does not revert the transaction there’s insufficient liquidity (<a href=\"https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L577-L622\">Controller.sol#L577-L622</a>).</p>\n<p>Recommend to revert the transaction when <code>_amount</code> is not equal to zero after the loop finishes.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/28\">GainsGoblin (yAxis) acknowledged</a></strong></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/28#issuecomment-943384332\">GalloDaSballo (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Agree with warden finding, this shows the path for an attack that is based on the Vault treating all tokens equally\nSince the finding shows a specific attack, the finding is unique</p>\n<p>Recommend the sponsor mitigates Single Sided Exposure risks to avoid this attack</p>\n</blockquote>\n<p><strong>BobbyYaxis (yAxis) noted:</strong></p>\n<blockquote>\n<p>We have mitigated by deploying vaults that only accept the Curve LP token itself used in the strategy. There is no longer an array of tokens accepted. E.g Instead of a wBTC vault, we have a renCrv vault. Or instead of 3CRV vault, we have a mimCrv vault. The strategy want token = the vault token.</p>\n</blockquote>\n<h2 id=\"h-05-vault-treats-all-tokens-exactly-the-same-that-creates-huge-arbitrage-opportunities\" style=\"position:relative;\"><a href=\"#h-05-vault-treats-all-tokens-exactly-the-same-that-creates-huge-arbitrage-opportunities\" aria-label=\"h 05 vault treats all tokens exactly the same that creates huge arbitrage opportunities permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/2\">[H-05] Vault treats all tokens exactly the same that creates (huge) arbitrage opportunities.</a></h2>\n<p><em>Submitted by jonah1005, also found by cmichel and itsmeSTYJ</em></p>\n<h4 id=\"impact-4\" style=\"position:relative;\"><a href=\"#impact-4\" aria-label=\"impact 4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h4>\n<p>The v3 vault treats all valid tokens exactly the same. Depositing 1M DAI would get the same share as depositing 1M USDT. User can withdraw their share in another token. Though there’s <code>withdrawalProtectionFee</code> (0.1 percent), the vault is still a no slippage stable coin exchange.</p>\n<p>Also, I notice that 3crv<em>token is added to the vault in the test. Treating 3crv</em>token and all other stable coins the same would make the vault vulnerable to flashloan attack. 3crv_token is an lp token and at the point of writing, the price of it is 1.01. The arbitrage space is about 0.8 percent and makes the vault vulnerable to flashloan attacks.</p>\n<p>Though the team may not add crv_token and dai to the same vault, its design makes the vault vulnerable. Strategies need to be designed with super caution or the vault would be vulnerable to attackers.</p>\n<p>Given the possibility of a flashloan attack, I consider this a high-risk issue.</p>\n<h4 id=\"proof-of-concept-3\" style=\"position:relative;\"><a href=\"#proof-of-concept-3\" aria-label=\"proof of concept 3 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h4>\n<p>The issue locates at the deposit function (<a href=\"https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Vault.sol#L147-L180\">Vault.sol#L147-L180</a>).\nThe share is minted according to the calculation here</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"6\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">_shares</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_shares</span><span class=\"mtk1\">.</span><span class=\"mtk11\">add</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_amount</span><span class=\"mtk1\">);</span></span></span></code></pre>\n<p>The share is burned at <a href=\"https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Vault.sol#L217\">Vault.sol L217</a></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"7\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_amount</span><span class=\"mtk1\"> = (</span><span class=\"mtk11\">balance</span><span class=\"mtk1\">().</span><span class=\"mtk11\">mul</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_shares</span><span class=\"mtk1\">)).</span><span class=\"mtk11\">div</span><span class=\"mtk1\">(</span><span class=\"mtk11\">totalSupply</span><span class=\"mtk1\">());</span></span></span></code></pre>\n<p>Here’s a sample exploit in web3.py.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"python\" data-index=\"8\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">deposit_amount = </span><span class=\"mtk7\">100000</span><span class=\"mtk1\"> * </span><span class=\"mtk7\">10</span><span class=\"mtk1\">**</span><span class=\"mtk7\">6</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">user = w3.eth.accounts[</span><span class=\"mtk7\">0</span><span class=\"mtk1\">]</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">get_token(usdt, user, deposit_amount)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">usdt.functions.approve(vault.address, deposit_amount).transact()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">vault.functions.deposit(usdt.address, deposit_amount).transact()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">vault.functions.withdrawAll(t3crv.address).transact()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\"># user can remove liquiditiy and get the profit.</span></span></span></code></pre>\n<h4 id=\"tools-used-2\" style=\"position:relative;\"><a href=\"#tools-used-2\" aria-label=\"tools used 2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tools Used</h4>\n<p>Hardhat</p>\n<h4 id=\"recommended-mitigation-steps-4\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-4\" aria-label=\"recommended mitigation steps 4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h4>\n<p>Given the protocols’ scenario, I feel like we can take iearn token’s architect as a Ref. <a href=\"https://etherscan.io/address/0x16de59092dAE5CcF4A1E6439D611fd0653f0Bd01#code\">yDdai</a></p>\n<p>yDai handles multiple tokens (cDai/ aDai/ dydx/ fulcrum). Though four tokens are pretty much the same, the contract still needs to calculate the price of each token.</p>\n<p>Or, creating a vault for each token might be an easier quick fix.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/2\">Haz077 (yAxis) acknowledged</a></strong></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/2#issuecomment-917660280\">transferAndCall (yAxis) commented</a>:</strong></p>\n<blockquote>\n<p>The design of the v3 vaults is to intentionally assume that all allowed tokens are of equal value. I do not see us enabling the 3CRV token in our Vault test, though if we did, that doesn’t mean we would in reality. Using a separate vault per token is an architecture we want to avoid.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/2#issuecomment-942441532\">GalloDaSballo (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Anecdotal example from warden makes sense.</p>\n<p>Assuming that 3CRV is worth the same as a stablecoin is in principle very similar to assuming that a swap between each stable on curve will yield a balanced trade</p>\n<p>This reminds me of the Single Sided Exposure Exploit that Yearn Suffered, and would recommend mitigating by checking the virtual_price on the 3CRV token</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/2#issuecomment-942441854\">GalloDaSballo (judge) commented</a>:</strong></p>\n<blockquote>\n<p>TODO: Review and check duplicates, need to read yaxis vault code and use cases before can judge this</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/2#issuecomment-943418352\">GalloDaSballo (judge) commented</a>:</strong></p>\n<blockquote>\n<p>After reviewing the code and the submissions, I have to agree that the vault creates arbitrage opportunities, since it heavily relies on 3CRV you may want to use it’s <code>virtual_price</code> as a way to mitigate potential exploits, alternatively you can roll your own pricing oracle solution</p>\n<p>Not mitigating this opportunity means that an attacker will exploit it at the detriment of the depositors</p>\n</blockquote>\n<p><strong>BobbyYaxis (yAxis) noted:</strong></p>\n<blockquote>\n<p>We have mitigated by deploying vaults that only accept the Curve LP token itself used in the strategy. There is no longer an array of tokens accepted. E.g Instead of a wBTC vault, we have a renCrv vault. Or instead of 3CRV vault, we have a mimCrv vault. The strategy want token = the vault token.</p>\n</blockquote>\n<h2 id=\"h-06-earn-results-in-decreasing-share-price\" style=\"position:relative;\"><a href=\"#h-06-earn-results-in-decreasing-share-price\" aria-label=\"h 06 earn results in decreasing share price permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/9\">[H-06] earn results in decreasing share price</a></h2>\n<p><em>Submitted by jonah1005</em></p>\n<h4 id=\"impact-5\" style=\"position:relative;\"><a href=\"#impact-5\" aria-label=\"impact 5 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h4>\n<p>For a dai vault that pairs with <code>NativeStrategyCurve3Crv</code>, every time <code>earn()</code> is called, shareholders would lose money. (about 2%)</p>\n<p>There are two issues involved. The <code>Vault</code> contract and the <code>controller</code> contract doesn’t handle the price difference between the want token and other tokens.</p>\n<p>At <a href=\"https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Vault.sol#L293-L303\">Vault.sol L293</a>, when a vault calculates its value, it sums up all tokens balance. However, when the controller calculates vaults’ value (at <a href=\"https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L410-L436\">Controller.sol L410-L436</a>), it only adds the amount of <code>strategy.want</code> it received. (in this case, it’s t3crv).</p>\n<p>Under the current design, users who deposit dai to the vault would not get yield. Instead, they would keep losing money. I consider this a high-risk issue</p>\n<h4 id=\"proof-of-concept-4\" style=\"position:relative;\"><a href=\"#proof-of-concept-4\" aria-label=\"proof of concept 4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h4>\n<p>I trigger the bug with the following web3.py script:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"python\" data-index=\"9\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">previous_price = vault.functions.getPricePerFullShare().call()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">vault.functions.available(dai.address).call()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">vault.functions.earn(dai.address, strategy.address).transact()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">current_price = vault.functions.getPricePerFullShare().call()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">print</span><span class=\"mtk1\">(previous_price)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">print</span><span class=\"mtk1\">(current_price)</span></span></span></code></pre>\n<h4 id=\"tools-used-3\" style=\"position:relative;\"><a href=\"#tools-used-3\" aria-label=\"tools used 3 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tools Used</h4>\n<p>Hardhat</p>\n<h4 id=\"recommended-mitigation-steps-5\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-5\" aria-label=\"recommended mitigation steps 5 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h4>\n<p>The protocol should decide what the balance sheet in each contract stands for and make it consistent in all cases. Take, for example, if <code>_vaultDetails[_vault].balance;</code> stands for the amount of ‘want’ token the vault owns, there shouldn’t exist two different want in all the strategies the vault has. Also, when the vault queries controllers <code>function balanceOf()</code>, they should always multiply it by the price.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/9\">transferAndCall (yAxis) acknowledged</a></strong></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/9#issuecomment-931250424\">gpersoon commented</a>:</strong></p>\n<blockquote>\n<p>I think this is also related to the underlying problem that all coins are assumed to have the same value.\nSee also #2, #8 and #158</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/9#issuecomment-943490025\">GalloDaSballo (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Agree with wardens finding and acknowledge it’s similitude with other issues</p>\n<p>Personally this is a different vulnerability that can be solved by solving the same underlying problem</p>\n<p>Marking this as unique finding as it’s a specific exploit the protocol could face</p>\n</blockquote>\n<p><strong>BobbyYaxis (yAxis) noted:</strong></p>\n<blockquote>\n<p>We have mitigated by deploying vaults that only accept the Curve LP token itself used in the strategy. There is no longer an array of tokens accepted. E.g Instead of a wBTC vault, we have a renCrv vault. Or instead of 3CRV vault, we have a mimCrv vault. The strategy want token = the vault token.</p>\n</blockquote>\n<h2 id=\"h-07-vaultbalance-mixes-normalized-and-standard-amounts\" style=\"position:relative;\"><a href=\"#h-07-vaultbalance-mixes-normalized-and-standard-amounts\" aria-label=\"h 07 vaultbalance mixes normalized and standard amounts permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/132\">[H-07] <code>Vault.balance()</code> mixes normalized and standard amounts</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The <code>Vault.balance</code> function uses the <code>balanceOfThis</code> function which scales (“normalizes”) all balances to 18 decimals.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"10\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">for</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint8</span><span class=\"mtk1\"> </span><span class=\"mtk12\">i</span><span class=\"mtk1\">; </span><span class=\"mtk12\">i</span><span class=\"mtk1\"> &lt; </span><span class=\"mtk12\">_tokens</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span><span class=\"mtk1\">; </span><span class=\"mtk12\">i</span><span class=\"mtk1\">++) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_token</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_tokens</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// everything is padded to 18 decimals</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">_balance</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_balance</span><span class=\"mtk1\">.</span><span class=\"mtk11\">add</span><span class=\"mtk1\">(</span><span class=\"mtk11\">_normalizeDecimals</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_token</span><span class=\"mtk1\">, </span><span class=\"mtk11\">IERC20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_token</span><span class=\"mtk1\">).</span><span class=\"mtk11\">balanceOf</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">))));</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p>Note that <code>balance()</code>’s second term <code>IController(manager.controllers(address(this))).balanceOf()</code> is not normalized.\nThe code is adding a non-normalized amount (for example 6 decimals only for USDC) to a normalized (18 decimals).</p>\n<h4 id=\"impact-6\" style=\"position:relative;\"><a href=\"#impact-6\" aria-label=\"impact 6 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h4>\n<p>The result is that the <code>balance()</code> will be under-reported.\nThis leads to receiving wrong shares when <code>deposit</code>ing tokens, and a wrong amount when redeeming <code>tokens</code>.</p>\n<h4 id=\"recommended-mitigation-steps-6\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-6\" aria-label=\"recommended mitigation steps 6 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h4>\n<p>The second term <code>IController(manager.controllers(address(this))).balanceOf()</code> must also be normalized before adding it.\n<code>IController(manager.controllers(address(this))).balanceOf()</code> uses <code>_vaultDetails[msg.sender].balance</code> which directly uses the raw token amounts which are not normalized.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/132\">GainsGoblin (yAxis) acknowledged</a></strong></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/132#issuecomment-943499944\">GalloDaSballo (judge) commented</a>:</strong></p>\n<blockquote>\n<p><code>balance</code> and <code>balanceOfThis</code> mixes the usage of decimals by alternatingly using <code>_normalizeDecimals</code>\nThis can break accounting as well as create opportunities for abuse\nA consistent usage of <code>_normalizeDecimals</code> would mitigate</p>\n</blockquote>\n<p><strong>BobbyYaxis (yAxis) noted:</strong></p>\n<blockquote>\n<p>Mitigated in PR 114: <a href=\"https://github.com/yaxis-project/metavault/pull/114/commits/b3c0405640719aa7d43560f4b4b910b7ba88170b\">https://github.com/yaxis-project/metavault/pull/114/commits/b3c0405640719aa7d43560f4b4b910b7ba88170b</a></p>\n</blockquote>\n<h2 id=\"h-08-vaultwithdraw-mixes-normalized-and-standard-amounts\" style=\"position:relative;\"><a href=\"#h-08-vaultwithdraw-mixes-normalized-and-standard-amounts\" aria-label=\"h 08 vaultwithdraw mixes normalized and standard amounts permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/131\">[H-08] <code>Vault.withdraw</code> mixes normalized and standard amounts</a></h2>\n<p><em>Submitted by cmichel, also found by hickuphh3 and jonah1005</em></p>\n<p>The <code>Vault.balance</code> function uses the <code>balanceOfThis</code> function which scales (“normalizes”) all balances to 18 decimals.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"11\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">for</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint8</span><span class=\"mtk1\"> </span><span class=\"mtk12\">i</span><span class=\"mtk1\">; </span><span class=\"mtk12\">i</span><span class=\"mtk1\"> &lt; </span><span class=\"mtk12\">_tokens</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span><span class=\"mtk1\">; </span><span class=\"mtk12\">i</span><span class=\"mtk1\">++) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_token</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_tokens</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// everything is padded to 18 decimals</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">_balance</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_balance</span><span class=\"mtk1\">.</span><span class=\"mtk11\">add</span><span class=\"mtk1\">(</span><span class=\"mtk11\">_normalizeDecimals</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_token</span><span class=\"mtk1\">, </span><span class=\"mtk11\">IERC20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_token</span><span class=\"mtk1\">).</span><span class=\"mtk11\">balanceOf</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">))));</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p>Note that <code>balance()</code>’s second term <code>IController(manager.controllers(address(this))).balanceOf()</code> is not normalized, but it must be.</p>\n<p>This leads to many issues through the contracts that use <code>balance</code> but don’t treat these values as normalized values.\nFor example, in <code>Vault.withdraw</code>, the computed <code>_amount</code> value is normalized (in 18 decimals).\nBut the <code>uint256 _balance = IERC20(_output).balanceOf(address(this));</code> value is not normalized but compared to the normalized <code>_amount</code> and even subtracted:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"12\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// @audit compares unnormalzied output to normalized output</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">_balance</span><span class=\"mtk1\"> &lt; </span><span class=\"mtk12\">_amount</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">IController</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_controller</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">IController</span><span class=\"mtk1\">(</span><span class=\"mtk12\">manager</span><span class=\"mtk1\">.</span><span class=\"mtk11\">controllers</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">)));</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// @audit cannot directly subtract unnormalized</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_toWithdraw</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_amount</span><span class=\"mtk1\">.</span><span class=\"mtk11\">sub</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_balance</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">_controller</span><span class=\"mtk1\">.</span><span class=\"mtk11\">strategies</span><span class=\"mtk1\">() &gt; </span><span class=\"mtk7\">0</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">_controller</span><span class=\"mtk1\">.</span><span class=\"mtk11\">withdraw</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_output</span><span class=\"mtk1\">, </span><span class=\"mtk12\">_toWithdraw</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_after</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">IERC20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_output</span><span class=\"mtk1\">).</span><span class=\"mtk11\">balanceOf</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">));</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_diff</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_after</span><span class=\"mtk1\">.</span><span class=\"mtk11\">sub</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_balance</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">_diff</span><span class=\"mtk1\"> &lt; </span><span class=\"mtk12\">_toWithdraw</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">_amount</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_balance</span><span class=\"mtk1\">.</span><span class=\"mtk11\">add</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_diff</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<h4 id=\"impact-7\" style=\"position:relative;\"><a href=\"#impact-7\" aria-label=\"impact 7 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h4>\n<p>Imagine in <code>withdraw</code>, the <code>output</code> is USDC with 6 decimals, then the normalized <code>_toWithdraw</code> with 18 decimals (due to using <code>_amount</code>) will be a huge number and attempt to withdraw an inflated amount.\nAn attacker can steal tokens this way by withdrawing a tiny amount of shares and receive an inflated USDC or USDT amount (or any <code>_output</code> token with less than 18 decimals).</p>\n<h4 id=\"recommended-mitigation-steps-7\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-7\" aria-label=\"recommended mitigation steps 7 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h4>\n<p>Whenever using anything involving <code>vault.balanceOfThis()</code> or <code>vault.balance()</code> one needs to be sure that any derived token amount needs to be denormalized again before using them.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/131#issuecomment-943502860\">GalloDaSballo (judge) commented</a>:</strong></p>\n<blockquote>\n<p>An inconsistent usage of <code>_normalizeDecimals</code> will cause accounting issues and potentially paths for an exploit</p>\n</blockquote>\n<p><strong>BobbyYaxis (yAxis) noted:</strong></p>\n<blockquote>\n<p>Mitigated in PR 114: <a href=\"https://github.com/yaxis-project/metavault/pull/114/commits/b3c0405640719aa7d43560f4b4b910b7ba88170b\">https://github.com/yaxis-project/metavault/pull/114/commits/b3c0405640719aa7d43560f4b4b910b7ba88170b</a></p>\n</blockquote>\n<h2 id=\"h-09-removetoken-would-break-the-vaultprotocol\" style=\"position:relative;\"><a href=\"#h-09-removetoken-would-break-the-vaultprotocol\" aria-label=\"h 09 removetoken would break the vaultprotocol permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/4\">[H-09] <code>removeToken</code> would break the vault/protocol.</a></h2>\n<p><em>Submitted by jonah1005</em></p>\n<h4 id=\"impact-8\" style=\"position:relative;\"><a href=\"#impact-8\" aria-label=\"impact 8 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h4>\n<p>There’s no safety check in Manager.sol’s <code>removeToken</code>. <a href=\"https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Manager.sol#L454-L487\">Manager.sol#L454-L487</a></p>\n<ol>\n<li>The token would be locked in the original vault. Given the current design, the vault would keep a ratio of total amount to save the gas. Once the token is removed at manager contract, these token would lost.</li>\n<li>Controller’s <code>balanceOf</code> would no longer reflects the real value. <a href=\"https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L488-L495\">Controller.sol#L488-L495</a> While <code>_vaultDetails[msg.sender].balance;</code> remains the same, user can nolonger withdraw those amount.</li>\n<li>Share price in the vault would decrease drastically. The share price is calculated as <code>totalValue / totalSupply</code> <a href=\"https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Vault.sol#L217\">Vault.sol#L217</a>. While the <code>totalSupply</code> of the share remains the same, the total balance has drastically decreased.</li>\n</ol>\n<p>Calling <code>removeToken</code> way would almost break the whole protocol if the vault has already started. I consider this is a high-risk issue.</p>\n<h4 id=\"proof-of-concept-5\" style=\"position:relative;\"><a href=\"#proof-of-concept-5\" aria-label=\"proof of concept 5 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h4>\n<p>We can see how the vault would be affected with below web3.py script.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"python\" data-index=\"13\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">print</span><span class=\"mtk1\">(vault.functions.balanceOfThis().call())</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">print</span><span class=\"mtk1\">(vault.functions.totalSupply().call())</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">manager.functions.removeToken(vault.address, dai.address).transact()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">print</span><span class=\"mtk1\">(vault.functions.balanceOfThis().call())</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">print</span><span class=\"mtk1\">(vault.functions.totalSupply().call())</span></span></span></code></pre>\n<p>output</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"\" data-index=\"14\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">100000000000000000000000</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">100000000000000000000000</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">0</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">100000000000000000000000</span></span></code></pre>\n<h4 id=\"tools-used-4\" style=\"position:relative;\"><a href=\"#tools-used-4\" aria-label=\"tools used 4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tools Used</h4>\n<p>Hardhat</p>\n<h4 id=\"recommended-mitigation-steps-8\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-8\" aria-label=\"recommended mitigation steps 8 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h4>\n<p>Remove tokens from a vault would be a really critical job. I recommend the team cover all possible cases and check all components’ states (all vault/ strategy/ controller’s state) in the test.</p>\n<p>Some steps that I try to come up with that is required to remove TokenA from a vault.</p>\n<ol>\n<li>Withdraw all tokenA from all strategies (and handle it correctly in the controller).</li>\n<li>Withdraw all tokenA from the vault.</li>\n<li>Convert all tokenA that’s collected in the previous step into tokenB.</li>\n<li>Transfer tokenB to the vault and compensate the transaction fee/slippage cost to the vault.</li>\n</ol>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/4#issuecomment-917676694\">transferAndCall (yAxis) acknowledged</a>:</strong></p>\n<blockquote>\n<p>Removing a token is understood as a critical (and possibly nuclear) operation within this architecture. We knew we would have to first withdraw all of the identified token from strategies, but what was missed was converting that token to another (without withdrawing, as that would be too much centralization).</p>\n<p>Proposed method of resolution:</p>\n<ul>\n<li>Withdraw all tokenA from all strategies (this sends it to the vault)</li>\n<li>Swap tokenA for tokenB in the vault (requires implementing a new function to be called by the strategist)</li>\n<li>Remove the token via the Manager function</li>\n</ul>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/4#issuecomment-917695184\">transferAndCall (yAxis) confirmed and patched</a>:</strong></p>\n<blockquote>\n<p>Please review <a href=\"https://github.com/code-423n4/2021-09-yaxis/pull/5\">https://github.com/code-423n4/2021-09-yaxis/pull/5</a> to check resolution.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/4#issuecomment-943519688\">GalloDaSballo (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Removing a token can cause accounting errors, stuck funds and break some of the functionality</p>\n<p>Adding additional checks to prevent removing the token until all tokens have been migrated may be the simplest path forward</p>\n<p>Sponsor has mitigated by adding custom functionality, however it is up to them to enforce that the vault has no token left before removing it, adding a couple extra checks may provide a guarantee against admin privileged abuses</p>\n</blockquote>\n<h2 id=\"h-10-an-attacker-can-steal-funds-from-multi-token-vaults\" style=\"position:relative;\"><a href=\"#h-10-an-attacker-can-steal-funds-from-multi-token-vaults\" aria-label=\"h 10 an attacker can steal funds from multi token vaults permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/77\">[H-10] An attacker can steal funds from multi-token vaults</a></h2>\n<p><em>Submitted by WatchPug, also found by cmichel and jonah1005</em></p>\n<p>The total balance should NOT be simply added from different tokens’ tokenAmounts, considering that the price of tokens may not be the same.</p>\n<p><a href=\"https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/Vault.sol#L324\"><code>Vault.sol</code> L324</a></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"15\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">balanceOfThis</span><span class=\"mtk1\">()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">public</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">view</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_balance</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">{</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">address</span><span class=\"mtk1\">[] </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_tokens</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">manager</span><span class=\"mtk1\">.</span><span class=\"mtk11\">getTokens</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">));</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">for</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint8</span><span class=\"mtk1\"> </span><span class=\"mtk12\">i</span><span class=\"mtk1\">; </span><span class=\"mtk12\">i</span><span class=\"mtk1\"> &lt; </span><span class=\"mtk12\">_tokens</span><span class=\"mtk1\">.</span><span class=\"mtk12\">length</span><span class=\"mtk1\">; </span><span class=\"mtk12\">i</span><span class=\"mtk1\">++) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_token</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_tokens</span><span class=\"mtk1\">[</span><span class=\"mtk12\">i</span><span class=\"mtk1\">];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">        </span><span class=\"mtk12\">_balance</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_balance</span><span class=\"mtk1\">.</span><span class=\"mtk11\">add</span><span class=\"mtk1\">(</span><span class=\"mtk11\">_normalizeDecimals</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_token</span><span class=\"mtk1\">, </span><span class=\"mtk11\">IERC20</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_token</span><span class=\"mtk1\">).</span><span class=\"mtk11\">balanceOf</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">))));</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    }</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p><a href=\"https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/controllers/Controller.sol#L396\"><code>Controller.sol</code> L396</a></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"16\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">harvestStrategy</span><span class=\"mtk1\">(</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_strategy</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_estimatedWETH</span><span class=\"mtk1\">,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_estimatedYAXIS</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">external</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">override</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">notHalted</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">onlyHarvester</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">onlyStrategy</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_strategy</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">{</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_before</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">IStrategy</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_strategy</span><span class=\"mtk1\">).</span><span class=\"mtk11\">balanceOf</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">IStrategy</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_strategy</span><span class=\"mtk1\">).</span><span class=\"mtk11\">harvest</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_estimatedWETH</span><span class=\"mtk1\">, </span><span class=\"mtk12\">_estimatedYAXIS</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_after</span><span class=\"mtk1\"> = </span><span class=\"mtk11\">IStrategy</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_strategy</span><span class=\"mtk1\">).</span><span class=\"mtk11\">balanceOf</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">address</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_vault</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_vaultStrategies</span><span class=\"mtk1\">[</span><span class=\"mtk12\">_strategy</span><span class=\"mtk1\">];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">_vaultDetails</span><span class=\"mtk1\">[</span><span class=\"mtk12\">_vault</span><span class=\"mtk1\">].</span><span class=\"mtk12\">balance</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_vaultDetails</span><span class=\"mtk1\">[</span><span class=\"mtk12\">_vault</span><span class=\"mtk1\">].</span><span class=\"mtk12\">balance</span><span class=\"mtk1\">.</span><span class=\"mtk11\">add</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_after</span><span class=\"mtk1\">.</span><span class=\"mtk11\">sub</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_before</span><span class=\"mtk1\">));</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">_vaultDetails</span><span class=\"mtk1\">[</span><span class=\"mtk12\">_vault</span><span class=\"mtk1\">].</span><span class=\"mtk12\">balances</span><span class=\"mtk1\">[</span><span class=\"mtk12\">_strategy</span><span class=\"mtk1\">] = </span><span class=\"mtk12\">_after</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">emit</span><span class=\"mtk1\"> </span><span class=\"mtk11\">Harvest</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_strategy</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p><a href=\"https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/Vault.sol#L310\"><code>Vault.sol</code> L310</a></p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"17\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">/**</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\"> * </span><span class=\"mtk4\">@notice</span><span class=\"mtk3\"> Returns the total balance of the vault, including strategies</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\"> */</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">function</span><span class=\"mtk1\"> </span><span class=\"mtk11\">balance</span><span class=\"mtk1\">()</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">public</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">view</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">override</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk11\">returns</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_balance</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">{</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk15\">return</span><span class=\"mtk1\"> </span><span class=\"mtk11\">balanceOfThis</span><span class=\"mtk1\">().</span><span class=\"mtk11\">add</span><span class=\"mtk1\">(</span><span class=\"mtk11\">IController</span><span class=\"mtk1\">(</span><span class=\"mtk12\">manager</span><span class=\"mtk1\">.</span><span class=\"mtk11\">controllers</span><span class=\"mtk1\">(</span><span class=\"mtk11\">address</span><span class=\"mtk1\">(</span><span class=\"mtk4\">this</span><span class=\"mtk1\">))).</span><span class=\"mtk11\">balanceOf</span><span class=\"mtk1\">());</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<h4 id=\"impact-9\" style=\"position:relative;\"><a href=\"#impact-9\" aria-label=\"impact 9 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h4>\n<p>An attacker can steal funds from multi-token vaults. Resulting in fund loss of all other users.</p>\n<h4 id=\"proof-of-concept-6\" style=\"position:relative;\"><a href=\"#proof-of-concept-6\" aria-label=\"proof of concept 6 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h4>\n<p>If there is a multi-token vault with 3 tokens: DAI, USDC, USDT, and their price in USD is now 1.05, 0.98, and 0.95. If the current balances are: 2M, 1M, and 0.5M.</p>\n<p>An attacker may do the following steps:</p>\n<ol>\n<li>Deposit 3M of USDT;</li>\n<li>Withdraw 3M, receive 2M in DAI and 1M in USDC.</li>\n</ol>\n<p>As 2M of DAI + 1M of USDC worth much more than 3M of USDT. The attacker will profit and all other users will be losing funds.</p>\n<h4 id=\"recommended-mitigation-steps-9\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-9\" aria-label=\"recommended mitigation steps 9 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h4>\n<p>Always consider the price differences between tokens.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/77\">BobbyYaxis (yAxis) acknowledged</a></strong></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/77#issuecomment-942445062\">GalloDaSballo (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Fully agree with the finding, assuming price of tokens is the same exposes the Vault and all depositors to risk of Single Sided Exposure</p>\n<p>This risk has been exploited multiple times, notably in the Yearn Exploit</p>\n<p>The solution for for managing tokens with multiple values while avoiding being rekt is to have an index that ensures your LP  Token maintains it’s peg, curve’s solution is called <code>virtual_price</code></p>\n<p>Having a virtual price would allow to maintain the Vault Architecture, while mitigating exploits that directly use balances</p>\n</blockquote>\n<p><strong>BobbyYaxis (yAxis) noted:</strong></p>\n<blockquote>\n<p>We have mitigated by deploying vaults that only accept the Curve LP token itself used in the strategy. There is no longer an array of tokens accepted. E.g Instead of a wBTC vault, we have a renCrv vault. Or instead of 3CRV vault, we have a mimCrv vault. The strategy want token = the vault token.</p>\n</blockquote>\n<h1 id=\"medium-risk-findings-15\" style=\"position:relative;\"><a href=\"#medium-risk-findings-15\" aria-label=\"medium risk findings 15 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Medium Risk Findings (15)</h1>\n<h2 id=\"m-01-vaulthelper-deposits-dont-work-with-fee-on-transfer-tokens\" style=\"position:relative;\"><a href=\"#m-01-vaulthelper-deposits-dont-work-with-fee-on-transfer-tokens\" aria-label=\"m 01 vaulthelper deposits dont work with fee on transfer tokens permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/127\">[M-01] <code>VaultHelper</code> deposits don’t work with fee-on transfer tokens</a></h2>\n<p><em>Submitted by cmichel, also found by 0xsanson</em></p>\n<p>There are ERC20 tokens that may make certain customizations to their ERC20 contracts.\nOne type of these tokens is deflationary tokens that charge a certain fee for every <code>transfer()</code> or <code>transferFrom()</code>.\nOthers are rebasing tokens that increase in value over time like Aave’s aTokens (<code>balanceOf</code> changes over time).</p>\n<h4 id=\"impact-10\" style=\"position:relative;\"><a href=\"#impact-10\" aria-label=\"impact 10 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h4>\n<p>The <code>VaultHelper</code>’s <code>depositVault()</code> and <code>depositMultipleVault</code> functions transfer <code>_amount</code> to <code>this</code> contract using <code>IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);</code>.\nThis could have a fee, and less than <code>_amount</code> ends up in the contract.\nThe next actual vault deposit using <code>IVault(_vault).deposit(_token, _amount);</code> will then try to transfer more than the <code>this</code> contract actually has and will revert the transaction.</p>\n<h4 id=\"recommended-mitigation-steps-10\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-10\" aria-label=\"recommended mitigation steps 10 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h4>\n<p>One possible mitigation is to measure the asset change right before and after the asset-transferring routines.\nThis is already done correctly in the <code>Vault.deposit</code> function.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/127#issuecomment-941740332\">GalloDaSballo (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Agree with finding, checking actual balance of contract would mitigate vulnerability\nAdditionally ensuring the protocol never uses rebasing or tokens with <code>feeOnTransfer</code> can be enough to mitigate</p>\n<p>The vulnerability can brick the protocol\nHowever it can be sidestepped by simply not using <code>feeOnTransfer</code> tokens\nDowngrading to medium</p>\n</blockquote>\n<h2 id=\"m-02-erc20-return-values-not-checked\" style=\"position:relative;\"><a href=\"#m-02-erc20-return-values-not-checked\" aria-label=\"m 02 erc20 return values not checked permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/114\">[M-02] ERC20 return values not checked</a></h2>\n<p><em>Submitted by cmichel, also found by defsec and jonah1005</em></p>\n<p>The <code>ERC20.transfer()</code> and <code>ERC20.transferFrom()</code> functions return a boolean value indicating success. This parameter needs to be checked for success.\nSome tokens do <strong>not</strong> revert if the transfer failed but return <code>false</code> instead.</p>\n<p>The <code>Manager.recoverToken</code> function does not check the return value of this function.</p>\n<h4 id=\"impact-11\" style=\"position:relative;\"><a href=\"#impact-11\" aria-label=\"impact 11 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h4>\n<p>Tokens that don’t actually perform the transfer and return <code>false</code> are still counted as a correct transfer.\nFurthermore, tokens that do not correctly implement the EIP20 standard, like USDT which does not return a success boolean, will revert.</p>\n<h4 id=\"recommended-mitigation-steps-11\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-11\" aria-label=\"recommended mitigation steps 11 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h4>\n<p>We recommend using <a href=\"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74\">OpenZeppelin’s <code>SafeERC20</code></a> versions with the <code>safeTransfer</code> and <code>safeTransferFrom</code> functions that handle the return value check as well as non-standard-compliant tokens.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/114#issuecomment-942781687\">GalloDaSballo (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Agree with finding, using a non reverting token can potentially cause issues to the protocol accounting</p>\n<p>Sponsor can check each token on a case by case basis, or simply use OpenZeppelin’s <code>safeERC20</code></p>\n</blockquote>\n<h2 id=\"m-03-vaultwithdraw-sometimes-burns-too-many-shares\" style=\"position:relative;\"><a href=\"#m-03-vaultwithdraw-sometimes-burns-too-many-shares\" aria-label=\"m 03 vaultwithdraw sometimes burns too many shares permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/121\">[M-03] <code>Vault.withdraw</code> sometimes burns too many shares</a></h2>\n<p><em>Submitted by cmichel, also found by 0xsanson and 0xRajeev</em></p>\n<p>The <code>Vault.withdraw</code> function attempts to withdraw funds from the controller if there are not enough in the vault already.\nIn the case the controller could not withdraw enough, i.e., where <code>_diff &#x3C; _toWithdraw</code>, the user will receive <strong>less</strong> output tokens than their fair share would entitle them to (the initial <code>_amount</code>).</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"18\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">_diff</span><span class=\"mtk1\"> &lt; </span><span class=\"mtk12\">_toWithdraw</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// @audit burns too many shares for a below fair-share amount</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">_amount</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_balance</span><span class=\"mtk1\">.</span><span class=\"mtk11\">add</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_diff</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<h4 id=\"impact-12\" style=\"position:relative;\"><a href=\"#impact-12\" aria-label=\"impact 12 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h4>\n<p>The withdrawer receives fewer output tokens than they were entitled to.</p>\n<h4 id=\"recommended-mitigation-steps-12\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-12\" aria-label=\"recommended mitigation steps 12 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h4>\n<p>In the mentioned case, the <code>_shares</code> should be recomputed to match the actual withdrawn <code>_amount</code> tokens:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"19\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">_diff</span><span class=\"mtk1\"> &lt; </span><span class=\"mtk12\">_toWithdraw</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">_amount</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_balance</span><span class=\"mtk1\">.</span><span class=\"mtk11\">add</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_diff</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// recompute _shares to burn based on the lower payout</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// should be something like this, better to cache balance() once at the start and use that cached value</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">_shares</span><span class=\"mtk1\"> = (</span><span class=\"mtk11\">totalSupply</span><span class=\"mtk1\">().</span><span class=\"mtk11\">mul</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_amount</span><span class=\"mtk1\">)).</span><span class=\"mtk11\">div</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_balance</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p>Only these shares should then be burned.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/121#issuecomment-932776915\">uN2RVw5q commented</a>:</strong></p>\n<blockquote>\n<p>Duplicate of <a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/41\">https://github.com/code-423n4/2021-09-yaxis-findings/issues/41</a> and <a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/136\">https://github.com/code-423n4/2021-09-yaxis-findings/issues/136</a></p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/121#issuecomment-942790860\">GalloDaSballo (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Agree with the finding</p>\n<p>Anytime the strategy incurs a loss during withdrawal, the person that triggered that withdrawal will get less for their shares than what they may expect.</p>\n<p>Since amount of shares is computed by checking balance in strategy, and controller enacts this withdrawal, adding a check in the controller to compare expected withdrawal vs actual shares received would be a clean way to mitigate</p>\n</blockquote>\n<p><strong>BobbyYaxis (yAxis) noted:</strong></p>\n<blockquote>\n<p>We have mitigated by deploying vaults that only accept the Curve LP token itself used in the strategy. There is no longer an array of tokens accepted. E.g Instead of a wBTC vault, we have a renCrv vault. Or instead of 3CRV vault, we have a mimCrv vault. The strategy want token = the vault token.</p>\n</blockquote>\n<h2 id=\"m-04-adding-asymmetric-liquidity-in-_addliquidity-results-in-fewer-lp-tokens-minted-than-what-should-be-wanted\" style=\"position:relative;\"><a href=\"#m-04-adding-asymmetric-liquidity-in-_addliquidity-results-in-fewer-lp-tokens-minted-than-what-should-be-wanted\" aria-label=\"m 04 adding asymmetric liquidity in _addliquidity results in fewer lp tokens minted than what should be wanted permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/158\">[M-04] Adding asymmetric liquidity in <code>_addLiquidity</code> results in fewer LP tokens minted than what should be wanted</a></h2>\n<h4 id=\"impact-13\" style=\"position:relative;\"><a href=\"#impact-13\" aria-label=\"impact 13 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h4>\n<p>Because the call in <code>_addLiquidity</code> forwards the entire balances of the 3 stablecoins without checking the ratio.\nbetween the 3, less liquidity is minted than what should be wanted. Furthermore, an attacker can abuse this arbitrage the forwarded balances if the discrepancy is large enough.</p>\n<p>For example, suppose the contract holds $10K each of usdc, usdt, dai. An attacker deposits $100K worth of DAI\nand get credited with $100K worth of shares in the protocol. Liquidity is added, but since the ratio is now skewed\n11:1:1, a lot less liquidity is minted by the stableswap algorithm to the protocol. The attacker can now arbitrage the curve pool for an additional profit.</p>\n<p>There doesn’t even need to be an attacker, just an unbalanced amount of user deposits will also lead to lower liquidity minted.</p>\n<h4 id=\"proof-of-concept-7\" style=\"position:relative;\"><a href=\"#proof-of-concept-7\" aria-label=\"proof of concept 7 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h4>\n<ul>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/strategies/NativeStrategyCurve3Crv.sol#L73\"><code>NativeStrategyCurve3Crv.sol</code> L73</a></li>\n</ul>\n<h4 id=\"recommended-mitigation-steps-13\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-13\" aria-label=\"recommended mitigation steps 13 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h4>\n<p>Adding liquidity should probably be managed more manually, it should be added in equal proportion to the curve pool balances, not the contract balances.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/158#issuecomment-930142403\">gpersoon commented</a>:</strong></p>\n<blockquote>\n<p>Seems the same as #2</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/158#issuecomment-943488554\">GalloDaSballo (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Agree on the finding\nThis finding claims that adding liquidity on Curve while treating each token to have the same weight is a surefire way to get less tokens than expected</p>\n<p>While #2 addresses a similar (IMO higher risk) vulnerability</p>\n<p>This finding shows how the vault can have a loss of value through how it deals with token accounting</p>\n<p>To me this is a unique finding, however am downgrading it to medium</p>\n</blockquote>\n<p><strong>BobbyYaxis (yAxis) noted:</strong></p>\n<blockquote>\n<p>We have mitigated by deploying vaults that only accept the Curve LP token itself used in the strategy. There is no longer an array of tokens accepted. E.g Instead of a wBTC vault, we have a renCrv vault. Or instead of 3CRV vault, we have a mimCrv vault. The strategy want token = the vault token.</p>\n</blockquote>\n<h2 id=\"m-05-vault-swaps-at-parity-with-swap-fee--withdrawal-fee\" style=\"position:relative;\"><a href=\"#m-05-vault-swaps-at-parity-with-swap-fee--withdrawal-fee\" aria-label=\"m 05 vault swaps at parity with swap fee  withdrawal fee permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/71\">[M-05] Vault: Swaps at parity with swap fee = withdrawal fee</a></h2>\n<p><em>Submitted by hickuphh3</em></p>\n<h5 id=\"impact-14\" style=\"position:relative;\"><a href=\"#impact-14\" aria-label=\"impact 14 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h5>\n<p>The vault treats all assets to be of the same price. Given that one can also deposit and withdraw in the same transaction, this offers users the ability to swap available funds held in the vault at parity, with the withdrawal protection fee (0.1%) effectively being the swap fee.</p>\n<p>Due care and consideration should therefore be placed if new stablecoins are to be added to the vault (eg. algorithmic ones that tend to occasionally be off-peg), or when lowering the withdrawal protection fee.</p>\n<h5 id=\"recommended-mitigation-steps-14\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-14\" aria-label=\"recommended mitigation steps 14 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h5>\n<ul>\n<li>Prevent users from depositing and withdrawing in the same transaction. This would help prevent potential flash loan attacks as well</li>\n<li><code>setWithdrawalProtectionFee()</code> could have a requirement for the value to be non-zero. Zero withdrawal fee could be set in <code>setHalted()</code> whereby only withdrawals will be allowed.</li>\n<li>Use price oracles to accurately calculate the shares to be transferred to users for deposits, or token amounts to be sent for withdrawals</li>\n</ul>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/71#issuecomment-942810131\">GalloDaSballo (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Agree with finding, this vault accounting can be used for arbitrage opportunities as tokens are treated at exact value while they may have imbalances in price</p>\n<p>This is not a duplicate as it’s explaining a specific attack vector</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/71#issuecomment-942810380\">GalloDaSballo (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Also raising risk valuation as this WILL be used to extract value from the system</p>\n</blockquote>\n<p><strong>BobbyYaxis (yAxis) noted:</strong></p>\n<blockquote>\n<p>We have mitigated by deploying vaults that only accept the Curve LP token itself used in the strategy. There is no longer an array of tokens accepted. E.g Instead of a wBTC vault, we have a renCrv vault. Or instead of 3CRV vault, we have a mimCrv vault. The strategy want token = the vault token.</p>\n</blockquote>\n<h2 id=\"m-06---controller-is-vulnerable-to-sandwich-attack\" style=\"position:relative;\"><a href=\"#m-06---controller-is-vulnerable-to-sandwich-attack\" aria-label=\"m 06   controller is vulnerable to sandwich attack permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/7\">[M-06]  # Controller is vulnerable to sandwich attack</a></h2>\n<p><em>Submitted by jonah1005</em></p>\n<h4 id=\"impact-15\" style=\"position:relative;\"><a href=\"#impact-15\" aria-label=\"impact 15 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h4>\n<p>The protocol frequently interacts with crv a lot. However, the contract doesn’t specify the minimum return amount.\nGiven the fact that there’s a lot of MEV searchers, calling swap without specifying the minimum return amount really puts user funds in danger.</p>\n<p>For example, controller’s <code>withdrawAll</code> is designed to transfer all the funds in a strategy.<a href=\"https://github.com/code-423n4/2021-09-yaxis/blob/a78d392156b90f8ac27de6d57cb0de2697d480d5/contracts/v3/controllers/Controller.sol#L360\">Controller.sol#L360</a> The arbitrage space is enough for a searcher to sandwich this trade.</p>\n<h4 id=\"proof-of-concept-8\" style=\"position:relative;\"><a href=\"#proof-of-concept-8\" aria-label=\"proof of concept 8 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h4>\n<p><a href=\"https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Manager.sol#L442-L452\">Manager.sol#L442-L452</a></p>\n<p><a href=\"https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L273\">Controller.sol#L273</a></p>\n<h4 id=\"recommended-mitigation-steps-15\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-15\" aria-label=\"recommended mitigation steps 15 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h4>\n<p>Always calculates an estimate return when calling to crv.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/7\">transferAndCall (yAxis) acknowledged</a></strong></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/7#issuecomment-942827851\">GalloDaSballo (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Agree with finding, agree with severity as this allows to “leak value”</p>\n</blockquote>\n<h2 id=\"m-07-vault-withdrawals-can-be-frontrun-to-cause-users-to-burn-tokens-without-receiving-funds-in-return\" style=\"position:relative;\"><a href=\"#m-07-vault-withdrawals-can-be-frontrun-to-cause-users-to-burn-tokens-without-receiving-funds-in-return\" aria-label=\"m 07 vault withdrawals can be frontrun to cause users to burn tokens without receiving funds in return permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/74\">[M-07] Vault: Withdrawals can be frontrun to cause users to burn tokens without receiving funds in return</a></h2>\n<p><em>Submitted by hickuphh3</em></p>\n<h5 id=\"impact-16\" style=\"position:relative;\"><a href=\"#impact-16\" aria-label=\"impact 16 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h5>\n<p>Let us assume either of the following cases:</p>\n<ol>\n<li>The vault / protocol is to be winded down or migrated, where either the protocol is halted and <code>withdrawAll()</code> has been called on all active strategies to transfer funds into the vault.</li>\n<li>There are 0 strategies. Specifically, <code>_controller.strategies() = 0</code></li>\n</ol>\n<p>Attempted withdrawals can be frontrun such that users will receive less, or even no funds in exchange for burning vault tokens. This is primarily enabled by the feature of having deposits in multiple stablecoins.</p>\n<h5 id=\"proof-of-concept-9\" style=\"position:relative;\"><a href=\"#proof-of-concept-9\" aria-label=\"proof of concept 9 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h5>\n<ol>\n<li>Assume <code>getPricePerFullShare()</code> of <code>1e18</code> (1 vault token = 1 stablecoin). Alice has 1000 vault tokens, while Mallory has 2000 vault tokens, with the vault holdings being 1000 USDC, 1000 USDT and 1000 DAI.</li>\n<li>Alice attempts to withdraw her deposit in a desired stablecoin (Eg. USDC).</li>\n<li>Mallory frontruns Alice’s transaction and exchanges 1000 vault tokens for the targeted stablecoin (USDC). The vault now holds 1000 USDT and 1000 DAI.</li>\n<li>Alice receives nothing in return for her deposit because the vault no longer has any USDC. <code>getPricePerFullShare()</code> now returns <code>2e18</code>.</li>\n<li>Mallory splits his withdrawals evenly, by burning 500 vault tokens for 1000 USDT and the other 500 vault tokens for 1000 DAI.</li>\n</ol>\n<p>Hence, Mallory is able to steal Alice’s funds by frontrunning her withdrawal transaction.</p>\n<h5 id=\"recommended-mitigation-steps-16\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-16\" aria-label=\"recommended mitigation steps 16 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h5>\n<p>The withdrawal amount could be checked against <code>getPricePerFullShare()</code>, perhaps with reasonable slippage.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/74#issuecomment-931750516\">GainsGoblin (yAxis) commented</a>:</strong></p>\n<blockquote>\n<p>Duplicate of #28</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/74#issuecomment-943385674\">GalloDaSballo (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Disagree with duplicate label as this shows a Value Extraction, front-running exploit.\nMedium severity as it’s a way to “leak value”</p>\n<p>This can be mitigated through addressing the “Vault value all tokens equally” issue</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/74#issuecomment-943707545\">GainsGoblin (yAxis) commented</a>:</strong></p>\n<blockquote>\n<p>The issue is exactly the same as #28. Both issues present the exact same front-running example.</p>\n</blockquote>\n<p><strong>BobbyYaxis (yAxis) noted:</strong></p>\n<blockquote>\n<p>We have mitigated by deploying vaults that only accept the Curve LP token itself used in the strategy. There is no longer an array of tokens accepted. E.g Instead of a wBTC vault, we have a renCrv vault. Or instead of 3CRV vault, we have a mimCrv vault. The strategy want token = the vault token.</p>\n</blockquote>\n<h2 id=\"m-08-controllerincasestrategygetstuck-does-not-update-balance\" style=\"position:relative;\"><a href=\"#m-08-controllerincasestrategygetstuck-does-not-update-balance\" aria-label=\"m 08 controllerincasestrategygetstuck does not update balance permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/130\">[M-08] <code>Controller.inCaseStrategyGetStuck</code> does not update balance</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The <code>Controller.inCaseStrategyGetStuck</code> withdraws from a strategy but does not call <code>updateBalance(_vault, _strategy)</code> afterwards.</p>\n<h4 id=\"impact-17\" style=\"position:relative;\"><a href=\"#impact-17\" aria-label=\"impact 17 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h4>\n<p>The <code>_vaultDetails[_vault].balances[_strategy]</code> variable does not correctly track the actual strategy balance anymore.\nI’m not sure what exactly this field is used for besides getting the withdraw amounts per strategy in <code>getBestStrategyWithdraw</code>.\nAs the strategy contains a lower amount than stored in the field, <code>Controller.withdraw</code> will attempt to withdraw too much.</p>\n<h4 id=\"recommended-mitigation-steps-17\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-17\" aria-label=\"recommended mitigation steps 17 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h4>\n<p>Call <code>updateBalance(_vault, _strategy)</code> in <code>inCaseStrategyGetStuck</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/130\">Haz077 (yAxis) acknowledged</a></strong></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/130#issuecomment-943400238\">GalloDaSballo (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Agree with finding, I also believe <code>inCaseStrategyGetStuck</code> and <code>inCaseTokenGetStuck</code> are vectors for admin rugging, may want to add checks to ensure only non strategy token can be withdrawn from the vaults and strats</p>\n</blockquote>\n<p><strong>BobbyYaxis (yAxis) noted:</strong></p>\n<blockquote>\n<p>It’s a needed function for the strategist. The risk of these functions are mitigated as the strategies and controller should never have a balance of any tokens regardless. So there should be nothing/meaningful for the strategist to ever “rug” in that sense. But we can make this a governance-only feature, rather than strategist.</p>\n</blockquote>\n<h2 id=\"m-09-token---vault-mapping-can-be-overwritten\" style=\"position:relative;\"><a href=\"#m-09-token---vault-mapping-can-be-overwritten\" aria-label=\"m 09 token   vault mapping can be overwritten permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/126\">[M-09] token -> vault mapping can be overwritten</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>One vault can have many tokens, but each token should only be assigned to a single vault.\nThe <code>Manager</code> contract keeps a mapping of tokens to vaults in the <code>vaults[_token] => _vault</code> map, and a mapping of vault to tokens in <code>tokens[vault] => token[]</code>.</p>\n<p>The <code>addToken</code> function can assign any token to a single vault and allows overwriting an existing <code>vaults[_token]</code> map entry with a different vault.\nThis indirectly disassociates the previous vault for the token.\nNote that the previous vault’s <code>tokens[_previousVault]</code> map still contains the <code>token</code>.</p>\n<h4 id=\"impact-18\" style=\"position:relative;\"><a href=\"#impact-18\" aria-label=\"impact 18 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h4>\n<p>The token disappears from the system for the previous vault but the actual tokens are still in there, getting stuck.\nOnly the new vault is considered for the token anymore, which leads to many issues, see <code>Controller.getBestStrategyWithdraw</code> and the <code>onlyVault</code> modifier that doesn’t work correctly anymore.</p>\n<h4 id=\"recommended-mitigation-steps-18\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-18\" aria-label=\"recommended mitigation steps 18 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h4>\n<p>It should check if the <code>token</code> is already used in a map, and either revert or correctly remove the token from the vault - from the <code>tokens</code> array.\nIt should do the same cleanup procedure as in <code>removeToken</code>:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"20\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk15\">if</span><span class=\"mtk1\"> (</span><span class=\"mtk12\">found</span><span class=\"mtk1\">) {</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk3\">// remove the token from the vault</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">tokens</span><span class=\"mtk1\">[</span><span class=\"mtk12\">_vault</span><span class=\"mtk1\">][</span><span class=\"mtk12\">index</span><span class=\"mtk1\">] = </span><span class=\"mtk12\">tokens</span><span class=\"mtk1\">[</span><span class=\"mtk12\">_vault</span><span class=\"mtk1\">][</span><span class=\"mtk12\">k</span><span class=\"mtk1\">-</span><span class=\"mtk7\">1</span><span class=\"mtk1\">];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">tokens</span><span class=\"mtk1\">[</span><span class=\"mtk12\">_vault</span><span class=\"mtk1\">].</span><span class=\"mtk11\">pop</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">delete</span><span class=\"mtk1\"> </span><span class=\"mtk12\">vaults</span><span class=\"mtk1\">[</span><span class=\"mtk12\">_token</span><span class=\"mtk1\">];</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk12\">emit</span><span class=\"mtk1\"> </span><span class=\"mtk11\">TokenRemoved</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_vault</span><span class=\"mtk1\">, </span><span class=\"mtk12\">_token</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">}</span></span></span></code></pre>\n<p><code>addToken</code> should also check that the token is not already in the <code>tokens[_vault]</code> array.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/126#issuecomment-943460833\">GalloDaSballo (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Mapping mismatch can cause undefined behaviour</p>\n<p>Recommend having one source of truth to keep things simple</p>\n</blockquote>\n<h2 id=\"m-10-yaxisvotepowerbalanceof-can-be-manipulated\" style=\"position:relative;\"><a href=\"#m-10-yaxisvotepowerbalanceof-can-be-manipulated\" aria-label=\"m 10 yaxisvotepowerbalanceof can be manipulated permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/113\">[M-10] <code>YAxisVotePower.balanceOf</code> can be manipulated</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The <code>YAxisVotePower.balanceOf</code> contract uses the Uniswap pool reserves to compute a <code>_lpStakingYax</code> reward:</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"21\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">(</span><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_yaxReserves</span><span class=\"mtk1\">,,) = </span><span class=\"mtk12\">yaxisEthUniswapV2Pair</span><span class=\"mtk1\">.</span><span class=\"mtk11\">getReserves</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">int256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_lpStakingYax</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_yaxReserves</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    .</span><span class=\"mtk11\">mul</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_stakeAmount</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    .</span><span class=\"mtk11\">div</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_supply</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    .</span><span class=\"mtk11\">add</span><span class=\"mtk1\">(</span><span class=\"mtk12\">rewardsYaxisEth</span><span class=\"mtk1\">.</span><span class=\"mtk11\">earned</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_voter</span><span class=\"mtk1\">));</span></span></span></code></pre>\n<p>The pool can be temporarily manipulated to increase the <code>_yaxReserves</code> amount.</p>\n<h4 id=\"impact-19\" style=\"position:relative;\"><a href=\"#impact-19\" aria-label=\"impact 19 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h4>\n<p>If this voting power is used for governance proposals, an attacker can increase their voting power and pass a proposal.</p>\n<h4 id=\"recommended-mitigation-steps-19\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-19\" aria-label=\"recommended mitigation steps 19 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h4>\n<p>One could build a TWAP-style contract that tracks a time-weighted-average reserve amount (instead of the price in traditional TWAPs).\nThis can then not be manipulated by flashloans.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/113#issuecomment-932350186\">uN2RVw5q commented</a>:</strong></p>\n<blockquote>\n<p>I disagree with the “sponsor disputed” tag.</p>\n<p>I think this is a valid issue and makes <code>balanceOf(_voter)</code> susceptible to flashloan attacks. However, as long as <code>balanceOf(_voter)</code> is always called by a trusted EOA during governance vote counts, this should not be a problem. I assume this is the case for governance proposals. If that is not the case, I would recommend changing the code. Otherwise, changing the risk to “documentation” would be reasonable.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/113#issuecomment-943463853\">GalloDaSballo (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Agree with original warden finding, as well as severity</p>\n<p>The ability to trigger the count at any time does prevent a flashloan attack (as flashloans are atomic)\nIt would allow the privilege of the flashloan attack to the trusted EOA (admin privilege)</p>\n<p>Additionally the voting power can still be frontrun, while you cannot manipulate that voting power via a flashloan, you can just buy and sell your position on the same block as when the count is being taken</p>\n<p>Due to this I will up the severity back to medium as this is a legitimate vector to extract value</p>\n</blockquote>\n<h2 id=\"m-11-wrong-yaxis-estimates\" style=\"position:relative;\"><a href=\"#m-11-wrong-yaxis-estimates\" aria-label=\"m 11 wrong yaxis estimates permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/112\">[M-11] wrong YAXIS estimates</a></h2>\n<p><em>Submitted by cmichel</em></p>\n<p>The <code>Harvester.getEstimates</code> contract tries to estimate a <code>YAXIS</code> amount but uses the wrong path and/or amount.</p>\n<p>It currently uses a <code>WETH</code> <strong>input</strong> amount to compute a <code>YAXIS -> WETH</code> trade.</p>\n<pre class=\"grvsc-container dark-default-dark\" data-language=\"solidity\" data-index=\"22\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">address</span><span class=\"mtk1\">[] </span><span class=\"mtk12\">memory</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_path</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">_path</span><span class=\"mtk1\">[</span><span class=\"mtk7\">0</span><span class=\"mtk1\">] = </span><span class=\"mtk11\">IStrategy</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_strategy</span><span class=\"mtk1\">).</span><span class=\"mtk11\">want</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">_path</span><span class=\"mtk1\">[</span><span class=\"mtk7\">1</span><span class=\"mtk1\">] = </span><span class=\"mtk11\">IStrategy</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_strategy</span><span class=\"mtk1\">).</span><span class=\"mtk11\">weth</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// ...</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">_path</span><span class=\"mtk1\">[</span><span class=\"mtk7\">0</span><span class=\"mtk1\">] = </span><span class=\"mtk12\">manager</span><span class=\"mtk1\">.</span><span class=\"mtk11\">yaxis</span><span class=\"mtk1\">();</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// path is YAXIS -&gt; WETH now</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// fee is a WETH precision value</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">uint256</span><span class=\"mtk1\"> </span><span class=\"mtk12\">_fee</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_estimatedWETH</span><span class=\"mtk1\">.</span><span class=\"mtk11\">mul</span><span class=\"mtk1\">(</span><span class=\"mtk12\">manager</span><span class=\"mtk1\">.</span><span class=\"mtk11\">treasuryFee</span><span class=\"mtk1\">()).</span><span class=\"mtk11\">div</span><span class=\"mtk1\">(</span><span class=\"mtk12\">ONE_HUNDRED_PERCENT</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk3\">// this will return wrong trade amounts</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">_amounts</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_router</span><span class=\"mtk1\">.</span><span class=\"mtk11\">getAmountsOut</span><span class=\"mtk1\">(</span><span class=\"mtk12\">_fee</span><span class=\"mtk1\">, </span><span class=\"mtk12\">_path</span><span class=\"mtk1\">);</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk12\">_estimatedYAXIS</span><span class=\"mtk1\"> = </span><span class=\"mtk12\">_amounts</span><span class=\"mtk1\">[</span><span class=\"mtk7\">1</span><span class=\"mtk1\">];</span></span></span></code></pre>\n<h4 id=\"impact-20\" style=\"position:relative;\"><a href=\"#impact-20\" aria-label=\"impact 20 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h4>\n<p>The estimations from <code>getEstimates</code> are wrong.\nThey seem to be used to provide min. amount slippage values <code>(_estimatedWETH, _estimatedYAXIS)</code> for the harvester when calling <code>Controller._estimatedYAXIS</code>.\nThese are then used in <code>BaseStrategy._payHarvestFees</code> and can revert the harvest transactions if the wrongly computed <code>_estimatedYAXIS</code> value is above the actual trade value.\nOr they can allow a large slippage if the <code>_estimatedYAXIS</code> value is below the actual trade value, which can then be used for a sandwich attack.</p>\n<h4 id=\"recommended-mitigation-steps-20\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-20\" aria-label=\"recommended mitigation steps 20 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h4>\n<p>Fix the estimations computations.</p>\n<p>As the estimations are used in <code>BaseStrategy._payHarvestFees</code>, the expected behavior seems to be trading <code>WETH</code> to <code>YAXIS</code>.\nThe path should therefore be changed to <code>path[0] = WETH; path[1] = YAXIS</code> in <code>Harvester.getEstimates</code>.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/112\">Haz077 (yAxis) acknowledged</a></strong></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/112#issuecomment-943475050\">GalloDaSballo (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Price estimates on Uniswap are dependent on which side of the swap you’re making</p>\n<p>Sponsor has mitigated in later PR</p>\n</blockquote>\n<h2 id=\"m-12-harvest-can-be-frontrun\" style=\"position:relative;\"><a href=\"#m-12-harvest-can-be-frontrun\" aria-label=\"m 12 harvest can be frontrun permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/140\">[M-12] Harvest can be frontrun</a></h2>\n<p><em>Submitted by 0xsanson</em></p>\n<h4 id=\"impact-21\" style=\"position:relative;\"><a href=\"#impact-21\" aria-label=\"impact 21 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h4>\n<p>In the <code>NativeStrategyCurve3Crv._harvest</code> there are two instances that a bad actor could use to frontrun the harvest.</p>\n<p>First, when we are swapping WETH to a stablecoin by calling <code>_swapTokens(weth, _stableCoin, _remainingWeth, 1)</code> the function isn’t checking the slippage, leading to the risk to a frontun (by imbalancing the Uniswap pair) and losing part of the harvesting profits.</p>\n<p>Second, during the <code>_addLiquidity</code> internal function: this calls <code>stableSwap3Pool.add_liquidity(amounts, 1)</code> not considering the slippage when minting the 3CRV tokens.</p>\n<h4 id=\"proof-of-concept-10\" style=\"position:relative;\"><a href=\"#proof-of-concept-10\" aria-label=\"proof of concept 10 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h4>\n<p><a href=\"https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/strategies/NativeStrategyCurve3Crv.sol#L108\"><code>NativeStrategyCurve3Crv.sol</code> L108</a></p>\n<h4 id=\"tools-used-5\" style=\"position:relative;\"><a href=\"#tools-used-5\" aria-label=\"tools used 5 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tools Used</h4>\n<p>editor</p>\n<h4 id=\"recommended-mitigation-steps-21\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-21\" aria-label=\"recommended mitigation steps 21 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h4>\n<p>In the function <code>_harvest(_estimatedWETH, _estimatedYAXIS)</code> consider adding two additional estimated quantities: one for the swapped-out stablecoin and one for the minted 3CRV.</p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/140\">BobbyYaxis (yAxis) acknowledged</a></strong></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/140#issuecomment-932765993\">uN2RVw5q commented</a>:</strong></p>\n<blockquote>\n<p>On second thought, I think this is a valid issue.</p>\n<blockquote>\n<p>consider adding two additional estimated quantities: one for the swapped-out stablecoin and one for the minted 3CRV.</p>\n</blockquote>\n<p>This suggestion should be considered.</p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/140#issuecomment-943477587\">GalloDaSballo (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Warden identified two paths for front-running</p>\n<p>Since these are ways to extract value, severity is Medium</p>\n</blockquote>\n<p><strong>BobbyYaxis (yAxis) noted:</strong></p>\n<blockquote>\n<p>Mitigated in PR 114: <a href=\"https://github.com/yaxis-project/metavault/pull/114\">https://github.com/yaxis-project/metavault/pull/114</a></p>\n</blockquote>\n<h2 id=\"m-13-managerallowedvaults-check-missing-for-addremove-strategy\" style=\"position:relative;\"><a href=\"#m-13-managerallowedvaults-check-missing-for-addremove-strategy\" aria-label=\"m 13 managerallowedvaults check missing for addremove strategy permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/50\">[M-13] <code>manager.allowedVaults</code> check missing for add/remove strategy</a></h2>\n<p><em>Submitted by 0xRajeev</em></p>\n<h4 id=\"impact-22\" style=\"position:relative;\"><a href=\"#impact-22\" aria-label=\"impact 22 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h4>\n<p>The <code>manager.allowedVaults</code> check is missing for add/remove strategy like how it is used in <code>reorderStrategies()</code>. This will allow a strategist to accidentally/maliciously add/remove strategies on unauthorized vaults.</p>\n<p>Given the critical access control that is missing on vaults here, this is classified as medium severity.</p>\n<h4 id=\"proof-of-concept-11\" style=\"position:relative;\"><a href=\"#proof-of-concept-11\" aria-label=\"proof of concept 11 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h4>\n<ul>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/controllers/Controller.sol#L101-L130\"><code>Controller.sol#L101</code> L130</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/controllers/Controller.sol#L172-L207\"><code>Controller.sol#L172</code> L207</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/controllers/Controller.sol#L224\"><code>Controller.sol</code> L224</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/Manager.sol#L210-L221\"><code>Manager.sol#L210</code> L221</a></li>\n</ul>\n<h4 id=\"tools-used-6\" style=\"position:relative;\"><a href=\"#tools-used-6\" aria-label=\"tools used 6 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tools Used</h4>\n<p>Manual Analysis</p>\n<h4 id=\"recommended-mitigation-steps-22\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-22\" aria-label=\"recommended mitigation steps 22 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h4>\n<p>Add <code>manager.allowedVaults</code> check in <code>addStrategy()</code> and <code>removeStrategy()</code></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/50\">GainsGoblin (yAxis) acknowledged</a></strong></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/50\">Haz077 (yAxis) confirmed</a></strong></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/50#issuecomment-933009311\">uN2RVw5q commented</a>:</strong></p>\n<blockquote>\n<p>Implemented in <a href=\"https://github.com/code-423n4/2021-09-yaxis/pull/36\">https://github.com/code-423n4/2021-09-yaxis/pull/36</a></p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/50#issuecomment-943479681\">GalloDaSballo (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Sponsor has acknowledged and mitigated by adding further access control checks</p>\n</blockquote>\n<h2 id=\"m-14-halting-the-protocol-should-be-onlygovernance-and-notonlystrategist\" style=\"position:relative;\"><a href=\"#m-14-halting-the-protocol-should-be-onlygovernance-and-notonlystrategist\" aria-label=\"m 14 halting the protocol should be onlygovernance and notonlystrategist permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/47\">[M-14] Halting the protocol should be <code>onlyGovernance</code> and not<code>onlyStrategist</code></a></h2>\n<p><em>Submitted by 0xRajeev</em></p>\n<h4 id=\"impact-23\" style=\"position:relative;\"><a href=\"#impact-23\" aria-label=\"impact 23 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Impact</h4>\n<p>A malicious strategist can halt the entire protocol and force a permanent shutdown once they observe that governance is trying to set a new strategist and they do not agree with that decision. They may use the 7 day window to halt the protocol. The access control on <code>setHalted()</code> should be <code>onlyGovernance</code>.</p>\n<h4 id=\"proof-of-concept-12\" style=\"position:relative;\"><a href=\"#proof-of-concept-12\" aria-label=\"proof of concept 12 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Proof of Concept</h4>\n<ul>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/Manager.sol#L515-L522\"><code>Manager.sol#L515</code> L522</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/Manager.sol#L333-L345\"><code>Manager.sol#L333</code> L345</a></li>\n</ul>\n<h4 id=\"tools-used-7\" style=\"position:relative;\"><a href=\"#tools-used-7\" aria-label=\"tools used 7 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tools Used</h4>\n<p>Manual Analysis</p>\n<h4 id=\"recommended-mitigation-steps-23\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-23\" aria-label=\"recommended mitigation steps 23 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h4>\n<p>Change access control to <code>onlyGovernance</code> from<code>onlyStrategist</code> for <code>setHalted()</code></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/47\">GainsGoblin (yAxis) acknowledged</a></strong></p>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/47#issuecomment-932978261\">uN2RVw5q commented</a>:</strong></p>\n<blockquote>\n<p>Implemented in <a href=\"https://github.com/code-423n4/2021-09-yaxis/pull/35\">https://github.com/code-423n4/2021-09-yaxis/pull/35</a></p>\n</blockquote>\n<p><strong><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/47#issuecomment-943481373\">GalloDaSballo (judge) commented</a>:</strong></p>\n<blockquote>\n<p>Agree that such critical functionality should be limited to the highest permission access role.\nSponsor has mitigated</p>\n</blockquote>\n<h1 id=\"low-risk-findings-25\" style=\"position:relative;\"><a href=\"#low-risk-findings-25\" aria-label=\"low risk findings 25 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Low Risk Findings (25)</h1>\n<ul>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/62\">[L-01] Missing support/documentation for use of deflationary tokens in protocol</a>\n<em>Submitted by 0xRajeev, also found by itsmeSTYJ</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/139\">[L-02] <code>getMostPremium()</code> can be wrong</a>\n<em>Submitted by 0xsanson</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/156\">[L-03] getMostPremium() does not necessarily return the best asset to trade for.</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/153\">[L-04] Be aware that transactions can be frontrun to exactly the estimated amount.</a></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/35\">[L-05] Missing zero-address checks</a>\n<em>Submitted by 0xRajeev</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/82\">[L-06] Decimals of upgradeable tokens may change</a>\n<em>Submitted by pauliax</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/38\">[L-07] Missing sanity/threshold check on totalDepositCap may cause DoS</a>\n<em>Submitted by 0xRajeev</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/57\">[L-08] No use of notHalted in LegacyController functions</a>\n<em>Submitted by 0xRajeev</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/60\">[L-09] onlyEnabledConverter modifier is not used in all functions</a>\n<em>Submitted by 0xRajeev</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/63\">[L-10] safeApprove may revert for non-zero to non-zero approvals</a>\n<em>Submitted by 0xRajeev, also found by 0xsanson</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/64\">[L-11] Max approvals are risky if contract is malicious/compromised</a>\n<em>Submitted by 0xRajeev</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/134\">[L-12] <code>cap</code> isn’t enforced</a>\n<em>Submitted by 0xsanson</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/135\">[L-13] Unclear <code>totalDepositCap</code></a>\n<em>Submitted by 0xsanson</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/144\">[L-14] Missing check in <code>reorderStrategies</code></a>\n<em>Submitted by 0xsanson</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/145\">[L-15] <code>maxStrategies</code> can be lower than existing strategies</a>\n<em>Submitted by 0xsanson</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/10\">[L-16] Harvesting and Funding Is Not Checked When the Contract Is Halted</a>\n<em>Submitted by defsec, also found by 0xsanson</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/111\">[L-17] Unbounded iterations over strategies or tokens</a>\n<em>Submitted by cmichel</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/122\">[L-18] Withdraw event uses wrong parameter</a>\n<em>Submitted by cmichel</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/75\">[L-19] Vault: Zero Withdrawal Fee If Protocol Halts</a>\n<em>Submitted by hickuphh3</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/104\">[L-20] The <code>sqrt</code> function can overflow execute invalid operation</a>\n<em>Submitted by hrkrshnn</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/23\">[L-21] missing safety check in addStrategy</a>\n<em>Submitted by jonah1005</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/25\">[L-22] vault cap’s at totalSupply would behave unexpectedly</a>\n<em>Submitted by jonah1005, also found by pauliax</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/69\">[L-23] Removed tokens can’t be withdrawn from vault</a>\n<em>Submitted by hickuphh3</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/133\">[L-24] No slippage checks can lead to sandwich attacks</a>\n<em>Submitted by cmichel</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/26\">[L-25] hijack the vault by pumping vault price.</a>\n<em>Submitted by jonah1005</em></li>\n</ul>\n<h1 id=\"non-critical-findings-11\" style=\"position:relative;\"><a href=\"#non-critical-findings-11\" aria-label=\"non critical findings 11 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Non-Critical Findings (11)</h1>\n<ul>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/55\">[N-01] Change public visibility to external</a>\n<em>Submitted by 0xRajeev</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/89\">[N-02] Unused imports</a>\n<em>Submitted by pauliax</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/93\">[N-03] Style issues</a>\n<em>Submitted by pauliax</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/81\">[N-04] setMinter should check that _minter is not empty</a>\n<em>Submitted by pauliax</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/42\">[N-05] Tokens with > 18 decimals will break logic</a>\n<em>Submitted by 0xRajeev, also found by hrkrshnn, and pauliax</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/49\">[N-06] Unused event may be unused code or indicative of missed emit/logic</a>\n<em>Submitted by 0xRajeev, also found by cmichel</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/107\">[N-07] Missing parameter validation</a>\n<em>Submitted by cmichel</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/17\">[N-08] shadowing of strategies</a>\n<em>Submitted by gpersoon</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/100\">[N-09] VaultHelper contract should never have tokens at the end of a transaction</a>\n<em>Submitted by hrkrshnn</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/99\">[N-10] Safety of the Vyper compiler</a>\n<em>Submitted by hrkrshnn</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/44\">[N-11] Single-step change of governance address is extremely risky</a>\n<em>Submitted by 0xRajeev</em></li>\n</ul>\n<h1 id=\"gas-optimizations-27\" style=\"position:relative;\"><a href=\"#gas-optimizations-27\" aria-label=\"gas optimizations 27 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Gas Optimizations (27)</h1>\n<ul>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/30\">[G-01] Checking for zero amounts can save gas by preventing expensive external calls</a>\n<em>Submitted by 0xRajeev</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/20\">[G-02] extra array length check in depositMultipleVault </a>\n<em>Submitted by gpersoon, also found by 0xRajeev</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/43\">[G-03] Rearranging declaration of state variables will save storage slots because of packing</a>\n<em>Submitted by 0xRajeev</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/46\">[G-04] Removal of last token in the array can be optimized</a>\n<em>Submitted by 0xRajeev, also found by hickuphh3</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/143\">[G-05] <code>tokens[i]</code> can be memorized</a>\n<em>Submitted by 0xsanson, also found by pauliax</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/58\">[G-06] Removing unused parameter and modifier can save gas</a>\n<em>Submitted by 0xRajeev</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/138\">[G-07] Earn process emits two events that can be arranged into one</a>\n<em>Submitted by 0xsanson</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/141\">[G-08] Unnecessary <code>balanceOfWant() > 0</code></a>\n<em>Submitted by 0xsanson</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/146\">[G-09] <code>harvestNextStrategy</code> can be optimized</a>\n<em>Submitted by 0xsanson</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/116\">[G-10] Gas: <code>removeToken</code> iteration over all tokens can be avoided</a>\n<em>Submitted by cmichel, also found by itsmeSTYJ</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/117\">[G-11] Gas: <code>removeStrategy</code> iteration over all strategies can be avoided</a>\n<em>Submitted by cmichel, also found by itsmeSTYJ</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/118\">[G-12] Gas: Unnecessary addition in <code>Vault.deposit</code></a>\n<em>Submitted by cmichel, also found by jonah1005, hickuphh3, and pauliax</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/70\">[G-13] Vault: Redundant notHalted modifier in depositMultiple()</a>\n<em>Submitted by hickuphh3, also found by cmichel, hrkrshnn, and pauliax</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/123\">[G-14] Gas: Loop in <code>StablesConverter.convert</code> can be avoided</a>\n<em>Submitted by cmichel</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/124\">[G-15] Gas: Loop in <code>StablesConverter.expected</code> can be avoided</a>\n<em>Submitted by cmichel</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/125\">[G-16] Gas: Timestamp in router swap can be hardcoded</a>\n<em>Submitted by cmichel</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/18\">[G-17] Save a step in withdraw of Vault.sol</a>\n<em>Submitted by gpersoon</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/65\">[G-18] Controller: Extra sload of <em>vaultDetails[</em>vault].balance</a>\n<em>Submitted by hickuphh3</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/66\">[G-19] Harvester: Simpler implementation for canHarvest()</a>\n<em>Submitted by hickuphh3</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/94\">[G-20] Consider making some constants as non-public to save gas</a>\n<em>Submitted by hrkrshnn</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/95\">[G-21] Caching the length in for loops</a>\n<em>Submitted by hrkrshnn</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/98\">[G-22] Upgrade to at least 0.8.4</a>\n<em>Submitted by hrkrshnn, also found by 0xRajeev</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/86\">[G-23] uint8 is less efficient than uint256 in loop iterations</a>\n<em>Submitted by pauliax, also found by hrkrshnn</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/87\">[G-24] Dead code</a>\n<em>Submitted by pauliax</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/91\">[G-25] Join _checkToken function and modifier together</a>\n<em>Submitted by pauliax</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/101\">[G-26] The function <code>removeToken</code> can get prohibitively expensive</a>\n<em>Submitted by hrkrshnn</em></li>\n<li><a href=\"https://github.com/code-423n4/2021-09-yaxis-findings/issues/85\">[G-27] VaultHelper could validate that amount is greater than 0</a>\n<em>Submitted by pauliax</em></li>\n</ul>\n<h1 id=\"disclosures\" style=\"position:relative;\"><a href=\"#disclosures\" aria-label=\"disclosures permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Disclosures</h1>\n<p>C4 is an open organization governed by participants in the community.</p>\n<p>C4 Contests incentivize the discovery of exploits, vulnerabilities, and bugs in smart contracts. Security researchers are rewarded at an increasing rate for finding higher-risk issues. Contest submissions are judged by a knowledgeable security researcher and solidity developer and disclosed to sponsoring developers. C4 does not conduct formal verification regarding the provided code but instead provides final verification.</p>\n<p>C4 does not provide any guarantee or warranty regarding the security of this project. All smart contract software should be used at the sole risk and responsibility of users.</p>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n  .dark-default-dark {\n    background-color: #1E1E1E;\n    color: #D4D4D4;\n  }\n  .dark-default-dark .mtk3 { color: #6A9955; }\n  .dark-default-dark .mtk12 { color: #9CDCFE; }\n  .dark-default-dark .mtk1 { color: #D4D4D4; }\n  .dark-default-dark .mtk11 { color: #DCDCAA; }\n  .dark-default-dark .mtk7 { color: #B5CEA8; }\n  .dark-default-dark .mtk15 { color: #C586C0; }\n  .dark-default-dark .mtk8 { color: #CE9178; }\n  .dark-default-dark .mtk4 { color: #569CD6; }\n  .dark-default-dark .grvsc-line-highlighted::before {\n    background-color: var(--grvsc-line-highlighted-background-color, rgba(255, 255, 255, 0.1));\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(255, 255, 255, 0.5));\n  }\n</style>",
  "toc": "<ul>\n<li>\n<p><a href=\"#overview\">Overview</a></p>\n<ul>\n<li><a href=\"#about-c4\">About C4</a></li>\n<li><a href=\"#wardens\">Wardens</a></li>\n</ul>\n</li>\n<li><a href=\"#summary\">Summary</a></li>\n<li><a href=\"#scope\">Scope</a></li>\n<li><a href=\"#severity-criteria\">Severity Criteria</a></li>\n<li>\n<p><a href=\"#high-risk-findings-10\">High Risk Findings (10)</a></p>\n<ul>\n<li><a href=\"#h-01-controllersetcap-sets-wrong-vault-balance\">[H-01] <code>Controller.setCap</code> sets wrong vault balance</a></li>\n<li><a href=\"#h-02--set-cap-breaks-vaults-balance\">[H-02]  set cap breaks vault’s Balance</a></li>\n<li><a href=\"#h-03-no-safety-check-in-addtoken\">[H-03] No safety check in <code>addToken</code></a></li>\n<li><a href=\"#h-04-controller-does-not-raise-an-error-when-theres-insufficient-liquidity\">[H-04] Controller does not raise an error when there’s insufficient liquidity</a></li>\n<li><a href=\"#h-05-vault-treats-all-tokens-exactly-the-same-that-creates-huge-arbitrage-opportunities\">[H-05] Vault treats all tokens exactly the same that creates (huge) arbitrage opportunities.</a></li>\n<li><a href=\"#h-06-earn-results-in-decreasing-share-price\">[H-06] earn results in decreasing share price</a></li>\n<li><a href=\"#h-07-vaultbalance-mixes-normalized-and-standard-amounts\">[H-07] <code>Vault.balance()</code> mixes normalized and standard amounts</a></li>\n<li><a href=\"#h-08-vaultwithdraw-mixes-normalized-and-standard-amounts\">[H-08] <code>Vault.withdraw</code> mixes normalized and standard amounts</a></li>\n<li><a href=\"#h-09-removetoken-would-break-the-vaultprotocol\">[H-09] <code>removeToken</code> would break the vault/protocol.</a></li>\n<li><a href=\"#h-10-an-attacker-can-steal-funds-from-multi-token-vaults\">[H-10] An attacker can steal funds from multi-token vaults</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#medium-risk-findings-15\">Medium Risk Findings (15)</a></p>\n<ul>\n<li><a href=\"#m-01-vaulthelper-deposits-dont-work-with-fee-on-transfer-tokens\">[M-01] <code>VaultHelper</code> deposits don’t work with fee-on transfer tokens</a></li>\n<li><a href=\"#m-02-erc20-return-values-not-checked\">[M-02] ERC20 return values not checked</a></li>\n<li><a href=\"#m-03-vaultwithdraw-sometimes-burns-too-many-shares\">[M-03] <code>Vault.withdraw</code> sometimes burns too many shares</a></li>\n<li><a href=\"#m-04-adding-asymmetric-liquidity-in-_addliquidity-results-in-fewer-lp-tokens-minted-than-what-should-be-wanted\">[M-04] Adding asymmetric liquidity in <code>_addLiquidity</code> results in fewer LP tokens minted than what should be wanted</a></li>\n<li><a href=\"#m-05-vault-swaps-at-parity-with-swap-fee--withdrawal-fee\">[M-05] Vault: Swaps at parity with swap fee = withdrawal fee</a></li>\n<li><a href=\"#m-06---controller-is-vulnerable-to-sandwich-attack\">[M-06]  # Controller is vulnerable to sandwich attack</a></li>\n<li><a href=\"#m-07-vault-withdrawals-can-be-frontrun-to-cause-users-to-burn-tokens-without-receiving-funds-in-return\">[M-07] Vault: Withdrawals can be frontrun to cause users to burn tokens without receiving funds in return</a></li>\n<li><a href=\"#m-08-controllerincasestrategygetstuck-does-not-update-balance\">[M-08] <code>Controller.inCaseStrategyGetStuck</code> does not update balance</a></li>\n<li><a href=\"#m-09-token---vault-mapping-can-be-overwritten\">[M-09] token -> vault mapping can be overwritten</a></li>\n<li><a href=\"#m-10-yaxisvotepowerbalanceof-can-be-manipulated\">[M-10] <code>YAxisVotePower.balanceOf</code> can be manipulated</a></li>\n<li><a href=\"#m-11-wrong-yaxis-estimates\">[M-11] wrong YAXIS estimates</a></li>\n<li><a href=\"#m-12-harvest-can-be-frontrun\">[M-12] Harvest can be frontrun</a></li>\n<li><a href=\"#m-13-managerallowedvaults-check-missing-for-addremove-strategy\">[M-13] <code>manager.allowedVaults</code> check missing for add/remove strategy</a></li>\n<li><a href=\"#m-14-halting-the-protocol-should-be-onlygovernance-and-notonlystrategist\">[M-14] Halting the protocol should be <code>onlyGovernance</code> and not<code>onlyStrategist</code></a></li>\n</ul>\n</li>\n<li><a href=\"#low-risk-findings-25\">Low Risk Findings (25)</a></li>\n<li><a href=\"#non-critical-findings-11\">Non-Critical Findings (11)</a></li>\n<li><a href=\"#gas-optimizations-27\">Gas Optimizations (27)</a></li>\n<li><a href=\"#disclosures\">Disclosures</a></li>\n</ul>",
  "md": "\n# Overview\n\n## About C4\n\nCode 432n4 (C4) is an open organization consisting of security researchers, auditors, developers, and individuals with domain expertise in smart contracts.\n\nA C4 code contest is an event in which community participants, referred to as Wardens, review, audit, or analyze smart contract logic in exchange for a bounty provided by sponsoring projects.\n\nDuring the code contest outlined in this document, C4 conducted an analysis of the yAxis smart contract system written in Solidity. The code contest took place between September 9—September 15 2021.\n\n## Wardens\n\n13 Wardens contributed reports to the yAxis code contest:\n\n1.  [cmichel](https://twitter.com/cmichelio)\n2.  [jonah1005](https://twitter.com/jonah1005w)\n3.  [0xRajeev](https://twitter.com/0xRajeev)\n4.  [0xsanson](https://github.com/0xsanson)\n5.  [hickuphh3](https://twitter.com/HickupH)\n6.  WatchPug\n    - [jtp](https://github.com/jack-the-pug)\n    - [ming](https://github.com/mingwatch)\n7.  [hrkrshnn](https://twitter.com/_hrkrshnn)\n8.   [itsmeSTYJ](https://twitter.com/itsmeSTYJ)\n9.    [pauliax](https://twitter.com/SolidityDev)\n10.   [defsec](https://twitter.com/defsec_)\n11.   [gpersoon](https://twitter.com/gpersoon)\n12.   [verifyfirst](https://github.com/verifyfirst)\n\nThis contest was judged by [AlexTheEntreprenerd](https://twitter.com/GalloDaSballo).\n\nC4 Warden [gpersoon](https://twitter.com/gpersoon) also contributed to mitigating issues after the contest closed, hence their handle appears in this report as a contributor to the yAxis repo, as well as alongside their vulnerability reports.\n\nFinal report assembled by [moneylegobatman](https://twitter.com/money_lego) and [CloudEllie](https://twitter.com/CloudEllie1).\n\n# Summary\n\nThe C4 analysis yielded an aggregated total of 50 unique vulnerabilities and 88 total findings.  All of the issues presented here are linked back to their original submissions.\n\nOf these vulnerabilities, 10 received a risk rating in the category of HIGH severity, 15 received a risk rating in the category of MEDIUM severity, and 25 received a risk rating in the category of LOW severity.\n\nC4 analysis also identified 11 non-critical recommendations and 27 gas optimizations.\n\n# Scope\n\nThe code under review can be found within the [C4 yAxis code contest repository](https://github.com/code-423n4/2021-09-yaxis) and is composed of 90 smart contracts written in the Solidity programming language and includes 4,933 lines of Solidity code.\n\n# Severity Criteria\n\nC4 assesses the severity of disclosed vulnerabilities according to a methodology based on [OWASP standards](https://owasp.org/www-community/OWASP_Risk_Rating_Methodology).\n\nVulnerabilities are divided into three primary risk categories: high, medium, and low.\n\nHigh-level considerations for vulnerabilities span the following key areas when conducting assessments:\n\n- Malicious Input Handling\n- Escalation of privileges\n- Arithmetic\n- Gas use\n\nFurther information regarding the severity criteria referenced throughout the submission review process, please refer to the documentation provided on [the C4 website](https://code423n4.com).\n\n# High Risk Findings (10)\n\n## [[H-01] `Controller.setCap` sets wrong vault balance](https://github.com/code-423n4/2021-09-yaxis-findings/issues/128)\n_Submitted by cmichel_\n\nThe `Controller.setCap` function sets a cap for a strategy and withdraws any excess amounts (`_diff`).\nThe vault balance is decreased by the entire strategy balance instead of by this `_diff`:\n\n```solidity\n// @audit why not sub _diff?\n_vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_balance);\n```\n\n#### Impact\nThe `_vaultDetails[_vault].balance` variable does not correctly track the actual vault balances anymore, it will usually **underestimate** the vault balance.\nThis variable is used in `Controller.balanceOf()`, which in turn is used in `Vault.balance()`, which in turn is used to determine how many shares to mint / amount to receive when redeeming shares.\nIf the value is less, users will lose money as they can redeem fewer tokens.\nAlso, an attacker can `deposit` and will receive more shares than they should receive. They can then wait until the balance is correctly updated again and withdraw their shares for a higher amount than they deposited. This leads to the vault losing tokens.\n\n#### Recommended Mitigation Steps\nSub the `_diff` instead of the `balance`: `_vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_diff);`\n\n**[Haz077 (yAxis) confirmed and patched](https://github.com/code-423n4/2021-09-yaxis-findings/issues/128#issuecomment-931659339):**\n > Already fixed in code-423n4/2021-09-yaxis#1\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-09-yaxis-findings/issues/128#issuecomment-943538237):**\n > Finding is valid, has been mitigated by sponsor as of 14 days ago\n\n## [[H-02]  set cap breaks vault's Balance](https://github.com/code-423n4/2021-09-yaxis-findings/issues/1)\n_Submitted by jonah1005, also found by 0xsanson_\n\n#### Impact\nIn controller.sol's function `setCap`, the contract wrongly handles `_vaultDetails[_vault].balance`. While the balance should be decreased by the difference of strategies balance, it subtracts the remaining balance of the strategy. See [Controller.sol L262-L278](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L262-L278).\n`_vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_balance);`\n\nThis would result in `vaultDetails[_vault].balance` being far smaller than the strategy's value. A user would trigger the assertion at [Controller.sol#475](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L475) and the fund would be locked in the strategy.\n\nThough `setCap` is a permission function that only the operator can call, it's likely to be called and the fund would be locked in the contract. I consider this a high severity issue.\n\n#### Proof of Concept\nWe can trigger the issue by setting the cap 1 wei smaller than the strategy's balance.\n\n```python\nstrategy_balance = strategy.functions.balanceOf().call()\ncontroller.functions.setCap(vault.address, strategy.address, strategy_balance - 1, dai.address).transact()\n\n## this would be reverted\nvault.functions.withdrawAll(dai.address).transact()\n```\n\n#### Tools Used\nHardhat\n\n#### Recommended Mitigation Steps\nI believe the dev would spot the issue in the test if `_vaultDetails[_vault].balance` is a public variable.\n\nOne possible fix is to subtract the difference of the balance.\n\n```solidity\nuint previousBalance = IStrategy(_strategy).balanceOf();\n_vaultDetails[_vault].balance.sub(previousBalance.sub(_amount));\n```\n\n**[transferAndCall (yAxis) confirmed and patched](https://github.com/code-423n4/2021-09-yaxis-findings/issues/1#issuecomment-917659418):**\n > Please review https://github.com/code-423n4/2021-09-yaxis/pull/1 to verify resolution.\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-09-yaxis-findings/issues/1#issuecomment-941742896):**\n > High risk vulnerability due to incorrect logic which can impact protocol functionality\n>\n> Sponsor has mitigated\n\n## [[H-03] No safety check in `addToken`](https://github.com/code-423n4/2021-09-yaxis-findings/issues/3)\n_Submitted by jonah1005, also found by hrkrshnn and 0xRajeev_\n\n#### Impact\nThere's no safety check in `Manager.sol` `addToken`. There are two possible cases that might happen.\n\n1.  One token being added twice in a Vault. Token would be counted doubly in the vault. Ref: [Vault.sol#L293-L303](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Vault.sol#L293-L303). There would be two item in the array when querying `manager.getTokens(address(this));`.\n\n2.  A token first being added to two vaults. The value calculation of the first vault would be broken. As `vaults[_token] = _vault;` would point to the other vault.\n\nPermission keys should always be treated cautiously. However, calling the same initialize function twice should not be able to destroy the vault. Also, as the protocol develops, there's likely that one token is supported in two vaults. The DAO may mistakenly add the same token twice. I consider this a high-risk issue.\n\n#### Proof of Concept\nAdding same token twice would not raise any error here.\n```solidity\n    manager.functions.addToken(vault.address, dai.address).transact()\n    manager.functions.addToken(vault.address, dai.address).transact()\n```\n#### Tools Used\nHardhat\n\n#### Recommended Mitigation Steps\nI recommend to add two checks\n\n```solidity\nrequire(vaults[_token] == address(0));\nbool notFound = True;\nfor(uint256 i; i < tokens[_vault].length; i++) {\n    if (tokens[_vault] == _token) {\n        notFound = False;\n    }\n}\nrequire(notFound, \"duplicate token\");\n```\n\n**[transferAndCall (yAxis) confirmed and patched](https://github.com/code-423n4/2021-09-yaxis-findings/issues/3#issuecomment-917665371):**\n > Please review https://github.com/code-423n4/2021-09-yaxis/pull/2 to verify resolution.\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-09-yaxis-findings/issues/3#issuecomment-942792919):**\n > Lack of check for duplicates can cause undefined behaviour, sponsor mitigated by adding a require check\n\n## [[H-04] Controller does not raise an error when there's insufficient liquidity](https://github.com/code-423n4/2021-09-yaxis-findings/issues/28)\n_Submitted by jonah1005, also found by 0xRajeev and WatchPug_\n\n#### Impact\nWhen a user tries to withdraw the token from the vault, the vault would withdraw the token from the controller if there's insufficient liquidity in the vault. However, the controller does not raise an error when there's insufficient liquidity in the controller/ strategies. The user would lose his shares while getting nothing.\n\nAn MEV searcher could apply this attack on any withdrawal. When an attacker found an unconfirmed tx that tries to withdraw 1M dai, he can do such sandwich attack.\n\n1.  Deposits USDC into the vault.\n2.  Withdraw all dai left in the vault/controller/strategy.\n3.  Place the vitims tx here. The victim would get zero dai while burning 1 M share. **This would pump the share price.**\n4.  Withdraw all liquidity.\n\nAll users would be vulnerable to MEV attackers. I consider this is a high-risk issue.\n\n#### Proof of Concept\nHere's web3.py script to reproduce the issue.\n\n```python\ndeposit_amount = 100000 * 10**18\nuser = w3.eth.accounts[0]\nget_token(dai, user, deposit_amount)\ndai.functions.approve(vault.address, deposit_amount + margin_deposit).transact()\nvault.functions.deposit(dai.address, deposit_amount).transact()\nvault.functions.withdrawAll(usdt.address).transact()\n\n#\nprint(\"usdt amount: \", usdt.functions.balanceOf(user).call())\n```\n\n#### Recommended Mitigation Steps\nThere are two issues involved.\nFirst, users pay the slippage when they try to withdraw. I do not find this fair. Users have to pay extra gas to withdraw liquidity from strategy, convert the token, and still paying the slippage. I recommend writing a view function for the frontend to display how much slippage the user has to pay ([Controler.sol L448-L479](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L448-L479)).\n\nSecond, the controller does not revert the transaction there's insufficient liquidity ([Controller.sol#L577-L622](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L577-L622)).\n\nRecommend to revert the transaction when `_amount` is not equal to zero after the loop finishes.\n\n**[GainsGoblin (yAxis) acknowledged](https://github.com/code-423n4/2021-09-yaxis-findings/issues/28)**\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-09-yaxis-findings/issues/28#issuecomment-943384332):**\n > Agree with warden finding, this shows the path for an attack that is based on the Vault treating all tokens equally\n> Since the finding shows a specific attack, the finding is unique\n>\n> Recommend the sponsor mitigates Single Sided Exposure risks to avoid this attack\n\n**BobbyYaxis (yAxis) noted:**\n> We have mitigated by deploying vaults that only accept the Curve LP token itself used in the strategy. There is no longer an array of tokens accepted. E.g Instead of a wBTC vault, we have a renCrv vault. Or instead of 3CRV vault, we have a mimCrv vault. The strategy want token = the vault token.\n\n\n## [[H-05] Vault treats all tokens exactly the same that creates (huge) arbitrage opportunities.](https://github.com/code-423n4/2021-09-yaxis-findings/issues/2)\n_Submitted by jonah1005, also found by cmichel and itsmeSTYJ_\n\n#### Impact\nThe v3 vault treats all valid tokens exactly the same. Depositing 1M DAI would get the same share as depositing 1M USDT. User can withdraw their share in another token. Though there's `withdrawalProtectionFee` (0.1 percent), the vault is still a no slippage stable coin exchange.\n\nAlso, I notice that 3crv_token is added to the vault in the test. Treating 3crv_token and all other stable coins the same would make the vault vulnerable to flashloan attack. 3crv_token is an lp token and at the point of writing, the price of it is 1.01. The arbitrage space is about 0.8 percent and makes the vault vulnerable to flashloan attacks.\n\nThough the team may not add crv_token and dai to the same vault, its design makes the vault vulnerable. Strategies need to be designed with super caution or the vault would be vulnerable to attackers.\n\nGiven the possibility of a flashloan attack, I consider this a high-risk issue.\n\n#### Proof of Concept\nThe issue locates at the deposit function ([Vault.sol#L147-L180](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Vault.sol#L147-L180)).\nThe share is minted according to the calculation here\n\n```solidity\n_shares = _shares.add(_amount);\n```\n\nThe share is burned at [Vault.sol L217](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Vault.sol#L217)\n```solidity\nuint256 _amount = (balance().mul(_shares)).div(totalSupply());\n```\n\nHere's a sample exploit in web3.py.\n\n```python\ndeposit_amount = 100000 * 10**6\nuser = w3.eth.accounts[0]\nget_token(usdt, user, deposit_amount)\nusdt.functions.approve(vault.address, deposit_amount).transact()\nvault.functions.deposit(usdt.address, deposit_amount).transact()\nvault.functions.withdrawAll(t3crv.address).transact()\n# user can remove liquiditiy and get the profit.\n```\n\n#### Tools Used\nHardhat\n\n#### Recommended Mitigation Steps\nGiven the protocols' scenario, I feel like we can take iearn token's architect as a Ref. [yDdai](https://etherscan.io/address/0x16de59092dAE5CcF4A1E6439D611fd0653f0Bd01#code)\n\nyDai handles multiple tokens (cDai/ aDai/ dydx/ fulcrum). Though four tokens are pretty much the same, the contract still needs to calculate the price of each token.\n\nOr, creating a vault for each token might be an easier quick fix.\n\n**[Haz077 (yAxis) acknowledged](https://github.com/code-423n4/2021-09-yaxis-findings/issues/2)**\n\n**[transferAndCall (yAxis) commented](https://github.com/code-423n4/2021-09-yaxis-findings/issues/2#issuecomment-917660280):**\n > The design of the v3 vaults is to intentionally assume that all allowed tokens are of equal value. I do not see us enabling the 3CRV token in our Vault test, though if we did, that doesn't mean we would in reality. Using a separate vault per token is an architecture we want to avoid.\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-09-yaxis-findings/issues/2#issuecomment-942441532):**\n > Anecdotal example from warden makes sense.\n>\n> Assuming that 3CRV is worth the same as a stablecoin is in principle very similar to assuming that a swap between each stable on curve will yield a balanced trade\n>\n> This reminds me of the Single Sided Exposure Exploit that Yearn Suffered, and would recommend mitigating by checking the virtual_price on the 3CRV token\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-09-yaxis-findings/issues/2#issuecomment-942441854):**\n > TODO: Review and check duplicates, need to read yaxis vault code and use cases before can judge this\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-09-yaxis-findings/issues/2#issuecomment-943418352):**\n > After reviewing the code and the submissions, I have to agree that the vault creates arbitrage opportunities, since it heavily relies on 3CRV you may want to use it's `virtual_price` as a way to mitigate potential exploits, alternatively you can roll your own pricing oracle solution\n>\n> Not mitigating this opportunity means that an attacker will exploit it at the detriment of the depositors\n\n**BobbyYaxis (yAxis) noted:**\n> We have mitigated by deploying vaults that only accept the Curve LP token itself used in the strategy. There is no longer an array of tokens accepted. E.g Instead of a wBTC vault, we have a renCrv vault. Or instead of 3CRV vault, we have a mimCrv vault. The strategy want token = the vault token.\n\n## [[H-06] earn results in decreasing share price](https://github.com/code-423n4/2021-09-yaxis-findings/issues/9)\n_Submitted by jonah1005_\n\n#### Impact\nFor a dai vault that pairs with `NativeStrategyCurve3Crv`, every time `earn()` is called, shareholders would lose money. (about 2%)\n\nThere are two issues involved. The `Vault` contract and the `controller` contract doesn't handle the price difference between the want token and other tokens.\n\nAt [Vault.sol L293](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Vault.sol#L293-L303), when a vault calculates its value, it sums up all tokens balance. However, when the controller calculates vaults' value (at [Controller.sol L410-L436](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L410-L436)), it only adds the amount of `strategy.want` it received. (in this case, it's t3crv).\n\nUnder the current design, users who deposit dai to the vault would not get yield. Instead, they would keep losing money. I consider this a high-risk issue\n\n#### Proof of Concept\nI trigger the bug with the following web3.py script:\n\n```python\nprevious_price = vault.functions.getPricePerFullShare().call()\nvault.functions.available(dai.address).call()\nvault.functions.earn(dai.address, strategy.address).transact()\ncurrent_price = vault.functions.getPricePerFullShare().call()\nprint(previous_price)\nprint(current_price)\n```\n\n#### Tools Used\nHardhat\n\n#### Recommended Mitigation Steps\n\nThe protocol should decide what the balance sheet in each contract stands for and make it consistent in all cases. Take, for example, if `_vaultDetails[_vault].balance;` stands for the amount of 'want' token the vault owns, there shouldn't exist two different want in all the strategies the vault has. Also, when the vault queries controllers `function balanceOf()`, they should always multiply it by the price.\n\n**[transferAndCall (yAxis) acknowledged](https://github.com/code-423n4/2021-09-yaxis-findings/issues/9)**\n\n**[gpersoon commented](https://github.com/code-423n4/2021-09-yaxis-findings/issues/9#issuecomment-931250424):**\n > I think this is also related to the underlying problem that all coins are assumed to have the same value.\n> See also #2, #8 and #158\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-09-yaxis-findings/issues/9#issuecomment-943490025):**\n > Agree with wardens finding and acknowledge it's similitude with other issues\n>\n> Personally this is a different vulnerability that can be solved by solving the same underlying problem\n>\n> Marking this as unique finding as it's a specific exploit the protocol could face\n\n**BobbyYaxis (yAxis) noted:**\n> We have mitigated by deploying vaults that only accept the Curve LP token itself used in the strategy. There is no longer an array of tokens accepted. E.g Instead of a wBTC vault, we have a renCrv vault. Or instead of 3CRV vault, we have a mimCrv vault. The strategy want token = the vault token.\n\n## [[H-07] `Vault.balance()` mixes normalized and standard amounts](https://github.com/code-423n4/2021-09-yaxis-findings/issues/132)\n_Submitted by cmichel_\n\nThe `Vault.balance` function uses the `balanceOfThis` function which scales (\"normalizes\") all balances to 18 decimals.\n```solidity\nfor (uint8 i; i < _tokens.length; i++) {\n    address _token = _tokens[i];\n    // everything is padded to 18 decimals\n    _balance = _balance.add(_normalizeDecimals(_token, IERC20(_token).balanceOf(address(this))));\n}\n```\nNote that `balance()`'s second term `IController(manager.controllers(address(this))).balanceOf()` is not normalized.\nThe code is adding a non-normalized amount (for example 6 decimals only for USDC) to a normalized (18 decimals).\n\n#### Impact\nThe result is that the `balance()` will be under-reported.\nThis leads to receiving wrong shares when `deposit`ing tokens, and a wrong amount when redeeming `tokens`.\n\n#### Recommended Mitigation Steps\nThe second term `IController(manager.controllers(address(this))).balanceOf()` must also be normalized before adding it.\n`IController(manager.controllers(address(this))).balanceOf()` uses `_vaultDetails[msg.sender].balance` which directly uses the raw token amounts which are not normalized.\n\n**[GainsGoblin (yAxis) acknowledged](https://github.com/code-423n4/2021-09-yaxis-findings/issues/132)**\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-09-yaxis-findings/issues/132#issuecomment-943499944):**\n > `balance` and `balanceOfThis` mixes the usage of decimals by alternatingly using `_normalizeDecimals`\n> This can break accounting as well as create opportunities for abuse\n> A consistent usage of `_normalizeDecimals` would mitigate\n\n**BobbyYaxis (yAxis) noted:**\n> Mitigated in PR 114: https://github.com/yaxis-project/metavault/pull/114/commits/b3c0405640719aa7d43560f4b4b910b7ba88170b\n\n## [[H-08] `Vault.withdraw` mixes normalized and standard amounts](https://github.com/code-423n4/2021-09-yaxis-findings/issues/131)\n_Submitted by cmichel, also found by hickuphh3 and jonah1005_\n\nThe `Vault.balance` function uses the `balanceOfThis` function which scales (\"normalizes\") all balances to 18 decimals.\n```solidity\nfor (uint8 i; i < _tokens.length; i++) {\n    address _token = _tokens[i];\n    // everything is padded to 18 decimals\n    _balance = _balance.add(_normalizeDecimals(_token, IERC20(_token).balanceOf(address(this))));\n}\n```\nNote that `balance()`'s second term `IController(manager.controllers(address(this))).balanceOf()` is not normalized, but it must be.\n\nThis leads to many issues through the contracts that use `balance` but don't treat these values as normalized values.\nFor example, in `Vault.withdraw`, the computed `_amount` value is normalized (in 18 decimals).\nBut the `uint256 _balance = IERC20(_output).balanceOf(address(this));` value is not normalized but compared to the normalized `_amount` and even subtracted:\n\n```solidity\n// @audit compares unnormalzied output to normalized output\nif (_balance < _amount) {\n    IController _controller = IController(manager.controllers(address(this)));\n    // @audit cannot directly subtract unnormalized\n    uint256 _toWithdraw = _amount.sub(_balance);\n    if (_controller.strategies() > 0) {\n        _controller.withdraw(_output, _toWithdraw);\n    }\n    uint256 _after = IERC20(_output).balanceOf(address(this));\n    uint256 _diff = _after.sub(_balance);\n    if (_diff < _toWithdraw) {\n        _amount = _balance.add(_diff);\n    }\n}\n```\n\n#### Impact\nImagine in `withdraw`, the `output` is USDC with 6 decimals, then the normalized `_toWithdraw` with 18 decimals (due to using `_amount`) will be a huge number and attempt to withdraw an inflated amount.\nAn attacker can steal tokens this way by withdrawing a tiny amount of shares and receive an inflated USDC or USDT amount (or any `_output` token with less than 18 decimals).\n\n#### Recommended Mitigation Steps\nWhenever using anything involving `vault.balanceOfThis()` or `vault.balance()` one needs to be sure that any derived token amount needs to be denormalized again before using them.\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-09-yaxis-findings/issues/131#issuecomment-943502860):**\n > An inconsistent usage of `_normalizeDecimals` will cause accounting issues and potentially paths for an exploit\n\n**BobbyYaxis (yAxis) noted:**\n> Mitigated in PR 114: https://github.com/yaxis-project/metavault/pull/114/commits/b3c0405640719aa7d43560f4b4b910b7ba88170b\n\n## [[H-09] `removeToken` would break the vault/protocol.](https://github.com/code-423n4/2021-09-yaxis-findings/issues/4)\n_Submitted by jonah1005_\n\n#### Impact\nThere's no safety check in Manager.sol's `removeToken`. [Manager.sol#L454-L487](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Manager.sol#L454-L487)\n\n1.  The token would be locked in the original vault. Given the current design, the vault would keep a ratio of total amount to save the gas. Once the token is removed at manager contract, these token would lost.\n2.  Controller's `balanceOf` would no longer reflects the real value. [Controller.sol#L488-L495](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L488-L495) While `_vaultDetails[msg.sender].balance;` remains the same, user can nolonger withdraw those amount.\n3.  Share price in the vault would decrease drastically. The share price is calculated as `totalValue / totalSupply` [Vault.sol#L217](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Vault.sol#L217). While the `totalSupply` of the share remains the same, the total balance has drastically decreased.\n\nCalling `removeToken` way would almost break the whole protocol if the vault has already started. I consider this is a high-risk issue.\n\n#### Proof of Concept\nWe can see how the vault would be affected with below web3.py script.\n\n```python\nprint(vault.functions.balanceOfThis().call())\nprint(vault.functions.totalSupply().call())\nmanager.functions.removeToken(vault.address, dai.address).transact()\nprint(vault.functions.balanceOfThis().call())\nprint(vault.functions.totalSupply().call())\n```\n\noutput\n\n    100000000000000000000000\n    100000000000000000000000\n    0\n    100000000000000000000000\n\n#### Tools Used\nHardhat\n\n#### Recommended Mitigation Steps\nRemove tokens from a vault would be a really critical job. I recommend the team cover all possible cases and check all components' states (all vault/ strategy/ controller's state) in the test.\n\nSome steps that I try to come up with that is required to remove TokenA from a vault.\n\n1.  Withdraw all tokenA from all strategies (and handle it correctly in the controller).\n2.  Withdraw all tokenA from the vault.\n3.  Convert all tokenA that's collected in the previous step into tokenB.\n4.  Transfer tokenB to the vault and compensate the transaction fee/slippage cost to the vault.\n\n**[transferAndCall (yAxis) acknowledged](https://github.com/code-423n4/2021-09-yaxis-findings/issues/4#issuecomment-917676694):**\n > Removing a token is understood as a critical (and possibly nuclear) operation within this architecture. We knew we would have to first withdraw all of the identified token from strategies, but what was missed was converting that token to another (without withdrawing, as that would be too much centralization).\n>\n> Proposed method of resolution:\n> - Withdraw all tokenA from all strategies (this sends it to the vault)\n> - Swap tokenA for tokenB in the vault (requires implementing a new function to be called by the strategist)\n> - Remove the token via the Manager function\n\n**[transferAndCall (yAxis) confirmed and patched](https://github.com/code-423n4/2021-09-yaxis-findings/issues/4#issuecomment-917695184):**\n > Please review https://github.com/code-423n4/2021-09-yaxis/pull/5 to check resolution.\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-09-yaxis-findings/issues/4#issuecomment-943519688):**\n > Removing a token can cause accounting errors, stuck funds and break some of the functionality\n>\n> Adding additional checks to prevent removing the token until all tokens have been migrated may be the simplest path forward\n>\n> Sponsor has mitigated by adding custom functionality, however it is up to them to enforce that the vault has no token left before removing it, adding a couple extra checks may provide a guarantee against admin privileged abuses\n\n## [[H-10] An attacker can steal funds from multi-token vaults](https://github.com/code-423n4/2021-09-yaxis-findings/issues/77)\n_Submitted by WatchPug, also found by cmichel and jonah1005_\n\nThe total balance should NOT be simply added from different tokens' tokenAmounts, considering that the price of tokens may not be the same.\n\n[`Vault.sol` L324](https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/Vault.sol#L324)\n\n```solidity\nfunction balanceOfThis()\n    public\n    view\n    returns (uint256 _balance)\n{\n    address[] memory _tokens = manager.getTokens(address(this));\n    for (uint8 i; i < _tokens.length; i++) {\n        address _token = _tokens[i];\n        _balance = _balance.add(_normalizeDecimals(_token, IERC20(_token).balanceOf(address(this))));\n    }\n}\n```\n\n[`Controller.sol` L396](https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/controllers/Controller.sol#L396)\n```solidity\nfunction harvestStrategy(\n    address _strategy,\n    uint256 _estimatedWETH,\n    uint256 _estimatedYAXIS\n)\n    external\n    override\n    notHalted\n    onlyHarvester\n    onlyStrategy(_strategy)\n{\n    uint256 _before = IStrategy(_strategy).balanceOf();\n    IStrategy(_strategy).harvest(_estimatedWETH, _estimatedYAXIS);\n    uint256 _after = IStrategy(_strategy).balanceOf();\n    address _vault = _vaultStrategies[_strategy];\n    _vaultDetails[_vault].balance = _vaultDetails[_vault].balance.add(_after.sub(_before));\n    _vaultDetails[_vault].balances[_strategy] = _after;\n    emit Harvest(_strategy);\n}\n```\n\n[`Vault.sol` L310](https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/Vault.sol#L310)\n```solidity\n/**\n * @notice Returns the total balance of the vault, including strategies\n */\nfunction balance()\n    public\n    view\n    override\n    returns (uint256 _balance)\n{\n    return balanceOfThis().add(IController(manager.controllers(address(this))).balanceOf());\n}\n```\n\n#### Impact\nAn attacker can steal funds from multi-token vaults. Resulting in fund loss of all other users.\n\n#### Proof of Concept\nIf there is a multi-token vault with 3 tokens: DAI, USDC, USDT, and their price in USD is now 1.05, 0.98, and 0.95. If the current balances are: 2M, 1M, and 0.5M.\n\nAn attacker may do the following steps:\n\n1.  Deposit 3M of USDT;\n2.  Withdraw 3M, receive 2M in DAI and 1M in USDC.\n\nAs 2M of DAI + 1M of USDC worth much more than 3M of USDT. The attacker will profit and all other users will be losing funds.\n\n#### Recommended Mitigation Steps\nAlways consider the price differences between tokens.\n\n**[BobbyYaxis (yAxis) acknowledged](https://github.com/code-423n4/2021-09-yaxis-findings/issues/77)**\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-09-yaxis-findings/issues/77#issuecomment-942445062):**\n > Fully agree with the finding, assuming price of tokens is the same exposes the Vault and all depositors to risk of Single Sided Exposure\n>\n> This risk has been exploited multiple times, notably in the Yearn Exploit\n>\n> The solution for for managing tokens with multiple values while avoiding being rekt is to have an index that ensures your LP  Token maintains it's peg, curve's solution is called `virtual_price`\n>\n> Having a virtual price would allow to maintain the Vault Architecture, while mitigating exploits that directly use balances\n\n**BobbyYaxis (yAxis) noted:**\n> We have mitigated by deploying vaults that only accept the Curve LP token itself used in the strategy. There is no longer an array of tokens accepted. E.g Instead of a wBTC vault, we have a renCrv vault. Or instead of 3CRV vault, we have a mimCrv vault. The strategy want token = the vault token.\n# Medium Risk Findings (15)\n\n## [[M-01] `VaultHelper` deposits don't work with fee-on transfer tokens](https://github.com/code-423n4/2021-09-yaxis-findings/issues/127)\n_Submitted by cmichel, also found by 0xsanson_\n\nThere are ERC20 tokens that may make certain customizations to their ERC20 contracts.\nOne type of these tokens is deflationary tokens that charge a certain fee for every `transfer()` or `transferFrom()`.\nOthers are rebasing tokens that increase in value over time like Aave's aTokens (`balanceOf` changes over time).\n\n#### Impact\nThe `VaultHelper`'s `depositVault()` and `depositMultipleVault` functions transfer `_amount` to `this` contract using `IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);`.\nThis could have a fee, and less than `_amount` ends up in the contract.\nThe next actual vault deposit using `IVault(_vault).deposit(_token, _amount);` will then try to transfer more than the `this` contract actually has and will revert the transaction.\n\n#### Recommended Mitigation Steps\nOne possible mitigation is to measure the asset change right before and after the asset-transferring routines.\nThis is already done correctly in the `Vault.deposit` function.\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-09-yaxis-findings/issues/127#issuecomment-941740332):**\n > Agree with finding, checking actual balance of contract would mitigate vulnerability\n> Additionally ensuring the protocol never uses rebasing or tokens with `feeOnTransfer` can be enough to mitigate\n>\n> The vulnerability can brick the protocol\n> However it can be sidestepped by simply not using `feeOnTransfer` tokens\n> Downgrading to medium\n\n## [[M-02] ERC20 return values not checked](https://github.com/code-423n4/2021-09-yaxis-findings/issues/114)\n_Submitted by cmichel, also found by defsec and jonah1005_\n\nThe `ERC20.transfer()` and `ERC20.transferFrom()` functions return a boolean value indicating success. This parameter needs to be checked for success.\nSome tokens do **not** revert if the transfer failed but return `false` instead.\n\nThe `Manager.recoverToken` function does not check the return value of this function.\n\n#### Impact\nTokens that don't actually perform the transfer and return `false` are still counted as a correct transfer.\nFurthermore, tokens that do not correctly implement the EIP20 standard, like USDT which does not return a success boolean, will revert.\n\n#### Recommended Mitigation Steps\nWe recommend using [OpenZeppelin’s `SafeERC20`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74) versions with the `safeTransfer` and `safeTransferFrom` functions that handle the return value check as well as non-standard-compliant tokens.\n\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-09-yaxis-findings/issues/114#issuecomment-942781687):**\n > Agree with finding, using a non reverting token can potentially cause issues to the protocol accounting\n>\n> Sponsor can check each token on a case by case basis, or simply use OpenZeppelin's `safeERC20`\n\n## [[M-03] `Vault.withdraw` sometimes burns too many shares](https://github.com/code-423n4/2021-09-yaxis-findings/issues/121)\n_Submitted by cmichel, also found by 0xsanson and 0xRajeev_\n\nThe `Vault.withdraw` function attempts to withdraw funds from the controller if there are not enough in the vault already.\nIn the case the controller could not withdraw enough, i.e., where `_diff < _toWithdraw`, the user will receive **less** output tokens than their fair share would entitle them to (the initial `_amount`).\n\n```solidity\nif (_diff < _toWithdraw) {\n    // @audit burns too many shares for a below fair-share amount\n    _amount = _balance.add(_diff);\n}\n```\n\n#### Impact\nThe withdrawer receives fewer output tokens than they were entitled to.\n\n#### Recommended Mitigation Steps\nIn the mentioned case, the `_shares` should be recomputed to match the actual withdrawn `_amount` tokens:\n\n```solidity\nif (_diff < _toWithdraw) {\n    _amount = _balance.add(_diff);\n    // recompute _shares to burn based on the lower payout\n    // should be something like this, better to cache balance() once at the start and use that cached value\n    _shares = (totalSupply().mul(_amount)).div(_balance);\n}\n```\n\nOnly these shares should then be burned.\n\n**[uN2RVw5q commented](https://github.com/code-423n4/2021-09-yaxis-findings/issues/121#issuecomment-932776915):**\n > Duplicate of https://github.com/code-423n4/2021-09-yaxis-findings/issues/41 and https://github.com/code-423n4/2021-09-yaxis-findings/issues/136\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-09-yaxis-findings/issues/121#issuecomment-942790860):**\n > Agree with the finding\n>\n> Anytime the strategy incurs a loss during withdrawal, the person that triggered that withdrawal will get less for their shares than what they may expect.\n>\n> Since amount of shares is computed by checking balance in strategy, and controller enacts this withdrawal, adding a check in the controller to compare expected withdrawal vs actual shares received would be a clean way to mitigate\n\n**BobbyYaxis (yAxis) noted:**\n> We have mitigated by deploying vaults that only accept the Curve LP token itself used in the strategy. There is no longer an array of tokens accepted. E.g Instead of a wBTC vault, we have a renCrv vault. Or instead of 3CRV vault, we have a mimCrv vault. The strategy want token = the vault token.\n\n## [[M-04] Adding asymmetric liquidity in `_addLiquidity` results in fewer LP tokens minted than what should be wanted](https://github.com/code-423n4/2021-09-yaxis-findings/issues/158)\n\n#### Impact\nBecause the call in `_addLiquidity` forwards the entire balances of the 3 stablecoins without checking the ratio.\nbetween the 3, less liquidity is minted than what should be wanted. Furthermore, an attacker can abuse this arbitrage the forwarded balances if the discrepancy is large enough.\n\nFor example, suppose the contract holds \\$10K each of usdc, usdt, dai. An attacker deposits \\$100K worth of DAI\nand get credited with \\$100K worth of shares in the protocol. Liquidity is added, but since the ratio is now skewed\n11:1:1, a lot less liquidity is minted by the stableswap algorithm to the protocol. The attacker can now arbitrage the curve pool for an additional profit.\n\nThere doesn't even need to be an attacker, just an unbalanced amount of user deposits will also lead to lower liquidity minted.\n\n#### Proof of Concept\n- [`NativeStrategyCurve3Crv.sol` L73](https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/strategies/NativeStrategyCurve3Crv.sol#L73)\n\n#### Recommended Mitigation Steps\nAdding liquidity should probably be managed more manually, it should be added in equal proportion to the curve pool balances, not the contract balances.\n\n**[gpersoon commented](https://github.com/code-423n4/2021-09-yaxis-findings/issues/158#issuecomment-930142403):**\n > Seems the same as #2\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-09-yaxis-findings/issues/158#issuecomment-943488554):**\n > Agree on the finding\n> This finding claims that adding liquidity on Curve while treating each token to have the same weight is a surefire way to get less tokens than expected\n>\n> While #2 addresses a similar (IMO higher risk) vulnerability\n>\n> This finding shows how the vault can have a loss of value through how it deals with token accounting\n>\n> To me this is a unique finding, however am downgrading it to medium\n\n**BobbyYaxis (yAxis) noted:**\n> We have mitigated by deploying vaults that only accept the Curve LP token itself used in the strategy. There is no longer an array of tokens accepted. E.g Instead of a wBTC vault, we have a renCrv vault. Or instead of 3CRV vault, we have a mimCrv vault. The strategy want token = the vault token.\n\n## [[M-05] Vault: Swaps at parity with swap fee = withdrawal fee](https://github.com/code-423n4/2021-09-yaxis-findings/issues/71)\n_Submitted by hickuphh3_\n\n##### Impact\nThe vault treats all assets to be of the same price. Given that one can also deposit and withdraw in the same transaction, this offers users the ability to swap available funds held in the vault at parity, with the withdrawal protection fee (0.1%) effectively being the swap fee.\n\nDue care and consideration should therefore be placed if new stablecoins are to be added to the vault (eg. algorithmic ones that tend to occasionally be off-peg), or when lowering the withdrawal protection fee.\n\n##### Recommended Mitigation Steps\n*   Prevent users from depositing and withdrawing in the same transaction. This would help prevent potential flash loan attacks as well\n*   `setWithdrawalProtectionFee()` could have a requirement for the value to be non-zero. Zero withdrawal fee could be set in `setHalted()` whereby only withdrawals will be allowed.\n*   Use price oracles to accurately calculate the shares to be transferred to users for deposits, or token amounts to be sent for withdrawals\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-09-yaxis-findings/issues/71#issuecomment-942810131):**\n > Agree with finding, this vault accounting can be used for arbitrage opportunities as tokens are treated at exact value while they may have imbalances in price\n>\n> This is not a duplicate as it's explaining a specific attack vector\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-09-yaxis-findings/issues/71#issuecomment-942810380):**\n > Also raising risk valuation as this WILL be used to extract value from the system\n\n**BobbyYaxis (yAxis) noted:**\n> We have mitigated by deploying vaults that only accept the Curve LP token itself used in the strategy. There is no longer an array of tokens accepted. E.g Instead of a wBTC vault, we have a renCrv vault. Or instead of 3CRV vault, we have a mimCrv vault. The strategy want token = the vault token.\n\n## [[M-06]  # Controller is vulnerable to sandwich attack](https://github.com/code-423n4/2021-09-yaxis-findings/issues/7)\n_Submitted by jonah1005_\n\n#### Impact\nThe protocol frequently interacts with crv a lot. However, the contract doesn't specify the minimum return amount.\nGiven the fact that there's a lot of MEV searchers, calling swap without specifying the minimum return amount really puts user funds in danger.\n\nFor example, controller's `withdrawAll` is designed to transfer all the funds in a strategy.[Controller.sol#L360](https://github.com/code-423n4/2021-09-yaxis/blob/a78d392156b90f8ac27de6d57cb0de2697d480d5/contracts/v3/controllers/Controller.sol#L360) The arbitrage space is enough for a searcher to sandwich this trade.\n\n#### Proof of Concept\n[Manager.sol#L442-L452](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/Manager.sol#L442-L452)\n\n[Controller.sol#L273](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/controllers/Controller.sol#L273)\n\n#### Recommended Mitigation Steps\nAlways calculates an estimate return when calling to crv.\n\n**[transferAndCall (yAxis) acknowledged](https://github.com/code-423n4/2021-09-yaxis-findings/issues/7)**\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-09-yaxis-findings/issues/7#issuecomment-942827851):**\n > Agree with finding, agree with severity as this allows to \"leak value\"\n\n## [[M-07] Vault: Withdrawals can be frontrun to cause users to burn tokens without receiving funds in return](https://github.com/code-423n4/2021-09-yaxis-findings/issues/74)\n_Submitted by hickuphh3_\n\n##### Impact\nLet us assume either of the following cases:\n\n1.  The vault / protocol is to be winded down or migrated, where either the protocol is halted and `withdrawAll()` has been called on all active strategies to transfer funds into the vault.\n2.  There are 0 strategies. Specifically, `_controller.strategies() = 0`\n\nAttempted withdrawals can be frontrun such that users will receive less, or even no funds in exchange for burning vault tokens. This is primarily enabled by the feature of having deposits in multiple stablecoins.\n\n##### Proof of Concept\n1.  Assume `getPricePerFullShare()` of `1e18` (1 vault token = 1 stablecoin). Alice has 1000 vault tokens, while Mallory has 2000 vault tokens, with the vault holdings being 1000 USDC, 1000 USDT and 1000 DAI.\n2.  Alice attempts to withdraw her deposit in a desired stablecoin (Eg. USDC).\n3.  Mallory frontruns Alice's transaction and exchanges 1000 vault tokens for the targeted stablecoin (USDC). The vault now holds 1000 USDT and 1000 DAI.\n4.  Alice receives nothing in return for her deposit because the vault no longer has any USDC. `getPricePerFullShare()` now returns `2e18`.\n5.  Mallory splits his withdrawals evenly, by burning 500 vault tokens for 1000 USDT and the other 500 vault tokens for 1000 DAI.\n\nHence, Mallory is able to steal Alice's funds by frontrunning her withdrawal transaction.\n\n##### Recommended Mitigation Steps\nThe withdrawal amount could be checked against `getPricePerFullShare()`, perhaps with reasonable slippage.\n\n**[GainsGoblin (yAxis) commented](https://github.com/code-423n4/2021-09-yaxis-findings/issues/74#issuecomment-931750516):**\n > Duplicate of #28\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-09-yaxis-findings/issues/74#issuecomment-943385674):**\n > Disagree with duplicate label as this shows a Value Extraction, front-running exploit.\n> Medium severity as it's a way to \"leak value\"\n>\n> This can be mitigated through addressing the \"Vault value all tokens equally\" issue\n\n**[GainsGoblin (yAxis) commented](https://github.com/code-423n4/2021-09-yaxis-findings/issues/74#issuecomment-943707545):**\n > The issue is exactly the same as #28. Both issues present the exact same front-running example.\n\n**BobbyYaxis (yAxis) noted:**\n> We have mitigated by deploying vaults that only accept the Curve LP token itself used in the strategy. There is no longer an array of tokens accepted. E.g Instead of a wBTC vault, we have a renCrv vault. Or instead of 3CRV vault, we have a mimCrv vault. The strategy want token = the vault token.\n\n## [[M-08] `Controller.inCaseStrategyGetStuck` does not update balance](https://github.com/code-423n4/2021-09-yaxis-findings/issues/130)\n_Submitted by cmichel_\n\nThe `Controller.inCaseStrategyGetStuck` withdraws from a strategy but does not call `updateBalance(_vault, _strategy)` afterwards.\n\n#### Impact\nThe `_vaultDetails[_vault].balances[_strategy]` variable does not correctly track the actual strategy balance anymore.\nI'm not sure what exactly this field is used for besides getting the withdraw amounts per strategy in `getBestStrategyWithdraw`.\nAs the strategy contains a lower amount than stored in the field, `Controller.withdraw` will attempt to withdraw too much.\n\n#### Recommended Mitigation Steps\nCall `updateBalance(_vault, _strategy)` in `inCaseStrategyGetStuck`.\n\n**[Haz077 (yAxis) acknowledged](https://github.com/code-423n4/2021-09-yaxis-findings/issues/130)**\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-09-yaxis-findings/issues/130#issuecomment-943400238):**\n > Agree with finding, I also believe `inCaseStrategyGetStuck` and `inCaseTokenGetStuck` are vectors for admin rugging, may want to add checks to ensure only non strategy token can be withdrawn from the vaults and strats\n\n**BobbyYaxis (yAxis) noted:**\n> It's a needed function for the strategist. The risk of these functions are mitigated as the strategies and controller should never have a balance of any tokens regardless. So there should be nothing/meaningful for the strategist to ever \"rug\" in that sense. But we can make this a governance-only feature, rather than strategist.\n\n## [[M-09] token -> vault mapping can be overwritten](https://github.com/code-423n4/2021-09-yaxis-findings/issues/126)\n_Submitted by cmichel_\n\nOne vault can have many tokens, but each token should only be assigned to a single vault.\nThe `Manager` contract keeps a mapping of tokens to vaults in the `vaults[_token] => _vault` map, and a mapping of vault to tokens in `tokens[vault] => token[]`.\n\nThe `addToken` function can assign any token to a single vault and allows overwriting an existing `vaults[_token]` map entry with a different vault.\nThis indirectly disassociates the previous vault for the token.\nNote that the previous vault's `tokens[_previousVault]` map still contains the `token`.\n\n#### Impact\nThe token disappears from the system for the previous vault but the actual tokens are still in there, getting stuck.\nOnly the new vault is considered for the token anymore, which leads to many issues, see `Controller.getBestStrategyWithdraw` and the `onlyVault` modifier that doesn't work correctly anymore.\n\n#### Recommended Mitigation Steps\nIt should check if the `token` is already used in a map, and either revert or correctly remove the token from the vault - from the `tokens` array.\nIt should do the same cleanup procedure as in `removeToken`:\n\n```solidity\nif (found) {\n    // remove the token from the vault\n    tokens[_vault][index] = tokens[_vault][k-1];\n    tokens[_vault].pop();\n    delete vaults[_token];\n    emit TokenRemoved(_vault, _token);\n}\n```\n\n`addToken` should also check that the token is not already in the `tokens[_vault]` array.\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-09-yaxis-findings/issues/126#issuecomment-943460833):**\n > Mapping mismatch can cause undefined behaviour\n>\n> Recommend having one source of truth to keep things simple\n\n## [[M-10] `YAxisVotePower.balanceOf` can be manipulated](https://github.com/code-423n4/2021-09-yaxis-findings/issues/113)\n_Submitted by cmichel_\n\nThe `YAxisVotePower.balanceOf` contract uses the Uniswap pool reserves to compute a `_lpStakingYax` reward:\n\n```solidity\n(uint256 _yaxReserves,,) = yaxisEthUniswapV2Pair.getReserves();\nint256 _lpStakingYax = _yaxReserves\n    .mul(_stakeAmount)\n    .div(_supply)\n    .add(rewardsYaxisEth.earned(_voter));\n```\n\nThe pool can be temporarily manipulated to increase the `_yaxReserves` amount.\n\n#### Impact\nIf this voting power is used for governance proposals, an attacker can increase their voting power and pass a proposal.\n\n#### Recommended Mitigation Steps\nOne could build a TWAP-style contract that tracks a time-weighted-average reserve amount (instead of the price in traditional TWAPs).\nThis can then not be manipulated by flashloans.\n\n**[uN2RVw5q commented](https://github.com/code-423n4/2021-09-yaxis-findings/issues/113#issuecomment-932350186):**\n > I disagree with the \"sponsor disputed\" tag.\n>\n> I think this is a valid issue and makes `balanceOf(_voter)` susceptible to flashloan attacks. However, as long as `balanceOf(_voter)` is always called by a trusted EOA during governance vote counts, this should not be a problem. I assume this is the case for governance proposals. If that is not the case, I would recommend changing the code. Otherwise, changing the risk to \"documentation\" would be reasonable.\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-09-yaxis-findings/issues/113#issuecomment-943463853):**\n > Agree with original warden finding, as well as severity\n>\n> The ability to trigger the count at any time does prevent a flashloan attack (as flashloans are atomic)\n> It would allow the privilege of the flashloan attack to the trusted EOA (admin privilege)\n>\n> Additionally the voting power can still be frontrun, while you cannot manipulate that voting power via a flashloan, you can just buy and sell your position on the same block as when the count is being taken\n>\n> Due to this I will up the severity back to medium as this is a legitimate vector to extract value\n\n## [[M-11] wrong YAXIS estimates](https://github.com/code-423n4/2021-09-yaxis-findings/issues/112)\n_Submitted by cmichel_\n\nThe `Harvester.getEstimates` contract tries to estimate a `YAXIS` amount but uses the wrong path and/or amount.\n\nIt currently uses a `WETH` **input** amount to compute a `YAXIS -> WETH` trade.\n\n```solidity\naddress[] memory _path;\n_path[0] = IStrategy(_strategy).want();\n_path[1] = IStrategy(_strategy).weth();\n// ...\n\n_path[0] = manager.yaxis();\n// path is YAXIS -> WETH now\n// fee is a WETH precision value\nuint256 _fee = _estimatedWETH.mul(manager.treasuryFee()).div(ONE_HUNDRED_PERCENT);\n// this will return wrong trade amounts\n_amounts = _router.getAmountsOut(_fee, _path);\n_estimatedYAXIS = _amounts[1];\n```\n\n#### Impact\nThe estimations from `getEstimates` are wrong.\nThey seem to be used to provide min. amount slippage values `(_estimatedWETH, _estimatedYAXIS)` for the harvester when calling `Controller._estimatedYAXIS`.\nThese are then used in `BaseStrategy._payHarvestFees` and can revert the harvest transactions if the wrongly computed `_estimatedYAXIS` value is above the actual trade value.\nOr they can allow a large slippage if the `_estimatedYAXIS` value is below the actual trade value, which can then be used for a sandwich attack.\n\n#### Recommended Mitigation Steps\nFix the estimations computations.\n\nAs the estimations are used in `BaseStrategy._payHarvestFees`, the expected behavior seems to be trading `WETH` to `YAXIS`.\nThe path should therefore be changed to `path[0] = WETH; path[1] = YAXIS` in `Harvester.getEstimates`.\n\n\n**[Haz077 (yAxis) acknowledged](https://github.com/code-423n4/2021-09-yaxis-findings/issues/112)**\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-09-yaxis-findings/issues/112#issuecomment-943475050):**\n > Price estimates on Uniswap are dependent on which side of the swap you're making\n>\n> Sponsor has mitigated in later PR\n\n## [[M-12] Harvest can be frontrun](https://github.com/code-423n4/2021-09-yaxis-findings/issues/140)\n_Submitted by 0xsanson_\n\n#### Impact\nIn the `NativeStrategyCurve3Crv._harvest` there are two instances that a bad actor could use to frontrun the harvest.\n\nFirst, when we are swapping WETH to a stablecoin by calling `_swapTokens(weth, _stableCoin, _remainingWeth, 1)` the function isn't checking the slippage, leading to the risk to a frontun (by imbalancing the Uniswap pair) and losing part of the harvesting profits.\n\nSecond, during the `_addLiquidity` internal function: this calls `stableSwap3Pool.add_liquidity(amounts, 1)` not considering the slippage when minting the 3CRV tokens.\n\n#### Proof of Concept\n[`NativeStrategyCurve3Crv.sol` L108](https://github.com/code-423n4/2021-09-yaxis/blob/main/contracts/v3/strategies/NativeStrategyCurve3Crv.sol#L108)\n\n#### Tools Used\neditor\n\n#### Recommended Mitigation Steps\nIn the function `_harvest(_estimatedWETH, _estimatedYAXIS)` consider adding two additional estimated quantities: one for the swapped-out stablecoin and one for the minted 3CRV.\n\n**[BobbyYaxis (yAxis) acknowledged](https://github.com/code-423n4/2021-09-yaxis-findings/issues/140)**\n\n**[uN2RVw5q commented](https://github.com/code-423n4/2021-09-yaxis-findings/issues/140#issuecomment-932765993):**\n > On second thought, I think this is a valid issue.\n>\n> > consider adding two additional estimated quantities: one for the swapped-out stablecoin and one for the minted 3CRV.\n>\n> This suggestion should be considered.\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-09-yaxis-findings/issues/140#issuecomment-943477587):**\n > Warden identified two paths for front-running\n>\n> Since these are ways to extract value, severity is Medium\n\n**BobbyYaxis (yAxis) noted:**\n> Mitigated in PR 114: https://github.com/yaxis-project/metavault/pull/114\n\n## [[M-13] `manager.allowedVaults` check missing for add/remove strategy](https://github.com/code-423n4/2021-09-yaxis-findings/issues/50)\n_Submitted by 0xRajeev_\n\n#### Impact\nThe `manager.allowedVaults` check is missing for add/remove strategy like how it is used in `reorderStrategies()`. This will allow a strategist to accidentally/maliciously add/remove strategies on unauthorized vaults.\n\nGiven the critical access control that is missing on vaults here, this is classified as medium severity.\n\n#### Proof of Concept\n- [`Controller.sol#L101` L130](https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/controllers/Controller.sol#L101-L130)\n- [`Controller.sol#L172` L207](https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/controllers/Controller.sol#L172-L207)\n- [`Controller.sol` L224](https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/controllers/Controller.sol#L224)\n- [`Manager.sol#L210` L221](https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/Manager.sol#L210-L221)\n\n#### Tools Used\nManual Analysis\n\n#### Recommended Mitigation Steps\nAdd `manager.allowedVaults` check in `addStrategy()` and `removeStrategy()`\n\n**[GainsGoblin (yAxis) acknowledged](https://github.com/code-423n4/2021-09-yaxis-findings/issues/50)**\n\n**[Haz077 (yAxis) confirmed](https://github.com/code-423n4/2021-09-yaxis-findings/issues/50)**\n\n**[uN2RVw5q commented](https://github.com/code-423n4/2021-09-yaxis-findings/issues/50#issuecomment-933009311):**\n > Implemented in https://github.com/code-423n4/2021-09-yaxis/pull/36\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-09-yaxis-findings/issues/50#issuecomment-943479681):**\n > Sponsor has acknowledged and mitigated by adding further access control checks\n\n## [[M-14] Halting the protocol should be `onlyGovernance` and not` onlyStrategist`](https://github.com/code-423n4/2021-09-yaxis-findings/issues/47)\n_Submitted by 0xRajeev_\n\n#### Impact\nA malicious strategist can halt the entire protocol and force a permanent shutdown once they observe that governance is trying to set a new strategist and they do not agree with that decision. They may use the 7 day window to halt the protocol. The access control on `setHalted()` should be `onlyGovernance`.\n\n#### Proof of Concept\n- [`Manager.sol#L515` L522](https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/Manager.sol#L515-L522)\n- [`Manager.sol#L333` L345](https://github.com/code-423n4/2021-09-yaxis/blob/cf7d9448e70b5c1163a1773adb4709d9d6ad6c99/contracts/v3/Manager.sol#L333-L345)\n\n#### Tools Used\nManual Analysis\n\n#### Recommended Mitigation Steps\nChange access control to `onlyGovernance` from` onlyStrategist` for `setHalted()`\n\n**[GainsGoblin (yAxis) acknowledged](https://github.com/code-423n4/2021-09-yaxis-findings/issues/47)**\n\n**[uN2RVw5q commented](https://github.com/code-423n4/2021-09-yaxis-findings/issues/47#issuecomment-932978261):**\n > Implemented in https://github.com/code-423n4/2021-09-yaxis/pull/35\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-09-yaxis-findings/issues/47#issuecomment-943481373):**\n > Agree that such critical functionality should be limited to the highest permission access role.\n> Sponsor has mitigated\n\n# Low Risk Findings (25)\n\n- [[L-01] Missing support/documentation for use of deflationary tokens in protocol](https://github.com/code-423n4/2021-09-yaxis-findings/issues/62)\n_Submitted by 0xRajeev, also found by itsmeSTYJ_\n- [[L-02] `getMostPremium()` can be wrong](https://github.com/code-423n4/2021-09-yaxis-findings/issues/139)\n_Submitted by 0xsanson_\n- [[L-03] getMostPremium() does not necessarily return the best asset to trade for.](https://github.com/code-423n4/2021-09-yaxis-findings/issues/156)\n- [[L-04] Be aware that transactions can be frontrun to exactly the estimated amount.](https://github.com/code-423n4/2021-09-yaxis-findings/issues/153)\n- [[L-05] Missing zero-address checks](https://github.com/code-423n4/2021-09-yaxis-findings/issues/35)\n_Submitted by 0xRajeev_\n- [[L-06] Decimals of upgradeable tokens may change](https://github.com/code-423n4/2021-09-yaxis-findings/issues/82)\n_Submitted by pauliax_\n- [[L-07] Missing sanity/threshold check on totalDepositCap may cause DoS](https://github.com/code-423n4/2021-09-yaxis-findings/issues/38)\n_Submitted by 0xRajeev_\n- [[L-08] No use of notHalted in LegacyController functions](https://github.com/code-423n4/2021-09-yaxis-findings/issues/57)\n_Submitted by 0xRajeev_\n- [[L-09] onlyEnabledConverter modifier is not used in all functions](https://github.com/code-423n4/2021-09-yaxis-findings/issues/60)\n_Submitted by 0xRajeev_\n- [[L-10] safeApprove may revert for non-zero to non-zero approvals](https://github.com/code-423n4/2021-09-yaxis-findings/issues/63)\n_Submitted by 0xRajeev, also found by 0xsanson_\n- [[L-11] Max approvals are risky if contract is malicious/compromised](https://github.com/code-423n4/2021-09-yaxis-findings/issues/64)\n_Submitted by 0xRajeev_\n- [[L-12] `cap` isn't enforced](https://github.com/code-423n4/2021-09-yaxis-findings/issues/134)\n_Submitted by 0xsanson_\n- [[L-13] Unclear `totalDepositCap`](https://github.com/code-423n4/2021-09-yaxis-findings/issues/135)\n_Submitted by 0xsanson_\n- [[L-14] Missing check in `reorderStrategies`](https://github.com/code-423n4/2021-09-yaxis-findings/issues/144)\n_Submitted by 0xsanson_\n- [[L-15] `maxStrategies` can be lower than existing strategies](https://github.com/code-423n4/2021-09-yaxis-findings/issues/145)\n_Submitted by 0xsanson_\n- [[L-16] Harvesting and Funding Is Not Checked When the Contract Is Halted](https://github.com/code-423n4/2021-09-yaxis-findings/issues/10)\n_Submitted by defsec, also found by 0xsanson_\n- [[L-17] Unbounded iterations over strategies or tokens](https://github.com/code-423n4/2021-09-yaxis-findings/issues/111)\n_Submitted by cmichel_\n- [[L-18] Withdraw event uses wrong parameter](https://github.com/code-423n4/2021-09-yaxis-findings/issues/122)\n_Submitted by cmichel_\n- [[L-19] Vault: Zero Withdrawal Fee If Protocol Halts](https://github.com/code-423n4/2021-09-yaxis-findings/issues/75)\n_Submitted by hickuphh3_\n- [[L-20] The `sqrt` function can overflow execute invalid operation](https://github.com/code-423n4/2021-09-yaxis-findings/issues/104)\n_Submitted by hrkrshnn_\n- [[L-21] missing safety check in addStrategy](https://github.com/code-423n4/2021-09-yaxis-findings/issues/23)\n_Submitted by jonah1005_\n- [[L-22] vault cap's at totalSupply would behave unexpectedly](https://github.com/code-423n4/2021-09-yaxis-findings/issues/25)\n_Submitted by jonah1005, also found by pauliax_\n- [[L-23] Removed tokens can't be withdrawn from vault](https://github.com/code-423n4/2021-09-yaxis-findings/issues/69)\n_Submitted by hickuphh3_\n- [[L-24] No slippage checks can lead to sandwich attacks](https://github.com/code-423n4/2021-09-yaxis-findings/issues/133)\n_Submitted by cmichel_\n- [[L-25] hijack the vault by pumping vault price.](https://github.com/code-423n4/2021-09-yaxis-findings/issues/26)\n_Submitted by jonah1005_\n\n# Non-Critical Findings (11)\n\n- [[N-01] Change public visibility to external](https://github.com/code-423n4/2021-09-yaxis-findings/issues/55)\n_Submitted by 0xRajeev_\n- [[N-02] Unused imports](https://github.com/code-423n4/2021-09-yaxis-findings/issues/89)\n_Submitted by pauliax_\n- [[N-03] Style issues](https://github.com/code-423n4/2021-09-yaxis-findings/issues/93)\n_Submitted by pauliax_\n- [[N-04] setMinter should check that _minter is not empty](https://github.com/code-423n4/2021-09-yaxis-findings/issues/81)\n_Submitted by pauliax_\n- [[N-05] Tokens with > 18 decimals will break logic](https://github.com/code-423n4/2021-09-yaxis-findings/issues/42)\n_Submitted by 0xRajeev, also found by hrkrshnn, and pauliax_\n- [[N-06] Unused event may be unused code or indicative of missed emit/logic](https://github.com/code-423n4/2021-09-yaxis-findings/issues/49)\n_Submitted by 0xRajeev, also found by cmichel_\n- [[N-07] Missing parameter validation](https://github.com/code-423n4/2021-09-yaxis-findings/issues/107)\n_Submitted by cmichel_\n- [[N-08] shadowing of strategies](https://github.com/code-423n4/2021-09-yaxis-findings/issues/17)\n_Submitted by gpersoon_\n- [[N-09] VaultHelper contract should never have tokens at the end of a transaction](https://github.com/code-423n4/2021-09-yaxis-findings/issues/100)\n_Submitted by hrkrshnn_\n- [[N-10] Safety of the Vyper compiler](https://github.com/code-423n4/2021-09-yaxis-findings/issues/99)\n_Submitted by hrkrshnn_\n- [[N-11] Single-step change of governance address is extremely risky](https://github.com/code-423n4/2021-09-yaxis-findings/issues/44)\n_Submitted by 0xRajeev_\n\n# Gas Optimizations (27)\n\n- [[G-01] Checking for zero amounts can save gas by preventing expensive external calls](https://github.com/code-423n4/2021-09-yaxis-findings/issues/30)\n_Submitted by 0xRajeev_\n- [[G-02] extra array length check in depositMultipleVault ](https://github.com/code-423n4/2021-09-yaxis-findings/issues/20)\n_Submitted by gpersoon, also found by 0xRajeev_\n- [[G-03] Rearranging declaration of state variables will save storage slots because of packing](https://github.com/code-423n4/2021-09-yaxis-findings/issues/43)\n_Submitted by 0xRajeev_\n- [[G-04] Removal of last token in the array can be optimized](https://github.com/code-423n4/2021-09-yaxis-findings/issues/46)\n_Submitted by 0xRajeev, also found by hickuphh3_\n- [[G-05] `tokens[i]` can be memorized](https://github.com/code-423n4/2021-09-yaxis-findings/issues/143)\n_Submitted by 0xsanson, also found by pauliax_\n- [[G-06] Removing unused parameter and modifier can save gas](https://github.com/code-423n4/2021-09-yaxis-findings/issues/58)\n_Submitted by 0xRajeev_\n- [[G-07] Earn process emits two events that can be arranged into one](https://github.com/code-423n4/2021-09-yaxis-findings/issues/138)\n_Submitted by 0xsanson_\n- [[G-08] Unnecessary `balanceOfWant() > 0`](https://github.com/code-423n4/2021-09-yaxis-findings/issues/141)\n_Submitted by 0xsanson_\n- [[G-09] `harvestNextStrategy` can be optimized](https://github.com/code-423n4/2021-09-yaxis-findings/issues/146)\n_Submitted by 0xsanson_\n- [[G-10] Gas: `removeToken` iteration over all tokens can be avoided](https://github.com/code-423n4/2021-09-yaxis-findings/issues/116)\n_Submitted by cmichel, also found by itsmeSTYJ_\n- [[G-11] Gas: `removeStrategy` iteration over all strategies can be avoided](https://github.com/code-423n4/2021-09-yaxis-findings/issues/117)\n_Submitted by cmichel, also found by itsmeSTYJ_\n- [[G-12] Gas: Unnecessary addition in `Vault.deposit`](https://github.com/code-423n4/2021-09-yaxis-findings/issues/118)\n_Submitted by cmichel, also found by jonah1005, hickuphh3, and pauliax_\n- [[G-13] Vault: Redundant notHalted modifier in depositMultiple()](https://github.com/code-423n4/2021-09-yaxis-findings/issues/70)\n_Submitted by hickuphh3, also found by cmichel, hrkrshnn, and pauliax_\n- [[G-14] Gas: Loop in `StablesConverter.convert` can be avoided](https://github.com/code-423n4/2021-09-yaxis-findings/issues/123)\n_Submitted by cmichel_\n- [[G-15] Gas: Loop in `StablesConverter.expected` can be avoided](https://github.com/code-423n4/2021-09-yaxis-findings/issues/124)\n_Submitted by cmichel_\n- [[G-16] Gas: Timestamp in router swap can be hardcoded](https://github.com/code-423n4/2021-09-yaxis-findings/issues/125)\n_Submitted by cmichel_\n- [[G-17] Save a step in withdraw of Vault.sol](https://github.com/code-423n4/2021-09-yaxis-findings/issues/18)\n_Submitted by gpersoon_\n- [[G-18] Controller: Extra sload of _vaultDetails[_vault].balance](https://github.com/code-423n4/2021-09-yaxis-findings/issues/65)\n_Submitted by hickuphh3_\n- [[G-19] Harvester: Simpler implementation for canHarvest()](https://github.com/code-423n4/2021-09-yaxis-findings/issues/66)\n_Submitted by hickuphh3_\n- [[G-20] Consider making some constants as non-public to save gas](https://github.com/code-423n4/2021-09-yaxis-findings/issues/94)\n_Submitted by hrkrshnn_\n- [[G-21] Caching the length in for loops](https://github.com/code-423n4/2021-09-yaxis-findings/issues/95)\n_Submitted by hrkrshnn_\n- [[G-22] Upgrade to at least 0.8.4](https://github.com/code-423n4/2021-09-yaxis-findings/issues/98)\n_Submitted by hrkrshnn, also found by 0xRajeev_\n- [[G-23] uint8 is less efficient than uint256 in loop iterations](https://github.com/code-423n4/2021-09-yaxis-findings/issues/86)\n_Submitted by pauliax, also found by hrkrshnn_\n- [[G-24] Dead code](https://github.com/code-423n4/2021-09-yaxis-findings/issues/87)\n_Submitted by pauliax_\n- [[G-25] Join _checkToken function and modifier together](https://github.com/code-423n4/2021-09-yaxis-findings/issues/91)\n_Submitted by pauliax_\n- [[G-26] The function `removeToken` can get prohibitively expensive](https://github.com/code-423n4/2021-09-yaxis-findings/issues/101)\n_Submitted by hrkrshnn_\n- [[G-27] VaultHelper could validate that amount is greater than 0](https://github.com/code-423n4/2021-09-yaxis-findings/issues/85)\n_Submitted by pauliax_\n\n# Disclosures\n\nC4 is an open organization governed by participants in the community.\n\nC4 Contests incentivize the discovery of exploits, vulnerabilities, and bugs in smart contracts. Security researchers are rewarded at an increasing rate for finding higher-risk issues. Contest submissions are judged by a knowledgeable security researcher and solidity developer and disclosed to sponsoring developers. C4 does not conduct formal verification regarding the provided code but instead provides final verification.\n\nC4 does not provide any guarantee or warranty regarding the security of this project. All smart contract software should be used at the sole risk and responsibility of users.\n"
}